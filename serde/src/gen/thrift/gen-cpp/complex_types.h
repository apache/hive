/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef complex_TYPES_H
#define complex_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>




class PropValueUnion;

class IntString;

class Complex;

class SetIntString;

typedef struct _PropValueUnion__isset {
  _PropValueUnion__isset() : intValue(false), longValue(false), stringValue(false), doubleValue(false), flag(false), lString(false), unionMStringString(false) {}
  bool intValue :1;
  bool longValue :1;
  bool stringValue :1;
  bool doubleValue :1;
  bool flag :1;
  bool lString :1;
  bool unionMStringString :1;
} _PropValueUnion__isset;

class PropValueUnion {
 public:

  PropValueUnion(const PropValueUnion&);
  PropValueUnion& operator=(const PropValueUnion&);
  PropValueUnion() : intValue(0), longValue(0), stringValue(), doubleValue(0), flag(0) {
  }

  virtual ~PropValueUnion() throw();
  int32_t intValue;
  int64_t longValue;
  std::string stringValue;
  double doubleValue;
  bool flag;
  std::vector<std::string>  lString;
  std::map<std::string, std::string>  unionMStringString;

  _PropValueUnion__isset __isset;

  void __set_intValue(const int32_t val);

  void __set_longValue(const int64_t val);

  void __set_stringValue(const std::string& val);

  void __set_doubleValue(const double val);

  void __set_flag(const bool val);

  void __set_lString(const std::vector<std::string> & val);

  void __set_unionMStringString(const std::map<std::string, std::string> & val);

  bool operator == (const PropValueUnion & rhs) const
  {
    if (__isset.intValue != rhs.__isset.intValue)
      return false;
    else if (__isset.intValue && !(intValue == rhs.intValue))
      return false;
    if (__isset.longValue != rhs.__isset.longValue)
      return false;
    else if (__isset.longValue && !(longValue == rhs.longValue))
      return false;
    if (__isset.stringValue != rhs.__isset.stringValue)
      return false;
    else if (__isset.stringValue && !(stringValue == rhs.stringValue))
      return false;
    if (__isset.doubleValue != rhs.__isset.doubleValue)
      return false;
    else if (__isset.doubleValue && !(doubleValue == rhs.doubleValue))
      return false;
    if (__isset.flag != rhs.__isset.flag)
      return false;
    else if (__isset.flag && !(flag == rhs.flag))
      return false;
    if (!(lString == rhs.lString))
      return false;
    if (!(unionMStringString == rhs.unionMStringString))
      return false;
    return true;
  }
  bool operator != (const PropValueUnion &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PropValueUnion & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PropValueUnion &a, PropValueUnion &b);

inline std::ostream& operator<<(std::ostream& out, const PropValueUnion& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _IntString__isset {
  _IntString__isset() : myint(false), myString(false), underscore_int(false) {}
  bool myint :1;
  bool myString :1;
  bool underscore_int :1;
} _IntString__isset;

class IntString {
 public:

  IntString(const IntString&);
  IntString& operator=(const IntString&);
  IntString() : myint(0), myString(), underscore_int(0) {
  }

  virtual ~IntString() throw();
  int32_t myint;
  std::string myString;
  int32_t underscore_int;

  _IntString__isset __isset;

  void __set_myint(const int32_t val);

  void __set_myString(const std::string& val);

  void __set_underscore_int(const int32_t val);

  bool operator == (const IntString & rhs) const
  {
    if (!(myint == rhs.myint))
      return false;
    if (!(myString == rhs.myString))
      return false;
    if (!(underscore_int == rhs.underscore_int))
      return false;
    return true;
  }
  bool operator != (const IntString &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IntString & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(IntString &a, IntString &b);

inline std::ostream& operator<<(std::ostream& out, const IntString& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Complex__isset {
  _Complex__isset() : aint(false), aString(false), lint(false), lString(false), lintString(false), mStringString(false), attributes(false), unionField1(false), unionField2(false), unionField3(false) {}
  bool aint :1;
  bool aString :1;
  bool lint :1;
  bool lString :1;
  bool lintString :1;
  bool mStringString :1;
  bool attributes :1;
  bool unionField1 :1;
  bool unionField2 :1;
  bool unionField3 :1;
} _Complex__isset;

class Complex {
 public:

  Complex(const Complex&);
  Complex& operator=(const Complex&);
  Complex() : aint(0), aString() {
  }

  virtual ~Complex() throw();
  int32_t aint;
  std::string aString;
  std::vector<int32_t>  lint;
  std::vector<std::string>  lString;
  std::vector<IntString>  lintString;
  std::map<std::string, std::string>  mStringString;
  std::map<std::string, std::map<std::string, std::map<std::string, PropValueUnion> > >  attributes;
  PropValueUnion unionField1;
  PropValueUnion unionField2;
  PropValueUnion unionField3;

  _Complex__isset __isset;

  void __set_aint(const int32_t val);

  void __set_aString(const std::string& val);

  void __set_lint(const std::vector<int32_t> & val);

  void __set_lString(const std::vector<std::string> & val);

  void __set_lintString(const std::vector<IntString> & val);

  void __set_mStringString(const std::map<std::string, std::string> & val);

  void __set_attributes(const std::map<std::string, std::map<std::string, std::map<std::string, PropValueUnion> > > & val);

  void __set_unionField1(const PropValueUnion& val);

  void __set_unionField2(const PropValueUnion& val);

  void __set_unionField3(const PropValueUnion& val);

  bool operator == (const Complex & rhs) const
  {
    if (!(aint == rhs.aint))
      return false;
    if (!(aString == rhs.aString))
      return false;
    if (!(lint == rhs.lint))
      return false;
    if (!(lString == rhs.lString))
      return false;
    if (!(lintString == rhs.lintString))
      return false;
    if (!(mStringString == rhs.mStringString))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    if (!(unionField1 == rhs.unionField1))
      return false;
    if (!(unionField2 == rhs.unionField2))
      return false;
    if (!(unionField3 == rhs.unionField3))
      return false;
    return true;
  }
  bool operator != (const Complex &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Complex & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Complex &a, Complex &b);

inline std::ostream& operator<<(std::ostream& out, const Complex& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SetIntString__isset {
  _SetIntString__isset() : sIntString(false), aString(false) {}
  bool sIntString :1;
  bool aString :1;
} _SetIntString__isset;

class SetIntString {
 public:

  SetIntString(const SetIntString&);
  SetIntString& operator=(const SetIntString&);
  SetIntString() : aString() {
  }

  virtual ~SetIntString() throw();
  std::set<IntString>  sIntString;
  std::string aString;

  _SetIntString__isset __isset;

  void __set_sIntString(const std::set<IntString> & val);

  void __set_aString(const std::string& val);

  bool operator == (const SetIntString & rhs) const
  {
    if (!(sIntString == rhs.sIntString))
      return false;
    if (!(aString == rhs.aString))
      return false;
    return true;
  }
  bool operator != (const SetIntString &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SetIntString & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SetIntString &a, SetIntString &b);

inline std::ostream& operator<<(std::ostream& out, const SetIntString& obj)
{
  obj.printTo(out);
  return out;
}



#endif
