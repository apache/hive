/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef megastruct_TYPES_H
#define megastruct_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>




struct MyEnum {
  enum type {
    LLAMA = 1,
    ALPACA = 2
  };
};

extern const std::map<int, const char*> _MyEnum_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const MyEnum::type& val);

std::string to_string(const MyEnum::type& val);

class MiniStruct;

class MegaStruct;

typedef struct _MiniStruct__isset {
  _MiniStruct__isset() : my_string(false), my_enum(false) {}
  bool my_string :1;
  bool my_enum :1;
} _MiniStruct__isset;

class MiniStruct : public virtual ::apache::thrift::TBase {
 public:

  MiniStruct(const MiniStruct&);
  MiniStruct& operator=(const MiniStruct&);
  MiniStruct() noexcept
             : my_string(),
               my_enum(static_cast<MyEnum::type>(0)) {
  }

  virtual ~MiniStruct() noexcept;
  std::string my_string;
  /**
   * 
   * @see MyEnum
   */
  MyEnum::type my_enum;

  _MiniStruct__isset __isset;

  void __set_my_string(const std::string& val);

  void __set_my_enum(const MyEnum::type val);

  bool operator == (const MiniStruct & rhs) const
  {
    if (__isset.my_string != rhs.__isset.my_string)
      return false;
    else if (__isset.my_string && !(my_string == rhs.my_string))
      return false;
    if (__isset.my_enum != rhs.__isset.my_enum)
      return false;
    else if (__isset.my_enum && !(my_enum == rhs.my_enum))
      return false;
    return true;
  }
  bool operator != (const MiniStruct &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MiniStruct & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(MiniStruct &a, MiniStruct &b);

std::ostream& operator<<(std::ostream& out, const MiniStruct& obj);

typedef struct _MegaStruct__isset {
  _MegaStruct__isset() : my_bool(false), my_byte(false), my_16bit_int(false), my_32bit_int(false), my_64bit_int(false), my_double(false), my_string(false), my_binary(false), my_string_string_map(false), my_string_enum_map(false), my_enum_string_map(false), my_enum_struct_map(false), my_enum_stringlist_map(false), my_enum_structlist_map(false), my_stringlist(false), my_structlist(false), my_enumlist(false), my_stringset(false), my_enumset(false), my_structset(false) {}
  bool my_bool :1;
  bool my_byte :1;
  bool my_16bit_int :1;
  bool my_32bit_int :1;
  bool my_64bit_int :1;
  bool my_double :1;
  bool my_string :1;
  bool my_binary :1;
  bool my_string_string_map :1;
  bool my_string_enum_map :1;
  bool my_enum_string_map :1;
  bool my_enum_struct_map :1;
  bool my_enum_stringlist_map :1;
  bool my_enum_structlist_map :1;
  bool my_stringlist :1;
  bool my_structlist :1;
  bool my_enumlist :1;
  bool my_stringset :1;
  bool my_enumset :1;
  bool my_structset :1;
} _MegaStruct__isset;

class MegaStruct : public virtual ::apache::thrift::TBase {
 public:

  MegaStruct(const MegaStruct&);
  MegaStruct& operator=(const MegaStruct&);
  MegaStruct() noexcept
             : my_bool(0),
               my_byte(0),
               my_16bit_int(0),
               my_32bit_int(0),
               my_64bit_int(0),
               my_double(0),
               my_string(),
               my_binary() {
  }

  virtual ~MegaStruct() noexcept;
  bool my_bool;
  int8_t my_byte;
  int16_t my_16bit_int;
  int32_t my_32bit_int;
  int64_t my_64bit_int;
  double my_double;
  std::string my_string;
  std::string my_binary;
  std::map<std::string, std::string>  my_string_string_map;
  std::map<std::string, MyEnum::type>  my_string_enum_map;
  std::map<MyEnum::type, std::string>  my_enum_string_map;
  std::map<MyEnum::type, MiniStruct>  my_enum_struct_map;
  std::map<MyEnum::type, std::vector<std::string> >  my_enum_stringlist_map;
  std::map<MyEnum::type, std::vector<MiniStruct> >  my_enum_structlist_map;
  std::vector<std::string>  my_stringlist;
  std::vector<MiniStruct>  my_structlist;
  std::vector<MyEnum::type>  my_enumlist;
  std::set<std::string>  my_stringset;
  std::set<MyEnum::type>  my_enumset;
  std::set<MiniStruct>  my_structset;

  _MegaStruct__isset __isset;

  void __set_my_bool(const bool val);

  void __set_my_byte(const int8_t val);

  void __set_my_16bit_int(const int16_t val);

  void __set_my_32bit_int(const int32_t val);

  void __set_my_64bit_int(const int64_t val);

  void __set_my_double(const double val);

  void __set_my_string(const std::string& val);

  void __set_my_binary(const std::string& val);

  void __set_my_string_string_map(const std::map<std::string, std::string> & val);

  void __set_my_string_enum_map(const std::map<std::string, MyEnum::type> & val);

  void __set_my_enum_string_map(const std::map<MyEnum::type, std::string> & val);

  void __set_my_enum_struct_map(const std::map<MyEnum::type, MiniStruct> & val);

  void __set_my_enum_stringlist_map(const std::map<MyEnum::type, std::vector<std::string> > & val);

  void __set_my_enum_structlist_map(const std::map<MyEnum::type, std::vector<MiniStruct> > & val);

  void __set_my_stringlist(const std::vector<std::string> & val);

  void __set_my_structlist(const std::vector<MiniStruct> & val);

  void __set_my_enumlist(const std::vector<MyEnum::type> & val);

  void __set_my_stringset(const std::set<std::string> & val);

  void __set_my_enumset(const std::set<MyEnum::type> & val);

  void __set_my_structset(const std::set<MiniStruct> & val);

  bool operator == (const MegaStruct & rhs) const
  {
    if (__isset.my_bool != rhs.__isset.my_bool)
      return false;
    else if (__isset.my_bool && !(my_bool == rhs.my_bool))
      return false;
    if (__isset.my_byte != rhs.__isset.my_byte)
      return false;
    else if (__isset.my_byte && !(my_byte == rhs.my_byte))
      return false;
    if (__isset.my_16bit_int != rhs.__isset.my_16bit_int)
      return false;
    else if (__isset.my_16bit_int && !(my_16bit_int == rhs.my_16bit_int))
      return false;
    if (__isset.my_32bit_int != rhs.__isset.my_32bit_int)
      return false;
    else if (__isset.my_32bit_int && !(my_32bit_int == rhs.my_32bit_int))
      return false;
    if (__isset.my_64bit_int != rhs.__isset.my_64bit_int)
      return false;
    else if (__isset.my_64bit_int && !(my_64bit_int == rhs.my_64bit_int))
      return false;
    if (__isset.my_double != rhs.__isset.my_double)
      return false;
    else if (__isset.my_double && !(my_double == rhs.my_double))
      return false;
    if (__isset.my_string != rhs.__isset.my_string)
      return false;
    else if (__isset.my_string && !(my_string == rhs.my_string))
      return false;
    if (__isset.my_binary != rhs.__isset.my_binary)
      return false;
    else if (__isset.my_binary && !(my_binary == rhs.my_binary))
      return false;
    if (__isset.my_string_string_map != rhs.__isset.my_string_string_map)
      return false;
    else if (__isset.my_string_string_map && !(my_string_string_map == rhs.my_string_string_map))
      return false;
    if (__isset.my_string_enum_map != rhs.__isset.my_string_enum_map)
      return false;
    else if (__isset.my_string_enum_map && !(my_string_enum_map == rhs.my_string_enum_map))
      return false;
    if (__isset.my_enum_string_map != rhs.__isset.my_enum_string_map)
      return false;
    else if (__isset.my_enum_string_map && !(my_enum_string_map == rhs.my_enum_string_map))
      return false;
    if (__isset.my_enum_struct_map != rhs.__isset.my_enum_struct_map)
      return false;
    else if (__isset.my_enum_struct_map && !(my_enum_struct_map == rhs.my_enum_struct_map))
      return false;
    if (__isset.my_enum_stringlist_map != rhs.__isset.my_enum_stringlist_map)
      return false;
    else if (__isset.my_enum_stringlist_map && !(my_enum_stringlist_map == rhs.my_enum_stringlist_map))
      return false;
    if (__isset.my_enum_structlist_map != rhs.__isset.my_enum_structlist_map)
      return false;
    else if (__isset.my_enum_structlist_map && !(my_enum_structlist_map == rhs.my_enum_structlist_map))
      return false;
    if (__isset.my_stringlist != rhs.__isset.my_stringlist)
      return false;
    else if (__isset.my_stringlist && !(my_stringlist == rhs.my_stringlist))
      return false;
    if (__isset.my_structlist != rhs.__isset.my_structlist)
      return false;
    else if (__isset.my_structlist && !(my_structlist == rhs.my_structlist))
      return false;
    if (__isset.my_enumlist != rhs.__isset.my_enumlist)
      return false;
    else if (__isset.my_enumlist && !(my_enumlist == rhs.my_enumlist))
      return false;
    if (__isset.my_stringset != rhs.__isset.my_stringset)
      return false;
    else if (__isset.my_stringset && !(my_stringset == rhs.my_stringset))
      return false;
    if (__isset.my_enumset != rhs.__isset.my_enumset)
      return false;
    else if (__isset.my_enumset && !(my_enumset == rhs.my_enumset))
      return false;
    if (__isset.my_structset != rhs.__isset.my_structset)
      return false;
    else if (__isset.my_structset && !(my_structset == rhs.my_structset))
      return false;
    return true;
  }
  bool operator != (const MegaStruct &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MegaStruct & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(MegaStruct &a, MegaStruct &b);

std::ostream& operator<<(std::ostream& out, const MegaStruct& obj);



#endif
