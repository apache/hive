<?php
/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;

class MegaStruct
{
    static public $isValidate = false;

    static public $_TSPEC = array(
        1 => array(
            'var' => 'my_bool',
            'isRequired' => false,
            'type' => TType::BOOL,
        ),
        2 => array(
            'var' => 'my_byte',
            'isRequired' => false,
            'type' => TType::BYTE,
        ),
        3 => array(
            'var' => 'my_16bit_int',
            'isRequired' => false,
            'type' => TType::I16,
        ),
        4 => array(
            'var' => 'my_32bit_int',
            'isRequired' => false,
            'type' => TType::I32,
        ),
        5 => array(
            'var' => 'my_64bit_int',
            'isRequired' => false,
            'type' => TType::I64,
        ),
        6 => array(
            'var' => 'my_double',
            'isRequired' => false,
            'type' => TType::DOUBLE,
        ),
        7 => array(
            'var' => 'my_string',
            'isRequired' => false,
            'type' => TType::STRING,
        ),
        8 => array(
            'var' => 'my_binary',
            'isRequired' => false,
            'type' => TType::STRING,
        ),
        9 => array(
            'var' => 'my_string_string_map',
            'isRequired' => false,
            'type' => TType::MAP,
            'ktype' => TType::STRING,
            'vtype' => TType::STRING,
            'key' => array(
                'type' => TType::STRING,
            ),
            'val' => array(
                'type' => TType::STRING,
                ),
        ),
        10 => array(
            'var' => 'my_string_enum_map',
            'isRequired' => false,
            'type' => TType::MAP,
            'ktype' => TType::STRING,
            'vtype' => TType::I32,
            'key' => array(
                'type' => TType::STRING,
            ),
            'val' => array(
                'type' => TType::I32,
                'class' => '\MyEnum',
                ),
        ),
        11 => array(
            'var' => 'my_enum_string_map',
            'isRequired' => false,
            'type' => TType::MAP,
            'ktype' => TType::I32,
            'vtype' => TType::STRING,
            'key' => array(
                'type' => TType::I32,
                'class' => '\MyEnum',
            ),
            'val' => array(
                'type' => TType::STRING,
                ),
        ),
        12 => array(
            'var' => 'my_enum_struct_map',
            'isRequired' => false,
            'type' => TType::MAP,
            'ktype' => TType::I32,
            'vtype' => TType::STRUCT,
            'key' => array(
                'type' => TType::I32,
                'class' => '\MyEnum',
            ),
            'val' => array(
                'type' => TType::STRUCT,
                'class' => '\MiniStruct',
                ),
        ),
        13 => array(
            'var' => 'my_enum_stringlist_map',
            'isRequired' => false,
            'type' => TType::MAP,
            'ktype' => TType::I32,
            'vtype' => TType::LST,
            'key' => array(
                'type' => TType::I32,
                'class' => '\MyEnum',
            ),
            'val' => array(
                'type' => TType::LST,
                'etype' => TType::STRING,
                'elem' => array(
                    'type' => TType::STRING,
                    ),
                ),
        ),
        14 => array(
            'var' => 'my_enum_structlist_map',
            'isRequired' => false,
            'type' => TType::MAP,
            'ktype' => TType::I32,
            'vtype' => TType::LST,
            'key' => array(
                'type' => TType::I32,
                'class' => '\MyEnum',
            ),
            'val' => array(
                'type' => TType::LST,
                'etype' => TType::STRUCT,
                'elem' => array(
                    'type' => TType::STRUCT,
                    'class' => '\MiniStruct',
                    ),
                ),
        ),
        15 => array(
            'var' => 'my_stringlist',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::STRING,
            'elem' => array(
                'type' => TType::STRING,
                ),
        ),
        16 => array(
            'var' => 'my_structlist',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
                'type' => TType::STRUCT,
                'class' => '\MiniStruct',
                ),
        ),
        17 => array(
            'var' => 'my_enumlist',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::I32,
            'elem' => array(
                'type' => TType::I32,
                'class' => '\MyEnum',
                ),
        ),
        18 => array(
            'var' => 'my_stringset',
            'isRequired' => false,
            'type' => TType::SET,
            'etype' => TType::STRING,
            'elem' => array(
                'type' => TType::STRING,
                ),
        ),
        19 => array(
            'var' => 'my_enumset',
            'isRequired' => false,
            'type' => TType::SET,
            'etype' => TType::I32,
            'elem' => array(
                'type' => TType::I32,
                'class' => '\MyEnum',
                ),
        ),
        20 => array(
            'var' => 'my_structset',
            'isRequired' => false,
            'type' => TType::SET,
            'etype' => TType::STRUCT,
            'elem' => array(
                'type' => TType::STRUCT,
                'class' => '\MiniStruct',
                ),
        ),
    );

    /**
     * @var bool
     */
    public $my_bool = null;
    /**
     * @var int
     */
    public $my_byte = null;
    /**
     * @var int
     */
    public $my_16bit_int = null;
    /**
     * @var int
     */
    public $my_32bit_int = null;
    /**
     * @var int
     */
    public $my_64bit_int = null;
    /**
     * @var double
     */
    public $my_double = null;
    /**
     * @var string
     */
    public $my_string = null;
    /**
     * @var string
     */
    public $my_binary = null;
    /**
     * @var array
     */
    public $my_string_string_map = null;
    /**
     * @var array
     */
    public $my_string_enum_map = null;
    /**
     * @var array
     */
    public $my_enum_string_map = null;
    /**
     * @var array
     */
    public $my_enum_struct_map = null;
    /**
     * @var array
     */
    public $my_enum_stringlist_map = null;
    /**
     * @var array
     */
    public $my_enum_structlist_map = null;
    /**
     * @var string[]
     */
    public $my_stringlist = null;
    /**
     * @var \MiniStruct[]
     */
    public $my_structlist = null;
    /**
     * @var int[]
     */
    public $my_enumlist = null;
    /**
     * @var string[]
     */
    public $my_stringset = null;
    /**
     * @var int[]
     */
    public $my_enumset = null;
    /**
     * @var \MiniStruct[]
     */
    public $my_structset = null;

    public function __construct($vals = null)
    {
        if (is_array($vals)) {
            if (isset($vals['my_bool'])) {
                $this->my_bool = $vals['my_bool'];
            }
            if (isset($vals['my_byte'])) {
                $this->my_byte = $vals['my_byte'];
            }
            if (isset($vals['my_16bit_int'])) {
                $this->my_16bit_int = $vals['my_16bit_int'];
            }
            if (isset($vals['my_32bit_int'])) {
                $this->my_32bit_int = $vals['my_32bit_int'];
            }
            if (isset($vals['my_64bit_int'])) {
                $this->my_64bit_int = $vals['my_64bit_int'];
            }
            if (isset($vals['my_double'])) {
                $this->my_double = $vals['my_double'];
            }
            if (isset($vals['my_string'])) {
                $this->my_string = $vals['my_string'];
            }
            if (isset($vals['my_binary'])) {
                $this->my_binary = $vals['my_binary'];
            }
            if (isset($vals['my_string_string_map'])) {
                $this->my_string_string_map = $vals['my_string_string_map'];
            }
            if (isset($vals['my_string_enum_map'])) {
                $this->my_string_enum_map = $vals['my_string_enum_map'];
            }
            if (isset($vals['my_enum_string_map'])) {
                $this->my_enum_string_map = $vals['my_enum_string_map'];
            }
            if (isset($vals['my_enum_struct_map'])) {
                $this->my_enum_struct_map = $vals['my_enum_struct_map'];
            }
            if (isset($vals['my_enum_stringlist_map'])) {
                $this->my_enum_stringlist_map = $vals['my_enum_stringlist_map'];
            }
            if (isset($vals['my_enum_structlist_map'])) {
                $this->my_enum_structlist_map = $vals['my_enum_structlist_map'];
            }
            if (isset($vals['my_stringlist'])) {
                $this->my_stringlist = $vals['my_stringlist'];
            }
            if (isset($vals['my_structlist'])) {
                $this->my_structlist = $vals['my_structlist'];
            }
            if (isset($vals['my_enumlist'])) {
                $this->my_enumlist = $vals['my_enumlist'];
            }
            if (isset($vals['my_stringset'])) {
                $this->my_stringset = $vals['my_stringset'];
            }
            if (isset($vals['my_enumset'])) {
                $this->my_enumset = $vals['my_enumset'];
            }
            if (isset($vals['my_structset'])) {
                $this->my_structset = $vals['my_structset'];
            }
        }
    }

    public function getName()
    {
        return 'MegaStruct';
    }


    public function read($input)
    {
        $xfer = 0;
        $fname = null;
        $ftype = 0;
        $fid = 0;
        $xfer += $input->readStructBegin($fname);
        while (true) {
            $xfer += $input->readFieldBegin($fname, $ftype, $fid);
            if ($ftype == TType::STOP) {
                break;
            }
            switch ($fid) {
                case 1:
                    if ($ftype == TType::BOOL) {
                        $xfer += $input->readBool($this->my_bool);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 2:
                    if ($ftype == TType::BYTE) {
                        $xfer += $input->readByte($this->my_byte);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 3:
                    if ($ftype == TType::I16) {
                        $xfer += $input->readI16($this->my_16bit_int);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 4:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->my_32bit_int);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 5:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->my_64bit_int);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 6:
                    if ($ftype == TType::DOUBLE) {
                        $xfer += $input->readDouble($this->my_double);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 7:
                    if ($ftype == TType::STRING) {
                        $xfer += $input->readString($this->my_string);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 8:
                    if ($ftype == TType::STRING) {
                        $xfer += $input->readString($this->my_binary);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 9:
                    if ($ftype == TType::MAP) {
                        $this->my_string_string_map = array();
                        $_size0 = 0;
                        $_ktype1 = 0;
                        $_vtype2 = 0;
                        $xfer += $input->readMapBegin($_ktype1, $_vtype2, $_size0);
                        for ($_i4 = 0; $_i4 < $_size0; ++$_i4) {
                            $key5 = '';
                            $val6 = '';
                            $xfer += $input->readString($key5);
                            $xfer += $input->readString($val6);
                            $this->my_string_string_map[$key5] = $val6;
                        }
                        $xfer += $input->readMapEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 10:
                    if ($ftype == TType::MAP) {
                        $this->my_string_enum_map = array();
                        $_size7 = 0;
                        $_ktype8 = 0;
                        $_vtype9 = 0;
                        $xfer += $input->readMapBegin($_ktype8, $_vtype9, $_size7);
                        for ($_i11 = 0; $_i11 < $_size7; ++$_i11) {
                            $key12 = '';
                            $val13 = 0;
                            $xfer += $input->readString($key12);
                            $xfer += $input->readI32($val13);
                            $this->my_string_enum_map[$key12] = $val13;
                        }
                        $xfer += $input->readMapEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 11:
                    if ($ftype == TType::MAP) {
                        $this->my_enum_string_map = array();
                        $_size14 = 0;
                        $_ktype15 = 0;
                        $_vtype16 = 0;
                        $xfer += $input->readMapBegin($_ktype15, $_vtype16, $_size14);
                        for ($_i18 = 0; $_i18 < $_size14; ++$_i18) {
                            $key19 = 0;
                            $val20 = '';
                            $xfer += $input->readI32($key19);
                            $xfer += $input->readString($val20);
                            $this->my_enum_string_map[$key19] = $val20;
                        }
                        $xfer += $input->readMapEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 12:
                    if ($ftype == TType::MAP) {
                        $this->my_enum_struct_map = array();
                        $_size21 = 0;
                        $_ktype22 = 0;
                        $_vtype23 = 0;
                        $xfer += $input->readMapBegin($_ktype22, $_vtype23, $_size21);
                        for ($_i25 = 0; $_i25 < $_size21; ++$_i25) {
                            $key26 = 0;
                            $val27 = new \MiniStruct();
                            $xfer += $input->readI32($key26);
                            $val27 = new \MiniStruct();
                            $xfer += $val27->read($input);
                            $this->my_enum_struct_map[$key26] = $val27;
                        }
                        $xfer += $input->readMapEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 13:
                    if ($ftype == TType::MAP) {
                        $this->my_enum_stringlist_map = array();
                        $_size28 = 0;
                        $_ktype29 = 0;
                        $_vtype30 = 0;
                        $xfer += $input->readMapBegin($_ktype29, $_vtype30, $_size28);
                        for ($_i32 = 0; $_i32 < $_size28; ++$_i32) {
                            $key33 = 0;
                            $val34 = array();
                            $xfer += $input->readI32($key33);
                            $val34 = array();
                            $_size35 = 0;
                            $_etype38 = 0;
                            $xfer += $input->readListBegin($_etype38, $_size35);
                            for ($_i39 = 0; $_i39 < $_size35; ++$_i39) {
                                $elem40 = null;
                                $xfer += $input->readString($elem40);
                                $val34 []= $elem40;
                            }
                            $xfer += $input->readListEnd();
                            $this->my_enum_stringlist_map[$key33] = $val34;
                        }
                        $xfer += $input->readMapEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 14:
                    if ($ftype == TType::MAP) {
                        $this->my_enum_structlist_map = array();
                        $_size41 = 0;
                        $_ktype42 = 0;
                        $_vtype43 = 0;
                        $xfer += $input->readMapBegin($_ktype42, $_vtype43, $_size41);
                        for ($_i45 = 0; $_i45 < $_size41; ++$_i45) {
                            $key46 = 0;
                            $val47 = array();
                            $xfer += $input->readI32($key46);
                            $val47 = array();
                            $_size48 = 0;
                            $_etype51 = 0;
                            $xfer += $input->readListBegin($_etype51, $_size48);
                            for ($_i52 = 0; $_i52 < $_size48; ++$_i52) {
                                $elem53 = null;
                                $elem53 = new \MiniStruct();
                                $xfer += $elem53->read($input);
                                $val47 []= $elem53;
                            }
                            $xfer += $input->readListEnd();
                            $this->my_enum_structlist_map[$key46] = $val47;
                        }
                        $xfer += $input->readMapEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 15:
                    if ($ftype == TType::LST) {
                        $this->my_stringlist = array();
                        $_size54 = 0;
                        $_etype57 = 0;
                        $xfer += $input->readListBegin($_etype57, $_size54);
                        for ($_i58 = 0; $_i58 < $_size54; ++$_i58) {
                            $elem59 = null;
                            $xfer += $input->readString($elem59);
                            $this->my_stringlist []= $elem59;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 16:
                    if ($ftype == TType::LST) {
                        $this->my_structlist = array();
                        $_size60 = 0;
                        $_etype63 = 0;
                        $xfer += $input->readListBegin($_etype63, $_size60);
                        for ($_i64 = 0; $_i64 < $_size60; ++$_i64) {
                            $elem65 = null;
                            $elem65 = new \MiniStruct();
                            $xfer += $elem65->read($input);
                            $this->my_structlist []= $elem65;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 17:
                    if ($ftype == TType::LST) {
                        $this->my_enumlist = array();
                        $_size66 = 0;
                        $_etype69 = 0;
                        $xfer += $input->readListBegin($_etype69, $_size66);
                        for ($_i70 = 0; $_i70 < $_size66; ++$_i70) {
                            $elem71 = null;
                            $xfer += $input->readI32($elem71);
                            $this->my_enumlist []= $elem71;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 18:
                    if ($ftype == TType::SET) {
                        $this->my_stringset = array();
                        $_size72 = 0;
                        $_etype75 = 0;
                        $xfer += $input->readSetBegin($_etype75, $_size72);
                        for ($_i76 = 0; $_i76 < $_size72; ++$_i76) {
                            $elem77 = null;
                            $xfer += $input->readString($elem77);
                            $this->my_stringset[$elem77] = true;
                        }
                        $xfer += $input->readSetEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 19:
                    if ($ftype == TType::SET) {
                        $this->my_enumset = array();
                        $_size78 = 0;
                        $_etype81 = 0;
                        $xfer += $input->readSetBegin($_etype81, $_size78);
                        for ($_i82 = 0; $_i82 < $_size78; ++$_i82) {
                            $elem83 = null;
                            $xfer += $input->readI32($elem83);
                            $this->my_enumset[$elem83] = true;
                        }
                        $xfer += $input->readSetEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 20:
                    if ($ftype == TType::SET) {
                        $this->my_structset = array();
                        $_size84 = 0;
                        $_etype87 = 0;
                        $xfer += $input->readSetBegin($_etype87, $_size84);
                        for ($_i88 = 0; $_i88 < $_size84; ++$_i88) {
                            $elem89 = null;
                            $elem89 = new \MiniStruct();
                            $xfer += $elem89->read($input);
                            $this->my_structset[] = $elem89;
                        }
                        $xfer += $input->readSetEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                default:
                    $xfer += $input->skip($ftype);
                    break;
            }
            $xfer += $input->readFieldEnd();
        }
        $xfer += $input->readStructEnd();
        return $xfer;
    }

    public function write($output)
    {
        $xfer = 0;
        $xfer += $output->writeStructBegin('MegaStruct');
        if ($this->my_bool !== null) {
            $xfer += $output->writeFieldBegin('my_bool', TType::BOOL, 1);
            $xfer += $output->writeBool($this->my_bool);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->my_byte !== null) {
            $xfer += $output->writeFieldBegin('my_byte', TType::BYTE, 2);
            $xfer += $output->writeByte($this->my_byte);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->my_16bit_int !== null) {
            $xfer += $output->writeFieldBegin('my_16bit_int', TType::I16, 3);
            $xfer += $output->writeI16($this->my_16bit_int);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->my_32bit_int !== null) {
            $xfer += $output->writeFieldBegin('my_32bit_int', TType::I32, 4);
            $xfer += $output->writeI32($this->my_32bit_int);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->my_64bit_int !== null) {
            $xfer += $output->writeFieldBegin('my_64bit_int', TType::I64, 5);
            $xfer += $output->writeI64($this->my_64bit_int);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->my_double !== null) {
            $xfer += $output->writeFieldBegin('my_double', TType::DOUBLE, 6);
            $xfer += $output->writeDouble($this->my_double);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->my_string !== null) {
            $xfer += $output->writeFieldBegin('my_string', TType::STRING, 7);
            $xfer += $output->writeString($this->my_string);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->my_binary !== null) {
            $xfer += $output->writeFieldBegin('my_binary', TType::STRING, 8);
            $xfer += $output->writeString($this->my_binary);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->my_string_string_map !== null) {
            if (!is_array($this->my_string_string_map)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('my_string_string_map', TType::MAP, 9);
            $output->writeMapBegin(TType::STRING, TType::STRING, count($this->my_string_string_map));
            foreach ($this->my_string_string_map as $kiter90 => $viter91) {
                $xfer += $output->writeString($kiter90);
                $xfer += $output->writeString($viter91);
            }
            $output->writeMapEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->my_string_enum_map !== null) {
            if (!is_array($this->my_string_enum_map)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('my_string_enum_map', TType::MAP, 10);
            $output->writeMapBegin(TType::STRING, TType::I32, count($this->my_string_enum_map));
            foreach ($this->my_string_enum_map as $kiter92 => $viter93) {
                $xfer += $output->writeString($kiter92);
                $xfer += $output->writeI32($viter93);
            }
            $output->writeMapEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->my_enum_string_map !== null) {
            if (!is_array($this->my_enum_string_map)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('my_enum_string_map', TType::MAP, 11);
            $output->writeMapBegin(TType::I32, TType::STRING, count($this->my_enum_string_map));
            foreach ($this->my_enum_string_map as $kiter94 => $viter95) {
                $xfer += $output->writeI32($kiter94);
                $xfer += $output->writeString($viter95);
            }
            $output->writeMapEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->my_enum_struct_map !== null) {
            if (!is_array($this->my_enum_struct_map)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('my_enum_struct_map', TType::MAP, 12);
            $output->writeMapBegin(TType::I32, TType::STRUCT, count($this->my_enum_struct_map));
            foreach ($this->my_enum_struct_map as $kiter96 => $viter97) {
                $xfer += $output->writeI32($kiter96);
                $xfer += $viter97->write($output);
            }
            $output->writeMapEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->my_enum_stringlist_map !== null) {
            if (!is_array($this->my_enum_stringlist_map)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('my_enum_stringlist_map', TType::MAP, 13);
            $output->writeMapBegin(TType::I32, TType::LST, count($this->my_enum_stringlist_map));
            foreach ($this->my_enum_stringlist_map as $kiter98 => $viter99) {
                $xfer += $output->writeI32($kiter98);
                $output->writeListBegin(TType::STRING, count($viter99));
                foreach ($viter99 as $iter100) {
                    $xfer += $output->writeString($iter100);
                }
                $output->writeListEnd();
            }
            $output->writeMapEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->my_enum_structlist_map !== null) {
            if (!is_array($this->my_enum_structlist_map)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('my_enum_structlist_map', TType::MAP, 14);
            $output->writeMapBegin(TType::I32, TType::LST, count($this->my_enum_structlist_map));
            foreach ($this->my_enum_structlist_map as $kiter101 => $viter102) {
                $xfer += $output->writeI32($kiter101);
                $output->writeListBegin(TType::STRUCT, count($viter102));
                foreach ($viter102 as $iter103) {
                    $xfer += $iter103->write($output);
                }
                $output->writeListEnd();
            }
            $output->writeMapEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->my_stringlist !== null) {
            if (!is_array($this->my_stringlist)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('my_stringlist', TType::LST, 15);
            $output->writeListBegin(TType::STRING, count($this->my_stringlist));
            foreach ($this->my_stringlist as $iter104) {
                $xfer += $output->writeString($iter104);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->my_structlist !== null) {
            if (!is_array($this->my_structlist)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('my_structlist', TType::LST, 16);
            $output->writeListBegin(TType::STRUCT, count($this->my_structlist));
            foreach ($this->my_structlist as $iter105) {
                $xfer += $iter105->write($output);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->my_enumlist !== null) {
            if (!is_array($this->my_enumlist)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('my_enumlist', TType::LST, 17);
            $output->writeListBegin(TType::I32, count($this->my_enumlist));
            foreach ($this->my_enumlist as $iter106) {
                $xfer += $output->writeI32($iter106);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->my_stringset !== null) {
            if (!is_array($this->my_stringset)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('my_stringset', TType::SET, 18);
            $output->writeSetBegin(TType::STRING, count($this->my_stringset));
            foreach ($this->my_stringset as $iter107 => $iter108) {
                $xfer += $output->writeString($iter107);
            }
            $output->writeSetEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->my_enumset !== null) {
            if (!is_array($this->my_enumset)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('my_enumset', TType::SET, 19);
            $output->writeSetBegin(TType::I32, count($this->my_enumset));
            foreach ($this->my_enumset as $iter109 => $iter110) {
                $xfer += $output->writeI32($iter109);
            }
            $output->writeSetEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->my_structset !== null) {
            if (!is_array($this->my_structset)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('my_structset', TType::SET, 20);
            $output->writeSetBegin(TType::STRUCT, count($this->my_structset));
            foreach ($this->my_structset as $iter111 => $iter112) {
                $xfer += $iter112->write($output);
            }
            $output->writeSetEnd();
            $xfer += $output->writeFieldEnd();
        }
        $xfer += $output->writeFieldStop();
        $xfer += $output->writeStructEnd();
        return $xfer;
    }
}
