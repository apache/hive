#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class TProtocolVersion:
  HIVE_CLI_SERVICE_PROTOCOL_V1 = 0
  HIVE_CLI_SERVICE_PROTOCOL_V2 = 1
  HIVE_CLI_SERVICE_PROTOCOL_V3 = 2
  HIVE_CLI_SERVICE_PROTOCOL_V4 = 3

  _VALUES_TO_NAMES = {
    0: "HIVE_CLI_SERVICE_PROTOCOL_V1",
    1: "HIVE_CLI_SERVICE_PROTOCOL_V2",
    2: "HIVE_CLI_SERVICE_PROTOCOL_V3",
    3: "HIVE_CLI_SERVICE_PROTOCOL_V4",
  }

  _NAMES_TO_VALUES = {
    "HIVE_CLI_SERVICE_PROTOCOL_V1": 0,
    "HIVE_CLI_SERVICE_PROTOCOL_V2": 1,
    "HIVE_CLI_SERVICE_PROTOCOL_V3": 2,
    "HIVE_CLI_SERVICE_PROTOCOL_V4": 3,
  }

class TTypeId:
  BOOLEAN_TYPE = 0
  TINYINT_TYPE = 1
  SMALLINT_TYPE = 2
  INT_TYPE = 3
  BIGINT_TYPE = 4
  FLOAT_TYPE = 5
  DOUBLE_TYPE = 6
  STRING_TYPE = 7
  TIMESTAMP_TYPE = 8
  BINARY_TYPE = 9
  ARRAY_TYPE = 10
  MAP_TYPE = 11
  STRUCT_TYPE = 12
  UNION_TYPE = 13
  USER_DEFINED_TYPE = 14
  DECIMAL_TYPE = 15
  NULL_TYPE = 16
  DATE_TYPE = 17
  VARCHAR_TYPE = 18
  CHAR_TYPE = 19

  _VALUES_TO_NAMES = {
    0: "BOOLEAN_TYPE",
    1: "TINYINT_TYPE",
    2: "SMALLINT_TYPE",
    3: "INT_TYPE",
    4: "BIGINT_TYPE",
    5: "FLOAT_TYPE",
    6: "DOUBLE_TYPE",
    7: "STRING_TYPE",
    8: "TIMESTAMP_TYPE",
    9: "BINARY_TYPE",
    10: "ARRAY_TYPE",
    11: "MAP_TYPE",
    12: "STRUCT_TYPE",
    13: "UNION_TYPE",
    14: "USER_DEFINED_TYPE",
    15: "DECIMAL_TYPE",
    16: "NULL_TYPE",
    17: "DATE_TYPE",
    18: "VARCHAR_TYPE",
    19: "CHAR_TYPE",
  }

  _NAMES_TO_VALUES = {
    "BOOLEAN_TYPE": 0,
    "TINYINT_TYPE": 1,
    "SMALLINT_TYPE": 2,
    "INT_TYPE": 3,
    "BIGINT_TYPE": 4,
    "FLOAT_TYPE": 5,
    "DOUBLE_TYPE": 6,
    "STRING_TYPE": 7,
    "TIMESTAMP_TYPE": 8,
    "BINARY_TYPE": 9,
    "ARRAY_TYPE": 10,
    "MAP_TYPE": 11,
    "STRUCT_TYPE": 12,
    "UNION_TYPE": 13,
    "USER_DEFINED_TYPE": 14,
    "DECIMAL_TYPE": 15,
    "NULL_TYPE": 16,
    "DATE_TYPE": 17,
    "VARCHAR_TYPE": 18,
    "CHAR_TYPE": 19,
  }

class TStatusCode:
  SUCCESS_STATUS = 0
  SUCCESS_WITH_INFO_STATUS = 1
  STILL_EXECUTING_STATUS = 2
  ERROR_STATUS = 3
  INVALID_HANDLE_STATUS = 4

  _VALUES_TO_NAMES = {
    0: "SUCCESS_STATUS",
    1: "SUCCESS_WITH_INFO_STATUS",
    2: "STILL_EXECUTING_STATUS",
    3: "ERROR_STATUS",
    4: "INVALID_HANDLE_STATUS",
  }

  _NAMES_TO_VALUES = {
    "SUCCESS_STATUS": 0,
    "SUCCESS_WITH_INFO_STATUS": 1,
    "STILL_EXECUTING_STATUS": 2,
    "ERROR_STATUS": 3,
    "INVALID_HANDLE_STATUS": 4,
  }

class TOperationState:
  INITIALIZED_STATE = 0
  RUNNING_STATE = 1
  FINISHED_STATE = 2
  CANCELED_STATE = 3
  CLOSED_STATE = 4
  ERROR_STATE = 5
  UKNOWN_STATE = 6
  PENDING_STATE = 7

  _VALUES_TO_NAMES = {
    0: "INITIALIZED_STATE",
    1: "RUNNING_STATE",
    2: "FINISHED_STATE",
    3: "CANCELED_STATE",
    4: "CLOSED_STATE",
    5: "ERROR_STATE",
    6: "UKNOWN_STATE",
    7: "PENDING_STATE",
  }

  _NAMES_TO_VALUES = {
    "INITIALIZED_STATE": 0,
    "RUNNING_STATE": 1,
    "FINISHED_STATE": 2,
    "CANCELED_STATE": 3,
    "CLOSED_STATE": 4,
    "ERROR_STATE": 5,
    "UKNOWN_STATE": 6,
    "PENDING_STATE": 7,
  }

class TOperationType:
  EXECUTE_STATEMENT = 0
  GET_TYPE_INFO = 1
  GET_CATALOGS = 2
  GET_SCHEMAS = 3
  GET_TABLES = 4
  GET_TABLE_TYPES = 5
  GET_COLUMNS = 6
  GET_FUNCTIONS = 7
  UNKNOWN = 8

  _VALUES_TO_NAMES = {
    0: "EXECUTE_STATEMENT",
    1: "GET_TYPE_INFO",
    2: "GET_CATALOGS",
    3: "GET_SCHEMAS",
    4: "GET_TABLES",
    5: "GET_TABLE_TYPES",
    6: "GET_COLUMNS",
    7: "GET_FUNCTIONS",
    8: "UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "EXECUTE_STATEMENT": 0,
    "GET_TYPE_INFO": 1,
    "GET_CATALOGS": 2,
    "GET_SCHEMAS": 3,
    "GET_TABLES": 4,
    "GET_TABLE_TYPES": 5,
    "GET_COLUMNS": 6,
    "GET_FUNCTIONS": 7,
    "UNKNOWN": 8,
  }

class TGetInfoType:
  CLI_MAX_DRIVER_CONNECTIONS = 0
  CLI_MAX_CONCURRENT_ACTIVITIES = 1
  CLI_DATA_SOURCE_NAME = 2
  CLI_FETCH_DIRECTION = 8
  CLI_SERVER_NAME = 13
  CLI_SEARCH_PATTERN_ESCAPE = 14
  CLI_DBMS_NAME = 17
  CLI_DBMS_VER = 18
  CLI_ACCESSIBLE_TABLES = 19
  CLI_ACCESSIBLE_PROCEDURES = 20
  CLI_CURSOR_COMMIT_BEHAVIOR = 23
  CLI_DATA_SOURCE_READ_ONLY = 25
  CLI_DEFAULT_TXN_ISOLATION = 26
  CLI_IDENTIFIER_CASE = 28
  CLI_IDENTIFIER_QUOTE_CHAR = 29
  CLI_MAX_COLUMN_NAME_LEN = 30
  CLI_MAX_CURSOR_NAME_LEN = 31
  CLI_MAX_SCHEMA_NAME_LEN = 32
  CLI_MAX_CATALOG_NAME_LEN = 34
  CLI_MAX_TABLE_NAME_LEN = 35
  CLI_SCROLL_CONCURRENCY = 43
  CLI_TXN_CAPABLE = 46
  CLI_USER_NAME = 47
  CLI_TXN_ISOLATION_OPTION = 72
  CLI_INTEGRITY = 73
  CLI_GETDATA_EXTENSIONS = 81
  CLI_NULL_COLLATION = 85
  CLI_ALTER_TABLE = 86
  CLI_ORDER_BY_COLUMNS_IN_SELECT = 90
  CLI_SPECIAL_CHARACTERS = 94
  CLI_MAX_COLUMNS_IN_GROUP_BY = 97
  CLI_MAX_COLUMNS_IN_INDEX = 98
  CLI_MAX_COLUMNS_IN_ORDER_BY = 99
  CLI_MAX_COLUMNS_IN_SELECT = 100
  CLI_MAX_COLUMNS_IN_TABLE = 101
  CLI_MAX_INDEX_SIZE = 102
  CLI_MAX_ROW_SIZE = 104
  CLI_MAX_STATEMENT_LEN = 105
  CLI_MAX_TABLES_IN_SELECT = 106
  CLI_MAX_USER_NAME_LEN = 107
  CLI_OJ_CAPABILITIES = 115
  CLI_XOPEN_CLI_YEAR = 10000
  CLI_CURSOR_SENSITIVITY = 10001
  CLI_DESCRIBE_PARAMETER = 10002
  CLI_CATALOG_NAME = 10003
  CLI_COLLATION_SEQ = 10004
  CLI_MAX_IDENTIFIER_LEN = 10005

  _VALUES_TO_NAMES = {
    0: "CLI_MAX_DRIVER_CONNECTIONS",
    1: "CLI_MAX_CONCURRENT_ACTIVITIES",
    2: "CLI_DATA_SOURCE_NAME",
    8: "CLI_FETCH_DIRECTION",
    13: "CLI_SERVER_NAME",
    14: "CLI_SEARCH_PATTERN_ESCAPE",
    17: "CLI_DBMS_NAME",
    18: "CLI_DBMS_VER",
    19: "CLI_ACCESSIBLE_TABLES",
    20: "CLI_ACCESSIBLE_PROCEDURES",
    23: "CLI_CURSOR_COMMIT_BEHAVIOR",
    25: "CLI_DATA_SOURCE_READ_ONLY",
    26: "CLI_DEFAULT_TXN_ISOLATION",
    28: "CLI_IDENTIFIER_CASE",
    29: "CLI_IDENTIFIER_QUOTE_CHAR",
    30: "CLI_MAX_COLUMN_NAME_LEN",
    31: "CLI_MAX_CURSOR_NAME_LEN",
    32: "CLI_MAX_SCHEMA_NAME_LEN",
    34: "CLI_MAX_CATALOG_NAME_LEN",
    35: "CLI_MAX_TABLE_NAME_LEN",
    43: "CLI_SCROLL_CONCURRENCY",
    46: "CLI_TXN_CAPABLE",
    47: "CLI_USER_NAME",
    72: "CLI_TXN_ISOLATION_OPTION",
    73: "CLI_INTEGRITY",
    81: "CLI_GETDATA_EXTENSIONS",
    85: "CLI_NULL_COLLATION",
    86: "CLI_ALTER_TABLE",
    90: "CLI_ORDER_BY_COLUMNS_IN_SELECT",
    94: "CLI_SPECIAL_CHARACTERS",
    97: "CLI_MAX_COLUMNS_IN_GROUP_BY",
    98: "CLI_MAX_COLUMNS_IN_INDEX",
    99: "CLI_MAX_COLUMNS_IN_ORDER_BY",
    100: "CLI_MAX_COLUMNS_IN_SELECT",
    101: "CLI_MAX_COLUMNS_IN_TABLE",
    102: "CLI_MAX_INDEX_SIZE",
    104: "CLI_MAX_ROW_SIZE",
    105: "CLI_MAX_STATEMENT_LEN",
    106: "CLI_MAX_TABLES_IN_SELECT",
    107: "CLI_MAX_USER_NAME_LEN",
    115: "CLI_OJ_CAPABILITIES",
    10000: "CLI_XOPEN_CLI_YEAR",
    10001: "CLI_CURSOR_SENSITIVITY",
    10002: "CLI_DESCRIBE_PARAMETER",
    10003: "CLI_CATALOG_NAME",
    10004: "CLI_COLLATION_SEQ",
    10005: "CLI_MAX_IDENTIFIER_LEN",
  }

  _NAMES_TO_VALUES = {
    "CLI_MAX_DRIVER_CONNECTIONS": 0,
    "CLI_MAX_CONCURRENT_ACTIVITIES": 1,
    "CLI_DATA_SOURCE_NAME": 2,
    "CLI_FETCH_DIRECTION": 8,
    "CLI_SERVER_NAME": 13,
    "CLI_SEARCH_PATTERN_ESCAPE": 14,
    "CLI_DBMS_NAME": 17,
    "CLI_DBMS_VER": 18,
    "CLI_ACCESSIBLE_TABLES": 19,
    "CLI_ACCESSIBLE_PROCEDURES": 20,
    "CLI_CURSOR_COMMIT_BEHAVIOR": 23,
    "CLI_DATA_SOURCE_READ_ONLY": 25,
    "CLI_DEFAULT_TXN_ISOLATION": 26,
    "CLI_IDENTIFIER_CASE": 28,
    "CLI_IDENTIFIER_QUOTE_CHAR": 29,
    "CLI_MAX_COLUMN_NAME_LEN": 30,
    "CLI_MAX_CURSOR_NAME_LEN": 31,
    "CLI_MAX_SCHEMA_NAME_LEN": 32,
    "CLI_MAX_CATALOG_NAME_LEN": 34,
    "CLI_MAX_TABLE_NAME_LEN": 35,
    "CLI_SCROLL_CONCURRENCY": 43,
    "CLI_TXN_CAPABLE": 46,
    "CLI_USER_NAME": 47,
    "CLI_TXN_ISOLATION_OPTION": 72,
    "CLI_INTEGRITY": 73,
    "CLI_GETDATA_EXTENSIONS": 81,
    "CLI_NULL_COLLATION": 85,
    "CLI_ALTER_TABLE": 86,
    "CLI_ORDER_BY_COLUMNS_IN_SELECT": 90,
    "CLI_SPECIAL_CHARACTERS": 94,
    "CLI_MAX_COLUMNS_IN_GROUP_BY": 97,
    "CLI_MAX_COLUMNS_IN_INDEX": 98,
    "CLI_MAX_COLUMNS_IN_ORDER_BY": 99,
    "CLI_MAX_COLUMNS_IN_SELECT": 100,
    "CLI_MAX_COLUMNS_IN_TABLE": 101,
    "CLI_MAX_INDEX_SIZE": 102,
    "CLI_MAX_ROW_SIZE": 104,
    "CLI_MAX_STATEMENT_LEN": 105,
    "CLI_MAX_TABLES_IN_SELECT": 106,
    "CLI_MAX_USER_NAME_LEN": 107,
    "CLI_OJ_CAPABILITIES": 115,
    "CLI_XOPEN_CLI_YEAR": 10000,
    "CLI_CURSOR_SENSITIVITY": 10001,
    "CLI_DESCRIBE_PARAMETER": 10002,
    "CLI_CATALOG_NAME": 10003,
    "CLI_COLLATION_SEQ": 10004,
    "CLI_MAX_IDENTIFIER_LEN": 10005,
  }

class TFetchOrientation:
  FETCH_NEXT = 0
  FETCH_PRIOR = 1
  FETCH_RELATIVE = 2
  FETCH_ABSOLUTE = 3
  FETCH_FIRST = 4
  FETCH_LAST = 5

  _VALUES_TO_NAMES = {
    0: "FETCH_NEXT",
    1: "FETCH_PRIOR",
    2: "FETCH_RELATIVE",
    3: "FETCH_ABSOLUTE",
    4: "FETCH_FIRST",
    5: "FETCH_LAST",
  }

  _NAMES_TO_VALUES = {
    "FETCH_NEXT": 0,
    "FETCH_PRIOR": 1,
    "FETCH_RELATIVE": 2,
    "FETCH_ABSOLUTE": 3,
    "FETCH_FIRST": 4,
    "FETCH_LAST": 5,
  }


class TTypeQualifierValue:
  """
  Attributes:
   - i32Value
   - stringValue
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'i32Value', None, None, ), # 1
    (2, TType.STRING, 'stringValue', None, None, ), # 2
  )

  def __init__(self, i32Value=None, stringValue=None,):
    self.i32Value = i32Value
    self.stringValue = stringValue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.i32Value = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.stringValue = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTypeQualifierValue')
    if self.i32Value is not None:
      oprot.writeFieldBegin('i32Value', TType.I32, 1)
      oprot.writeI32(self.i32Value)
      oprot.writeFieldEnd()
    if self.stringValue is not None:
      oprot.writeFieldBegin('stringValue', TType.STRING, 2)
      oprot.writeString(self.stringValue)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTypeQualifiers:
  """
  Attributes:
   - qualifiers
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'qualifiers', (TType.STRING,None,TType.STRUCT,(TTypeQualifierValue, TTypeQualifierValue.thrift_spec)), None, ), # 1
  )

  def __init__(self, qualifiers=None,):
    self.qualifiers = qualifiers

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.qualifiers = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin() 
          for _i4 in xrange(_size0):
            _key5 = iprot.readString();
            _val6 = TTypeQualifierValue()
            _val6.read(iprot)
            self.qualifiers[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTypeQualifiers')
    if self.qualifiers is not None:
      oprot.writeFieldBegin('qualifiers', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.qualifiers))
      for kiter7,viter8 in self.qualifiers.items():
        oprot.writeString(kiter7)
        viter8.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.qualifiers is None:
      raise TProtocol.TProtocolException(message='Required field qualifiers is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPrimitiveTypeEntry:
  """
  Attributes:
   - type
   - typeQualifiers
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.STRUCT, 'typeQualifiers', (TTypeQualifiers, TTypeQualifiers.thrift_spec), None, ), # 2
  )

  def __init__(self, type=None, typeQualifiers=None,):
    self.type = type
    self.typeQualifiers = typeQualifiers

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.typeQualifiers = TTypeQualifiers()
          self.typeQualifiers.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPrimitiveTypeEntry')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.typeQualifiers is not None:
      oprot.writeFieldBegin('typeQualifiers', TType.STRUCT, 2)
      self.typeQualifiers.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TArrayTypeEntry:
  """
  Attributes:
   - objectTypePtr
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'objectTypePtr', None, None, ), # 1
  )

  def __init__(self, objectTypePtr=None,):
    self.objectTypePtr = objectTypePtr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.objectTypePtr = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TArrayTypeEntry')
    if self.objectTypePtr is not None:
      oprot.writeFieldBegin('objectTypePtr', TType.I32, 1)
      oprot.writeI32(self.objectTypePtr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.objectTypePtr is None:
      raise TProtocol.TProtocolException(message='Required field objectTypePtr is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TMapTypeEntry:
  """
  Attributes:
   - keyTypePtr
   - valueTypePtr
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'keyTypePtr', None, None, ), # 1
    (2, TType.I32, 'valueTypePtr', None, None, ), # 2
  )

  def __init__(self, keyTypePtr=None, valueTypePtr=None,):
    self.keyTypePtr = keyTypePtr
    self.valueTypePtr = valueTypePtr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.keyTypePtr = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.valueTypePtr = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TMapTypeEntry')
    if self.keyTypePtr is not None:
      oprot.writeFieldBegin('keyTypePtr', TType.I32, 1)
      oprot.writeI32(self.keyTypePtr)
      oprot.writeFieldEnd()
    if self.valueTypePtr is not None:
      oprot.writeFieldBegin('valueTypePtr', TType.I32, 2)
      oprot.writeI32(self.valueTypePtr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.keyTypePtr is None:
      raise TProtocol.TProtocolException(message='Required field keyTypePtr is unset!')
    if self.valueTypePtr is None:
      raise TProtocol.TProtocolException(message='Required field valueTypePtr is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TStructTypeEntry:
  """
  Attributes:
   - nameToTypePtr
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'nameToTypePtr', (TType.STRING,None,TType.I32,None), None, ), # 1
  )

  def __init__(self, nameToTypePtr=None,):
    self.nameToTypePtr = nameToTypePtr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.nameToTypePtr = {}
          (_ktype10, _vtype11, _size9 ) = iprot.readMapBegin() 
          for _i13 in xrange(_size9):
            _key14 = iprot.readString();
            _val15 = iprot.readI32();
            self.nameToTypePtr[_key14] = _val15
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TStructTypeEntry')
    if self.nameToTypePtr is not None:
      oprot.writeFieldBegin('nameToTypePtr', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.nameToTypePtr))
      for kiter16,viter17 in self.nameToTypePtr.items():
        oprot.writeString(kiter16)
        oprot.writeI32(viter17)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.nameToTypePtr is None:
      raise TProtocol.TProtocolException(message='Required field nameToTypePtr is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TUnionTypeEntry:
  """
  Attributes:
   - nameToTypePtr
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'nameToTypePtr', (TType.STRING,None,TType.I32,None), None, ), # 1
  )

  def __init__(self, nameToTypePtr=None,):
    self.nameToTypePtr = nameToTypePtr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.nameToTypePtr = {}
          (_ktype19, _vtype20, _size18 ) = iprot.readMapBegin() 
          for _i22 in xrange(_size18):
            _key23 = iprot.readString();
            _val24 = iprot.readI32();
            self.nameToTypePtr[_key23] = _val24
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TUnionTypeEntry')
    if self.nameToTypePtr is not None:
      oprot.writeFieldBegin('nameToTypePtr', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.nameToTypePtr))
      for kiter25,viter26 in self.nameToTypePtr.items():
        oprot.writeString(kiter25)
        oprot.writeI32(viter26)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.nameToTypePtr is None:
      raise TProtocol.TProtocolException(message='Required field nameToTypePtr is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TUserDefinedTypeEntry:
  """
  Attributes:
   - typeClassName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'typeClassName', None, None, ), # 1
  )

  def __init__(self, typeClassName=None,):
    self.typeClassName = typeClassName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.typeClassName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TUserDefinedTypeEntry')
    if self.typeClassName is not None:
      oprot.writeFieldBegin('typeClassName', TType.STRING, 1)
      oprot.writeString(self.typeClassName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.typeClassName is None:
      raise TProtocol.TProtocolException(message='Required field typeClassName is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTypeEntry:
  """
  Attributes:
   - primitiveEntry
   - arrayEntry
   - mapEntry
   - structEntry
   - unionEntry
   - userDefinedTypeEntry
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'primitiveEntry', (TPrimitiveTypeEntry, TPrimitiveTypeEntry.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arrayEntry', (TArrayTypeEntry, TArrayTypeEntry.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'mapEntry', (TMapTypeEntry, TMapTypeEntry.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'structEntry', (TStructTypeEntry, TStructTypeEntry.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'unionEntry', (TUnionTypeEntry, TUnionTypeEntry.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'userDefinedTypeEntry', (TUserDefinedTypeEntry, TUserDefinedTypeEntry.thrift_spec), None, ), # 6
  )

  def __init__(self, primitiveEntry=None, arrayEntry=None, mapEntry=None, structEntry=None, unionEntry=None, userDefinedTypeEntry=None,):
    self.primitiveEntry = primitiveEntry
    self.arrayEntry = arrayEntry
    self.mapEntry = mapEntry
    self.structEntry = structEntry
    self.unionEntry = unionEntry
    self.userDefinedTypeEntry = userDefinedTypeEntry

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.primitiveEntry = TPrimitiveTypeEntry()
          self.primitiveEntry.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arrayEntry = TArrayTypeEntry()
          self.arrayEntry.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.mapEntry = TMapTypeEntry()
          self.mapEntry.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.structEntry = TStructTypeEntry()
          self.structEntry.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.unionEntry = TUnionTypeEntry()
          self.unionEntry.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.userDefinedTypeEntry = TUserDefinedTypeEntry()
          self.userDefinedTypeEntry.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTypeEntry')
    if self.primitiveEntry is not None:
      oprot.writeFieldBegin('primitiveEntry', TType.STRUCT, 1)
      self.primitiveEntry.write(oprot)
      oprot.writeFieldEnd()
    if self.arrayEntry is not None:
      oprot.writeFieldBegin('arrayEntry', TType.STRUCT, 2)
      self.arrayEntry.write(oprot)
      oprot.writeFieldEnd()
    if self.mapEntry is not None:
      oprot.writeFieldBegin('mapEntry', TType.STRUCT, 3)
      self.mapEntry.write(oprot)
      oprot.writeFieldEnd()
    if self.structEntry is not None:
      oprot.writeFieldBegin('structEntry', TType.STRUCT, 4)
      self.structEntry.write(oprot)
      oprot.writeFieldEnd()
    if self.unionEntry is not None:
      oprot.writeFieldBegin('unionEntry', TType.STRUCT, 5)
      self.unionEntry.write(oprot)
      oprot.writeFieldEnd()
    if self.userDefinedTypeEntry is not None:
      oprot.writeFieldBegin('userDefinedTypeEntry', TType.STRUCT, 6)
      self.userDefinedTypeEntry.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTypeDesc:
  """
  Attributes:
   - types
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'types', (TType.STRUCT,(TTypeEntry, TTypeEntry.thrift_spec)), None, ), # 1
  )

  def __init__(self, types=None,):
    self.types = types

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.types = []
          (_etype30, _size27) = iprot.readListBegin()
          for _i31 in xrange(_size27):
            _elem32 = TTypeEntry()
            _elem32.read(iprot)
            self.types.append(_elem32)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTypeDesc')
    if self.types is not None:
      oprot.writeFieldBegin('types', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.types))
      for iter33 in self.types:
        iter33.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.types is None:
      raise TProtocol.TProtocolException(message='Required field types is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TColumnDesc:
  """
  Attributes:
   - columnName
   - typeDesc
   - position
   - comment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'columnName', None, None, ), # 1
    (2, TType.STRUCT, 'typeDesc', (TTypeDesc, TTypeDesc.thrift_spec), None, ), # 2
    (3, TType.I32, 'position', None, None, ), # 3
    (4, TType.STRING, 'comment', None, None, ), # 4
  )

  def __init__(self, columnName=None, typeDesc=None, position=None, comment=None,):
    self.columnName = columnName
    self.typeDesc = typeDesc
    self.position = position
    self.comment = comment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.columnName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.typeDesc = TTypeDesc()
          self.typeDesc.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.position = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.comment = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TColumnDesc')
    if self.columnName is not None:
      oprot.writeFieldBegin('columnName', TType.STRING, 1)
      oprot.writeString(self.columnName)
      oprot.writeFieldEnd()
    if self.typeDesc is not None:
      oprot.writeFieldBegin('typeDesc', TType.STRUCT, 2)
      self.typeDesc.write(oprot)
      oprot.writeFieldEnd()
    if self.position is not None:
      oprot.writeFieldBegin('position', TType.I32, 3)
      oprot.writeI32(self.position)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 4)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.columnName is None:
      raise TProtocol.TProtocolException(message='Required field columnName is unset!')
    if self.typeDesc is None:
      raise TProtocol.TProtocolException(message='Required field typeDesc is unset!')
    if self.position is None:
      raise TProtocol.TProtocolException(message='Required field position is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTableSchema:
  """
  Attributes:
   - columns
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'columns', (TType.STRUCT,(TColumnDesc, TColumnDesc.thrift_spec)), None, ), # 1
  )

  def __init__(self, columns=None,):
    self.columns = columns

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.columns = []
          (_etype37, _size34) = iprot.readListBegin()
          for _i38 in xrange(_size34):
            _elem39 = TColumnDesc()
            _elem39.read(iprot)
            self.columns.append(_elem39)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTableSchema')
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter40 in self.columns:
        iter40.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.columns is None:
      raise TProtocol.TProtocolException(message='Required field columns is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TBoolValue:
  """
  Attributes:
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'value', None, None, ), # 1
  )

  def __init__(self, value=None,):
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.value = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TBoolValue')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.BOOL, 1)
      oprot.writeBool(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TByteValue:
  """
  Attributes:
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'value', None, None, ), # 1
  )

  def __init__(self, value=None,):
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.value = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TByteValue')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.BYTE, 1)
      oprot.writeByte(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TI16Value:
  """
  Attributes:
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'value', None, None, ), # 1
  )

  def __init__(self, value=None,):
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.value = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TI16Value')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I16, 1)
      oprot.writeI16(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TI32Value:
  """
  Attributes:
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'value', None, None, ), # 1
  )

  def __init__(self, value=None,):
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TI32Value')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 1)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TI64Value:
  """
  Attributes:
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'value', None, None, ), # 1
  )

  def __init__(self, value=None,):
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.value = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TI64Value')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I64, 1)
      oprot.writeI64(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDoubleValue:
  """
  Attributes:
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'value', None, None, ), # 1
  )

  def __init__(self, value=None,):
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.value = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDoubleValue')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.DOUBLE, 1)
      oprot.writeDouble(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TStringValue:
  """
  Attributes:
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'value', None, None, ), # 1
  )

  def __init__(self, value=None,):
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TStringValue')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 1)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TColumn:
  """
  Attributes:
   - boolColumn
   - byteColumn
   - i16Column
   - i32Column
   - i64Column
   - doubleColumn
   - stringColumn
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'boolColumn', (TType.STRUCT,(TBoolValue, TBoolValue.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'byteColumn', (TType.STRUCT,(TByteValue, TByteValue.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'i16Column', (TType.STRUCT,(TI16Value, TI16Value.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'i32Column', (TType.STRUCT,(TI32Value, TI32Value.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'i64Column', (TType.STRUCT,(TI64Value, TI64Value.thrift_spec)), None, ), # 5
    (6, TType.LIST, 'doubleColumn', (TType.STRUCT,(TDoubleValue, TDoubleValue.thrift_spec)), None, ), # 6
    (7, TType.LIST, 'stringColumn', (TType.STRUCT,(TStringValue, TStringValue.thrift_spec)), None, ), # 7
  )

  def __init__(self, boolColumn=None, byteColumn=None, i16Column=None, i32Column=None, i64Column=None, doubleColumn=None, stringColumn=None,):
    self.boolColumn = boolColumn
    self.byteColumn = byteColumn
    self.i16Column = i16Column
    self.i32Column = i32Column
    self.i64Column = i64Column
    self.doubleColumn = doubleColumn
    self.stringColumn = stringColumn

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.boolColumn = []
          (_etype44, _size41) = iprot.readListBegin()
          for _i45 in xrange(_size41):
            _elem46 = TBoolValue()
            _elem46.read(iprot)
            self.boolColumn.append(_elem46)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.byteColumn = []
          (_etype50, _size47) = iprot.readListBegin()
          for _i51 in xrange(_size47):
            _elem52 = TByteValue()
            _elem52.read(iprot)
            self.byteColumn.append(_elem52)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.i16Column = []
          (_etype56, _size53) = iprot.readListBegin()
          for _i57 in xrange(_size53):
            _elem58 = TI16Value()
            _elem58.read(iprot)
            self.i16Column.append(_elem58)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.i32Column = []
          (_etype62, _size59) = iprot.readListBegin()
          for _i63 in xrange(_size59):
            _elem64 = TI32Value()
            _elem64.read(iprot)
            self.i32Column.append(_elem64)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.i64Column = []
          (_etype68, _size65) = iprot.readListBegin()
          for _i69 in xrange(_size65):
            _elem70 = TI64Value()
            _elem70.read(iprot)
            self.i64Column.append(_elem70)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.doubleColumn = []
          (_etype74, _size71) = iprot.readListBegin()
          for _i75 in xrange(_size71):
            _elem76 = TDoubleValue()
            _elem76.read(iprot)
            self.doubleColumn.append(_elem76)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.stringColumn = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = TStringValue()
            _elem82.read(iprot)
            self.stringColumn.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TColumn')
    if self.boolColumn is not None:
      oprot.writeFieldBegin('boolColumn', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.boolColumn))
      for iter83 in self.boolColumn:
        iter83.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.byteColumn is not None:
      oprot.writeFieldBegin('byteColumn', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.byteColumn))
      for iter84 in self.byteColumn:
        iter84.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.i16Column is not None:
      oprot.writeFieldBegin('i16Column', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.i16Column))
      for iter85 in self.i16Column:
        iter85.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.i32Column is not None:
      oprot.writeFieldBegin('i32Column', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.i32Column))
      for iter86 in self.i32Column:
        iter86.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.i64Column is not None:
      oprot.writeFieldBegin('i64Column', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.i64Column))
      for iter87 in self.i64Column:
        iter87.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.doubleColumn is not None:
      oprot.writeFieldBegin('doubleColumn', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.doubleColumn))
      for iter88 in self.doubleColumn:
        iter88.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.stringColumn is not None:
      oprot.writeFieldBegin('stringColumn', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.stringColumn))
      for iter89 in self.stringColumn:
        iter89.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TColumnValue:
  """
  Attributes:
   - boolVal
   - byteVal
   - i16Val
   - i32Val
   - i64Val
   - doubleVal
   - stringVal
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'boolVal', (TBoolValue, TBoolValue.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'byteVal', (TByteValue, TByteValue.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'i16Val', (TI16Value, TI16Value.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'i32Val', (TI32Value, TI32Value.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'i64Val', (TI64Value, TI64Value.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'doubleVal', (TDoubleValue, TDoubleValue.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'stringVal', (TStringValue, TStringValue.thrift_spec), None, ), # 7
  )

  def __init__(self, boolVal=None, byteVal=None, i16Val=None, i32Val=None, i64Val=None, doubleVal=None, stringVal=None,):
    self.boolVal = boolVal
    self.byteVal = byteVal
    self.i16Val = i16Val
    self.i32Val = i32Val
    self.i64Val = i64Val
    self.doubleVal = doubleVal
    self.stringVal = stringVal

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.boolVal = TBoolValue()
          self.boolVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.byteVal = TByteValue()
          self.byteVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.i16Val = TI16Value()
          self.i16Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.i32Val = TI32Value()
          self.i32Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.i64Val = TI64Value()
          self.i64Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.doubleVal = TDoubleValue()
          self.doubleVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.stringVal = TStringValue()
          self.stringVal.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TColumnValue')
    if self.boolVal is not None:
      oprot.writeFieldBegin('boolVal', TType.STRUCT, 1)
      self.boolVal.write(oprot)
      oprot.writeFieldEnd()
    if self.byteVal is not None:
      oprot.writeFieldBegin('byteVal', TType.STRUCT, 2)
      self.byteVal.write(oprot)
      oprot.writeFieldEnd()
    if self.i16Val is not None:
      oprot.writeFieldBegin('i16Val', TType.STRUCT, 3)
      self.i16Val.write(oprot)
      oprot.writeFieldEnd()
    if self.i32Val is not None:
      oprot.writeFieldBegin('i32Val', TType.STRUCT, 4)
      self.i32Val.write(oprot)
      oprot.writeFieldEnd()
    if self.i64Val is not None:
      oprot.writeFieldBegin('i64Val', TType.STRUCT, 5)
      self.i64Val.write(oprot)
      oprot.writeFieldEnd()
    if self.doubleVal is not None:
      oprot.writeFieldBegin('doubleVal', TType.STRUCT, 6)
      self.doubleVal.write(oprot)
      oprot.writeFieldEnd()
    if self.stringVal is not None:
      oprot.writeFieldBegin('stringVal', TType.STRUCT, 7)
      self.stringVal.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TRow:
  """
  Attributes:
   - colVals
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'colVals', (TType.STRUCT,(TColumnValue, TColumnValue.thrift_spec)), None, ), # 1
  )

  def __init__(self, colVals=None,):
    self.colVals = colVals

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.colVals = []
          (_etype93, _size90) = iprot.readListBegin()
          for _i94 in xrange(_size90):
            _elem95 = TColumnValue()
            _elem95.read(iprot)
            self.colVals.append(_elem95)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TRow')
    if self.colVals is not None:
      oprot.writeFieldBegin('colVals', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.colVals))
      for iter96 in self.colVals:
        iter96.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.colVals is None:
      raise TProtocol.TProtocolException(message='Required field colVals is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TRowSet:
  """
  Attributes:
   - startRowOffset
   - rows
   - columns
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'startRowOffset', None, None, ), # 1
    (2, TType.LIST, 'rows', (TType.STRUCT,(TRow, TRow.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'columns', (TType.STRUCT,(TColumn, TColumn.thrift_spec)), None, ), # 3
  )

  def __init__(self, startRowOffset=None, rows=None, columns=None,):
    self.startRowOffset = startRowOffset
    self.rows = rows
    self.columns = columns

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.startRowOffset = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.rows = []
          (_etype100, _size97) = iprot.readListBegin()
          for _i101 in xrange(_size97):
            _elem102 = TRow()
            _elem102.read(iprot)
            self.rows.append(_elem102)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.columns = []
          (_etype106, _size103) = iprot.readListBegin()
          for _i107 in xrange(_size103):
            _elem108 = TColumn()
            _elem108.read(iprot)
            self.columns.append(_elem108)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TRowSet')
    if self.startRowOffset is not None:
      oprot.writeFieldBegin('startRowOffset', TType.I64, 1)
      oprot.writeI64(self.startRowOffset)
      oprot.writeFieldEnd()
    if self.rows is not None:
      oprot.writeFieldBegin('rows', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.rows))
      for iter109 in self.rows:
        iter109.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter110 in self.columns:
        iter110.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.startRowOffset is None:
      raise TProtocol.TProtocolException(message='Required field startRowOffset is unset!')
    if self.rows is None:
      raise TProtocol.TProtocolException(message='Required field rows is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TStatus:
  """
  Attributes:
   - statusCode
   - infoMessages
   - sqlState
   - errorCode
   - errorMessage
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'statusCode', None, None, ), # 1
    (2, TType.LIST, 'infoMessages', (TType.STRING,None), None, ), # 2
    (3, TType.STRING, 'sqlState', None, None, ), # 3
    (4, TType.I32, 'errorCode', None, None, ), # 4
    (5, TType.STRING, 'errorMessage', None, None, ), # 5
  )

  def __init__(self, statusCode=None, infoMessages=None, sqlState=None, errorCode=None, errorMessage=None,):
    self.statusCode = statusCode
    self.infoMessages = infoMessages
    self.sqlState = sqlState
    self.errorCode = errorCode
    self.errorMessage = errorMessage

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.statusCode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.infoMessages = []
          (_etype114, _size111) = iprot.readListBegin()
          for _i115 in xrange(_size111):
            _elem116 = iprot.readString();
            self.infoMessages.append(_elem116)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.sqlState = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.errorCode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.errorMessage = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TStatus')
    if self.statusCode is not None:
      oprot.writeFieldBegin('statusCode', TType.I32, 1)
      oprot.writeI32(self.statusCode)
      oprot.writeFieldEnd()
    if self.infoMessages is not None:
      oprot.writeFieldBegin('infoMessages', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.infoMessages))
      for iter117 in self.infoMessages:
        oprot.writeString(iter117)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sqlState is not None:
      oprot.writeFieldBegin('sqlState', TType.STRING, 3)
      oprot.writeString(self.sqlState)
      oprot.writeFieldEnd()
    if self.errorCode is not None:
      oprot.writeFieldBegin('errorCode', TType.I32, 4)
      oprot.writeI32(self.errorCode)
      oprot.writeFieldEnd()
    if self.errorMessage is not None:
      oprot.writeFieldBegin('errorMessage', TType.STRING, 5)
      oprot.writeString(self.errorMessage)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.statusCode is None:
      raise TProtocol.TProtocolException(message='Required field statusCode is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THandleIdentifier:
  """
  Attributes:
   - guid
   - secret
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.STRING, 'secret', None, None, ), # 2
  )

  def __init__(self, guid=None, secret=None,):
    self.guid = guid
    self.secret = secret

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.secret = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THandleIdentifier')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.secret is not None:
      oprot.writeFieldBegin('secret', TType.STRING, 2)
      oprot.writeString(self.secret)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.guid is None:
      raise TProtocol.TProtocolException(message='Required field guid is unset!')
    if self.secret is None:
      raise TProtocol.TProtocolException(message='Required field secret is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TSessionHandle:
  """
  Attributes:
   - sessionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sessionId', (THandleIdentifier, THandleIdentifier.thrift_spec), None, ), # 1
  )

  def __init__(self, sessionId=None,):
    self.sessionId = sessionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sessionId = THandleIdentifier()
          self.sessionId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TSessionHandle')
    if self.sessionId is not None:
      oprot.writeFieldBegin('sessionId', TType.STRUCT, 1)
      self.sessionId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.sessionId is None:
      raise TProtocol.TProtocolException(message='Required field sessionId is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TOperationHandle:
  """
  Attributes:
   - operationId
   - operationType
   - hasResultSet
   - modifiedRowCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'operationId', (THandleIdentifier, THandleIdentifier.thrift_spec), None, ), # 1
    (2, TType.I32, 'operationType', None, None, ), # 2
    (3, TType.BOOL, 'hasResultSet', None, None, ), # 3
    (4, TType.DOUBLE, 'modifiedRowCount', None, None, ), # 4
  )

  def __init__(self, operationId=None, operationType=None, hasResultSet=None, modifiedRowCount=None,):
    self.operationId = operationId
    self.operationType = operationType
    self.hasResultSet = hasResultSet
    self.modifiedRowCount = modifiedRowCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.operationId = THandleIdentifier()
          self.operationId.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.operationType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.hasResultSet = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.modifiedRowCount = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TOperationHandle')
    if self.operationId is not None:
      oprot.writeFieldBegin('operationId', TType.STRUCT, 1)
      self.operationId.write(oprot)
      oprot.writeFieldEnd()
    if self.operationType is not None:
      oprot.writeFieldBegin('operationType', TType.I32, 2)
      oprot.writeI32(self.operationType)
      oprot.writeFieldEnd()
    if self.hasResultSet is not None:
      oprot.writeFieldBegin('hasResultSet', TType.BOOL, 3)
      oprot.writeBool(self.hasResultSet)
      oprot.writeFieldEnd()
    if self.modifiedRowCount is not None:
      oprot.writeFieldBegin('modifiedRowCount', TType.DOUBLE, 4)
      oprot.writeDouble(self.modifiedRowCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.operationId is None:
      raise TProtocol.TProtocolException(message='Required field operationId is unset!')
    if self.operationType is None:
      raise TProtocol.TProtocolException(message='Required field operationType is unset!')
    if self.hasResultSet is None:
      raise TProtocol.TProtocolException(message='Required field hasResultSet is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TOpenSessionReq:
  """
  Attributes:
   - client_protocol
   - username
   - password
   - configuration
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'client_protocol', None,     2, ), # 1
    (2, TType.STRING, 'username', None, None, ), # 2
    (3, TType.STRING, 'password', None, None, ), # 3
    (4, TType.MAP, 'configuration', (TType.STRING,None,TType.STRING,None), None, ), # 4
  )

  def __init__(self, client_protocol=thrift_spec[1][4], username=None, password=None, configuration=None,):
    self.client_protocol = client_protocol
    self.username = username
    self.password = password
    self.configuration = configuration

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.client_protocol = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.username = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.password = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.configuration = {}
          (_ktype119, _vtype120, _size118 ) = iprot.readMapBegin() 
          for _i122 in xrange(_size118):
            _key123 = iprot.readString();
            _val124 = iprot.readString();
            self.configuration[_key123] = _val124
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TOpenSessionReq')
    if self.client_protocol is not None:
      oprot.writeFieldBegin('client_protocol', TType.I32, 1)
      oprot.writeI32(self.client_protocol)
      oprot.writeFieldEnd()
    if self.username is not None:
      oprot.writeFieldBegin('username', TType.STRING, 2)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.password is not None:
      oprot.writeFieldBegin('password', TType.STRING, 3)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    if self.configuration is not None:
      oprot.writeFieldBegin('configuration', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.configuration))
      for kiter125,viter126 in self.configuration.items():
        oprot.writeString(kiter125)
        oprot.writeString(viter126)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.client_protocol is None:
      raise TProtocol.TProtocolException(message='Required field client_protocol is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TOpenSessionResp:
  """
  Attributes:
   - status
   - serverProtocolVersion
   - sessionHandle
   - configuration
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
    (2, TType.I32, 'serverProtocolVersion', None,     3, ), # 2
    (3, TType.STRUCT, 'sessionHandle', (TSessionHandle, TSessionHandle.thrift_spec), None, ), # 3
    (4, TType.MAP, 'configuration', (TType.STRING,None,TType.STRING,None), None, ), # 4
  )

  def __init__(self, status=None, serverProtocolVersion=thrift_spec[2][4], sessionHandle=None, configuration=None,):
    self.status = status
    self.serverProtocolVersion = serverProtocolVersion
    self.sessionHandle = sessionHandle
    self.configuration = configuration

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.serverProtocolVersion = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.sessionHandle = TSessionHandle()
          self.sessionHandle.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.configuration = {}
          (_ktype128, _vtype129, _size127 ) = iprot.readMapBegin() 
          for _i131 in xrange(_size127):
            _key132 = iprot.readString();
            _val133 = iprot.readString();
            self.configuration[_key132] = _val133
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TOpenSessionResp')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.serverProtocolVersion is not None:
      oprot.writeFieldBegin('serverProtocolVersion', TType.I32, 2)
      oprot.writeI32(self.serverProtocolVersion)
      oprot.writeFieldEnd()
    if self.sessionHandle is not None:
      oprot.writeFieldBegin('sessionHandle', TType.STRUCT, 3)
      self.sessionHandle.write(oprot)
      oprot.writeFieldEnd()
    if self.configuration is not None:
      oprot.writeFieldBegin('configuration', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.configuration))
      for kiter134,viter135 in self.configuration.items():
        oprot.writeString(kiter134)
        oprot.writeString(viter135)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    if self.serverProtocolVersion is None:
      raise TProtocol.TProtocolException(message='Required field serverProtocolVersion is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCloseSessionReq:
  """
  Attributes:
   - sessionHandle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sessionHandle', (TSessionHandle, TSessionHandle.thrift_spec), None, ), # 1
  )

  def __init__(self, sessionHandle=None,):
    self.sessionHandle = sessionHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sessionHandle = TSessionHandle()
          self.sessionHandle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCloseSessionReq')
    if self.sessionHandle is not None:
      oprot.writeFieldBegin('sessionHandle', TType.STRUCT, 1)
      self.sessionHandle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.sessionHandle is None:
      raise TProtocol.TProtocolException(message='Required field sessionHandle is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCloseSessionResp:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCloseSessionResp')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetInfoValue:
  """
  Attributes:
   - stringValue
   - smallIntValue
   - integerBitmask
   - integerFlag
   - binaryValue
   - lenValue
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'stringValue', None, None, ), # 1
    (2, TType.I16, 'smallIntValue', None, None, ), # 2
    (3, TType.I32, 'integerBitmask', None, None, ), # 3
    (4, TType.I32, 'integerFlag', None, None, ), # 4
    (5, TType.I32, 'binaryValue', None, None, ), # 5
    (6, TType.I64, 'lenValue', None, None, ), # 6
  )

  def __init__(self, stringValue=None, smallIntValue=None, integerBitmask=None, integerFlag=None, binaryValue=None, lenValue=None,):
    self.stringValue = stringValue
    self.smallIntValue = smallIntValue
    self.integerBitmask = integerBitmask
    self.integerFlag = integerFlag
    self.binaryValue = binaryValue
    self.lenValue = lenValue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.stringValue = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.smallIntValue = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.integerBitmask = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.integerFlag = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.binaryValue = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.lenValue = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetInfoValue')
    if self.stringValue is not None:
      oprot.writeFieldBegin('stringValue', TType.STRING, 1)
      oprot.writeString(self.stringValue)
      oprot.writeFieldEnd()
    if self.smallIntValue is not None:
      oprot.writeFieldBegin('smallIntValue', TType.I16, 2)
      oprot.writeI16(self.smallIntValue)
      oprot.writeFieldEnd()
    if self.integerBitmask is not None:
      oprot.writeFieldBegin('integerBitmask', TType.I32, 3)
      oprot.writeI32(self.integerBitmask)
      oprot.writeFieldEnd()
    if self.integerFlag is not None:
      oprot.writeFieldBegin('integerFlag', TType.I32, 4)
      oprot.writeI32(self.integerFlag)
      oprot.writeFieldEnd()
    if self.binaryValue is not None:
      oprot.writeFieldBegin('binaryValue', TType.I32, 5)
      oprot.writeI32(self.binaryValue)
      oprot.writeFieldEnd()
    if self.lenValue is not None:
      oprot.writeFieldBegin('lenValue', TType.I64, 6)
      oprot.writeI64(self.lenValue)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetInfoReq:
  """
  Attributes:
   - sessionHandle
   - infoType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sessionHandle', (TSessionHandle, TSessionHandle.thrift_spec), None, ), # 1
    (2, TType.I32, 'infoType', None, None, ), # 2
  )

  def __init__(self, sessionHandle=None, infoType=None,):
    self.sessionHandle = sessionHandle
    self.infoType = infoType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sessionHandle = TSessionHandle()
          self.sessionHandle.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.infoType = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetInfoReq')
    if self.sessionHandle is not None:
      oprot.writeFieldBegin('sessionHandle', TType.STRUCT, 1)
      self.sessionHandle.write(oprot)
      oprot.writeFieldEnd()
    if self.infoType is not None:
      oprot.writeFieldBegin('infoType', TType.I32, 2)
      oprot.writeI32(self.infoType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.sessionHandle is None:
      raise TProtocol.TProtocolException(message='Required field sessionHandle is unset!')
    if self.infoType is None:
      raise TProtocol.TProtocolException(message='Required field infoType is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetInfoResp:
  """
  Attributes:
   - status
   - infoValue
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'infoValue', (TGetInfoValue, TGetInfoValue.thrift_spec), None, ), # 2
  )

  def __init__(self, status=None, infoValue=None,):
    self.status = status
    self.infoValue = infoValue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.infoValue = TGetInfoValue()
          self.infoValue.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetInfoResp')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.infoValue is not None:
      oprot.writeFieldBegin('infoValue', TType.STRUCT, 2)
      self.infoValue.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    if self.infoValue is None:
      raise TProtocol.TProtocolException(message='Required field infoValue is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TExecuteStatementReq:
  """
  Attributes:
   - sessionHandle
   - statement
   - confOverlay
   - runAsync
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sessionHandle', (TSessionHandle, TSessionHandle.thrift_spec), None, ), # 1
    (2, TType.STRING, 'statement', None, None, ), # 2
    (3, TType.MAP, 'confOverlay', (TType.STRING,None,TType.STRING,None), None, ), # 3
    (4, TType.BOOL, 'runAsync', None, False, ), # 4
  )

  def __init__(self, sessionHandle=None, statement=None, confOverlay=None, runAsync=thrift_spec[4][4],):
    self.sessionHandle = sessionHandle
    self.statement = statement
    self.confOverlay = confOverlay
    self.runAsync = runAsync

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sessionHandle = TSessionHandle()
          self.sessionHandle.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.statement = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.confOverlay = {}
          (_ktype137, _vtype138, _size136 ) = iprot.readMapBegin() 
          for _i140 in xrange(_size136):
            _key141 = iprot.readString();
            _val142 = iprot.readString();
            self.confOverlay[_key141] = _val142
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.runAsync = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TExecuteStatementReq')
    if self.sessionHandle is not None:
      oprot.writeFieldBegin('sessionHandle', TType.STRUCT, 1)
      self.sessionHandle.write(oprot)
      oprot.writeFieldEnd()
    if self.statement is not None:
      oprot.writeFieldBegin('statement', TType.STRING, 2)
      oprot.writeString(self.statement)
      oprot.writeFieldEnd()
    if self.confOverlay is not None:
      oprot.writeFieldBegin('confOverlay', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.confOverlay))
      for kiter143,viter144 in self.confOverlay.items():
        oprot.writeString(kiter143)
        oprot.writeString(viter144)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.runAsync is not None:
      oprot.writeFieldBegin('runAsync', TType.BOOL, 4)
      oprot.writeBool(self.runAsync)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.sessionHandle is None:
      raise TProtocol.TProtocolException(message='Required field sessionHandle is unset!')
    if self.statement is None:
      raise TProtocol.TProtocolException(message='Required field statement is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TExecuteStatementResp:
  """
  Attributes:
   - status
   - operationHandle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'operationHandle', (TOperationHandle, TOperationHandle.thrift_spec), None, ), # 2
  )

  def __init__(self, status=None, operationHandle=None,):
    self.status = status
    self.operationHandle = operationHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.operationHandle = TOperationHandle()
          self.operationHandle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TExecuteStatementResp')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.operationHandle is not None:
      oprot.writeFieldBegin('operationHandle', TType.STRUCT, 2)
      self.operationHandle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetTypeInfoReq:
  """
  Attributes:
   - sessionHandle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sessionHandle', (TSessionHandle, TSessionHandle.thrift_spec), None, ), # 1
  )

  def __init__(self, sessionHandle=None,):
    self.sessionHandle = sessionHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sessionHandle = TSessionHandle()
          self.sessionHandle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetTypeInfoReq')
    if self.sessionHandle is not None:
      oprot.writeFieldBegin('sessionHandle', TType.STRUCT, 1)
      self.sessionHandle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.sessionHandle is None:
      raise TProtocol.TProtocolException(message='Required field sessionHandle is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetTypeInfoResp:
  """
  Attributes:
   - status
   - operationHandle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'operationHandle', (TOperationHandle, TOperationHandle.thrift_spec), None, ), # 2
  )

  def __init__(self, status=None, operationHandle=None,):
    self.status = status
    self.operationHandle = operationHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.operationHandle = TOperationHandle()
          self.operationHandle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetTypeInfoResp')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.operationHandle is not None:
      oprot.writeFieldBegin('operationHandle', TType.STRUCT, 2)
      self.operationHandle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetCatalogsReq:
  """
  Attributes:
   - sessionHandle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sessionHandle', (TSessionHandle, TSessionHandle.thrift_spec), None, ), # 1
  )

  def __init__(self, sessionHandle=None,):
    self.sessionHandle = sessionHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sessionHandle = TSessionHandle()
          self.sessionHandle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetCatalogsReq')
    if self.sessionHandle is not None:
      oprot.writeFieldBegin('sessionHandle', TType.STRUCT, 1)
      self.sessionHandle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.sessionHandle is None:
      raise TProtocol.TProtocolException(message='Required field sessionHandle is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetCatalogsResp:
  """
  Attributes:
   - status
   - operationHandle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'operationHandle', (TOperationHandle, TOperationHandle.thrift_spec), None, ), # 2
  )

  def __init__(self, status=None, operationHandle=None,):
    self.status = status
    self.operationHandle = operationHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.operationHandle = TOperationHandle()
          self.operationHandle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetCatalogsResp')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.operationHandle is not None:
      oprot.writeFieldBegin('operationHandle', TType.STRUCT, 2)
      self.operationHandle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetSchemasReq:
  """
  Attributes:
   - sessionHandle
   - catalogName
   - schemaName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sessionHandle', (TSessionHandle, TSessionHandle.thrift_spec), None, ), # 1
    (2, TType.STRING, 'catalogName', None, None, ), # 2
    (3, TType.STRING, 'schemaName', None, None, ), # 3
  )

  def __init__(self, sessionHandle=None, catalogName=None, schemaName=None,):
    self.sessionHandle = sessionHandle
    self.catalogName = catalogName
    self.schemaName = schemaName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sessionHandle = TSessionHandle()
          self.sessionHandle.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.catalogName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.schemaName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetSchemasReq')
    if self.sessionHandle is not None:
      oprot.writeFieldBegin('sessionHandle', TType.STRUCT, 1)
      self.sessionHandle.write(oprot)
      oprot.writeFieldEnd()
    if self.catalogName is not None:
      oprot.writeFieldBegin('catalogName', TType.STRING, 2)
      oprot.writeString(self.catalogName)
      oprot.writeFieldEnd()
    if self.schemaName is not None:
      oprot.writeFieldBegin('schemaName', TType.STRING, 3)
      oprot.writeString(self.schemaName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.sessionHandle is None:
      raise TProtocol.TProtocolException(message='Required field sessionHandle is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetSchemasResp:
  """
  Attributes:
   - status
   - operationHandle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'operationHandle', (TOperationHandle, TOperationHandle.thrift_spec), None, ), # 2
  )

  def __init__(self, status=None, operationHandle=None,):
    self.status = status
    self.operationHandle = operationHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.operationHandle = TOperationHandle()
          self.operationHandle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetSchemasResp')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.operationHandle is not None:
      oprot.writeFieldBegin('operationHandle', TType.STRUCT, 2)
      self.operationHandle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetTablesReq:
  """
  Attributes:
   - sessionHandle
   - catalogName
   - schemaName
   - tableName
   - tableTypes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sessionHandle', (TSessionHandle, TSessionHandle.thrift_spec), None, ), # 1
    (2, TType.STRING, 'catalogName', None, None, ), # 2
    (3, TType.STRING, 'schemaName', None, None, ), # 3
    (4, TType.STRING, 'tableName', None, None, ), # 4
    (5, TType.LIST, 'tableTypes', (TType.STRING,None), None, ), # 5
  )

  def __init__(self, sessionHandle=None, catalogName=None, schemaName=None, tableName=None, tableTypes=None,):
    self.sessionHandle = sessionHandle
    self.catalogName = catalogName
    self.schemaName = schemaName
    self.tableName = tableName
    self.tableTypes = tableTypes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sessionHandle = TSessionHandle()
          self.sessionHandle.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.catalogName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.schemaName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.tableTypes = []
          (_etype148, _size145) = iprot.readListBegin()
          for _i149 in xrange(_size145):
            _elem150 = iprot.readString();
            self.tableTypes.append(_elem150)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetTablesReq')
    if self.sessionHandle is not None:
      oprot.writeFieldBegin('sessionHandle', TType.STRUCT, 1)
      self.sessionHandle.write(oprot)
      oprot.writeFieldEnd()
    if self.catalogName is not None:
      oprot.writeFieldBegin('catalogName', TType.STRING, 2)
      oprot.writeString(self.catalogName)
      oprot.writeFieldEnd()
    if self.schemaName is not None:
      oprot.writeFieldBegin('schemaName', TType.STRING, 3)
      oprot.writeString(self.schemaName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 4)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.tableTypes is not None:
      oprot.writeFieldBegin('tableTypes', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.tableTypes))
      for iter151 in self.tableTypes:
        oprot.writeString(iter151)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.sessionHandle is None:
      raise TProtocol.TProtocolException(message='Required field sessionHandle is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetTablesResp:
  """
  Attributes:
   - status
   - operationHandle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'operationHandle', (TOperationHandle, TOperationHandle.thrift_spec), None, ), # 2
  )

  def __init__(self, status=None, operationHandle=None,):
    self.status = status
    self.operationHandle = operationHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.operationHandle = TOperationHandle()
          self.operationHandle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetTablesResp')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.operationHandle is not None:
      oprot.writeFieldBegin('operationHandle', TType.STRUCT, 2)
      self.operationHandle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetTableTypesReq:
  """
  Attributes:
   - sessionHandle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sessionHandle', (TSessionHandle, TSessionHandle.thrift_spec), None, ), # 1
  )

  def __init__(self, sessionHandle=None,):
    self.sessionHandle = sessionHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sessionHandle = TSessionHandle()
          self.sessionHandle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetTableTypesReq')
    if self.sessionHandle is not None:
      oprot.writeFieldBegin('sessionHandle', TType.STRUCT, 1)
      self.sessionHandle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.sessionHandle is None:
      raise TProtocol.TProtocolException(message='Required field sessionHandle is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetTableTypesResp:
  """
  Attributes:
   - status
   - operationHandle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'operationHandle', (TOperationHandle, TOperationHandle.thrift_spec), None, ), # 2
  )

  def __init__(self, status=None, operationHandle=None,):
    self.status = status
    self.operationHandle = operationHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.operationHandle = TOperationHandle()
          self.operationHandle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetTableTypesResp')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.operationHandle is not None:
      oprot.writeFieldBegin('operationHandle', TType.STRUCT, 2)
      self.operationHandle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetColumnsReq:
  """
  Attributes:
   - sessionHandle
   - catalogName
   - schemaName
   - tableName
   - columnName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sessionHandle', (TSessionHandle, TSessionHandle.thrift_spec), None, ), # 1
    (2, TType.STRING, 'catalogName', None, None, ), # 2
    (3, TType.STRING, 'schemaName', None, None, ), # 3
    (4, TType.STRING, 'tableName', None, None, ), # 4
    (5, TType.STRING, 'columnName', None, None, ), # 5
  )

  def __init__(self, sessionHandle=None, catalogName=None, schemaName=None, tableName=None, columnName=None,):
    self.sessionHandle = sessionHandle
    self.catalogName = catalogName
    self.schemaName = schemaName
    self.tableName = tableName
    self.columnName = columnName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sessionHandle = TSessionHandle()
          self.sessionHandle.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.catalogName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.schemaName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.columnName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetColumnsReq')
    if self.sessionHandle is not None:
      oprot.writeFieldBegin('sessionHandle', TType.STRUCT, 1)
      self.sessionHandle.write(oprot)
      oprot.writeFieldEnd()
    if self.catalogName is not None:
      oprot.writeFieldBegin('catalogName', TType.STRING, 2)
      oprot.writeString(self.catalogName)
      oprot.writeFieldEnd()
    if self.schemaName is not None:
      oprot.writeFieldBegin('schemaName', TType.STRING, 3)
      oprot.writeString(self.schemaName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 4)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.columnName is not None:
      oprot.writeFieldBegin('columnName', TType.STRING, 5)
      oprot.writeString(self.columnName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.sessionHandle is None:
      raise TProtocol.TProtocolException(message='Required field sessionHandle is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetColumnsResp:
  """
  Attributes:
   - status
   - operationHandle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'operationHandle', (TOperationHandle, TOperationHandle.thrift_spec), None, ), # 2
  )

  def __init__(self, status=None, operationHandle=None,):
    self.status = status
    self.operationHandle = operationHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.operationHandle = TOperationHandle()
          self.operationHandle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetColumnsResp')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.operationHandle is not None:
      oprot.writeFieldBegin('operationHandle', TType.STRUCT, 2)
      self.operationHandle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetFunctionsReq:
  """
  Attributes:
   - sessionHandle
   - catalogName
   - schemaName
   - functionName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sessionHandle', (TSessionHandle, TSessionHandle.thrift_spec), None, ), # 1
    (2, TType.STRING, 'catalogName', None, None, ), # 2
    (3, TType.STRING, 'schemaName', None, None, ), # 3
    (4, TType.STRING, 'functionName', None, None, ), # 4
  )

  def __init__(self, sessionHandle=None, catalogName=None, schemaName=None, functionName=None,):
    self.sessionHandle = sessionHandle
    self.catalogName = catalogName
    self.schemaName = schemaName
    self.functionName = functionName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sessionHandle = TSessionHandle()
          self.sessionHandle.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.catalogName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.schemaName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.functionName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetFunctionsReq')
    if self.sessionHandle is not None:
      oprot.writeFieldBegin('sessionHandle', TType.STRUCT, 1)
      self.sessionHandle.write(oprot)
      oprot.writeFieldEnd()
    if self.catalogName is not None:
      oprot.writeFieldBegin('catalogName', TType.STRING, 2)
      oprot.writeString(self.catalogName)
      oprot.writeFieldEnd()
    if self.schemaName is not None:
      oprot.writeFieldBegin('schemaName', TType.STRING, 3)
      oprot.writeString(self.schemaName)
      oprot.writeFieldEnd()
    if self.functionName is not None:
      oprot.writeFieldBegin('functionName', TType.STRING, 4)
      oprot.writeString(self.functionName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.sessionHandle is None:
      raise TProtocol.TProtocolException(message='Required field sessionHandle is unset!')
    if self.functionName is None:
      raise TProtocol.TProtocolException(message='Required field functionName is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetFunctionsResp:
  """
  Attributes:
   - status
   - operationHandle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'operationHandle', (TOperationHandle, TOperationHandle.thrift_spec), None, ), # 2
  )

  def __init__(self, status=None, operationHandle=None,):
    self.status = status
    self.operationHandle = operationHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.operationHandle = TOperationHandle()
          self.operationHandle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetFunctionsResp')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.operationHandle is not None:
      oprot.writeFieldBegin('operationHandle', TType.STRUCT, 2)
      self.operationHandle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetOperationStatusReq:
  """
  Attributes:
   - operationHandle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'operationHandle', (TOperationHandle, TOperationHandle.thrift_spec), None, ), # 1
  )

  def __init__(self, operationHandle=None,):
    self.operationHandle = operationHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.operationHandle = TOperationHandle()
          self.operationHandle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetOperationStatusReq')
    if self.operationHandle is not None:
      oprot.writeFieldBegin('operationHandle', TType.STRUCT, 1)
      self.operationHandle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.operationHandle is None:
      raise TProtocol.TProtocolException(message='Required field operationHandle is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetOperationStatusResp:
  """
  Attributes:
   - status
   - operationState
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
    (2, TType.I32, 'operationState', None, None, ), # 2
  )

  def __init__(self, status=None, operationState=None,):
    self.status = status
    self.operationState = operationState

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.operationState = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetOperationStatusResp')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.operationState is not None:
      oprot.writeFieldBegin('operationState', TType.I32, 2)
      oprot.writeI32(self.operationState)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCancelOperationReq:
  """
  Attributes:
   - operationHandle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'operationHandle', (TOperationHandle, TOperationHandle.thrift_spec), None, ), # 1
  )

  def __init__(self, operationHandle=None,):
    self.operationHandle = operationHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.operationHandle = TOperationHandle()
          self.operationHandle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCancelOperationReq')
    if self.operationHandle is not None:
      oprot.writeFieldBegin('operationHandle', TType.STRUCT, 1)
      self.operationHandle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.operationHandle is None:
      raise TProtocol.TProtocolException(message='Required field operationHandle is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCancelOperationResp:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCancelOperationResp')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCloseOperationReq:
  """
  Attributes:
   - operationHandle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'operationHandle', (TOperationHandle, TOperationHandle.thrift_spec), None, ), # 1
  )

  def __init__(self, operationHandle=None,):
    self.operationHandle = operationHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.operationHandle = TOperationHandle()
          self.operationHandle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCloseOperationReq')
    if self.operationHandle is not None:
      oprot.writeFieldBegin('operationHandle', TType.STRUCT, 1)
      self.operationHandle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.operationHandle is None:
      raise TProtocol.TProtocolException(message='Required field operationHandle is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCloseOperationResp:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCloseOperationResp')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetResultSetMetadataReq:
  """
  Attributes:
   - operationHandle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'operationHandle', (TOperationHandle, TOperationHandle.thrift_spec), None, ), # 1
  )

  def __init__(self, operationHandle=None,):
    self.operationHandle = operationHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.operationHandle = TOperationHandle()
          self.operationHandle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetResultSetMetadataReq')
    if self.operationHandle is not None:
      oprot.writeFieldBegin('operationHandle', TType.STRUCT, 1)
      self.operationHandle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.operationHandle is None:
      raise TProtocol.TProtocolException(message='Required field operationHandle is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetResultSetMetadataResp:
  """
  Attributes:
   - status
   - schema
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'schema', (TTableSchema, TTableSchema.thrift_spec), None, ), # 2
  )

  def __init__(self, status=None, schema=None,):
    self.status = status
    self.schema = schema

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.schema = TTableSchema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetResultSetMetadataResp')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.schema is not None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 2)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TFetchResultsReq:
  """
  Attributes:
   - operationHandle
   - orientation
   - maxRows
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'operationHandle', (TOperationHandle, TOperationHandle.thrift_spec), None, ), # 1
    (2, TType.I32, 'orientation', None,     0, ), # 2
    (3, TType.I64, 'maxRows', None, None, ), # 3
  )

  def __init__(self, operationHandle=None, orientation=thrift_spec[2][4], maxRows=None,):
    self.operationHandle = operationHandle
    self.orientation = orientation
    self.maxRows = maxRows

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.operationHandle = TOperationHandle()
          self.operationHandle.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.orientation = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.maxRows = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TFetchResultsReq')
    if self.operationHandle is not None:
      oprot.writeFieldBegin('operationHandle', TType.STRUCT, 1)
      self.operationHandle.write(oprot)
      oprot.writeFieldEnd()
    if self.orientation is not None:
      oprot.writeFieldBegin('orientation', TType.I32, 2)
      oprot.writeI32(self.orientation)
      oprot.writeFieldEnd()
    if self.maxRows is not None:
      oprot.writeFieldBegin('maxRows', TType.I64, 3)
      oprot.writeI64(self.maxRows)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.operationHandle is None:
      raise TProtocol.TProtocolException(message='Required field operationHandle is unset!')
    if self.orientation is None:
      raise TProtocol.TProtocolException(message='Required field orientation is unset!')
    if self.maxRows is None:
      raise TProtocol.TProtocolException(message='Required field maxRows is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TFetchResultsResp:
  """
  Attributes:
   - status
   - hasMoreRows
   - results
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'hasMoreRows', None, None, ), # 2
    (3, TType.STRUCT, 'results', (TRowSet, TRowSet.thrift_spec), None, ), # 3
  )

  def __init__(self, status=None, hasMoreRows=None, results=None,):
    self.status = status
    self.hasMoreRows = hasMoreRows
    self.results = results

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.hasMoreRows = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.results = TRowSet()
          self.results.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TFetchResultsResp')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.hasMoreRows is not None:
      oprot.writeFieldBegin('hasMoreRows', TType.BOOL, 2)
      oprot.writeBool(self.hasMoreRows)
      oprot.writeFieldEnd()
    if self.results is not None:
      oprot.writeFieldBegin('results', TType.STRUCT, 3)
      self.results.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
