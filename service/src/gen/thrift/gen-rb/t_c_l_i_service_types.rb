#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'

module TProtocolVersion
  HIVE_CLI_SERVICE_PROTOCOL_V1 = 0
  VALUE_MAP = {0 => "HIVE_CLI_SERVICE_PROTOCOL_V1"}
  VALID_VALUES = Set.new([HIVE_CLI_SERVICE_PROTOCOL_V1]).freeze
end

module TTypeId
  BOOLEAN_TYPE = 0
  TINYINT_TYPE = 1
  SMALLINT_TYPE = 2
  INT_TYPE = 3
  BIGINT_TYPE = 4
  FLOAT_TYPE = 5
  DOUBLE_TYPE = 6
  STRING_TYPE = 7
  TIMESTAMP_TYPE = 8
  BINARY_TYPE = 9
  ARRAY_TYPE = 10
  MAP_TYPE = 11
  STRUCT_TYPE = 12
  UNION_TYPE = 13
  USER_DEFINED_TYPE = 14
  DECIMAL_TYPE = 15
  VALUE_MAP = {0 => "BOOLEAN_TYPE", 1 => "TINYINT_TYPE", 2 => "SMALLINT_TYPE", 3 => "INT_TYPE", 4 => "BIGINT_TYPE", 5 => "FLOAT_TYPE", 6 => "DOUBLE_TYPE", 7 => "STRING_TYPE", 8 => "TIMESTAMP_TYPE", 9 => "BINARY_TYPE", 10 => "ARRAY_TYPE", 11 => "MAP_TYPE", 12 => "STRUCT_TYPE", 13 => "UNION_TYPE", 14 => "USER_DEFINED_TYPE", 15 => "DECIMAL_TYPE"}
  VALID_VALUES = Set.new([BOOLEAN_TYPE, TINYINT_TYPE, SMALLINT_TYPE, INT_TYPE, BIGINT_TYPE, FLOAT_TYPE, DOUBLE_TYPE, STRING_TYPE, TIMESTAMP_TYPE, BINARY_TYPE, ARRAY_TYPE, MAP_TYPE, STRUCT_TYPE, UNION_TYPE, USER_DEFINED_TYPE, DECIMAL_TYPE]).freeze
end

module TStatusCode
  SUCCESS_STATUS = 0
  SUCCESS_WITH_INFO_STATUS = 1
  STILL_EXECUTING_STATUS = 2
  ERROR_STATUS = 3
  INVALID_HANDLE_STATUS = 4
  VALUE_MAP = {0 => "SUCCESS_STATUS", 1 => "SUCCESS_WITH_INFO_STATUS", 2 => "STILL_EXECUTING_STATUS", 3 => "ERROR_STATUS", 4 => "INVALID_HANDLE_STATUS"}
  VALID_VALUES = Set.new([SUCCESS_STATUS, SUCCESS_WITH_INFO_STATUS, STILL_EXECUTING_STATUS, ERROR_STATUS, INVALID_HANDLE_STATUS]).freeze
end

module TOperationState
  INITIALIZED_STATE = 0
  RUNNING_STATE = 1
  FINISHED_STATE = 2
  CANCELED_STATE = 3
  CLOSED_STATE = 4
  ERROR_STATE = 5
  UKNOWN_STATE = 6
  VALUE_MAP = {0 => "INITIALIZED_STATE", 1 => "RUNNING_STATE", 2 => "FINISHED_STATE", 3 => "CANCELED_STATE", 4 => "CLOSED_STATE", 5 => "ERROR_STATE", 6 => "UKNOWN_STATE"}
  VALID_VALUES = Set.new([INITIALIZED_STATE, RUNNING_STATE, FINISHED_STATE, CANCELED_STATE, CLOSED_STATE, ERROR_STATE, UKNOWN_STATE]).freeze
end

module TOperationType
  EXECUTE_STATEMENT = 0
  GET_TYPE_INFO = 1
  GET_CATALOGS = 2
  GET_SCHEMAS = 3
  GET_TABLES = 4
  GET_TABLE_TYPES = 5
  GET_COLUMNS = 6
  GET_FUNCTIONS = 7
  UNKNOWN = 8
  VALUE_MAP = {0 => "EXECUTE_STATEMENT", 1 => "GET_TYPE_INFO", 2 => "GET_CATALOGS", 3 => "GET_SCHEMAS", 4 => "GET_TABLES", 5 => "GET_TABLE_TYPES", 6 => "GET_COLUMNS", 7 => "GET_FUNCTIONS", 8 => "UNKNOWN"}
  VALID_VALUES = Set.new([EXECUTE_STATEMENT, GET_TYPE_INFO, GET_CATALOGS, GET_SCHEMAS, GET_TABLES, GET_TABLE_TYPES, GET_COLUMNS, GET_FUNCTIONS, UNKNOWN]).freeze
end

module TGetInfoType
  CLI_MAX_DRIVER_CONNECTIONS = 0
  CLI_MAX_CONCURRENT_ACTIVITIES = 1
  CLI_DATA_SOURCE_NAME = 2
  CLI_FETCH_DIRECTION = 8
  CLI_SERVER_NAME = 13
  CLI_SEARCH_PATTERN_ESCAPE = 14
  CLI_DBMS_NAME = 17
  CLI_DBMS_VER = 18
  CLI_ACCESSIBLE_TABLES = 19
  CLI_ACCESSIBLE_PROCEDURES = 20
  CLI_CURSOR_COMMIT_BEHAVIOR = 23
  CLI_DATA_SOURCE_READ_ONLY = 25
  CLI_DEFAULT_TXN_ISOLATION = 26
  CLI_IDENTIFIER_CASE = 28
  CLI_IDENTIFIER_QUOTE_CHAR = 29
  CLI_MAX_COLUMN_NAME_LEN = 30
  CLI_MAX_CURSOR_NAME_LEN = 31
  CLI_MAX_SCHEMA_NAME_LEN = 32
  CLI_MAX_CATALOG_NAME_LEN = 34
  CLI_MAX_TABLE_NAME_LEN = 35
  CLI_SCROLL_CONCURRENCY = 43
  CLI_TXN_CAPABLE = 46
  CLI_USER_NAME = 47
  CLI_TXN_ISOLATION_OPTION = 72
  CLI_INTEGRITY = 73
  CLI_GETDATA_EXTENSIONS = 81
  CLI_NULL_COLLATION = 85
  CLI_ALTER_TABLE = 86
  CLI_ORDER_BY_COLUMNS_IN_SELECT = 90
  CLI_SPECIAL_CHARACTERS = 94
  CLI_MAX_COLUMNS_IN_GROUP_BY = 97
  CLI_MAX_COLUMNS_IN_INDEX = 98
  CLI_MAX_COLUMNS_IN_ORDER_BY = 99
  CLI_MAX_COLUMNS_IN_SELECT = 100
  CLI_MAX_COLUMNS_IN_TABLE = 101
  CLI_MAX_INDEX_SIZE = 102
  CLI_MAX_ROW_SIZE = 104
  CLI_MAX_STATEMENT_LEN = 105
  CLI_MAX_TABLES_IN_SELECT = 106
  CLI_MAX_USER_NAME_LEN = 107
  CLI_OJ_CAPABILITIES = 115
  CLI_XOPEN_CLI_YEAR = 10000
  CLI_CURSOR_SENSITIVITY = 10001
  CLI_DESCRIBE_PARAMETER = 10002
  CLI_CATALOG_NAME = 10003
  CLI_COLLATION_SEQ = 10004
  CLI_MAX_IDENTIFIER_LEN = 10005
  VALUE_MAP = {0 => "CLI_MAX_DRIVER_CONNECTIONS", 1 => "CLI_MAX_CONCURRENT_ACTIVITIES", 2 => "CLI_DATA_SOURCE_NAME", 8 => "CLI_FETCH_DIRECTION", 13 => "CLI_SERVER_NAME", 14 => "CLI_SEARCH_PATTERN_ESCAPE", 17 => "CLI_DBMS_NAME", 18 => "CLI_DBMS_VER", 19 => "CLI_ACCESSIBLE_TABLES", 20 => "CLI_ACCESSIBLE_PROCEDURES", 23 => "CLI_CURSOR_COMMIT_BEHAVIOR", 25 => "CLI_DATA_SOURCE_READ_ONLY", 26 => "CLI_DEFAULT_TXN_ISOLATION", 28 => "CLI_IDENTIFIER_CASE", 29 => "CLI_IDENTIFIER_QUOTE_CHAR", 30 => "CLI_MAX_COLUMN_NAME_LEN", 31 => "CLI_MAX_CURSOR_NAME_LEN", 32 => "CLI_MAX_SCHEMA_NAME_LEN", 34 => "CLI_MAX_CATALOG_NAME_LEN", 35 => "CLI_MAX_TABLE_NAME_LEN", 43 => "CLI_SCROLL_CONCURRENCY", 46 => "CLI_TXN_CAPABLE", 47 => "CLI_USER_NAME", 72 => "CLI_TXN_ISOLATION_OPTION", 73 => "CLI_INTEGRITY", 81 => "CLI_GETDATA_EXTENSIONS", 85 => "CLI_NULL_COLLATION", 86 => "CLI_ALTER_TABLE", 90 => "CLI_ORDER_BY_COLUMNS_IN_SELECT", 94 => "CLI_SPECIAL_CHARACTERS", 97 => "CLI_MAX_COLUMNS_IN_GROUP_BY", 98 => "CLI_MAX_COLUMNS_IN_INDEX", 99 => "CLI_MAX_COLUMNS_IN_ORDER_BY", 100 => "CLI_MAX_COLUMNS_IN_SELECT", 101 => "CLI_MAX_COLUMNS_IN_TABLE", 102 => "CLI_MAX_INDEX_SIZE", 104 => "CLI_MAX_ROW_SIZE", 105 => "CLI_MAX_STATEMENT_LEN", 106 => "CLI_MAX_TABLES_IN_SELECT", 107 => "CLI_MAX_USER_NAME_LEN", 115 => "CLI_OJ_CAPABILITIES", 10000 => "CLI_XOPEN_CLI_YEAR", 10001 => "CLI_CURSOR_SENSITIVITY", 10002 => "CLI_DESCRIBE_PARAMETER", 10003 => "CLI_CATALOG_NAME", 10004 => "CLI_COLLATION_SEQ", 10005 => "CLI_MAX_IDENTIFIER_LEN"}
  VALID_VALUES = Set.new([CLI_MAX_DRIVER_CONNECTIONS, CLI_MAX_CONCURRENT_ACTIVITIES, CLI_DATA_SOURCE_NAME, CLI_FETCH_DIRECTION, CLI_SERVER_NAME, CLI_SEARCH_PATTERN_ESCAPE, CLI_DBMS_NAME, CLI_DBMS_VER, CLI_ACCESSIBLE_TABLES, CLI_ACCESSIBLE_PROCEDURES, CLI_CURSOR_COMMIT_BEHAVIOR, CLI_DATA_SOURCE_READ_ONLY, CLI_DEFAULT_TXN_ISOLATION, CLI_IDENTIFIER_CASE, CLI_IDENTIFIER_QUOTE_CHAR, CLI_MAX_COLUMN_NAME_LEN, CLI_MAX_CURSOR_NAME_LEN, CLI_MAX_SCHEMA_NAME_LEN, CLI_MAX_CATALOG_NAME_LEN, CLI_MAX_TABLE_NAME_LEN, CLI_SCROLL_CONCURRENCY, CLI_TXN_CAPABLE, CLI_USER_NAME, CLI_TXN_ISOLATION_OPTION, CLI_INTEGRITY, CLI_GETDATA_EXTENSIONS, CLI_NULL_COLLATION, CLI_ALTER_TABLE, CLI_ORDER_BY_COLUMNS_IN_SELECT, CLI_SPECIAL_CHARACTERS, CLI_MAX_COLUMNS_IN_GROUP_BY, CLI_MAX_COLUMNS_IN_INDEX, CLI_MAX_COLUMNS_IN_ORDER_BY, CLI_MAX_COLUMNS_IN_SELECT, CLI_MAX_COLUMNS_IN_TABLE, CLI_MAX_INDEX_SIZE, CLI_MAX_ROW_SIZE, CLI_MAX_STATEMENT_LEN, CLI_MAX_TABLES_IN_SELECT, CLI_MAX_USER_NAME_LEN, CLI_OJ_CAPABILITIES, CLI_XOPEN_CLI_YEAR, CLI_CURSOR_SENSITIVITY, CLI_DESCRIBE_PARAMETER, CLI_CATALOG_NAME, CLI_COLLATION_SEQ, CLI_MAX_IDENTIFIER_LEN]).freeze
end

module TFetchOrientation
  FETCH_NEXT = 0
  FETCH_PRIOR = 1
  FETCH_RELATIVE = 2
  FETCH_ABSOLUTE = 3
  FETCH_FIRST = 4
  FETCH_LAST = 5
  VALUE_MAP = {0 => "FETCH_NEXT", 1 => "FETCH_PRIOR", 2 => "FETCH_RELATIVE", 3 => "FETCH_ABSOLUTE", 4 => "FETCH_FIRST", 5 => "FETCH_LAST"}
  VALID_VALUES = Set.new([FETCH_NEXT, FETCH_PRIOR, FETCH_RELATIVE, FETCH_ABSOLUTE, FETCH_FIRST, FETCH_LAST]).freeze
end

class TPrimitiveTypeEntry
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TYPE = 1

  FIELDS = {
    TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::TTypeId}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field type is unset!') unless @type
    unless @type.nil? || ::TTypeId::VALID_VALUES.include?(@type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class TArrayTypeEntry
  include ::Thrift::Struct, ::Thrift::Struct_Union
  OBJECTTYPEPTR = 1

  FIELDS = {
    OBJECTTYPEPTR => {:type => ::Thrift::Types::I32, :name => 'objectTypePtr'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field objectTypePtr is unset!') unless @objectTypePtr
  end

  ::Thrift::Struct.generate_accessors self
end

class TMapTypeEntry
  include ::Thrift::Struct, ::Thrift::Struct_Union
  KEYTYPEPTR = 1
  VALUETYPEPTR = 2

  FIELDS = {
    KEYTYPEPTR => {:type => ::Thrift::Types::I32, :name => 'keyTypePtr'},
    VALUETYPEPTR => {:type => ::Thrift::Types::I32, :name => 'valueTypePtr'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field keyTypePtr is unset!') unless @keyTypePtr
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field valueTypePtr is unset!') unless @valueTypePtr
  end

  ::Thrift::Struct.generate_accessors self
end

class TStructTypeEntry
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NAMETOTYPEPTR = 1

  FIELDS = {
    NAMETOTYPEPTR => {:type => ::Thrift::Types::MAP, :name => 'nameToTypePtr', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I32}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field nameToTypePtr is unset!') unless @nameToTypePtr
  end

  ::Thrift::Struct.generate_accessors self
end

class TUnionTypeEntry
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NAMETOTYPEPTR = 1

  FIELDS = {
    NAMETOTYPEPTR => {:type => ::Thrift::Types::MAP, :name => 'nameToTypePtr', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I32}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field nameToTypePtr is unset!') unless @nameToTypePtr
  end

  ::Thrift::Struct.generate_accessors self
end

class TUserDefinedTypeEntry
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TYPECLASSNAME = 1

  FIELDS = {
    TYPECLASSNAME => {:type => ::Thrift::Types::STRING, :name => 'typeClassName'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field typeClassName is unset!') unless @typeClassName
  end

  ::Thrift::Struct.generate_accessors self
end

class TTypeEntry < ::Thrift::Union
  include ::Thrift::Struct_Union
  class << self
    def primitiveEntry(val)
      TTypeEntry.new(:primitiveEntry, val)
    end

    def arrayEntry(val)
      TTypeEntry.new(:arrayEntry, val)
    end

    def mapEntry(val)
      TTypeEntry.new(:mapEntry, val)
    end

    def structEntry(val)
      TTypeEntry.new(:structEntry, val)
    end

    def unionEntry(val)
      TTypeEntry.new(:unionEntry, val)
    end

    def userDefinedTypeEntry(val)
      TTypeEntry.new(:userDefinedTypeEntry, val)
    end
  end

  PRIMITIVEENTRY = 1
  ARRAYENTRY = 2
  MAPENTRY = 3
  STRUCTENTRY = 4
  UNIONENTRY = 5
  USERDEFINEDTYPEENTRY = 6

  FIELDS = {
    PRIMITIVEENTRY => {:type => ::Thrift::Types::STRUCT, :name => 'primitiveEntry', :class => ::TPrimitiveTypeEntry},
    ARRAYENTRY => {:type => ::Thrift::Types::STRUCT, :name => 'arrayEntry', :class => ::TArrayTypeEntry},
    MAPENTRY => {:type => ::Thrift::Types::STRUCT, :name => 'mapEntry', :class => ::TMapTypeEntry},
    STRUCTENTRY => {:type => ::Thrift::Types::STRUCT, :name => 'structEntry', :class => ::TStructTypeEntry},
    UNIONENTRY => {:type => ::Thrift::Types::STRUCT, :name => 'unionEntry', :class => ::TUnionTypeEntry},
    USERDEFINEDTYPEENTRY => {:type => ::Thrift::Types::STRUCT, :name => 'userDefinedTypeEntry', :class => ::TUserDefinedTypeEntry}
  }

  def struct_fields; FIELDS; end

  def validate
    raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
  end

  ::Thrift::Union.generate_accessors self
end

class TTypeDesc
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TYPES = 1

  FIELDS = {
    TYPES => {:type => ::Thrift::Types::LIST, :name => 'types', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TTypeEntry}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field types is unset!') unless @types
  end

  ::Thrift::Struct.generate_accessors self
end

class TColumnDesc
  include ::Thrift::Struct, ::Thrift::Struct_Union
  COLUMNNAME = 1
  TYPEDESC = 2
  POSITION = 3
  COMMENT = 4

  FIELDS = {
    COLUMNNAME => {:type => ::Thrift::Types::STRING, :name => 'columnName'},
    TYPEDESC => {:type => ::Thrift::Types::STRUCT, :name => 'typeDesc', :class => ::TTypeDesc},
    POSITION => {:type => ::Thrift::Types::I32, :name => 'position'},
    COMMENT => {:type => ::Thrift::Types::STRING, :name => 'comment', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field columnName is unset!') unless @columnName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field typeDesc is unset!') unless @typeDesc
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field position is unset!') unless @position
  end

  ::Thrift::Struct.generate_accessors self
end

class TTableSchema
  include ::Thrift::Struct, ::Thrift::Struct_Union
  COLUMNS = 1

  FIELDS = {
    COLUMNS => {:type => ::Thrift::Types::LIST, :name => 'columns', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TColumnDesc}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field columns is unset!') unless @columns
  end

  ::Thrift::Struct.generate_accessors self
end

class TBoolValue
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUE = 1

  FIELDS = {
    VALUE => {:type => ::Thrift::Types::BOOL, :name => 'value', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class TByteValue
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUE = 1

  FIELDS = {
    VALUE => {:type => ::Thrift::Types::BYTE, :name => 'value', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class TI16Value
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUE = 1

  FIELDS = {
    VALUE => {:type => ::Thrift::Types::I16, :name => 'value', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class TI32Value
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUE = 1

  FIELDS = {
    VALUE => {:type => ::Thrift::Types::I32, :name => 'value', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class TI64Value
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUE = 1

  FIELDS = {
    VALUE => {:type => ::Thrift::Types::I64, :name => 'value', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class TDoubleValue
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUE = 1

  FIELDS = {
    VALUE => {:type => ::Thrift::Types::DOUBLE, :name => 'value', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class TStringValue
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUE = 1

  FIELDS = {
    VALUE => {:type => ::Thrift::Types::STRING, :name => 'value', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class TColumn < ::Thrift::Union
  include ::Thrift::Struct_Union
  class << self
    def boolColumn(val)
      TColumn.new(:boolColumn, val)
    end

    def byteColumn(val)
      TColumn.new(:byteColumn, val)
    end

    def i16Column(val)
      TColumn.new(:i16Column, val)
    end

    def i32Column(val)
      TColumn.new(:i32Column, val)
    end

    def i64Column(val)
      TColumn.new(:i64Column, val)
    end

    def doubleColumn(val)
      TColumn.new(:doubleColumn, val)
    end

    def stringColumn(val)
      TColumn.new(:stringColumn, val)
    end
  end

  BOOLCOLUMN = 1
  BYTECOLUMN = 2
  I16COLUMN = 3
  I32COLUMN = 4
  I64COLUMN = 5
  DOUBLECOLUMN = 6
  STRINGCOLUMN = 7

  FIELDS = {
    BOOLCOLUMN => {:type => ::Thrift::Types::LIST, :name => 'boolColumn', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TBoolValue}},
    BYTECOLUMN => {:type => ::Thrift::Types::LIST, :name => 'byteColumn', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TByteValue}},
    I16COLUMN => {:type => ::Thrift::Types::LIST, :name => 'i16Column', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TI16Value}},
    I32COLUMN => {:type => ::Thrift::Types::LIST, :name => 'i32Column', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TI32Value}},
    I64COLUMN => {:type => ::Thrift::Types::LIST, :name => 'i64Column', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TI64Value}},
    DOUBLECOLUMN => {:type => ::Thrift::Types::LIST, :name => 'doubleColumn', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TDoubleValue}},
    STRINGCOLUMN => {:type => ::Thrift::Types::LIST, :name => 'stringColumn', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TStringValue}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
  end

  ::Thrift::Union.generate_accessors self
end

class TColumnValue < ::Thrift::Union
  include ::Thrift::Struct_Union
  class << self
    def boolVal(val)
      TColumnValue.new(:boolVal, val)
    end

    def byteVal(val)
      TColumnValue.new(:byteVal, val)
    end

    def i16Val(val)
      TColumnValue.new(:i16Val, val)
    end

    def i32Val(val)
      TColumnValue.new(:i32Val, val)
    end

    def i64Val(val)
      TColumnValue.new(:i64Val, val)
    end

    def doubleVal(val)
      TColumnValue.new(:doubleVal, val)
    end

    def stringVal(val)
      TColumnValue.new(:stringVal, val)
    end
  end

  BOOLVAL = 1
  BYTEVAL = 2
  I16VAL = 3
  I32VAL = 4
  I64VAL = 5
  DOUBLEVAL = 6
  STRINGVAL = 7

  FIELDS = {
    BOOLVAL => {:type => ::Thrift::Types::STRUCT, :name => 'boolVal', :class => ::TBoolValue},
    BYTEVAL => {:type => ::Thrift::Types::STRUCT, :name => 'byteVal', :class => ::TByteValue},
    I16VAL => {:type => ::Thrift::Types::STRUCT, :name => 'i16Val', :class => ::TI16Value},
    I32VAL => {:type => ::Thrift::Types::STRUCT, :name => 'i32Val', :class => ::TI32Value},
    I64VAL => {:type => ::Thrift::Types::STRUCT, :name => 'i64Val', :class => ::TI64Value},
    DOUBLEVAL => {:type => ::Thrift::Types::STRUCT, :name => 'doubleVal', :class => ::TDoubleValue},
    STRINGVAL => {:type => ::Thrift::Types::STRUCT, :name => 'stringVal', :class => ::TStringValue}
  }

  def struct_fields; FIELDS; end

  def validate
    raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
  end

  ::Thrift::Union.generate_accessors self
end

class TRow
  include ::Thrift::Struct, ::Thrift::Struct_Union
  COLVALS = 1

  FIELDS = {
    COLVALS => {:type => ::Thrift::Types::LIST, :name => 'colVals', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TColumnValue}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field colVals is unset!') unless @colVals
  end

  ::Thrift::Struct.generate_accessors self
end

class TRowSet
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STARTROWOFFSET = 1
  ROWS = 2
  COLUMNS = 3

  FIELDS = {
    STARTROWOFFSET => {:type => ::Thrift::Types::I64, :name => 'startRowOffset'},
    ROWS => {:type => ::Thrift::Types::LIST, :name => 'rows', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TRow}},
    COLUMNS => {:type => ::Thrift::Types::LIST, :name => 'columns', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TColumn}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field startRowOffset is unset!') unless @startRowOffset
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field rows is unset!') unless @rows
  end

  ::Thrift::Struct.generate_accessors self
end

class TStatus
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUSCODE = 1
  INFOMESSAGES = 2
  SQLSTATE = 3
  ERRORCODE = 4
  ERRORMESSAGE = 5

  FIELDS = {
    STATUSCODE => {:type => ::Thrift::Types::I32, :name => 'statusCode', :enum_class => ::TStatusCode},
    INFOMESSAGES => {:type => ::Thrift::Types::LIST, :name => 'infoMessages', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    SQLSTATE => {:type => ::Thrift::Types::STRING, :name => 'sqlState', :optional => true},
    ERRORCODE => {:type => ::Thrift::Types::I32, :name => 'errorCode', :optional => true},
    ERRORMESSAGE => {:type => ::Thrift::Types::STRING, :name => 'errorMessage', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field statusCode is unset!') unless @statusCode
    unless @statusCode.nil? || ::TStatusCode::VALID_VALUES.include?(@statusCode)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field statusCode!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class THandleIdentifier
  include ::Thrift::Struct, ::Thrift::Struct_Union
  GUID = 1
  SECRET = 2

  FIELDS = {
    GUID => {:type => ::Thrift::Types::STRING, :name => 'guid', :binary => true},
    SECRET => {:type => ::Thrift::Types::STRING, :name => 'secret', :binary => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field guid is unset!') unless @guid
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field secret is unset!') unless @secret
  end

  ::Thrift::Struct.generate_accessors self
end

class TSessionHandle
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONID = 1

  FIELDS = {
    SESSIONID => {:type => ::Thrift::Types::STRUCT, :name => 'sessionId', :class => ::THandleIdentifier}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionId is unset!') unless @sessionId
  end

  ::Thrift::Struct.generate_accessors self
end

class TOperationHandle
  include ::Thrift::Struct, ::Thrift::Struct_Union
  OPERATIONID = 1
  OPERATIONTYPE = 2
  HASRESULTSET = 3
  MODIFIEDROWCOUNT = 4

  FIELDS = {
    OPERATIONID => {:type => ::Thrift::Types::STRUCT, :name => 'operationId', :class => ::THandleIdentifier},
    OPERATIONTYPE => {:type => ::Thrift::Types::I32, :name => 'operationType', :enum_class => ::TOperationType},
    HASRESULTSET => {:type => ::Thrift::Types::BOOL, :name => 'hasResultSet'},
    MODIFIEDROWCOUNT => {:type => ::Thrift::Types::DOUBLE, :name => 'modifiedRowCount', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field operationId is unset!') unless @operationId
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field operationType is unset!') unless @operationType
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field hasResultSet is unset!') if @hasResultSet.nil?
    unless @operationType.nil? || ::TOperationType::VALID_VALUES.include?(@operationType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field operationType!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class TOpenSessionReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CLIENT_PROTOCOL = 1
  USERNAME = 2
  PASSWORD = 3
  CONFIGURATION = 4

  FIELDS = {
    CLIENT_PROTOCOL => {:type => ::Thrift::Types::I32, :name => 'client_protocol', :default =>     0, :enum_class => ::TProtocolVersion},
    USERNAME => {:type => ::Thrift::Types::STRING, :name => 'username', :optional => true},
    PASSWORD => {:type => ::Thrift::Types::STRING, :name => 'password', :optional => true},
    CONFIGURATION => {:type => ::Thrift::Types::MAP, :name => 'configuration', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field client_protocol is unset!') unless @client_protocol
    unless @client_protocol.nil? || ::TProtocolVersion::VALID_VALUES.include?(@client_protocol)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field client_protocol!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class TOpenSessionResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  SERVERPROTOCOLVERSION = 2
  SESSIONHANDLE = 3
  CONFIGURATION = 4

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    SERVERPROTOCOLVERSION => {:type => ::Thrift::Types::I32, :name => 'serverProtocolVersion', :default =>     0, :enum_class => ::TProtocolVersion},
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle, :optional => true},
    CONFIGURATION => {:type => ::Thrift::Types::MAP, :name => 'configuration', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field serverProtocolVersion is unset!') unless @serverProtocolVersion
    unless @serverProtocolVersion.nil? || ::TProtocolVersion::VALID_VALUES.include?(@serverProtocolVersion)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field serverProtocolVersion!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class TCloseSessionReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TCloseSessionResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetInfoValue < ::Thrift::Union
  include ::Thrift::Struct_Union
  class << self
    def stringValue(val)
      TGetInfoValue.new(:stringValue, val)
    end

    def smallIntValue(val)
      TGetInfoValue.new(:smallIntValue, val)
    end

    def integerBitmask(val)
      TGetInfoValue.new(:integerBitmask, val)
    end

    def integerFlag(val)
      TGetInfoValue.new(:integerFlag, val)
    end

    def binaryValue(val)
      TGetInfoValue.new(:binaryValue, val)
    end

    def lenValue(val)
      TGetInfoValue.new(:lenValue, val)
    end
  end

  STRINGVALUE = 1
  SMALLINTVALUE = 2
  INTEGERBITMASK = 3
  INTEGERFLAG = 4
  BINARYVALUE = 5
  LENVALUE = 6

  FIELDS = {
    STRINGVALUE => {:type => ::Thrift::Types::STRING, :name => 'stringValue'},
    SMALLINTVALUE => {:type => ::Thrift::Types::I16, :name => 'smallIntValue'},
    INTEGERBITMASK => {:type => ::Thrift::Types::I32, :name => 'integerBitmask'},
    INTEGERFLAG => {:type => ::Thrift::Types::I32, :name => 'integerFlag'},
    BINARYVALUE => {:type => ::Thrift::Types::I32, :name => 'binaryValue'},
    LENVALUE => {:type => ::Thrift::Types::I64, :name => 'lenValue'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
  end

  ::Thrift::Union.generate_accessors self
end

class TGetInfoReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1
  INFOTYPE = 2

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle},
    INFOTYPE => {:type => ::Thrift::Types::I32, :name => 'infoType', :enum_class => ::TGetInfoType}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field infoType is unset!') unless @infoType
    unless @infoType.nil? || ::TGetInfoType::VALID_VALUES.include?(@infoType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field infoType!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetInfoResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  INFOVALUE = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    INFOVALUE => {:type => ::Thrift::Types::STRUCT, :name => 'infoValue', :class => ::TGetInfoValue}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field infoValue is unset!') unless @infoValue
  end

  ::Thrift::Struct.generate_accessors self
end

class TExecuteStatementReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1
  STATEMENT = 2
  CONFOVERLAY = 3

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle},
    STATEMENT => {:type => ::Thrift::Types::STRING, :name => 'statement'},
    CONFOVERLAY => {:type => ::Thrift::Types::MAP, :name => 'confOverlay', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field statement is unset!') unless @statement
  end

  ::Thrift::Struct.generate_accessors self
end

class TExecuteStatementResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  OPERATIONHANDLE = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetTypeInfoReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetTypeInfoResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  OPERATIONHANDLE = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetCatalogsReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetCatalogsResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  OPERATIONHANDLE = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetSchemasReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1
  CATALOGNAME = 2
  SCHEMANAME = 3

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle},
    CATALOGNAME => {:type => ::Thrift::Types::STRING, :name => 'catalogName', :optional => true},
    SCHEMANAME => {:type => ::Thrift::Types::STRING, :name => 'schemaName', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetSchemasResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  OPERATIONHANDLE = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetTablesReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1
  CATALOGNAME = 2
  SCHEMANAME = 3
  TABLENAME = 4
  TABLETYPES = 5

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle},
    CATALOGNAME => {:type => ::Thrift::Types::STRING, :name => 'catalogName', :optional => true},
    SCHEMANAME => {:type => ::Thrift::Types::STRING, :name => 'schemaName', :optional => true},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :optional => true},
    TABLETYPES => {:type => ::Thrift::Types::LIST, :name => 'tableTypes', :element => {:type => ::Thrift::Types::STRING}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetTablesResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  OPERATIONHANDLE = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetTableTypesReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetTableTypesResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  OPERATIONHANDLE = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetColumnsReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1
  CATALOGNAME = 2
  SCHEMANAME = 3
  TABLENAME = 4
  COLUMNNAME = 5

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle},
    CATALOGNAME => {:type => ::Thrift::Types::STRING, :name => 'catalogName', :optional => true},
    SCHEMANAME => {:type => ::Thrift::Types::STRING, :name => 'schemaName', :optional => true},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :optional => true},
    COLUMNNAME => {:type => ::Thrift::Types::STRING, :name => 'columnName', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetColumnsResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  OPERATIONHANDLE = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetFunctionsReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1
  CATALOGNAME = 2
  SCHEMANAME = 3
  FUNCTIONNAME = 4

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle},
    CATALOGNAME => {:type => ::Thrift::Types::STRING, :name => 'catalogName', :optional => true},
    SCHEMANAME => {:type => ::Thrift::Types::STRING, :name => 'schemaName', :optional => true},
    FUNCTIONNAME => {:type => ::Thrift::Types::STRING, :name => 'functionName'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field functionName is unset!') unless @functionName
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetFunctionsResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  OPERATIONHANDLE = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetOperationStatusReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  OPERATIONHANDLE = 1

  FIELDS = {
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field operationHandle is unset!') unless @operationHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetOperationStatusResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  OPERATIONSTATE = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    OPERATIONSTATE => {:type => ::Thrift::Types::I32, :name => 'operationState', :optional => true, :enum_class => ::TOperationState}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
    unless @operationState.nil? || ::TOperationState::VALID_VALUES.include?(@operationState)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field operationState!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class TCancelOperationReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  OPERATIONHANDLE = 1

  FIELDS = {
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field operationHandle is unset!') unless @operationHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TCancelOperationResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TCloseOperationReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  OPERATIONHANDLE = 1

  FIELDS = {
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field operationHandle is unset!') unless @operationHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TCloseOperationResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetResultSetMetadataReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  OPERATIONHANDLE = 1

  FIELDS = {
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field operationHandle is unset!') unless @operationHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetResultSetMetadataResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  SCHEMA = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    SCHEMA => {:type => ::Thrift::Types::STRUCT, :name => 'schema', :class => ::TTableSchema, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TFetchResultsReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  OPERATIONHANDLE = 1
  ORIENTATION = 2
  MAXROWS = 3

  FIELDS = {
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle},
    ORIENTATION => {:type => ::Thrift::Types::I32, :name => 'orientation', :default =>     0, :enum_class => ::TFetchOrientation},
    MAXROWS => {:type => ::Thrift::Types::I64, :name => 'maxRows'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field operationHandle is unset!') unless @operationHandle
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field orientation is unset!') unless @orientation
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field maxRows is unset!') unless @maxRows
    unless @orientation.nil? || ::TFetchOrientation::VALID_VALUES.include?(@orientation)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field orientation!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class TFetchResultsResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  HASMOREROWS = 2
  RESULTS = 3

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    HASMOREROWS => {:type => ::Thrift::Types::BOOL, :name => 'hasMoreRows', :optional => true},
    RESULTS => {:type => ::Thrift::Types::STRUCT, :name => 'results', :class => ::TRowSet, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

