/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef TCLIService_TYPES_H
#define TCLIService_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>



namespace apache { namespace hive { namespace service { namespace cli { namespace thrift {

struct TProtocolVersion {
  enum type {
    HIVE_CLI_SERVICE_PROTOCOL_V1 = 0
  };
};

extern const std::map<int, const char*> _TProtocolVersion_VALUES_TO_NAMES;

struct TTypeId {
  enum type {
    BOOLEAN_TYPE = 0,
    TINYINT_TYPE = 1,
    SMALLINT_TYPE = 2,
    INT_TYPE = 3,
    BIGINT_TYPE = 4,
    FLOAT_TYPE = 5,
    DOUBLE_TYPE = 6,
    STRING_TYPE = 7,
    TIMESTAMP_TYPE = 8,
    BINARY_TYPE = 9,
    ARRAY_TYPE = 10,
    MAP_TYPE = 11,
    STRUCT_TYPE = 12,
    UNION_TYPE = 13,
    USER_DEFINED_TYPE = 14,
    DECIMAL_TYPE = 15
  };
};

extern const std::map<int, const char*> _TTypeId_VALUES_TO_NAMES;

struct TStatusCode {
  enum type {
    SUCCESS_STATUS = 0,
    SUCCESS_WITH_INFO_STATUS = 1,
    STILL_EXECUTING_STATUS = 2,
    ERROR_STATUS = 3,
    INVALID_HANDLE_STATUS = 4
  };
};

extern const std::map<int, const char*> _TStatusCode_VALUES_TO_NAMES;

struct TOperationState {
  enum type {
    INITIALIZED_STATE = 0,
    RUNNING_STATE = 1,
    FINISHED_STATE = 2,
    CANCELED_STATE = 3,
    CLOSED_STATE = 4,
    ERROR_STATE = 5,
    UKNOWN_STATE = 6
  };
};

extern const std::map<int, const char*> _TOperationState_VALUES_TO_NAMES;

struct TOperationType {
  enum type {
    EXECUTE_STATEMENT = 0,
    GET_TYPE_INFO = 1,
    GET_CATALOGS = 2,
    GET_SCHEMAS = 3,
    GET_TABLES = 4,
    GET_TABLE_TYPES = 5,
    GET_COLUMNS = 6,
    GET_FUNCTIONS = 7,
    UNKNOWN = 8
  };
};

extern const std::map<int, const char*> _TOperationType_VALUES_TO_NAMES;

struct TGetInfoType {
  enum type {
    CLI_MAX_DRIVER_CONNECTIONS = 0,
    CLI_MAX_CONCURRENT_ACTIVITIES = 1,
    CLI_DATA_SOURCE_NAME = 2,
    CLI_FETCH_DIRECTION = 8,
    CLI_SERVER_NAME = 13,
    CLI_SEARCH_PATTERN_ESCAPE = 14,
    CLI_DBMS_NAME = 17,
    CLI_DBMS_VER = 18,
    CLI_ACCESSIBLE_TABLES = 19,
    CLI_ACCESSIBLE_PROCEDURES = 20,
    CLI_CURSOR_COMMIT_BEHAVIOR = 23,
    CLI_DATA_SOURCE_READ_ONLY = 25,
    CLI_DEFAULT_TXN_ISOLATION = 26,
    CLI_IDENTIFIER_CASE = 28,
    CLI_IDENTIFIER_QUOTE_CHAR = 29,
    CLI_MAX_COLUMN_NAME_LEN = 30,
    CLI_MAX_CURSOR_NAME_LEN = 31,
    CLI_MAX_SCHEMA_NAME_LEN = 32,
    CLI_MAX_CATALOG_NAME_LEN = 34,
    CLI_MAX_TABLE_NAME_LEN = 35,
    CLI_SCROLL_CONCURRENCY = 43,
    CLI_TXN_CAPABLE = 46,
    CLI_USER_NAME = 47,
    CLI_TXN_ISOLATION_OPTION = 72,
    CLI_INTEGRITY = 73,
    CLI_GETDATA_EXTENSIONS = 81,
    CLI_NULL_COLLATION = 85,
    CLI_ALTER_TABLE = 86,
    CLI_ORDER_BY_COLUMNS_IN_SELECT = 90,
    CLI_SPECIAL_CHARACTERS = 94,
    CLI_MAX_COLUMNS_IN_GROUP_BY = 97,
    CLI_MAX_COLUMNS_IN_INDEX = 98,
    CLI_MAX_COLUMNS_IN_ORDER_BY = 99,
    CLI_MAX_COLUMNS_IN_SELECT = 100,
    CLI_MAX_COLUMNS_IN_TABLE = 101,
    CLI_MAX_INDEX_SIZE = 102,
    CLI_MAX_ROW_SIZE = 104,
    CLI_MAX_STATEMENT_LEN = 105,
    CLI_MAX_TABLES_IN_SELECT = 106,
    CLI_MAX_USER_NAME_LEN = 107,
    CLI_OJ_CAPABILITIES = 115,
    CLI_XOPEN_CLI_YEAR = 10000,
    CLI_CURSOR_SENSITIVITY = 10001,
    CLI_DESCRIBE_PARAMETER = 10002,
    CLI_CATALOG_NAME = 10003,
    CLI_COLLATION_SEQ = 10004,
    CLI_MAX_IDENTIFIER_LEN = 10005
  };
};

extern const std::map<int, const char*> _TGetInfoType_VALUES_TO_NAMES;

struct TFetchOrientation {
  enum type {
    FETCH_NEXT = 0,
    FETCH_PRIOR = 1,
    FETCH_RELATIVE = 2,
    FETCH_ABSOLUTE = 3,
    FETCH_FIRST = 4,
    FETCH_LAST = 5
  };
};

extern const std::map<int, const char*> _TFetchOrientation_VALUES_TO_NAMES;

typedef int32_t TTypeEntryPtr;

typedef std::string TIdentifier;

typedef std::string TPattern;

typedef std::string TPatternOrIdentifier;


class TPrimitiveTypeEntry {
 public:

  static const char* ascii_fingerprint; // = "8BBB3D0C3B370CB38F2D1340BB79F0AA";
  static const uint8_t binary_fingerprint[16]; // = {0x8B,0xBB,0x3D,0x0C,0x3B,0x37,0x0C,0xB3,0x8F,0x2D,0x13,0x40,0xBB,0x79,0xF0,0xAA};

  TPrimitiveTypeEntry() : type((TTypeId::type)0) {
  }

  virtual ~TPrimitiveTypeEntry() throw() {}

  TTypeId::type type;

  void __set_type(const TTypeId::type val) {
    type = val;
  }

  bool operator == (const TPrimitiveTypeEntry & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const TPrimitiveTypeEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPrimitiveTypeEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPrimitiveTypeEntry &a, TPrimitiveTypeEntry &b);


class TArrayTypeEntry {
 public:

  static const char* ascii_fingerprint; // = "E86CACEB22240450EDCBEFC3A83970E4";
  static const uint8_t binary_fingerprint[16]; // = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

  TArrayTypeEntry() : objectTypePtr(0) {
  }

  virtual ~TArrayTypeEntry() throw() {}

  TTypeEntryPtr objectTypePtr;

  void __set_objectTypePtr(const TTypeEntryPtr val) {
    objectTypePtr = val;
  }

  bool operator == (const TArrayTypeEntry & rhs) const
  {
    if (!(objectTypePtr == rhs.objectTypePtr))
      return false;
    return true;
  }
  bool operator != (const TArrayTypeEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TArrayTypeEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TArrayTypeEntry &a, TArrayTypeEntry &b);


class TMapTypeEntry {
 public:

  static const char* ascii_fingerprint; // = "989D1F1AE8D148D5E2119FFEC4BBBEE3";
  static const uint8_t binary_fingerprint[16]; // = {0x98,0x9D,0x1F,0x1A,0xE8,0xD1,0x48,0xD5,0xE2,0x11,0x9F,0xFE,0xC4,0xBB,0xBE,0xE3};

  TMapTypeEntry() : keyTypePtr(0), valueTypePtr(0) {
  }

  virtual ~TMapTypeEntry() throw() {}

  TTypeEntryPtr keyTypePtr;
  TTypeEntryPtr valueTypePtr;

  void __set_keyTypePtr(const TTypeEntryPtr val) {
    keyTypePtr = val;
  }

  void __set_valueTypePtr(const TTypeEntryPtr val) {
    valueTypePtr = val;
  }

  bool operator == (const TMapTypeEntry & rhs) const
  {
    if (!(keyTypePtr == rhs.keyTypePtr))
      return false;
    if (!(valueTypePtr == rhs.valueTypePtr))
      return false;
    return true;
  }
  bool operator != (const TMapTypeEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMapTypeEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TMapTypeEntry &a, TMapTypeEntry &b);


class TStructTypeEntry {
 public:

  static const char* ascii_fingerprint; // = "91F548CA159B4AB4291F5741AC161402";
  static const uint8_t binary_fingerprint[16]; // = {0x91,0xF5,0x48,0xCA,0x15,0x9B,0x4A,0xB4,0x29,0x1F,0x57,0x41,0xAC,0x16,0x14,0x02};

  TStructTypeEntry() {
  }

  virtual ~TStructTypeEntry() throw() {}

  std::map<std::string, TTypeEntryPtr>  nameToTypePtr;

  void __set_nameToTypePtr(const std::map<std::string, TTypeEntryPtr> & val) {
    nameToTypePtr = val;
  }

  bool operator == (const TStructTypeEntry & rhs) const
  {
    if (!(nameToTypePtr == rhs.nameToTypePtr))
      return false;
    return true;
  }
  bool operator != (const TStructTypeEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStructTypeEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TStructTypeEntry &a, TStructTypeEntry &b);


class TUnionTypeEntry {
 public:

  static const char* ascii_fingerprint; // = "91F548CA159B4AB4291F5741AC161402";
  static const uint8_t binary_fingerprint[16]; // = {0x91,0xF5,0x48,0xCA,0x15,0x9B,0x4A,0xB4,0x29,0x1F,0x57,0x41,0xAC,0x16,0x14,0x02};

  TUnionTypeEntry() {
  }

  virtual ~TUnionTypeEntry() throw() {}

  std::map<std::string, TTypeEntryPtr>  nameToTypePtr;

  void __set_nameToTypePtr(const std::map<std::string, TTypeEntryPtr> & val) {
    nameToTypePtr = val;
  }

  bool operator == (const TUnionTypeEntry & rhs) const
  {
    if (!(nameToTypePtr == rhs.nameToTypePtr))
      return false;
    return true;
  }
  bool operator != (const TUnionTypeEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TUnionTypeEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TUnionTypeEntry &a, TUnionTypeEntry &b);


class TUserDefinedTypeEntry {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TUserDefinedTypeEntry() : typeClassName() {
  }

  virtual ~TUserDefinedTypeEntry() throw() {}

  std::string typeClassName;

  void __set_typeClassName(const std::string& val) {
    typeClassName = val;
  }

  bool operator == (const TUserDefinedTypeEntry & rhs) const
  {
    if (!(typeClassName == rhs.typeClassName))
      return false;
    return true;
  }
  bool operator != (const TUserDefinedTypeEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TUserDefinedTypeEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TUserDefinedTypeEntry &a, TUserDefinedTypeEntry &b);

typedef struct _TTypeEntry__isset {
  _TTypeEntry__isset() : primitiveEntry(false), arrayEntry(false), mapEntry(false), structEntry(false), unionEntry(false), userDefinedTypeEntry(false) {}
  bool primitiveEntry;
  bool arrayEntry;
  bool mapEntry;
  bool structEntry;
  bool unionEntry;
  bool userDefinedTypeEntry;
} _TTypeEntry__isset;

class TTypeEntry {
 public:

  static const char* ascii_fingerprint; // = "0C3ACE4054603E2D37B8BFEBA79F4159";
  static const uint8_t binary_fingerprint[16]; // = {0x0C,0x3A,0xCE,0x40,0x54,0x60,0x3E,0x2D,0x37,0xB8,0xBF,0xEB,0xA7,0x9F,0x41,0x59};

  TTypeEntry() {
  }

  virtual ~TTypeEntry() throw() {}

  TPrimitiveTypeEntry primitiveEntry;
  TArrayTypeEntry arrayEntry;
  TMapTypeEntry mapEntry;
  TStructTypeEntry structEntry;
  TUnionTypeEntry unionEntry;
  TUserDefinedTypeEntry userDefinedTypeEntry;

  _TTypeEntry__isset __isset;

  void __set_primitiveEntry(const TPrimitiveTypeEntry& val) {
    primitiveEntry = val;
  }

  void __set_arrayEntry(const TArrayTypeEntry& val) {
    arrayEntry = val;
  }

  void __set_mapEntry(const TMapTypeEntry& val) {
    mapEntry = val;
  }

  void __set_structEntry(const TStructTypeEntry& val) {
    structEntry = val;
  }

  void __set_unionEntry(const TUnionTypeEntry& val) {
    unionEntry = val;
  }

  void __set_userDefinedTypeEntry(const TUserDefinedTypeEntry& val) {
    userDefinedTypeEntry = val;
  }

  bool operator == (const TTypeEntry & rhs) const
  {
    if (!(primitiveEntry == rhs.primitiveEntry))
      return false;
    if (!(arrayEntry == rhs.arrayEntry))
      return false;
    if (!(mapEntry == rhs.mapEntry))
      return false;
    if (!(structEntry == rhs.structEntry))
      return false;
    if (!(unionEntry == rhs.unionEntry))
      return false;
    if (!(userDefinedTypeEntry == rhs.userDefinedTypeEntry))
      return false;
    return true;
  }
  bool operator != (const TTypeEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTypeEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTypeEntry &a, TTypeEntry &b);


class TTypeDesc {
 public:

  static const char* ascii_fingerprint; // = "60CA5B8BACFCD38D1D3EC1F0E3F1C36A";
  static const uint8_t binary_fingerprint[16]; // = {0x60,0xCA,0x5B,0x8B,0xAC,0xFC,0xD3,0x8D,0x1D,0x3E,0xC1,0xF0,0xE3,0xF1,0xC3,0x6A};

  TTypeDesc() {
  }

  virtual ~TTypeDesc() throw() {}

  std::vector<TTypeEntry>  types;

  void __set_types(const std::vector<TTypeEntry> & val) {
    types = val;
  }

  bool operator == (const TTypeDesc & rhs) const
  {
    if (!(types == rhs.types))
      return false;
    return true;
  }
  bool operator != (const TTypeDesc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTypeDesc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTypeDesc &a, TTypeDesc &b);

typedef struct _TColumnDesc__isset {
  _TColumnDesc__isset() : comment(false) {}
  bool comment;
} _TColumnDesc__isset;

class TColumnDesc {
 public:

  static const char* ascii_fingerprint; // = "0DF9A37B81B1EE73D35A0AC01F33A48D";
  static const uint8_t binary_fingerprint[16]; // = {0x0D,0xF9,0xA3,0x7B,0x81,0xB1,0xEE,0x73,0xD3,0x5A,0x0A,0xC0,0x1F,0x33,0xA4,0x8D};

  TColumnDesc() : columnName(), position(0), comment() {
  }

  virtual ~TColumnDesc() throw() {}

  std::string columnName;
  TTypeDesc typeDesc;
  int32_t position;
  std::string comment;

  _TColumnDesc__isset __isset;

  void __set_columnName(const std::string& val) {
    columnName = val;
  }

  void __set_typeDesc(const TTypeDesc& val) {
    typeDesc = val;
  }

  void __set_position(const int32_t val) {
    position = val;
  }

  void __set_comment(const std::string& val) {
    comment = val;
    __isset.comment = true;
  }

  bool operator == (const TColumnDesc & rhs) const
  {
    if (!(columnName == rhs.columnName))
      return false;
    if (!(typeDesc == rhs.typeDesc))
      return false;
    if (!(position == rhs.position))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    return true;
  }
  bool operator != (const TColumnDesc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumnDesc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TColumnDesc &a, TColumnDesc &b);


class TTableSchema {
 public:

  static const char* ascii_fingerprint; // = "E67E789F1EF836E4B9FC922C788AFDC8";
  static const uint8_t binary_fingerprint[16]; // = {0xE6,0x7E,0x78,0x9F,0x1E,0xF8,0x36,0xE4,0xB9,0xFC,0x92,0x2C,0x78,0x8A,0xFD,0xC8};

  TTableSchema() {
  }

  virtual ~TTableSchema() throw() {}

  std::vector<TColumnDesc>  columns;

  void __set_columns(const std::vector<TColumnDesc> & val) {
    columns = val;
  }

  bool operator == (const TTableSchema & rhs) const
  {
    if (!(columns == rhs.columns))
      return false;
    return true;
  }
  bool operator != (const TTableSchema &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTableSchema & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTableSchema &a, TTableSchema &b);

typedef struct _TBoolValue__isset {
  _TBoolValue__isset() : value(false) {}
  bool value;
} _TBoolValue__isset;

class TBoolValue {
 public:

  static const char* ascii_fingerprint; // = "BF054652DEF86253C2BEE7D947F167DD";
  static const uint8_t binary_fingerprint[16]; // = {0xBF,0x05,0x46,0x52,0xDE,0xF8,0x62,0x53,0xC2,0xBE,0xE7,0xD9,0x47,0xF1,0x67,0xDD};

  TBoolValue() : value(0) {
  }

  virtual ~TBoolValue() throw() {}

  bool value;

  _TBoolValue__isset __isset;

  void __set_value(const bool val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const TBoolValue & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TBoolValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBoolValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TBoolValue &a, TBoolValue &b);

typedef struct _TByteValue__isset {
  _TByteValue__isset() : value(false) {}
  bool value;
} _TByteValue__isset;

class TByteValue {
 public:

  static const char* ascii_fingerprint; // = "9C15298ACB5D04AEA9B52D5DDE6F9208";
  static const uint8_t binary_fingerprint[16]; // = {0x9C,0x15,0x29,0x8A,0xCB,0x5D,0x04,0xAE,0xA9,0xB5,0x2D,0x5D,0xDE,0x6F,0x92,0x08};

  TByteValue() : value(0) {
  }

  virtual ~TByteValue() throw() {}

  int8_t value;

  _TByteValue__isset __isset;

  void __set_value(const int8_t val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const TByteValue & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TByteValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TByteValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TByteValue &a, TByteValue &b);

typedef struct _TI16Value__isset {
  _TI16Value__isset() : value(false) {}
  bool value;
} _TI16Value__isset;

class TI16Value {
 public:

  static const char* ascii_fingerprint; // = "5DAC9C51C7E1106BF936FC71860BE9D5";
  static const uint8_t binary_fingerprint[16]; // = {0x5D,0xAC,0x9C,0x51,0xC7,0xE1,0x10,0x6B,0xF9,0x36,0xFC,0x71,0x86,0x0B,0xE9,0xD5};

  TI16Value() : value(0) {
  }

  virtual ~TI16Value() throw() {}

  int16_t value;

  _TI16Value__isset __isset;

  void __set_value(const int16_t val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const TI16Value & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TI16Value &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TI16Value & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TI16Value &a, TI16Value &b);

typedef struct _TI32Value__isset {
  _TI32Value__isset() : value(false) {}
  bool value;
} _TI32Value__isset;

class TI32Value {
 public:

  static const char* ascii_fingerprint; // = "E7A96B151330359E84C0A3AC91BCBACD";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0xA9,0x6B,0x15,0x13,0x30,0x35,0x9E,0x84,0xC0,0xA3,0xAC,0x91,0xBC,0xBA,0xCD};

  TI32Value() : value(0) {
  }

  virtual ~TI32Value() throw() {}

  int32_t value;

  _TI32Value__isset __isset;

  void __set_value(const int32_t val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const TI32Value & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TI32Value &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TI32Value & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TI32Value &a, TI32Value &b);

typedef struct _TI64Value__isset {
  _TI64Value__isset() : value(false) {}
  bool value;
} _TI64Value__isset;

class TI64Value {
 public:

  static const char* ascii_fingerprint; // = "148F3AAAC1D9859963D5E800D187BF26";
  static const uint8_t binary_fingerprint[16]; // = {0x14,0x8F,0x3A,0xAA,0xC1,0xD9,0x85,0x99,0x63,0xD5,0xE8,0x00,0xD1,0x87,0xBF,0x26};

  TI64Value() : value(0) {
  }

  virtual ~TI64Value() throw() {}

  int64_t value;

  _TI64Value__isset __isset;

  void __set_value(const int64_t val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const TI64Value & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TI64Value &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TI64Value & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TI64Value &a, TI64Value &b);

typedef struct _TDoubleValue__isset {
  _TDoubleValue__isset() : value(false) {}
  bool value;
} _TDoubleValue__isset;

class TDoubleValue {
 public:

  static const char* ascii_fingerprint; // = "3586E570A474C4A8603B4FF74903B3A6";
  static const uint8_t binary_fingerprint[16]; // = {0x35,0x86,0xE5,0x70,0xA4,0x74,0xC4,0xA8,0x60,0x3B,0x4F,0xF7,0x49,0x03,0xB3,0xA6};

  TDoubleValue() : value(0) {
  }

  virtual ~TDoubleValue() throw() {}

  double value;

  _TDoubleValue__isset __isset;

  void __set_value(const double val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const TDoubleValue & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TDoubleValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDoubleValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDoubleValue &a, TDoubleValue &b);

typedef struct _TStringValue__isset {
  _TStringValue__isset() : value(false) {}
  bool value;
} _TStringValue__isset;

class TStringValue {
 public:

  static const char* ascii_fingerprint; // = "66E694018C17E5B65A59AE8F55CCA3CD";
  static const uint8_t binary_fingerprint[16]; // = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

  TStringValue() : value() {
  }

  virtual ~TStringValue() throw() {}

  std::string value;

  _TStringValue__isset __isset;

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const TStringValue & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TStringValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStringValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TStringValue &a, TStringValue &b);

typedef struct _TColumn__isset {
  _TColumn__isset() : boolColumn(false), byteColumn(false), i16Column(false), i32Column(false), i64Column(false), doubleColumn(false), stringColumn(false) {}
  bool boolColumn;
  bool byteColumn;
  bool i16Column;
  bool i32Column;
  bool i64Column;
  bool doubleColumn;
  bool stringColumn;
} _TColumn__isset;

class TColumn {
 public:

  static const char* ascii_fingerprint; // = "B39B4E4E565DB31DC891D62FDC3208DC";
  static const uint8_t binary_fingerprint[16]; // = {0xB3,0x9B,0x4E,0x4E,0x56,0x5D,0xB3,0x1D,0xC8,0x91,0xD6,0x2F,0xDC,0x32,0x08,0xDC};

  TColumn() {
  }

  virtual ~TColumn() throw() {}

  std::vector<TBoolValue>  boolColumn;
  std::vector<TByteValue>  byteColumn;
  std::vector<TI16Value>  i16Column;
  std::vector<TI32Value>  i32Column;
  std::vector<TI64Value>  i64Column;
  std::vector<TDoubleValue>  doubleColumn;
  std::vector<TStringValue>  stringColumn;

  _TColumn__isset __isset;

  void __set_boolColumn(const std::vector<TBoolValue> & val) {
    boolColumn = val;
  }

  void __set_byteColumn(const std::vector<TByteValue> & val) {
    byteColumn = val;
  }

  void __set_i16Column(const std::vector<TI16Value> & val) {
    i16Column = val;
  }

  void __set_i32Column(const std::vector<TI32Value> & val) {
    i32Column = val;
  }

  void __set_i64Column(const std::vector<TI64Value> & val) {
    i64Column = val;
  }

  void __set_doubleColumn(const std::vector<TDoubleValue> & val) {
    doubleColumn = val;
  }

  void __set_stringColumn(const std::vector<TStringValue> & val) {
    stringColumn = val;
  }

  bool operator == (const TColumn & rhs) const
  {
    if (!(boolColumn == rhs.boolColumn))
      return false;
    if (!(byteColumn == rhs.byteColumn))
      return false;
    if (!(i16Column == rhs.i16Column))
      return false;
    if (!(i32Column == rhs.i32Column))
      return false;
    if (!(i64Column == rhs.i64Column))
      return false;
    if (!(doubleColumn == rhs.doubleColumn))
      return false;
    if (!(stringColumn == rhs.stringColumn))
      return false;
    return true;
  }
  bool operator != (const TColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TColumn &a, TColumn &b);

typedef struct _TColumnValue__isset {
  _TColumnValue__isset() : boolVal(false), byteVal(false), i16Val(false), i32Val(false), i64Val(false), doubleVal(false), stringVal(false) {}
  bool boolVal;
  bool byteVal;
  bool i16Val;
  bool i32Val;
  bool i64Val;
  bool doubleVal;
  bool stringVal;
} _TColumnValue__isset;

class TColumnValue {
 public:

  static const char* ascii_fingerprint; // = "C2DDD988447EA7999A8285AA38AAE9AD";
  static const uint8_t binary_fingerprint[16]; // = {0xC2,0xDD,0xD9,0x88,0x44,0x7E,0xA7,0x99,0x9A,0x82,0x85,0xAA,0x38,0xAA,0xE9,0xAD};

  TColumnValue() {
  }

  virtual ~TColumnValue() throw() {}

  TBoolValue boolVal;
  TByteValue byteVal;
  TI16Value i16Val;
  TI32Value i32Val;
  TI64Value i64Val;
  TDoubleValue doubleVal;
  TStringValue stringVal;

  _TColumnValue__isset __isset;

  void __set_boolVal(const TBoolValue& val) {
    boolVal = val;
  }

  void __set_byteVal(const TByteValue& val) {
    byteVal = val;
  }

  void __set_i16Val(const TI16Value& val) {
    i16Val = val;
  }

  void __set_i32Val(const TI32Value& val) {
    i32Val = val;
  }

  void __set_i64Val(const TI64Value& val) {
    i64Val = val;
  }

  void __set_doubleVal(const TDoubleValue& val) {
    doubleVal = val;
  }

  void __set_stringVal(const TStringValue& val) {
    stringVal = val;
  }

  bool operator == (const TColumnValue & rhs) const
  {
    if (!(boolVal == rhs.boolVal))
      return false;
    if (!(byteVal == rhs.byteVal))
      return false;
    if (!(i16Val == rhs.i16Val))
      return false;
    if (!(i32Val == rhs.i32Val))
      return false;
    if (!(i64Val == rhs.i64Val))
      return false;
    if (!(doubleVal == rhs.doubleVal))
      return false;
    if (!(stringVal == rhs.stringVal))
      return false;
    return true;
  }
  bool operator != (const TColumnValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumnValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TColumnValue &a, TColumnValue &b);


class TRow {
 public:

  static const char* ascii_fingerprint; // = "E73FD1FCA0CA58A669FC3E02FB68D534";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0x3F,0xD1,0xFC,0xA0,0xCA,0x58,0xA6,0x69,0xFC,0x3E,0x02,0xFB,0x68,0xD5,0x34};

  TRow() {
  }

  virtual ~TRow() throw() {}

  std::vector<TColumnValue>  colVals;

  void __set_colVals(const std::vector<TColumnValue> & val) {
    colVals = val;
  }

  bool operator == (const TRow & rhs) const
  {
    if (!(colVals == rhs.colVals))
      return false;
    return true;
  }
  bool operator != (const TRow &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRow & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TRow &a, TRow &b);

typedef struct _TRowSet__isset {
  _TRowSet__isset() : columns(false) {}
  bool columns;
} _TRowSet__isset;

class TRowSet {
 public:

  static const char* ascii_fingerprint; // = "698727A24268879440EE0DAFE68FC1C5";
  static const uint8_t binary_fingerprint[16]; // = {0x69,0x87,0x27,0xA2,0x42,0x68,0x87,0x94,0x40,0xEE,0x0D,0xAF,0xE6,0x8F,0xC1,0xC5};

  TRowSet() : startRowOffset(0) {
  }

  virtual ~TRowSet() throw() {}

  int64_t startRowOffset;
  std::vector<TRow>  rows;
  std::vector<TColumn>  columns;

  _TRowSet__isset __isset;

  void __set_startRowOffset(const int64_t val) {
    startRowOffset = val;
  }

  void __set_rows(const std::vector<TRow> & val) {
    rows = val;
  }

  void __set_columns(const std::vector<TColumn> & val) {
    columns = val;
    __isset.columns = true;
  }

  bool operator == (const TRowSet & rhs) const
  {
    if (!(startRowOffset == rhs.startRowOffset))
      return false;
    if (!(rows == rhs.rows))
      return false;
    if (__isset.columns != rhs.__isset.columns)
      return false;
    else if (__isset.columns && !(columns == rhs.columns))
      return false;
    return true;
  }
  bool operator != (const TRowSet &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRowSet & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TRowSet &a, TRowSet &b);

typedef struct _TStatus__isset {
  _TStatus__isset() : infoMessages(false), sqlState(false), errorCode(false), errorMessage(false) {}
  bool infoMessages;
  bool sqlState;
  bool errorCode;
  bool errorMessage;
} _TStatus__isset;

class TStatus {
 public:

  static const char* ascii_fingerprint; // = "D5DEF49634A59C615C1B3A6F7D0DADB5";
  static const uint8_t binary_fingerprint[16]; // = {0xD5,0xDE,0xF4,0x96,0x34,0xA5,0x9C,0x61,0x5C,0x1B,0x3A,0x6F,0x7D,0x0D,0xAD,0xB5};

  TStatus() : statusCode((TStatusCode::type)0), sqlState(), errorCode(0), errorMessage() {
  }

  virtual ~TStatus() throw() {}

  TStatusCode::type statusCode;
  std::vector<std::string>  infoMessages;
  std::string sqlState;
  int32_t errorCode;
  std::string errorMessage;

  _TStatus__isset __isset;

  void __set_statusCode(const TStatusCode::type val) {
    statusCode = val;
  }

  void __set_infoMessages(const std::vector<std::string> & val) {
    infoMessages = val;
    __isset.infoMessages = true;
  }

  void __set_sqlState(const std::string& val) {
    sqlState = val;
    __isset.sqlState = true;
  }

  void __set_errorCode(const int32_t val) {
    errorCode = val;
    __isset.errorCode = true;
  }

  void __set_errorMessage(const std::string& val) {
    errorMessage = val;
    __isset.errorMessage = true;
  }

  bool operator == (const TStatus & rhs) const
  {
    if (!(statusCode == rhs.statusCode))
      return false;
    if (__isset.infoMessages != rhs.__isset.infoMessages)
      return false;
    else if (__isset.infoMessages && !(infoMessages == rhs.infoMessages))
      return false;
    if (__isset.sqlState != rhs.__isset.sqlState)
      return false;
    else if (__isset.sqlState && !(sqlState == rhs.sqlState))
      return false;
    if (__isset.errorCode != rhs.__isset.errorCode)
      return false;
    else if (__isset.errorCode && !(errorCode == rhs.errorCode))
      return false;
    if (__isset.errorMessage != rhs.__isset.errorMessage)
      return false;
    else if (__isset.errorMessage && !(errorMessage == rhs.errorMessage))
      return false;
    return true;
  }
  bool operator != (const TStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TStatus &a, TStatus &b);


class THandleIdentifier {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  THandleIdentifier() : guid(), secret() {
  }

  virtual ~THandleIdentifier() throw() {}

  std::string guid;
  std::string secret;

  void __set_guid(const std::string& val) {
    guid = val;
  }

  void __set_secret(const std::string& val) {
    secret = val;
  }

  bool operator == (const THandleIdentifier & rhs) const
  {
    if (!(guid == rhs.guid))
      return false;
    if (!(secret == rhs.secret))
      return false;
    return true;
  }
  bool operator != (const THandleIdentifier &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THandleIdentifier & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THandleIdentifier &a, THandleIdentifier &b);


class TSessionHandle {
 public:

  static const char* ascii_fingerprint; // = "A756D3DBE614FB13F70BF7F7B6EB3D73";
  static const uint8_t binary_fingerprint[16]; // = {0xA7,0x56,0xD3,0xDB,0xE6,0x14,0xFB,0x13,0xF7,0x0B,0xF7,0xF7,0xB6,0xEB,0x3D,0x73};

  TSessionHandle() {
  }

  virtual ~TSessionHandle() throw() {}

  THandleIdentifier sessionId;

  void __set_sessionId(const THandleIdentifier& val) {
    sessionId = val;
  }

  bool operator == (const TSessionHandle & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    return true;
  }
  bool operator != (const TSessionHandle &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSessionHandle & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TSessionHandle &a, TSessionHandle &b);

typedef struct _TOperationHandle__isset {
  _TOperationHandle__isset() : modifiedRowCount(false) {}
  bool modifiedRowCount;
} _TOperationHandle__isset;

class TOperationHandle {
 public:

  static const char* ascii_fingerprint; // = "29FD80F4F96804A30FCC59C23D2E5349";
  static const uint8_t binary_fingerprint[16]; // = {0x29,0xFD,0x80,0xF4,0xF9,0x68,0x04,0xA3,0x0F,0xCC,0x59,0xC2,0x3D,0x2E,0x53,0x49};

  TOperationHandle() : operationType((TOperationType::type)0), hasResultSet(0), modifiedRowCount(0) {
  }

  virtual ~TOperationHandle() throw() {}

  THandleIdentifier operationId;
  TOperationType::type operationType;
  bool hasResultSet;
  double modifiedRowCount;

  _TOperationHandle__isset __isset;

  void __set_operationId(const THandleIdentifier& val) {
    operationId = val;
  }

  void __set_operationType(const TOperationType::type val) {
    operationType = val;
  }

  void __set_hasResultSet(const bool val) {
    hasResultSet = val;
  }

  void __set_modifiedRowCount(const double val) {
    modifiedRowCount = val;
    __isset.modifiedRowCount = true;
  }

  bool operator == (const TOperationHandle & rhs) const
  {
    if (!(operationId == rhs.operationId))
      return false;
    if (!(operationType == rhs.operationType))
      return false;
    if (!(hasResultSet == rhs.hasResultSet))
      return false;
    if (__isset.modifiedRowCount != rhs.__isset.modifiedRowCount)
      return false;
    else if (__isset.modifiedRowCount && !(modifiedRowCount == rhs.modifiedRowCount))
      return false;
    return true;
  }
  bool operator != (const TOperationHandle &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TOperationHandle & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TOperationHandle &a, TOperationHandle &b);

typedef struct _TOpenSessionReq__isset {
  _TOpenSessionReq__isset() : username(false), password(false), configuration(false) {}
  bool username;
  bool password;
  bool configuration;
} _TOpenSessionReq__isset;

class TOpenSessionReq {
 public:

  static const char* ascii_fingerprint; // = "C8FD0F306A16C16BDA7B57F58BFAE5B2";
  static const uint8_t binary_fingerprint[16]; // = {0xC8,0xFD,0x0F,0x30,0x6A,0x16,0xC1,0x6B,0xDA,0x7B,0x57,0xF5,0x8B,0xFA,0xE5,0xB2};

  TOpenSessionReq() : client_protocol((TProtocolVersion::type)0), username(), password() {
    client_protocol = (TProtocolVersion::type)0;

  }

  virtual ~TOpenSessionReq() throw() {}

  TProtocolVersion::type client_protocol;
  std::string username;
  std::string password;
  std::map<std::string, std::string>  configuration;

  _TOpenSessionReq__isset __isset;

  void __set_client_protocol(const TProtocolVersion::type val) {
    client_protocol = val;
  }

  void __set_username(const std::string& val) {
    username = val;
    __isset.username = true;
  }

  void __set_password(const std::string& val) {
    password = val;
    __isset.password = true;
  }

  void __set_configuration(const std::map<std::string, std::string> & val) {
    configuration = val;
    __isset.configuration = true;
  }

  bool operator == (const TOpenSessionReq & rhs) const
  {
    if (!(client_protocol == rhs.client_protocol))
      return false;
    if (__isset.username != rhs.__isset.username)
      return false;
    else if (__isset.username && !(username == rhs.username))
      return false;
    if (__isset.password != rhs.__isset.password)
      return false;
    else if (__isset.password && !(password == rhs.password))
      return false;
    if (__isset.configuration != rhs.__isset.configuration)
      return false;
    else if (__isset.configuration && !(configuration == rhs.configuration))
      return false;
    return true;
  }
  bool operator != (const TOpenSessionReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TOpenSessionReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TOpenSessionReq &a, TOpenSessionReq &b);

typedef struct _TOpenSessionResp__isset {
  _TOpenSessionResp__isset() : sessionHandle(false), configuration(false) {}
  bool sessionHandle;
  bool configuration;
} _TOpenSessionResp__isset;

class TOpenSessionResp {
 public:

  static const char* ascii_fingerprint; // = "CFE7D7F4E9EC671F2518ED74FEE9F163";
  static const uint8_t binary_fingerprint[16]; // = {0xCF,0xE7,0xD7,0xF4,0xE9,0xEC,0x67,0x1F,0x25,0x18,0xED,0x74,0xFE,0xE9,0xF1,0x63};

  TOpenSessionResp() : serverProtocolVersion((TProtocolVersion::type)0) {
    serverProtocolVersion = (TProtocolVersion::type)0;

  }

  virtual ~TOpenSessionResp() throw() {}

  TStatus status;
  TProtocolVersion::type serverProtocolVersion;
  TSessionHandle sessionHandle;
  std::map<std::string, std::string>  configuration;

  _TOpenSessionResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_serverProtocolVersion(const TProtocolVersion::type val) {
    serverProtocolVersion = val;
  }

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
    __isset.sessionHandle = true;
  }

  void __set_configuration(const std::map<std::string, std::string> & val) {
    configuration = val;
    __isset.configuration = true;
  }

  bool operator == (const TOpenSessionResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(serverProtocolVersion == rhs.serverProtocolVersion))
      return false;
    if (__isset.sessionHandle != rhs.__isset.sessionHandle)
      return false;
    else if (__isset.sessionHandle && !(sessionHandle == rhs.sessionHandle))
      return false;
    if (__isset.configuration != rhs.__isset.configuration)
      return false;
    else if (__isset.configuration && !(configuration == rhs.configuration))
      return false;
    return true;
  }
  bool operator != (const TOpenSessionResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TOpenSessionResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TOpenSessionResp &a, TOpenSessionResp &b);


class TCloseSessionReq {
 public:

  static const char* ascii_fingerprint; // = "82377107F8BD0526960537D5A112E6EF";
  static const uint8_t binary_fingerprint[16]; // = {0x82,0x37,0x71,0x07,0xF8,0xBD,0x05,0x26,0x96,0x05,0x37,0xD5,0xA1,0x12,0xE6,0xEF};

  TCloseSessionReq() {
  }

  virtual ~TCloseSessionReq() throw() {}

  TSessionHandle sessionHandle;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  bool operator == (const TCloseSessionReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    return true;
  }
  bool operator != (const TCloseSessionReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCloseSessionReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCloseSessionReq &a, TCloseSessionReq &b);


class TCloseSessionResp {
 public:

  static const char* ascii_fingerprint; // = "7142E89F09DC7C5F6FA916C7393F46C2";
  static const uint8_t binary_fingerprint[16]; // = {0x71,0x42,0xE8,0x9F,0x09,0xDC,0x7C,0x5F,0x6F,0xA9,0x16,0xC7,0x39,0x3F,0x46,0xC2};

  TCloseSessionResp() {
  }

  virtual ~TCloseSessionResp() throw() {}

  TStatus status;

  void __set_status(const TStatus& val) {
    status = val;
  }

  bool operator == (const TCloseSessionResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TCloseSessionResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCloseSessionResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCloseSessionResp &a, TCloseSessionResp &b);

typedef struct _TGetInfoValue__isset {
  _TGetInfoValue__isset() : stringValue(false), smallIntValue(false), integerBitmask(false), integerFlag(false), binaryValue(false), lenValue(false) {}
  bool stringValue;
  bool smallIntValue;
  bool integerBitmask;
  bool integerFlag;
  bool binaryValue;
  bool lenValue;
} _TGetInfoValue__isset;

class TGetInfoValue {
 public:

  static const char* ascii_fingerprint; // = "057FED11279FD7248CFE73EE82ED579E";
  static const uint8_t binary_fingerprint[16]; // = {0x05,0x7F,0xED,0x11,0x27,0x9F,0xD7,0x24,0x8C,0xFE,0x73,0xEE,0x82,0xED,0x57,0x9E};

  TGetInfoValue() : stringValue(), smallIntValue(0), integerBitmask(0), integerFlag(0), binaryValue(0), lenValue(0) {
  }

  virtual ~TGetInfoValue() throw() {}

  std::string stringValue;
  int16_t smallIntValue;
  int32_t integerBitmask;
  int32_t integerFlag;
  int32_t binaryValue;
  int64_t lenValue;

  _TGetInfoValue__isset __isset;

  void __set_stringValue(const std::string& val) {
    stringValue = val;
  }

  void __set_smallIntValue(const int16_t val) {
    smallIntValue = val;
  }

  void __set_integerBitmask(const int32_t val) {
    integerBitmask = val;
  }

  void __set_integerFlag(const int32_t val) {
    integerFlag = val;
  }

  void __set_binaryValue(const int32_t val) {
    binaryValue = val;
  }

  void __set_lenValue(const int64_t val) {
    lenValue = val;
  }

  bool operator == (const TGetInfoValue & rhs) const
  {
    if (!(stringValue == rhs.stringValue))
      return false;
    if (!(smallIntValue == rhs.smallIntValue))
      return false;
    if (!(integerBitmask == rhs.integerBitmask))
      return false;
    if (!(integerFlag == rhs.integerFlag))
      return false;
    if (!(binaryValue == rhs.binaryValue))
      return false;
    if (!(lenValue == rhs.lenValue))
      return false;
    return true;
  }
  bool operator != (const TGetInfoValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetInfoValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetInfoValue &a, TGetInfoValue &b);


class TGetInfoReq {
 public:

  static const char* ascii_fingerprint; // = "95675B1A0BADE5F7EDE323809DB679B2";
  static const uint8_t binary_fingerprint[16]; // = {0x95,0x67,0x5B,0x1A,0x0B,0xAD,0xE5,0xF7,0xED,0xE3,0x23,0x80,0x9D,0xB6,0x79,0xB2};

  TGetInfoReq() : infoType((TGetInfoType::type)0) {
  }

  virtual ~TGetInfoReq() throw() {}

  TSessionHandle sessionHandle;
  TGetInfoType::type infoType;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  void __set_infoType(const TGetInfoType::type val) {
    infoType = val;
  }

  bool operator == (const TGetInfoReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (!(infoType == rhs.infoType))
      return false;
    return true;
  }
  bool operator != (const TGetInfoReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetInfoReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetInfoReq &a, TGetInfoReq &b);


class TGetInfoResp {
 public:

  static const char* ascii_fingerprint; // = "72AFA10A82728B51FDE91092012868DE";
  static const uint8_t binary_fingerprint[16]; // = {0x72,0xAF,0xA1,0x0A,0x82,0x72,0x8B,0x51,0xFD,0xE9,0x10,0x92,0x01,0x28,0x68,0xDE};

  TGetInfoResp() {
  }

  virtual ~TGetInfoResp() throw() {}

  TStatus status;
  TGetInfoValue infoValue;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_infoValue(const TGetInfoValue& val) {
    infoValue = val;
  }

  bool operator == (const TGetInfoResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(infoValue == rhs.infoValue))
      return false;
    return true;
  }
  bool operator != (const TGetInfoResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetInfoResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetInfoResp &a, TGetInfoResp &b);

typedef struct _TExecuteStatementReq__isset {
  _TExecuteStatementReq__isset() : confOverlay(false) {}
  bool confOverlay;
} _TExecuteStatementReq__isset;

class TExecuteStatementReq {
 public:

  static const char* ascii_fingerprint; // = "4CDA19909D21B7D9907F85E3387EAB27";
  static const uint8_t binary_fingerprint[16]; // = {0x4C,0xDA,0x19,0x90,0x9D,0x21,0xB7,0xD9,0x90,0x7F,0x85,0xE3,0x38,0x7E,0xAB,0x27};

  TExecuteStatementReq() : statement() {
  }

  virtual ~TExecuteStatementReq() throw() {}

  TSessionHandle sessionHandle;
  std::string statement;
  std::map<std::string, std::string>  confOverlay;

  _TExecuteStatementReq__isset __isset;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  void __set_statement(const std::string& val) {
    statement = val;
  }

  void __set_confOverlay(const std::map<std::string, std::string> & val) {
    confOverlay = val;
    __isset.confOverlay = true;
  }

  bool operator == (const TExecuteStatementReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (!(statement == rhs.statement))
      return false;
    if (__isset.confOverlay != rhs.__isset.confOverlay)
      return false;
    else if (__isset.confOverlay && !(confOverlay == rhs.confOverlay))
      return false;
    return true;
  }
  bool operator != (const TExecuteStatementReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExecuteStatementReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExecuteStatementReq &a, TExecuteStatementReq &b);

typedef struct _TExecuteStatementResp__isset {
  _TExecuteStatementResp__isset() : operationHandle(false) {}
  bool operationHandle;
} _TExecuteStatementResp__isset;

class TExecuteStatementResp {
 public:

  static const char* ascii_fingerprint; // = "02A075A0FF88D3A172916D8F23C7B286";
  static const uint8_t binary_fingerprint[16]; // = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

  TExecuteStatementResp() {
  }

  virtual ~TExecuteStatementResp() throw() {}

  TStatus status;
  TOperationHandle operationHandle;

  _TExecuteStatementResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
    __isset.operationHandle = true;
  }

  bool operator == (const TExecuteStatementResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TExecuteStatementResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExecuteStatementResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExecuteStatementResp &a, TExecuteStatementResp &b);


class TGetTypeInfoReq {
 public:

  static const char* ascii_fingerprint; // = "82377107F8BD0526960537D5A112E6EF";
  static const uint8_t binary_fingerprint[16]; // = {0x82,0x37,0x71,0x07,0xF8,0xBD,0x05,0x26,0x96,0x05,0x37,0xD5,0xA1,0x12,0xE6,0xEF};

  TGetTypeInfoReq() {
  }

  virtual ~TGetTypeInfoReq() throw() {}

  TSessionHandle sessionHandle;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  bool operator == (const TGetTypeInfoReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    return true;
  }
  bool operator != (const TGetTypeInfoReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTypeInfoReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetTypeInfoReq &a, TGetTypeInfoReq &b);

typedef struct _TGetTypeInfoResp__isset {
  _TGetTypeInfoResp__isset() : operationHandle(false) {}
  bool operationHandle;
} _TGetTypeInfoResp__isset;

class TGetTypeInfoResp {
 public:

  static const char* ascii_fingerprint; // = "02A075A0FF88D3A172916D8F23C7B286";
  static const uint8_t binary_fingerprint[16]; // = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

  TGetTypeInfoResp() {
  }

  virtual ~TGetTypeInfoResp() throw() {}

  TStatus status;
  TOperationHandle operationHandle;

  _TGetTypeInfoResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
    __isset.operationHandle = true;
  }

  bool operator == (const TGetTypeInfoResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetTypeInfoResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTypeInfoResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetTypeInfoResp &a, TGetTypeInfoResp &b);


class TGetCatalogsReq {
 public:

  static const char* ascii_fingerprint; // = "82377107F8BD0526960537D5A112E6EF";
  static const uint8_t binary_fingerprint[16]; // = {0x82,0x37,0x71,0x07,0xF8,0xBD,0x05,0x26,0x96,0x05,0x37,0xD5,0xA1,0x12,0xE6,0xEF};

  TGetCatalogsReq() {
  }

  virtual ~TGetCatalogsReq() throw() {}

  TSessionHandle sessionHandle;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  bool operator == (const TGetCatalogsReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    return true;
  }
  bool operator != (const TGetCatalogsReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetCatalogsReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetCatalogsReq &a, TGetCatalogsReq &b);

typedef struct _TGetCatalogsResp__isset {
  _TGetCatalogsResp__isset() : operationHandle(false) {}
  bool operationHandle;
} _TGetCatalogsResp__isset;

class TGetCatalogsResp {
 public:

  static const char* ascii_fingerprint; // = "02A075A0FF88D3A172916D8F23C7B286";
  static const uint8_t binary_fingerprint[16]; // = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

  TGetCatalogsResp() {
  }

  virtual ~TGetCatalogsResp() throw() {}

  TStatus status;
  TOperationHandle operationHandle;

  _TGetCatalogsResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
    __isset.operationHandle = true;
  }

  bool operator == (const TGetCatalogsResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetCatalogsResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetCatalogsResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetCatalogsResp &a, TGetCatalogsResp &b);

typedef struct _TGetSchemasReq__isset {
  _TGetSchemasReq__isset() : catalogName(false), schemaName(false) {}
  bool catalogName;
  bool schemaName;
} _TGetSchemasReq__isset;

class TGetSchemasReq {
 public:

  static const char* ascii_fingerprint; // = "28A9D12DE8393DD3E73FC1E5AE6E113B";
  static const uint8_t binary_fingerprint[16]; // = {0x28,0xA9,0xD1,0x2D,0xE8,0x39,0x3D,0xD3,0xE7,0x3F,0xC1,0xE5,0xAE,0x6E,0x11,0x3B};

  TGetSchemasReq() : catalogName(), schemaName() {
  }

  virtual ~TGetSchemasReq() throw() {}

  TSessionHandle sessionHandle;
  TIdentifier catalogName;
  TPatternOrIdentifier schemaName;

  _TGetSchemasReq__isset __isset;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  void __set_catalogName(const TIdentifier& val) {
    catalogName = val;
    __isset.catalogName = true;
  }

  void __set_schemaName(const TPatternOrIdentifier& val) {
    schemaName = val;
    __isset.schemaName = true;
  }

  bool operator == (const TGetSchemasReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (__isset.catalogName != rhs.__isset.catalogName)
      return false;
    else if (__isset.catalogName && !(catalogName == rhs.catalogName))
      return false;
    if (__isset.schemaName != rhs.__isset.schemaName)
      return false;
    else if (__isset.schemaName && !(schemaName == rhs.schemaName))
      return false;
    return true;
  }
  bool operator != (const TGetSchemasReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetSchemasReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetSchemasReq &a, TGetSchemasReq &b);

typedef struct _TGetSchemasResp__isset {
  _TGetSchemasResp__isset() : operationHandle(false) {}
  bool operationHandle;
} _TGetSchemasResp__isset;

class TGetSchemasResp {
 public:

  static const char* ascii_fingerprint; // = "02A075A0FF88D3A172916D8F23C7B286";
  static const uint8_t binary_fingerprint[16]; // = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

  TGetSchemasResp() {
  }

  virtual ~TGetSchemasResp() throw() {}

  TStatus status;
  TOperationHandle operationHandle;

  _TGetSchemasResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
    __isset.operationHandle = true;
  }

  bool operator == (const TGetSchemasResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetSchemasResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetSchemasResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetSchemasResp &a, TGetSchemasResp &b);

typedef struct _TGetTablesReq__isset {
  _TGetTablesReq__isset() : catalogName(false), schemaName(false), tableName(false), tableTypes(false) {}
  bool catalogName;
  bool schemaName;
  bool tableName;
  bool tableTypes;
} _TGetTablesReq__isset;

class TGetTablesReq {
 public:

  static const char* ascii_fingerprint; // = "C80DFEE06850052F5A445BE81ED763DB";
  static const uint8_t binary_fingerprint[16]; // = {0xC8,0x0D,0xFE,0xE0,0x68,0x50,0x05,0x2F,0x5A,0x44,0x5B,0xE8,0x1E,0xD7,0x63,0xDB};

  TGetTablesReq() : catalogName(), schemaName(), tableName() {
  }

  virtual ~TGetTablesReq() throw() {}

  TSessionHandle sessionHandle;
  TPatternOrIdentifier catalogName;
  TPatternOrIdentifier schemaName;
  TPatternOrIdentifier tableName;
  std::vector<std::string>  tableTypes;

  _TGetTablesReq__isset __isset;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  void __set_catalogName(const TPatternOrIdentifier& val) {
    catalogName = val;
    __isset.catalogName = true;
  }

  void __set_schemaName(const TPatternOrIdentifier& val) {
    schemaName = val;
    __isset.schemaName = true;
  }

  void __set_tableName(const TPatternOrIdentifier& val) {
    tableName = val;
    __isset.tableName = true;
  }

  void __set_tableTypes(const std::vector<std::string> & val) {
    tableTypes = val;
    __isset.tableTypes = true;
  }

  bool operator == (const TGetTablesReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (__isset.catalogName != rhs.__isset.catalogName)
      return false;
    else if (__isset.catalogName && !(catalogName == rhs.catalogName))
      return false;
    if (__isset.schemaName != rhs.__isset.schemaName)
      return false;
    else if (__isset.schemaName && !(schemaName == rhs.schemaName))
      return false;
    if (__isset.tableName != rhs.__isset.tableName)
      return false;
    else if (__isset.tableName && !(tableName == rhs.tableName))
      return false;
    if (__isset.tableTypes != rhs.__isset.tableTypes)
      return false;
    else if (__isset.tableTypes && !(tableTypes == rhs.tableTypes))
      return false;
    return true;
  }
  bool operator != (const TGetTablesReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTablesReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetTablesReq &a, TGetTablesReq &b);

typedef struct _TGetTablesResp__isset {
  _TGetTablesResp__isset() : operationHandle(false) {}
  bool operationHandle;
} _TGetTablesResp__isset;

class TGetTablesResp {
 public:

  static const char* ascii_fingerprint; // = "02A075A0FF88D3A172916D8F23C7B286";
  static const uint8_t binary_fingerprint[16]; // = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

  TGetTablesResp() {
  }

  virtual ~TGetTablesResp() throw() {}

  TStatus status;
  TOperationHandle operationHandle;

  _TGetTablesResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
    __isset.operationHandle = true;
  }

  bool operator == (const TGetTablesResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetTablesResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTablesResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetTablesResp &a, TGetTablesResp &b);


class TGetTableTypesReq {
 public:

  static const char* ascii_fingerprint; // = "82377107F8BD0526960537D5A112E6EF";
  static const uint8_t binary_fingerprint[16]; // = {0x82,0x37,0x71,0x07,0xF8,0xBD,0x05,0x26,0x96,0x05,0x37,0xD5,0xA1,0x12,0xE6,0xEF};

  TGetTableTypesReq() {
  }

  virtual ~TGetTableTypesReq() throw() {}

  TSessionHandle sessionHandle;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  bool operator == (const TGetTableTypesReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    return true;
  }
  bool operator != (const TGetTableTypesReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTableTypesReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetTableTypesReq &a, TGetTableTypesReq &b);

typedef struct _TGetTableTypesResp__isset {
  _TGetTableTypesResp__isset() : operationHandle(false) {}
  bool operationHandle;
} _TGetTableTypesResp__isset;

class TGetTableTypesResp {
 public:

  static const char* ascii_fingerprint; // = "02A075A0FF88D3A172916D8F23C7B286";
  static const uint8_t binary_fingerprint[16]; // = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

  TGetTableTypesResp() {
  }

  virtual ~TGetTableTypesResp() throw() {}

  TStatus status;
  TOperationHandle operationHandle;

  _TGetTableTypesResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
    __isset.operationHandle = true;
  }

  bool operator == (const TGetTableTypesResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetTableTypesResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTableTypesResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetTableTypesResp &a, TGetTableTypesResp &b);

typedef struct _TGetColumnsReq__isset {
  _TGetColumnsReq__isset() : catalogName(false), schemaName(false), tableName(false), columnName(false) {}
  bool catalogName;
  bool schemaName;
  bool tableName;
  bool columnName;
} _TGetColumnsReq__isset;

class TGetColumnsReq {
 public:

  static const char* ascii_fingerprint; // = "72D0F28ED33A49B7306DF63EEE956C28";
  static const uint8_t binary_fingerprint[16]; // = {0x72,0xD0,0xF2,0x8E,0xD3,0x3A,0x49,0xB7,0x30,0x6D,0xF6,0x3E,0xEE,0x95,0x6C,0x28};

  TGetColumnsReq() : catalogName(), schemaName(), tableName(), columnName() {
  }

  virtual ~TGetColumnsReq() throw() {}

  TSessionHandle sessionHandle;
  TIdentifier catalogName;
  TPatternOrIdentifier schemaName;
  TPatternOrIdentifier tableName;
  TPatternOrIdentifier columnName;

  _TGetColumnsReq__isset __isset;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  void __set_catalogName(const TIdentifier& val) {
    catalogName = val;
    __isset.catalogName = true;
  }

  void __set_schemaName(const TPatternOrIdentifier& val) {
    schemaName = val;
    __isset.schemaName = true;
  }

  void __set_tableName(const TPatternOrIdentifier& val) {
    tableName = val;
    __isset.tableName = true;
  }

  void __set_columnName(const TPatternOrIdentifier& val) {
    columnName = val;
    __isset.columnName = true;
  }

  bool operator == (const TGetColumnsReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (__isset.catalogName != rhs.__isset.catalogName)
      return false;
    else if (__isset.catalogName && !(catalogName == rhs.catalogName))
      return false;
    if (__isset.schemaName != rhs.__isset.schemaName)
      return false;
    else if (__isset.schemaName && !(schemaName == rhs.schemaName))
      return false;
    if (__isset.tableName != rhs.__isset.tableName)
      return false;
    else if (__isset.tableName && !(tableName == rhs.tableName))
      return false;
    if (__isset.columnName != rhs.__isset.columnName)
      return false;
    else if (__isset.columnName && !(columnName == rhs.columnName))
      return false;
    return true;
  }
  bool operator != (const TGetColumnsReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetColumnsReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetColumnsReq &a, TGetColumnsReq &b);

typedef struct _TGetColumnsResp__isset {
  _TGetColumnsResp__isset() : operationHandle(false) {}
  bool operationHandle;
} _TGetColumnsResp__isset;

class TGetColumnsResp {
 public:

  static const char* ascii_fingerprint; // = "02A075A0FF88D3A172916D8F23C7B286";
  static const uint8_t binary_fingerprint[16]; // = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

  TGetColumnsResp() {
  }

  virtual ~TGetColumnsResp() throw() {}

  TStatus status;
  TOperationHandle operationHandle;

  _TGetColumnsResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
    __isset.operationHandle = true;
  }

  bool operator == (const TGetColumnsResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetColumnsResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetColumnsResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetColumnsResp &a, TGetColumnsResp &b);

typedef struct _TGetFunctionsReq__isset {
  _TGetFunctionsReq__isset() : catalogName(false), schemaName(false) {}
  bool catalogName;
  bool schemaName;
} _TGetFunctionsReq__isset;

class TGetFunctionsReq {
 public:

  static const char* ascii_fingerprint; // = "0887E0916ADE4521BF6017B534493138";
  static const uint8_t binary_fingerprint[16]; // = {0x08,0x87,0xE0,0x91,0x6A,0xDE,0x45,0x21,0xBF,0x60,0x17,0xB5,0x34,0x49,0x31,0x38};

  TGetFunctionsReq() : catalogName(), schemaName(), functionName() {
  }

  virtual ~TGetFunctionsReq() throw() {}

  TSessionHandle sessionHandle;
  TIdentifier catalogName;
  TPatternOrIdentifier schemaName;
  TPatternOrIdentifier functionName;

  _TGetFunctionsReq__isset __isset;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  void __set_catalogName(const TIdentifier& val) {
    catalogName = val;
    __isset.catalogName = true;
  }

  void __set_schemaName(const TPatternOrIdentifier& val) {
    schemaName = val;
    __isset.schemaName = true;
  }

  void __set_functionName(const TPatternOrIdentifier& val) {
    functionName = val;
  }

  bool operator == (const TGetFunctionsReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (__isset.catalogName != rhs.__isset.catalogName)
      return false;
    else if (__isset.catalogName && !(catalogName == rhs.catalogName))
      return false;
    if (__isset.schemaName != rhs.__isset.schemaName)
      return false;
    else if (__isset.schemaName && !(schemaName == rhs.schemaName))
      return false;
    if (!(functionName == rhs.functionName))
      return false;
    return true;
  }
  bool operator != (const TGetFunctionsReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetFunctionsReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetFunctionsReq &a, TGetFunctionsReq &b);

typedef struct _TGetFunctionsResp__isset {
  _TGetFunctionsResp__isset() : operationHandle(false) {}
  bool operationHandle;
} _TGetFunctionsResp__isset;

class TGetFunctionsResp {
 public:

  static const char* ascii_fingerprint; // = "02A075A0FF88D3A172916D8F23C7B286";
  static const uint8_t binary_fingerprint[16]; // = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

  TGetFunctionsResp() {
  }

  virtual ~TGetFunctionsResp() throw() {}

  TStatus status;
  TOperationHandle operationHandle;

  _TGetFunctionsResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
    __isset.operationHandle = true;
  }

  bool operator == (const TGetFunctionsResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetFunctionsResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetFunctionsResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetFunctionsResp &a, TGetFunctionsResp &b);


class TGetOperationStatusReq {
 public:

  static const char* ascii_fingerprint; // = "414FA38522AE6B9CEC1438B56CA1DE5A";
  static const uint8_t binary_fingerprint[16]; // = {0x41,0x4F,0xA3,0x85,0x22,0xAE,0x6B,0x9C,0xEC,0x14,0x38,0xB5,0x6C,0xA1,0xDE,0x5A};

  TGetOperationStatusReq() {
  }

  virtual ~TGetOperationStatusReq() throw() {}

  TOperationHandle operationHandle;

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
  }

  bool operator == (const TGetOperationStatusReq & rhs) const
  {
    if (!(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetOperationStatusReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetOperationStatusReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetOperationStatusReq &a, TGetOperationStatusReq &b);

typedef struct _TGetOperationStatusResp__isset {
  _TGetOperationStatusResp__isset() : operationState(false) {}
  bool operationState;
} _TGetOperationStatusResp__isset;

class TGetOperationStatusResp {
 public:

  static const char* ascii_fingerprint; // = "4F27EC6715D9B6D702A4842459E6587B";
  static const uint8_t binary_fingerprint[16]; // = {0x4F,0x27,0xEC,0x67,0x15,0xD9,0xB6,0xD7,0x02,0xA4,0x84,0x24,0x59,0xE6,0x58,0x7B};

  TGetOperationStatusResp() : operationState((TOperationState::type)0) {
  }

  virtual ~TGetOperationStatusResp() throw() {}

  TStatus status;
  TOperationState::type operationState;

  _TGetOperationStatusResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_operationState(const TOperationState::type val) {
    operationState = val;
    __isset.operationState = true;
  }

  bool operator == (const TGetOperationStatusResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationState != rhs.__isset.operationState)
      return false;
    else if (__isset.operationState && !(operationState == rhs.operationState))
      return false;
    return true;
  }
  bool operator != (const TGetOperationStatusResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetOperationStatusResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetOperationStatusResp &a, TGetOperationStatusResp &b);


class TCancelOperationReq {
 public:

  static const char* ascii_fingerprint; // = "414FA38522AE6B9CEC1438B56CA1DE5A";
  static const uint8_t binary_fingerprint[16]; // = {0x41,0x4F,0xA3,0x85,0x22,0xAE,0x6B,0x9C,0xEC,0x14,0x38,0xB5,0x6C,0xA1,0xDE,0x5A};

  TCancelOperationReq() {
  }

  virtual ~TCancelOperationReq() throw() {}

  TOperationHandle operationHandle;

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
  }

  bool operator == (const TCancelOperationReq & rhs) const
  {
    if (!(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TCancelOperationReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCancelOperationReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCancelOperationReq &a, TCancelOperationReq &b);


class TCancelOperationResp {
 public:

  static const char* ascii_fingerprint; // = "7142E89F09DC7C5F6FA916C7393F46C2";
  static const uint8_t binary_fingerprint[16]; // = {0x71,0x42,0xE8,0x9F,0x09,0xDC,0x7C,0x5F,0x6F,0xA9,0x16,0xC7,0x39,0x3F,0x46,0xC2};

  TCancelOperationResp() {
  }

  virtual ~TCancelOperationResp() throw() {}

  TStatus status;

  void __set_status(const TStatus& val) {
    status = val;
  }

  bool operator == (const TCancelOperationResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TCancelOperationResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCancelOperationResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCancelOperationResp &a, TCancelOperationResp &b);


class TCloseOperationReq {
 public:

  static const char* ascii_fingerprint; // = "414FA38522AE6B9CEC1438B56CA1DE5A";
  static const uint8_t binary_fingerprint[16]; // = {0x41,0x4F,0xA3,0x85,0x22,0xAE,0x6B,0x9C,0xEC,0x14,0x38,0xB5,0x6C,0xA1,0xDE,0x5A};

  TCloseOperationReq() {
  }

  virtual ~TCloseOperationReq() throw() {}

  TOperationHandle operationHandle;

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
  }

  bool operator == (const TCloseOperationReq & rhs) const
  {
    if (!(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TCloseOperationReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCloseOperationReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCloseOperationReq &a, TCloseOperationReq &b);


class TCloseOperationResp {
 public:

  static const char* ascii_fingerprint; // = "7142E89F09DC7C5F6FA916C7393F46C2";
  static const uint8_t binary_fingerprint[16]; // = {0x71,0x42,0xE8,0x9F,0x09,0xDC,0x7C,0x5F,0x6F,0xA9,0x16,0xC7,0x39,0x3F,0x46,0xC2};

  TCloseOperationResp() {
  }

  virtual ~TCloseOperationResp() throw() {}

  TStatus status;

  void __set_status(const TStatus& val) {
    status = val;
  }

  bool operator == (const TCloseOperationResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TCloseOperationResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCloseOperationResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCloseOperationResp &a, TCloseOperationResp &b);


class TGetResultSetMetadataReq {
 public:

  static const char* ascii_fingerprint; // = "414FA38522AE6B9CEC1438B56CA1DE5A";
  static const uint8_t binary_fingerprint[16]; // = {0x41,0x4F,0xA3,0x85,0x22,0xAE,0x6B,0x9C,0xEC,0x14,0x38,0xB5,0x6C,0xA1,0xDE,0x5A};

  TGetResultSetMetadataReq() {
  }

  virtual ~TGetResultSetMetadataReq() throw() {}

  TOperationHandle operationHandle;

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
  }

  bool operator == (const TGetResultSetMetadataReq & rhs) const
  {
    if (!(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetResultSetMetadataReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetResultSetMetadataReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetResultSetMetadataReq &a, TGetResultSetMetadataReq &b);

typedef struct _TGetResultSetMetadataResp__isset {
  _TGetResultSetMetadataResp__isset() : schema(false) {}
  bool schema;
} _TGetResultSetMetadataResp__isset;

class TGetResultSetMetadataResp {
 public:

  static const char* ascii_fingerprint; // = "8778316D0AFC17584F192162BFF2AEDE";
  static const uint8_t binary_fingerprint[16]; // = {0x87,0x78,0x31,0x6D,0x0A,0xFC,0x17,0x58,0x4F,0x19,0x21,0x62,0xBF,0xF2,0xAE,0xDE};

  TGetResultSetMetadataResp() {
  }

  virtual ~TGetResultSetMetadataResp() throw() {}

  TStatus status;
  TTableSchema schema;

  _TGetResultSetMetadataResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_schema(const TTableSchema& val) {
    schema = val;
    __isset.schema = true;
  }

  bool operator == (const TGetResultSetMetadataResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.schema != rhs.__isset.schema)
      return false;
    else if (__isset.schema && !(schema == rhs.schema))
      return false;
    return true;
  }
  bool operator != (const TGetResultSetMetadataResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetResultSetMetadataResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetResultSetMetadataResp &a, TGetResultSetMetadataResp &b);


class TFetchResultsReq {
 public:

  static const char* ascii_fingerprint; // = "1B96A8C05BA9DD699FC8CD842240ABDE";
  static const uint8_t binary_fingerprint[16]; // = {0x1B,0x96,0xA8,0xC0,0x5B,0xA9,0xDD,0x69,0x9F,0xC8,0xCD,0x84,0x22,0x40,0xAB,0xDE};

  TFetchResultsReq() : orientation((TFetchOrientation::type)0), maxRows(0) {
    orientation = (TFetchOrientation::type)0;

  }

  virtual ~TFetchResultsReq() throw() {}

  TOperationHandle operationHandle;
  TFetchOrientation::type orientation;
  int64_t maxRows;

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
  }

  void __set_orientation(const TFetchOrientation::type val) {
    orientation = val;
  }

  void __set_maxRows(const int64_t val) {
    maxRows = val;
  }

  bool operator == (const TFetchResultsReq & rhs) const
  {
    if (!(operationHandle == rhs.operationHandle))
      return false;
    if (!(orientation == rhs.orientation))
      return false;
    if (!(maxRows == rhs.maxRows))
      return false;
    return true;
  }
  bool operator != (const TFetchResultsReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFetchResultsReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TFetchResultsReq &a, TFetchResultsReq &b);

typedef struct _TFetchResultsResp__isset {
  _TFetchResultsResp__isset() : hasMoreRows(false), results(false) {}
  bool hasMoreRows;
  bool results;
} _TFetchResultsResp__isset;

class TFetchResultsResp {
 public:

  static const char* ascii_fingerprint; // = "29891EA4D71B4283E8715DA5B95F2763";
  static const uint8_t binary_fingerprint[16]; // = {0x29,0x89,0x1E,0xA4,0xD7,0x1B,0x42,0x83,0xE8,0x71,0x5D,0xA5,0xB9,0x5F,0x27,0x63};

  TFetchResultsResp() : hasMoreRows(0) {
  }

  virtual ~TFetchResultsResp() throw() {}

  TStatus status;
  bool hasMoreRows;
  TRowSet results;

  _TFetchResultsResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_hasMoreRows(const bool val) {
    hasMoreRows = val;
    __isset.hasMoreRows = true;
  }

  void __set_results(const TRowSet& val) {
    results = val;
    __isset.results = true;
  }

  bool operator == (const TFetchResultsResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.hasMoreRows != rhs.__isset.hasMoreRows)
      return false;
    else if (__isset.hasMoreRows && !(hasMoreRows == rhs.hasMoreRows))
      return false;
    if (__isset.results != rhs.__isset.results)
      return false;
    else if (__isset.results && !(results == rhs.results))
      return false;
    return true;
  }
  bool operator != (const TFetchResultsResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFetchResultsResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TFetchResultsResp &a, TFetchResultsResp &b);

}}}}} // namespace

#endif
