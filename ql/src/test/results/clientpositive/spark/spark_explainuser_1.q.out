PREHOOK: query: explain create table src_orc_merge_test_part(key int, value string) partitioned by (ds string, ts string) stored as orc
PREHOOK: type: CREATETABLE
POSTHOOK: query: explain create table src_orc_merge_test_part(key int, value string) partitioned by (ds string, ts string) stored as orc
POSTHOOK: type: CREATETABLE
Stage-0
  Create Table Operator:
    name:default.src_orc_merge_test_part

PREHOOK: query: create table src_orc_merge_test_part(key int, value string) partitioned by (ds string, ts string) stored as orc
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@src_orc_merge_test_part
POSTHOOK: query: create table src_orc_merge_test_part(key int, value string) partitioned by (ds string, ts string) stored as orc
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@src_orc_merge_test_part
PREHOOK: query: alter table src_orc_merge_test_part add partition (ds='2012-01-03', ts='2012-01-03+14:46:31')
PREHOOK: type: ALTERTABLE_ADDPARTS
PREHOOK: Output: default@src_orc_merge_test_part
POSTHOOK: query: alter table src_orc_merge_test_part add partition (ds='2012-01-03', ts='2012-01-03+14:46:31')
POSTHOOK: type: ALTERTABLE_ADDPARTS
POSTHOOK: Output: default@src_orc_merge_test_part
POSTHOOK: Output: default@src_orc_merge_test_part@ds=2012-01-03/ts=2012-01-03+14%3A46%3A31
PREHOOK: query: desc extended src_orc_merge_test_part partition (ds='2012-01-03', ts='2012-01-03+14:46:31')
PREHOOK: type: DESCTABLE
PREHOOK: Input: default@src_orc_merge_test_part
POSTHOOK: query: desc extended src_orc_merge_test_part partition (ds='2012-01-03', ts='2012-01-03+14:46:31')
POSTHOOK: type: DESCTABLE
POSTHOOK: Input: default@src_orc_merge_test_part
key                 	int                 	                    
value               	string              	                    
ds                  	string              	                    
ts                  	string              	                    
	 	 
# Partition Information	 	 
# col_name            	data_type           	comment             
ds                  	string              	                    
ts                  	string              	                    
	 	 
#### A masked pattern was here ####
PREHOOK: query: explain insert overwrite table src_orc_merge_test_part partition(ds='2012-01-03', ts='2012-01-03+14:46:31') select * from src
PREHOOK: type: QUERY
POSTHOOK: query: explain insert overwrite table src_orc_merge_test_part partition(ds='2012-01-03', ts='2012-01-03+14:46:31') select * from src
POSTHOOK: type: QUERY
Plan optimized by CBO.

Stage-2
  Stats Work{}
    Stage-0
      Move Operator
        table:{"name:":"default.src_orc_merge_test_part"}
        Stage-1
          Map 1
          File Output Operator [FS_3]
            table:{"name:":"default.src_orc_merge_test_part"}
            Select Operator [SEL_1] (rows=500 width=10)
              Output:["_col0","_col1"]
              TableScan [TS_0] (rows=500 width=10)
                default@src,src,Tbl:COMPLETE,Col:NONE,Output:["key","value"]

PREHOOK: query: insert overwrite table src_orc_merge_test_part partition(ds='2012-01-03', ts='2012-01-03+14:46:31') select * from src
PREHOOK: type: QUERY
PREHOOK: Input: default@src
PREHOOK: Output: default@src_orc_merge_test_part@ds=2012-01-03/ts=2012-01-03+14%3A46%3A31
POSTHOOK: query: insert overwrite table src_orc_merge_test_part partition(ds='2012-01-03', ts='2012-01-03+14:46:31') select * from src
POSTHOOK: type: QUERY
POSTHOOK: Input: default@src
POSTHOOK: Output: default@src_orc_merge_test_part@ds=2012-01-03/ts=2012-01-03+14%3A46%3A31
POSTHOOK: Lineage: src_orc_merge_test_part PARTITION(ds=2012-01-03,ts=2012-01-03+14:46:31).key EXPRESSION [(src)src.FieldSchema(name:key, type:string, comment:default), ]
POSTHOOK: Lineage: src_orc_merge_test_part PARTITION(ds=2012-01-03,ts=2012-01-03+14:46:31).value SIMPLE [(src)src.FieldSchema(name:value, type:string, comment:default), ]
PREHOOK: query: explain insert into table src_orc_merge_test_part partition(ds='2012-01-03', ts='2012-01-03+14:46:31') select * from src limit 100
PREHOOK: type: QUERY
POSTHOOK: query: explain insert into table src_orc_merge_test_part partition(ds='2012-01-03', ts='2012-01-03+14:46:31') select * from src limit 100
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP)

Stage-2
  Stats Work{}
    Stage-0
      Move Operator
        table:{"name:":"default.src_orc_merge_test_part"}
        Stage-1
          Reducer 2
          File Output Operator [FS_7]
            table:{"name:":"default.src_orc_merge_test_part"}
            Select Operator [SEL_6] (rows=100 width=10)
              Output:["_col0","_col1"]
              Limit [LIM_5] (rows=100 width=10)
                Number of rows:100
                Select Operator [SEL_4] (rows=100 width=10)
                  Output:["_col0","_col1"]
                <-Map 1 [GROUP]
                  GROUP [RS_3]
                    Limit [LIM_2] (rows=100 width=10)
                      Number of rows:100
                      Select Operator [SEL_1] (rows=500 width=10)
                        Output:["_col0","_col1"]
                        TableScan [TS_0] (rows=500 width=10)
                          default@src,src,Tbl:COMPLETE,Col:NONE,Output:["key","value"]

PREHOOK: query: explain select count(1) from src_orc_merge_test_part where ds='2012-01-03' and ts='2012-01-03+14:46:31'
PREHOOK: type: QUERY
POSTHOOK: query: explain select count(1) from src_orc_merge_test_part where ds='2012-01-03' and ts='2012-01-03+14:46:31'
POSTHOOK: type: QUERY
Plan optimized by CBO.

Stage-0
  Fetch Operator
    limit:1

PREHOOK: query: explain select sum(hash(key)), sum(hash(value)) from src_orc_merge_test_part where ds='2012-01-03' and ts='2012-01-03+14:46:31'
PREHOOK: type: QUERY
POSTHOOK: query: explain select sum(hash(key)), sum(hash(value)) from src_orc_merge_test_part where ds='2012-01-03' and ts='2012-01-03+14:46:31'
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_8]
        Group By Operator [GBY_6] (rows=1 width=16)
          Output:["_col0","_col1"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)"]
        <-Map 1 [GROUP]
          GROUP [RS_5]
            Group By Operator [GBY_4] (rows=1 width=16)
              Output:["_col0","_col1"],aggregations:["sum(_col0)","sum(_col1)"]
              Select Operator [SEL_2] (rows=500 width=94)
                Output:["_col0","_col1"]
                TableScan [TS_0] (rows=500 width=94)
                  default@src_orc_merge_test_part,src_orc_merge_test_part,Tbl:COMPLETE,Col:NONE,Output:["key","value"]

PREHOOK: query: alter table src_orc_merge_test_part partition (ds='2012-01-03', ts='2012-01-03+14:46:31') concatenate
PREHOOK: type: ALTER_PARTITION_MERGE
PREHOOK: Input: default@src_orc_merge_test_part
PREHOOK: Output: default@src_orc_merge_test_part@ds=2012-01-03/ts=2012-01-03+14%3A46%3A31
POSTHOOK: query: alter table src_orc_merge_test_part partition (ds='2012-01-03', ts='2012-01-03+14:46:31') concatenate
POSTHOOK: type: ALTER_PARTITION_MERGE
POSTHOOK: Input: default@src_orc_merge_test_part
POSTHOOK: Output: default@src_orc_merge_test_part@ds=2012-01-03/ts=2012-01-03+14%3A46%3A31
PREHOOK: query: explain select count(1) from src_orc_merge_test_part where ds='2012-01-03' and ts='2012-01-03+14:46:31'
PREHOOK: type: QUERY
POSTHOOK: query: explain select count(1) from src_orc_merge_test_part where ds='2012-01-03' and ts='2012-01-03+14:46:31'
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_7]
        Group By Operator [GBY_5] (rows=1 width=8)
          Output:["_col0"],aggregations:["count(VALUE._col0)"]
        <-Map 1 [GROUP]
          GROUP [RS_4]
            Group By Operator [GBY_3] (rows=1 width=8)
              Output:["_col0"],aggregations:["count()"]
              Select Operator [SEL_2] (rows=500 width=94)
                TableScan [TS_0] (rows=500 width=94)
                  default@src_orc_merge_test_part,src_orc_merge_test_part,Tbl:COMPLETE,Col:NONE

PREHOOK: query: explain select sum(hash(key)), sum(hash(value)) from src_orc_merge_test_part where ds='2012-01-03' and ts='2012-01-03+14:46:31'
PREHOOK: type: QUERY
POSTHOOK: query: explain select sum(hash(key)), sum(hash(value)) from src_orc_merge_test_part where ds='2012-01-03' and ts='2012-01-03+14:46:31'
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_8]
        Group By Operator [GBY_6] (rows=1 width=16)
          Output:["_col0","_col1"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)"]
        <-Map 1 [GROUP]
          GROUP [RS_5]
            Group By Operator [GBY_4] (rows=1 width=16)
              Output:["_col0","_col1"],aggregations:["sum(_col0)","sum(_col1)"]
              Select Operator [SEL_2] (rows=500 width=94)
                Output:["_col0","_col1"]
                TableScan [TS_0] (rows=500 width=94)
                  default@src_orc_merge_test_part,src_orc_merge_test_part,Tbl:COMPLETE,Col:NONE,Output:["key","value"]

PREHOOK: query: drop table src_orc_merge_test_part
PREHOOK: type: DROPTABLE
PREHOOK: Input: default@src_orc_merge_test_part
PREHOOK: Output: default@src_orc_merge_test_part
POSTHOOK: query: drop table src_orc_merge_test_part
POSTHOOK: type: DROPTABLE
POSTHOOK: Input: default@src_orc_merge_test_part
POSTHOOK: Output: default@src_orc_merge_test_part
Warning: Map Join MAPJOIN[18][bigTable=?] in task 'Stage-1:MAPRED' is a cross product
PREHOOK: query: explain select sum(hash(a.k1,a.v1,a.k2, a.v2))
from (
select src1.key as k1, src1.value as v1,
       src2.key as k2, src2.value as v2 FROM
  (select * FROM src WHERE src.key < 10) src1
    JOIN
  (select * FROM src WHERE src.key < 10) src2
  SORT BY k1, v1, k2, v2
) a
PREHOOK: type: QUERY
POSTHOOK: query: explain select sum(hash(a.k1,a.v1,a.k2, a.v2))
from (
select src1.key as k1, src1.value as v1,
       src2.key as k2, src2.value as v2 FROM
  (select * FROM src WHERE src.key < 10) src1
    JOIN
  (select * FROM src WHERE src.key < 10) src2
  SORT BY k1, v1, k2, v2
) a
POSTHOOK: type: QUERY
Plan not optimized by CBO.

Vertex dependency in Stage-1
Reducer 2 <- Map 1 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_15]
        Group By Operator [GBY_13] (rows=1 width=8)
          Output:["_col0"],aggregations:["sum(VALUE._col0)"]
        <-Map 1 [GROUP]
          GROUP [RS_12]
            Group By Operator [GBY_11] (rows=1 width=8)
              Output:["_col0"],aggregations:["sum(hash(_col0,_col1,_col2,_col3))"]
              Map Join Operator [MAPJOIN_18] (rows=27556 width=22)
                Conds:(Inner),Output:["_col0","_col1","_col2","_col3"]
              <-Select Operator [SEL_2] (rows=166 width=10)
                  Output:["_col0","_col1"]
                  Filter Operator [FIL_16] (rows=166 width=10)
                    predicate:(key < 10)
                    TableScan [TS_0] (rows=500 width=10)
                      default@src,src,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
          Map Reduce Local Work
        Stage-2
          Map 3
          keys: [HASHTABLESINK_20]
            Select Operator [SEL_5] (rows=166 width=10)
              Output:["_col0","_col1"]
              Filter Operator [FIL_17] (rows=166 width=10)
                predicate:(key < 10)
                TableScan [TS_3] (rows=500 width=10)
                  default@src,src,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
          Map Reduce Local Work

PREHOOK: query: explain select key, (c_int+1)+2 as x, sum(c_int) from cbo_t1 group by c_float, cbo_t1.c_int, key
PREHOOK: type: QUERY
POSTHOOK: query: explain select key, (c_int+1)+2 as x, sum(c_int) from cbo_t1 group by c_float, cbo_t1.c_int, key
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_6]
        Select Operator [SEL_5] (rows=10 width=97)
          Output:["_col0","_col1","_col2"]
          Group By Operator [GBY_4] (rows=10 width=101)
            Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(VALUE._col0)"],keys:KEY._col0, KEY._col1, KEY._col2
          <-Map 1 [GROUP]
            GROUP [RS_3]
              PartitionCols:_col0, _col1, _col2
              Group By Operator [GBY_2] (rows=10 width=101)
                Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(c_int)"],keys:key, c_int, c_float
                Select Operator [SEL_1] (rows=20 width=88)
                  Output:["key","c_int","c_float"]
                  TableScan [TS_0] (rows=20 width=88)
                    default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]

PREHOOK: query: explain select x, y, count(*) from (select key, (c_int+c_float+1+2) as x, sum(c_int) as y from cbo_t1 group by c_float, cbo_t1.c_int, key) R group by y, x
PREHOOK: type: QUERY
POSTHOOK: query: explain select x, y, count(*) from (select key, (c_int+c_float+1+2) as x, sum(c_int) as y from cbo_t1 group by c_float, cbo_t1.c_int, key) R group by y, x
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP)
Reducer 3 <- Reducer 2 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_11]
        Select Operator [SEL_10] (rows=5 width=20)
          Output:["_col0","_col1","_col2"]
          Group By Operator [GBY_9] (rows=5 width=20)
            Output:["_col0","_col1","_col2"],aggregations:["count(VALUE._col0)"],keys:KEY._col0, KEY._col1
          <-Reducer 2 [GROUP]
            GROUP [RS_8]
              PartitionCols:_col0, _col1
              Group By Operator [GBY_7] (rows=5 width=20)
                Output:["_col0","_col1","_col2"],aggregations:["count()"],keys:_col0, _col1
                Select Operator [SEL_5] (rows=10 width=101)
                  Output:["_col0","_col1"]
                  Group By Operator [GBY_4] (rows=10 width=101)
                    Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(VALUE._col0)"],keys:KEY._col0, KEY._col1, KEY._col2
                  <-Map 1 [GROUP]
                    GROUP [RS_3]
                      PartitionCols:_col0, _col1, _col2
                      Group By Operator [GBY_2] (rows=10 width=101)
                        Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(c_int)"],keys:key, c_int, c_float
                        Select Operator [SEL_1] (rows=20 width=88)
                          Output:["key","c_int","c_float"]
                          TableScan [TS_0] (rows=20 width=88)
                            default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]

PREHOOK: query: explain select cbo_t3.c_int, c, count(*) from (select key as a, c_int+1 as b, sum(c_int) as c from cbo_t1 where (cbo_t1.c_int + 1 >= 0) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0) group by c_float, cbo_t1.c_int, key order by a) cbo_t1 join (select key as p, c_int+1 as q, sum(c_int) as r from cbo_t2 where (cbo_t2.c_int + 1 >= 0) and (cbo_t2.c_int > 0 or cbo_t2.c_float >= 0)  group by c_float, cbo_t2.c_int, key order by q/10 desc, r asc) cbo_t2 on cbo_t1.a=p join cbo_t3 on cbo_t1.a=key where (b + cbo_t2.q >= 0) and (b > 0 or c_int >= 0) group by cbo_t3.c_int, c order by cbo_t3.c_int+c desc, c
PREHOOK: type: QUERY
POSTHOOK: query: explain select cbo_t3.c_int, c, count(*) from (select key as a, c_int+1 as b, sum(c_int) as c from cbo_t1 where (cbo_t1.c_int + 1 >= 0) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0) group by c_float, cbo_t1.c_int, key order by a) cbo_t1 join (select key as p, c_int+1 as q, sum(c_int) as r from cbo_t2 where (cbo_t2.c_int + 1 >= 0) and (cbo_t2.c_int > 0 or cbo_t2.c_float >= 0)  group by c_float, cbo_t2.c_int, key order by q/10 desc, r asc) cbo_t2 on cbo_t1.a=p join cbo_t3 on cbo_t1.a=key where (b + cbo_t2.q >= 0) and (b > 0 or c_int >= 0) group by cbo_t3.c_int, c order by cbo_t3.c_int+c desc, c
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Reducer 6 (PARTITION-LEVEL SORT), Reducer 8 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (GROUP)
Reducer 4 <- Reducer 3 (SORT)
Reducer 6 <- Map 5 (GROUP)
Reducer 8 <- Map 7 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 4
      File Output Operator [FS_31]
        Select Operator [SEL_29] (rows=1 width=20)
          Output:["_col0","_col1","_col2"]
        <-Reducer 3 [SORT]
          SORT [RS_28]
            Select Operator [SEL_27] (rows=1 width=28)
              Output:["_col0","_col1","_col2","_col3"]
              Group By Operator [GBY_26] (rows=1 width=20)
                Output:["_col0","_col1","_col2"],aggregations:["count(VALUE._col0)"],keys:KEY._col0, KEY._col1
              <-Reducer 2 [GROUP]
                GROUP [RS_25]
                  PartitionCols:_col0, _col1
                  Group By Operator [GBY_24] (rows=1 width=20)
                    Output:["_col0","_col1","_col2"],aggregations:["count()"],keys:_col4, _col1
                    Select Operator [SEL_23] (rows=1 width=20)
                      Output:["_col1","_col4"]
                      Filter Operator [FIL_21] (rows=1 width=20)
                        predicate:(((_col3 + _col6) >= 0) and ((_col3 > 0) or (_col1 >= 0)))
                        Join Operator [JOIN_20] (rows=3 width=18)
                          Output:["_col1","_col3","_col4","_col6"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"},{"":"{\"type\":\"Inner\",\"left\":1,\"right\":2}"}],keys:{"0":"_col0","1":"_col0","2":"_col0"}
                        <-Map 1 [PARTITION-LEVEL SORT]
                          PARTITION-LEVEL SORT [RS_17]
                            PartitionCols:_col0
                            Select Operator [SEL_2] (rows=18 width=84)
                              Output:["_col0","_col1"]
                              Filter Operator [FIL_32] (rows=18 width=84)
                                predicate:key is not null
                                TableScan [TS_0] (rows=20 width=84)
                                  default@cbo_t3,cbo_t3,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int"]
                        <-Reducer 6 [PARTITION-LEVEL SORT]
                          PARTITION-LEVEL SORT [RS_18]
                            PartitionCols:_col0
                            Select Operator [SEL_9] (rows=1 width=97)
                              Output:["_col0","_col1","_col2"]
                              Group By Operator [GBY_8] (rows=1 width=101)
                                Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(VALUE._col0)"],keys:KEY._col0, KEY._col1, KEY._col2
                              <-Map 5 [GROUP]
                                GROUP [RS_7]
                                  PartitionCols:_col0, _col1, _col2
                                  Group By Operator [GBY_6] (rows=1 width=101)
                                    Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(c_int)"],keys:key, c_int, c_float
                                    Filter Operator [FIL_33] (rows=4 width=93)
                                      predicate:(((c_int + 1) >= 0) and ((c_int > 0) or (c_float >= 0)) and key is not null)
                                      TableScan [TS_3] (rows=20 width=88)
                                        default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]
                        <-Reducer 8 [PARTITION-LEVEL SORT]
                          PARTITION-LEVEL SORT [RS_19]
                            PartitionCols:_col0
                            Select Operator [SEL_16] (rows=1 width=89)
                              Output:["_col0","_col1"]
                              Group By Operator [GBY_15] (rows=1 width=93)
                                Output:["_col0","_col1","_col2"],keys:KEY._col0, KEY._col1, KEY._col2
                              <-Map 7 [GROUP]
                                GROUP [RS_14]
                                  PartitionCols:_col0, _col1, _col2
                                  Group By Operator [GBY_13] (rows=1 width=93)
                                    Output:["_col0","_col1","_col2"],keys:key, c_int, c_float
                                    Filter Operator [FIL_34] (rows=4 width=93)
                                      predicate:(((c_int + 1) >= 0) and ((c_int > 0) or (c_float >= 0)) and key is not null)
                                      TableScan [TS_10] (rows=20 width=88)
                                        default@cbo_t2,cbo_t2,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]

PREHOOK: query: explain select cbo_t3.c_int, c, count(*) from (select key as a, c_int+1 as b, sum(c_int) as c from cbo_t1 where (cbo_t1.c_int + 1 >= 0) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0)  group by c_float, cbo_t1.c_int, key having cbo_t1.c_float > 0 and (c_int >=1 or c_float >= 1) and (c_int + c_float) >= 0 order by b % c asc, b desc) cbo_t1 left outer join (select key as p, c_int+1 as q, sum(c_int) as r from cbo_t2 where (cbo_t2.c_int + 1 >= 0) and (cbo_t2.c_int > 0 or cbo_t2.c_float >= 0)  group by c_float, cbo_t2.c_int, key  having cbo_t2.c_float > 0 and (c_int >=1 or c_float >= 1) and (c_int + c_float) >= 0) cbo_t2 on cbo_t1.a=p left outer join cbo_t3 on cbo_t1.a=key where (b + cbo_t2.q >= 0) and (b > 0 or c_int >= 0) group by cbo_t3.c_int, c  having cbo_t3.c_int > 0 and (c_int >=1 or c >= 1) and (c_int + c) >= 0  order by cbo_t3.c_int % c asc, cbo_t3.c_int desc
PREHOOK: type: QUERY
POSTHOOK: query: explain select cbo_t3.c_int, c, count(*) from (select key as a, c_int+1 as b, sum(c_int) as c from cbo_t1 where (cbo_t1.c_int + 1 >= 0) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0)  group by c_float, cbo_t1.c_int, key having cbo_t1.c_float > 0 and (c_int >=1 or c_float >= 1) and (c_int + c_float) >= 0 order by b % c asc, b desc) cbo_t1 left outer join (select key as p, c_int+1 as q, sum(c_int) as r from cbo_t2 where (cbo_t2.c_int + 1 >= 0) and (cbo_t2.c_int > 0 or cbo_t2.c_float >= 0)  group by c_float, cbo_t2.c_int, key  having cbo_t2.c_float > 0 and (c_int >=1 or c_float >= 1) and (c_int + c_float) >= 0) cbo_t2 on cbo_t1.a=p left outer join cbo_t3 on cbo_t1.a=key where (b + cbo_t2.q >= 0) and (b > 0 or c_int >= 0) group by cbo_t3.c_int, c  having cbo_t3.c_int > 0 and (c_int >=1 or c >= 1) and (c_int + c) >= 0  order by cbo_t3.c_int % c asc, cbo_t3.c_int desc
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Reducer 6 (PARTITION-LEVEL SORT), Reducer 8 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (GROUP)
Reducer 4 <- Reducer 3 (SORT)
Reducer 6 <- Map 5 (GROUP)
Reducer 8 <- Map 7 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 4
      File Output Operator [FS_32]
        Select Operator [SEL_30] (rows=1 width=20)
          Output:["_col0","_col1","_col2"]
        <-Reducer 3 [SORT]
          SORT [RS_29]
            Select Operator [SEL_28] (rows=1 width=28)
              Output:["_col0","_col1","_col2","_col3"]
              Group By Operator [GBY_27] (rows=1 width=20)
                Output:["_col0","_col1","_col2"],aggregations:["count(VALUE._col0)"],keys:KEY._col0, KEY._col1
              <-Reducer 2 [GROUP]
                GROUP [RS_26]
                  PartitionCols:_col0, _col1
                  Group By Operator [GBY_25] (rows=1 width=20)
                    Output:["_col0","_col1","_col2"],aggregations:["count()"],keys:_col1, _col4
                    Select Operator [SEL_24] (rows=1 width=20)
                      Output:["_col1","_col4"]
                      Filter Operator [FIL_21] (rows=1 width=20)
                        predicate:(((UDFToLong(_col1) + _col4) >= 0) and ((_col1 >= 1) or (_col4 >= 1L)) and ((_col3 + _col6) >= 0))
                        Join Operator [JOIN_20] (rows=3 width=18)
                          Output:["_col1","_col3","_col4","_col6"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"},{"":"{\"type\":\"Inner\",\"left\":1,\"right\":2}"}],keys:{"0":"_col0","1":"_col0","2":"_col0"}
                        <-Map 1 [PARTITION-LEVEL SORT]
                          PARTITION-LEVEL SORT [RS_17]
                            PartitionCols:_col0
                            Select Operator [SEL_2] (rows=18 width=84)
                              Output:["_col0","_col1"]
                              Filter Operator [FIL_33] (rows=18 width=84)
                                predicate:((c_int > 0) and key is not null)
                                TableScan [TS_0] (rows=20 width=84)
                                  default@cbo_t3,cbo_t3,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int"]
                        <-Reducer 6 [PARTITION-LEVEL SORT]
                          PARTITION-LEVEL SORT [RS_18]
                            PartitionCols:_col0
                            Select Operator [SEL_9] (rows=1 width=97)
                              Output:["_col0","_col1","_col2"]
                              Group By Operator [GBY_8] (rows=1 width=101)
                                Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(VALUE._col0)"],keys:KEY._col0, KEY._col1, KEY._col2
                              <-Map 5 [GROUP]
                                GROUP [RS_7]
                                  PartitionCols:_col0, _col1, _col2
                                  Group By Operator [GBY_6] (rows=1 width=101)
                                    Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(c_int)"],keys:key, c_int, c_float
                                    Filter Operator [FIL_34] (rows=2 width=93)
                                      predicate:(((UDFToFloat(c_int) + c_float) >= 0) and ((c_int + 1) >= 0) and ((c_int > 0) or (c_float >= 0)) and ((c_int >= 1) or (c_float >= 1)) and (c_float > 0) and key is not null)
                                      TableScan [TS_3] (rows=20 width=88)
                                        default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]
                        <-Reducer 8 [PARTITION-LEVEL SORT]
                          PARTITION-LEVEL SORT [RS_19]
                            PartitionCols:_col0
                            Select Operator [SEL_16] (rows=1 width=89)
                              Output:["_col0","_col1"]
                              Group By Operator [GBY_15] (rows=1 width=93)
                                Output:["_col0","_col1","_col2"],keys:KEY._col0, KEY._col1, KEY._col2
                              <-Map 7 [GROUP]
                                GROUP [RS_14]
                                  PartitionCols:_col0, _col1, _col2
                                  Group By Operator [GBY_13] (rows=1 width=93)
                                    Output:["_col0","_col1","_col2"],keys:key, c_int, c_float
                                    Filter Operator [FIL_35] (rows=2 width=93)
                                      predicate:(((UDFToFloat(c_int) + c_float) >= 0) and ((c_int + 1) >= 0) and ((c_int > 0) or (c_float >= 0)) and ((c_int >= 1) or (c_float >= 1)) and (c_float > 0) and key is not null)
                                      TableScan [TS_10] (rows=20 width=88)
                                        default@cbo_t2,cbo_t2,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]

PREHOOK: query: explain select cbo_t3.c_int, c, count(*) from (select key as a, c_int+1 as b, sum(c_int) as c from cbo_t1 where (cbo_t1.c_int + 1 >= 0) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0)  group by c_float, cbo_t1.c_int, key having cbo_t1.c_float > 0 and (c_int >=1 or c_float >= 1) and (c_int + c_float) >= 0 order by b+c, a desc) cbo_t1 right outer join (select key as p, c_int+1 as q, sum(c_int) as r from cbo_t2 where (cbo_t2.c_int + 1 >= 0) and (cbo_t2.c_int > 0 or cbo_t2.c_float >= 0)  group by c_float, cbo_t2.c_int, key having cbo_t2.c_float > 0 and (c_int >=1 or c_float >= 1) and (c_int + c_float) >= 0) cbo_t2 on cbo_t1.a=p right outer join cbo_t3 on cbo_t1.a=key where (b + cbo_t2.q >= 2) and (b > 0 or c_int >= 0) group by cbo_t3.c_int, c
PREHOOK: type: QUERY
POSTHOOK: query: explain select cbo_t3.c_int, c, count(*) from (select key as a, c_int+1 as b, sum(c_int) as c from cbo_t1 where (cbo_t1.c_int + 1 >= 0) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0)  group by c_float, cbo_t1.c_int, key having cbo_t1.c_float > 0 and (c_int >=1 or c_float >= 1) and (c_int + c_float) >= 0 order by b+c, a desc) cbo_t1 right outer join (select key as p, c_int+1 as q, sum(c_int) as r from cbo_t2 where (cbo_t2.c_int + 1 >= 0) and (cbo_t2.c_int > 0 or cbo_t2.c_float >= 0)  group by c_float, cbo_t2.c_int, key having cbo_t2.c_float > 0 and (c_int >=1 or c_float >= 1) and (c_int + c_float) >= 0) cbo_t2 on cbo_t1.a=p right outer join cbo_t3 on cbo_t1.a=key where (b + cbo_t2.q >= 2) and (b > 0 or c_int >= 0) group by cbo_t3.c_int, c
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Reducer 5 (PARTITION-LEVEL SORT), Reducer 7 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (GROUP)
Reducer 5 <- Map 4 (GROUP)
Reducer 7 <- Map 6 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_28]
        Group By Operator [GBY_26] (rows=1 width=20)
          Output:["_col0","_col1","_col2"],aggregations:["count(VALUE._col0)"],keys:KEY._col0, KEY._col1
        <-Reducer 2 [GROUP]
          GROUP [RS_25]
            PartitionCols:_col0, _col1
            Group By Operator [GBY_24] (rows=1 width=20)
              Output:["_col0","_col1","_col2"],aggregations:["count()"],keys:_col1, _col4
              Select Operator [SEL_23] (rows=1 width=20)
                Output:["_col1","_col4"]
                Filter Operator [FIL_21] (rows=1 width=20)
                  predicate:(((_col3 + _col6) >= 2) and ((_col3 > 0) or (_col1 >= 0)))
                  Join Operator [JOIN_20] (rows=3 width=18)
                    Output:["_col1","_col3","_col4","_col6"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"},{"":"{\"type\":\"Inner\",\"left\":1,\"right\":2}"}],keys:{"0":"_col0","1":"_col0","2":"_col0"}
                  <-Map 1 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_17]
                      PartitionCols:_col0
                      Select Operator [SEL_2] (rows=18 width=84)
                        Output:["_col0","_col1"]
                        Filter Operator [FIL_29] (rows=18 width=84)
                          predicate:key is not null
                          TableScan [TS_0] (rows=20 width=84)
                            default@cbo_t3,cbo_t3,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int"]
                  <-Reducer 5 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_18]
                      PartitionCols:_col0
                      Select Operator [SEL_9] (rows=1 width=97)
                        Output:["_col0","_col1","_col2"]
                        Group By Operator [GBY_8] (rows=1 width=101)
                          Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(VALUE._col0)"],keys:KEY._col0, KEY._col1, KEY._col2
                        <-Map 4 [GROUP]
                          GROUP [RS_7]
                            PartitionCols:_col0, _col1, _col2
                            Group By Operator [GBY_6] (rows=1 width=101)
                              Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(c_int)"],keys:key, c_int, c_float
                              Filter Operator [FIL_30] (rows=2 width=93)
                                predicate:(((UDFToFloat(c_int) + c_float) >= 0) and ((c_int + 1) >= 0) and ((c_int > 0) or (c_float >= 0)) and ((c_int >= 1) or (c_float >= 1)) and (c_float > 0) and key is not null)
                                TableScan [TS_3] (rows=20 width=88)
                                  default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]
                  <-Reducer 7 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_19]
                      PartitionCols:_col0
                      Select Operator [SEL_16] (rows=1 width=89)
                        Output:["_col0","_col1"]
                        Group By Operator [GBY_15] (rows=1 width=93)
                          Output:["_col0","_col1","_col2"],keys:KEY._col0, KEY._col1, KEY._col2
                        <-Map 6 [GROUP]
                          GROUP [RS_14]
                            PartitionCols:_col0, _col1, _col2
                            Group By Operator [GBY_13] (rows=1 width=93)
                              Output:["_col0","_col1","_col2"],keys:key, c_int, c_float
                              Filter Operator [FIL_31] (rows=2 width=93)
                                predicate:(((UDFToFloat(c_int) + c_float) >= 0) and ((c_int + 1) >= 0) and ((c_int > 0) or (c_float >= 0)) and ((c_int >= 1) or (c_float >= 1)) and (c_float > 0) and key is not null)
                                TableScan [TS_10] (rows=20 width=88)
                                  default@cbo_t2,cbo_t2,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]

PREHOOK: query: explain select cbo_t3.c_int, c, count(*) from (select key as a, c_int+1 as b, sum(c_int) as c from cbo_t1 where (cbo_t1.c_int + 1 >= 0) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0)  group by c_float, cbo_t1.c_int, key having cbo_t1.c_float > 0 and (c_int >=1 or c_float >= 1) and (c_int + c_float) >= 0 order by c+a desc) cbo_t1 full outer join (select key as p, c_int+1 as q, sum(c_int) as r from cbo_t2 where (cbo_t2.c_int + 1 >= 0) and (cbo_t2.c_int > 0 or cbo_t2.c_float >= 0)  group by c_float, cbo_t2.c_int, key having cbo_t2.c_float > 0 and (c_int >=1 or c_float >= 1) and (c_int + c_float) >= 0 order by p+q desc, r asc) cbo_t2 on cbo_t1.a=p full outer join cbo_t3 on cbo_t1.a=key where (b + cbo_t2.q >= 0) and (b > 0 or c_int >= 0) group by cbo_t3.c_int, c having cbo_t3.c_int > 0 and (c_int >=1 or c >= 1) and (c_int + c) >= 0 order by cbo_t3.c_int
PREHOOK: type: QUERY
POSTHOOK: query: explain select cbo_t3.c_int, c, count(*) from (select key as a, c_int+1 as b, sum(c_int) as c from cbo_t1 where (cbo_t1.c_int + 1 >= 0) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0)  group by c_float, cbo_t1.c_int, key having cbo_t1.c_float > 0 and (c_int >=1 or c_float >= 1) and (c_int + c_float) >= 0 order by c+a desc) cbo_t1 full outer join (select key as p, c_int+1 as q, sum(c_int) as r from cbo_t2 where (cbo_t2.c_int + 1 >= 0) and (cbo_t2.c_int > 0 or cbo_t2.c_float >= 0)  group by c_float, cbo_t2.c_int, key having cbo_t2.c_float > 0 and (c_int >=1 or c_float >= 1) and (c_int + c_float) >= 0 order by p+q desc, r asc) cbo_t2 on cbo_t1.a=p full outer join cbo_t3 on cbo_t1.a=key where (b + cbo_t2.q >= 0) and (b > 0 or c_int >= 0) group by cbo_t3.c_int, c having cbo_t3.c_int > 0 and (c_int >=1 or c >= 1) and (c_int + c) >= 0 order by cbo_t3.c_int
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Reducer 6 (PARTITION-LEVEL SORT), Reducer 8 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (GROUP)
Reducer 4 <- Reducer 3 (SORT)
Reducer 6 <- Map 5 (GROUP)
Reducer 8 <- Map 7 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 4
      File Output Operator [FS_31]
        Select Operator [SEL_30] (rows=1 width=20)
          Output:["_col0","_col1","_col2"]
        <-Reducer 3 [SORT]
          SORT [RS_29]
            Group By Operator [GBY_27] (rows=1 width=20)
              Output:["_col0","_col1","_col2"],aggregations:["count(VALUE._col0)"],keys:KEY._col0, KEY._col1
            <-Reducer 2 [GROUP]
              GROUP [RS_26]
                PartitionCols:_col0, _col1
                Group By Operator [GBY_25] (rows=1 width=20)
                  Output:["_col0","_col1","_col2"],aggregations:["count()"],keys:_col1, _col4
                  Select Operator [SEL_24] (rows=1 width=20)
                    Output:["_col1","_col4"]
                    Filter Operator [FIL_21] (rows=1 width=20)
                      predicate:(((UDFToLong(_col1) + _col4) >= 0) and ((_col1 >= 1) or (_col4 >= 1L)) and ((_col3 + _col6) >= 0))
                      Join Operator [JOIN_20] (rows=3 width=18)
                        Output:["_col1","_col3","_col4","_col6"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"},{"":"{\"type\":\"Inner\",\"left\":1,\"right\":2}"}],keys:{"0":"_col0","1":"_col0","2":"_col0"}
                      <-Map 1 [PARTITION-LEVEL SORT]
                        PARTITION-LEVEL SORT [RS_17]
                          PartitionCols:_col0
                          Select Operator [SEL_2] (rows=18 width=84)
                            Output:["_col0","_col1"]
                            Filter Operator [FIL_32] (rows=18 width=84)
                              predicate:((c_int > 0) and key is not null)
                              TableScan [TS_0] (rows=20 width=84)
                                default@cbo_t3,cbo_t3,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int"]
                      <-Reducer 6 [PARTITION-LEVEL SORT]
                        PARTITION-LEVEL SORT [RS_18]
                          PartitionCols:_col0
                          Select Operator [SEL_9] (rows=1 width=97)
                            Output:["_col0","_col1","_col2"]
                            Group By Operator [GBY_8] (rows=1 width=101)
                              Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(VALUE._col0)"],keys:KEY._col0, KEY._col1, KEY._col2
                            <-Map 5 [GROUP]
                              GROUP [RS_7]
                                PartitionCols:_col0, _col1, _col2
                                Group By Operator [GBY_6] (rows=1 width=101)
                                  Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(c_int)"],keys:key, c_int, c_float
                                  Filter Operator [FIL_33] (rows=2 width=93)
                                    predicate:(((UDFToFloat(c_int) + c_float) >= 0) and ((c_int + 1) >= 0) and ((c_int > 0) or (c_float >= 0)) and ((c_int >= 1) or (c_float >= 1)) and (c_float > 0) and key is not null)
                                    TableScan [TS_3] (rows=20 width=88)
                                      default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]
                      <-Reducer 8 [PARTITION-LEVEL SORT]
                        PARTITION-LEVEL SORT [RS_19]
                          PartitionCols:_col0
                          Select Operator [SEL_16] (rows=1 width=89)
                            Output:["_col0","_col1"]
                            Group By Operator [GBY_15] (rows=1 width=93)
                              Output:["_col0","_col1","_col2"],keys:KEY._col0, KEY._col1, KEY._col2
                            <-Map 7 [GROUP]
                              GROUP [RS_14]
                                PartitionCols:_col0, _col1, _col2
                                Group By Operator [GBY_13] (rows=1 width=93)
                                  Output:["_col0","_col1","_col2"],keys:key, c_int, c_float
                                  Filter Operator [FIL_34] (rows=2 width=93)
                                    predicate:(((UDFToFloat(c_int) + c_float) >= 0) and ((c_int + 1) >= 0) and ((c_int > 0) or (c_float >= 0)) and ((c_int >= 1) or (c_float >= 1)) and (c_float > 0) and key is not null)
                                    TableScan [TS_10] (rows=20 width=88)
                                      default@cbo_t2,cbo_t2,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]

PREHOOK: query: explain select cbo_t3.c_int, c, count(*) from (select key as a, c_int+1 as b, sum(c_int) as c from cbo_t1 where (cbo_t1.c_int + 1 >= 0) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0)  group by c_float, cbo_t1.c_int, key having cbo_t1.c_float > 0 and (c_int >=1 or c_float >= 1) and (c_int + c_float) >= 0) cbo_t1 join (select key as p, c_int+1 as q, sum(c_int) as r from cbo_t2 where (cbo_t2.c_int + 1 >= 0) and (cbo_t2.c_int > 0 or cbo_t2.c_float >= 0)  group by c_float, cbo_t2.c_int, key having cbo_t2.c_float > 0 and (c_int >=1 or c_float >= 1) and (c_int + c_float) >= 0) cbo_t2 on cbo_t1.a=p join cbo_t3 on cbo_t1.a=key where (b + cbo_t2.q >= 0) and (b > 0 or c_int >= 0) group by cbo_t3.c_int, c
PREHOOK: type: QUERY
POSTHOOK: query: explain select cbo_t3.c_int, c, count(*) from (select key as a, c_int+1 as b, sum(c_int) as c from cbo_t1 where (cbo_t1.c_int + 1 >= 0) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0)  group by c_float, cbo_t1.c_int, key having cbo_t1.c_float > 0 and (c_int >=1 or c_float >= 1) and (c_int + c_float) >= 0) cbo_t1 join (select key as p, c_int+1 as q, sum(c_int) as r from cbo_t2 where (cbo_t2.c_int + 1 >= 0) and (cbo_t2.c_int > 0 or cbo_t2.c_float >= 0)  group by c_float, cbo_t2.c_int, key having cbo_t2.c_float > 0 and (c_int >=1 or c_float >= 1) and (c_int + c_float) >= 0) cbo_t2 on cbo_t1.a=p join cbo_t3 on cbo_t1.a=key where (b + cbo_t2.q >= 0) and (b > 0 or c_int >= 0) group by cbo_t3.c_int, c
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Reducer 5 (PARTITION-LEVEL SORT), Reducer 7 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (GROUP)
Reducer 5 <- Map 4 (GROUP)
Reducer 7 <- Map 6 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_28]
        Group By Operator [GBY_26] (rows=1 width=20)
          Output:["_col0","_col1","_col2"],aggregations:["count(VALUE._col0)"],keys:KEY._col0, KEY._col1
        <-Reducer 2 [GROUP]
          GROUP [RS_25]
            PartitionCols:_col0, _col1
            Group By Operator [GBY_24] (rows=1 width=20)
              Output:["_col0","_col1","_col2"],aggregations:["count()"],keys:_col1, _col4
              Select Operator [SEL_23] (rows=1 width=20)
                Output:["_col1","_col4"]
                Filter Operator [FIL_21] (rows=1 width=20)
                  predicate:(((_col3 + _col6) >= 0) and ((_col3 > 0) or (_col1 >= 0)))
                  Join Operator [JOIN_20] (rows=3 width=18)
                    Output:["_col1","_col3","_col4","_col6"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"},{"":"{\"type\":\"Inner\",\"left\":1,\"right\":2}"}],keys:{"0":"_col0","1":"_col0","2":"_col0"}
                  <-Map 1 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_17]
                      PartitionCols:_col0
                      Select Operator [SEL_2] (rows=18 width=84)
                        Output:["_col0","_col1"]
                        Filter Operator [FIL_29] (rows=18 width=84)
                          predicate:key is not null
                          TableScan [TS_0] (rows=20 width=84)
                            default@cbo_t3,cbo_t3,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int"]
                  <-Reducer 5 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_18]
                      PartitionCols:_col0
                      Select Operator [SEL_9] (rows=1 width=97)
                        Output:["_col0","_col1","_col2"]
                        Group By Operator [GBY_8] (rows=1 width=101)
                          Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(VALUE._col0)"],keys:KEY._col0, KEY._col1, KEY._col2
                        <-Map 4 [GROUP]
                          GROUP [RS_7]
                            PartitionCols:_col0, _col1, _col2
                            Group By Operator [GBY_6] (rows=1 width=101)
                              Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(c_int)"],keys:key, c_int, c_float
                              Filter Operator [FIL_30] (rows=2 width=93)
                                predicate:(((UDFToFloat(c_int) + c_float) >= 0) and ((c_int + 1) >= 0) and ((c_int > 0) or (c_float >= 0)) and ((c_int >= 1) or (c_float >= 1)) and (c_float > 0) and key is not null)
                                TableScan [TS_3] (rows=20 width=88)
                                  default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]
                  <-Reducer 7 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_19]
                      PartitionCols:_col0
                      Select Operator [SEL_16] (rows=1 width=89)
                        Output:["_col0","_col1"]
                        Group By Operator [GBY_15] (rows=1 width=93)
                          Output:["_col0","_col1","_col2"],keys:KEY._col0, KEY._col1, KEY._col2
                        <-Map 6 [GROUP]
                          GROUP [RS_14]
                            PartitionCols:_col0, _col1, _col2
                            Group By Operator [GBY_13] (rows=1 width=93)
                              Output:["_col0","_col1","_col2"],keys:key, c_int, c_float
                              Filter Operator [FIL_31] (rows=2 width=93)
                                predicate:(((UDFToFloat(c_int) + c_float) >= 0) and ((c_int + 1) >= 0) and ((c_int > 0) or (c_float >= 0)) and ((c_int >= 1) or (c_float >= 1)) and (c_float > 0) and key is not null)
                                TableScan [TS_10] (rows=20 width=88)
                                  default@cbo_t2,cbo_t2,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]

PREHOOK: query: explain select unionsrc.key FROM (select 'tst1' as key, count(1) as value from src) unionsrc
PREHOOK: type: QUERY
POSTHOOK: query: explain select unionsrc.key FROM (select 'tst1' as key, count(1) as value from src) unionsrc
POSTHOOK: type: QUERY
Plan optimized by CBO.

Stage-0
  Fetch Operator
    limit:1

PREHOOK: query: explain select unionsrc.key FROM (select 'max' as key, max(c_int) as value from cbo_t3 s1
	UNION  ALL
	select 'min' as key,  min(c_int) as value from cbo_t3 s2
    UNION ALL
        select 'avg' as key,  avg(c_int) as value from cbo_t3 s3) unionsrc order by unionsrc.key
PREHOOK: type: QUERY
POSTHOOK: query: explain select unionsrc.key FROM (select 'max' as key, max(c_int) as value from cbo_t3 s1
	UNION  ALL
	select 'min' as key,  min(c_int) as value from cbo_t3 s2
    UNION ALL
        select 'avg' as key,  avg(c_int) as value from cbo_t3 s3) unionsrc order by unionsrc.key
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP)
Reducer 3 <- Reducer 2 (SORT), Reducer 5 (SORT), Reducer 7 (SORT)
Reducer 5 <- Map 4 (GROUP)
Reducer 7 <- Map 6 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_25]
        Select Operator [SEL_24] (rows=3 width=87)
          Output:["_col0"]
        <-Reducer 2 [SORT]
          SORT [RS_23]
            Select Operator [SEL_5] (rows=1 width=87)
              Output:["_col0"]
              Group By Operator [GBY_4] (rows=1 width=8)
                Output:["_col0"],aggregations:["count(VALUE._col0)"]
              <-Map 1 [GROUP]
                GROUP [RS_3]
                  Group By Operator [GBY_2] (rows=1 width=8)
                    Output:["_col0"],aggregations:["count(key)"]
                    Select Operator [SEL_1] (rows=20 width=80)
                      Output:["key"]
                      TableScan [TS_0] (rows=20 width=80)
                        default@cbo_t3,s1,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]
        <-Reducer 5 [SORT]
          SORT [RS_23]
            Select Operator [SEL_12] (rows=1 width=87)
              Output:["_col0"]
              Group By Operator [GBY_11] (rows=1 width=8)
                Output:["_col0"],aggregations:["count(VALUE._col0)"]
              <-Map 4 [GROUP]
                GROUP [RS_10]
                  Group By Operator [GBY_9] (rows=1 width=8)
                    Output:["_col0"],aggregations:["count(key)"]
                    Select Operator [SEL_8] (rows=20 width=80)
                      Output:["key"]
                      TableScan [TS_7] (rows=20 width=80)
                        default@cbo_t3,s2,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]
        <-Reducer 7 [SORT]
          SORT [RS_23]
            Select Operator [SEL_20] (rows=1 width=87)
              Output:["_col0"]
              Group By Operator [GBY_19] (rows=1 width=8)
                Output:["_col0"],aggregations:["count(VALUE._col0)"]
              <-Map 6 [GROUP]
                GROUP [RS_18]
                  Group By Operator [GBY_17] (rows=1 width=8)
                    Output:["_col0"],aggregations:["count(key)"]
                    Select Operator [SEL_16] (rows=20 width=80)
                      Output:["key"]
                      TableScan [TS_15] (rows=20 width=80)
                        default@cbo_t3,s3,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]

PREHOOK: query: explain select unionsrc.key, count(1) FROM (select 'max' as key, max(c_int) as value from cbo_t3 s1
    UNION  ALL
        select 'min' as key,  min(c_int) as value from cbo_t3 s2
    UNION ALL
        select 'avg' as key,  avg(c_int) as value from cbo_t3 s3) unionsrc group by unionsrc.key order by unionsrc.key
PREHOOK: type: QUERY
POSTHOOK: query: explain select unionsrc.key, count(1) FROM (select 'max' as key, max(c_int) as value from cbo_t3 s1
    UNION  ALL
        select 'min' as key,  min(c_int) as value from cbo_t3 s2
    UNION ALL
        select 'avg' as key,  avg(c_int) as value from cbo_t3 s3) unionsrc group by unionsrc.key order by unionsrc.key
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP)
Reducer 3 <- Reducer 2 (GROUP), Reducer 6 (GROUP), Reducer 8 (GROUP)
Reducer 4 <- Reducer 3 (SORT)
Reducer 6 <- Map 5 (GROUP)
Reducer 8 <- Map 7 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 4
      File Output Operator [FS_30]
        Select Operator [SEL_29] (rows=1 width=95)
          Output:["_col0","_col1"]
        <-Reducer 3 [SORT]
          SORT [RS_28]
            Group By Operator [GBY_26] (rows=1 width=95)
              Output:["_col0","_col1"],aggregations:["count(VALUE._col0)"],keys:KEY._col0
            <-Reducer 2 [GROUP]
              GROUP [RS_25]
                PartitionCols:_col0
                Group By Operator [GBY_24] (rows=1 width=95)
                  Output:["_col0","_col1"],aggregations:["count()"],keys:_col0
                  Select Operator [SEL_5] (rows=1 width=87)
                    Output:["_col0"]
                    Group By Operator [GBY_4] (rows=1 width=8)
                      Output:["_col0"],aggregations:["count(VALUE._col0)"]
                    <-Map 1 [GROUP]
                      GROUP [RS_3]
                        Group By Operator [GBY_2] (rows=1 width=8)
                          Output:["_col0"],aggregations:["count(key)"]
                          Select Operator [SEL_1] (rows=20 width=80)
                            Output:["key"]
                            TableScan [TS_0] (rows=20 width=80)
                              default@cbo_t3,s1,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]
            <-Reducer 6 [GROUP]
              GROUP [RS_25]
                PartitionCols:_col0
                Group By Operator [GBY_24] (rows=1 width=95)
                  Output:["_col0","_col1"],aggregations:["count()"],keys:_col0
                  Select Operator [SEL_12] (rows=1 width=87)
                    Output:["_col0"]
                    Group By Operator [GBY_11] (rows=1 width=8)
                      Output:["_col0"],aggregations:["count(VALUE._col0)"]
                    <-Map 5 [GROUP]
                      GROUP [RS_10]
                        Group By Operator [GBY_9] (rows=1 width=8)
                          Output:["_col0"],aggregations:["count(key)"]
                          Select Operator [SEL_8] (rows=20 width=80)
                            Output:["key"]
                            TableScan [TS_7] (rows=20 width=80)
                              default@cbo_t3,s2,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]
            <-Reducer 8 [GROUP]
              GROUP [RS_25]
                PartitionCols:_col0
                Group By Operator [GBY_24] (rows=1 width=95)
                  Output:["_col0","_col1"],aggregations:["count()"],keys:_col0
                  Select Operator [SEL_20] (rows=1 width=87)
                    Output:["_col0"]
                    Group By Operator [GBY_19] (rows=1 width=8)
                      Output:["_col0"],aggregations:["count(VALUE._col0)"]
                    <-Map 7 [GROUP]
                      GROUP [RS_18]
                        Group By Operator [GBY_17] (rows=1 width=8)
                          Output:["_col0"],aggregations:["count(key)"]
                          Select Operator [SEL_16] (rows=20 width=80)
                            Output:["key"]
                            TableScan [TS_15] (rows=20 width=80)
                              default@cbo_t3,s3,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]

PREHOOK: query: explain select cbo_t1.key from cbo_t1 join cbo_t3 where cbo_t1.key=cbo_t3.key and cbo_t1.key >= 1
PREHOOK: type: QUERY
POSTHOOK: query: explain select cbo_t1.key from cbo_t1 join cbo_t3 where cbo_t1.key=cbo_t3.key and cbo_t1.key >= 1
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_10]
        Join Operator [JOIN_8] (rows=18 width=85)
          Output:["_col0"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"}],keys:{"0":"_col0","1":"_col0"}
        <-Map 1 [PARTITION-LEVEL SORT]
          PARTITION-LEVEL SORT [RS_6]
            PartitionCols:_col0
            Select Operator [SEL_2] (rows=6 width=85)
              Output:["_col0"]
              Filter Operator [FIL_11] (rows=6 width=85)
                predicate:(UDFToDouble(key) >= 1.0D)
                TableScan [TS_0] (rows=20 width=80)
                  default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]
        <-Map 3 [PARTITION-LEVEL SORT]
          PARTITION-LEVEL SORT [RS_7]
            PartitionCols:_col0
            Select Operator [SEL_5] (rows=6 width=85)
              Output:["_col0"]
              Filter Operator [FIL_12] (rows=6 width=85)
                predicate:(UDFToDouble(key) >= 1.0D)
                TableScan [TS_3] (rows=20 width=80)
                  default@cbo_t3,cbo_t3,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]

PREHOOK: query: explain select cbo_t1.c_int, cbo_t2.c_int from cbo_t1 left outer join  cbo_t2 on cbo_t1.key=cbo_t2.key
PREHOOK: type: QUERY
POSTHOOK: query: explain select cbo_t1.c_int, cbo_t2.c_int from cbo_t1 left outer join  cbo_t2 on cbo_t1.key=cbo_t2.key
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_8]
        Select Operator [SEL_7] (rows=80 width=7)
          Output:["_col0","_col1"]
          Join Operator [JOIN_6] (rows=80 width=7)
            Output:["_col1","_col3"],condition map:[{"":"{\"type\":\"Left Outer\",\"left\":0,\"right\":1}"}],keys:{"0":"_col0","1":"_col0"}
          <-Map 1 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_4]
              PartitionCols:_col0
              Select Operator [SEL_1] (rows=20 width=84)
                Output:["_col0","_col1"]
                TableScan [TS_0] (rows=20 width=84)
                  default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int"]
          <-Map 3 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_5]
              PartitionCols:_col0
              Select Operator [SEL_3] (rows=20 width=84)
                Output:["_col0","_col1"]
                TableScan [TS_2] (rows=20 width=84)
                  default@cbo_t2,cbo_t2,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int"]

PREHOOK: query: explain select cbo_t1.c_int, cbo_t2.c_int from cbo_t1 full outer join  cbo_t2 on cbo_t1.key=cbo_t2.key
PREHOOK: type: QUERY
POSTHOOK: query: explain select cbo_t1.c_int, cbo_t2.c_int from cbo_t1 full outer join  cbo_t2 on cbo_t1.key=cbo_t2.key
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_8]
        Select Operator [SEL_7] (rows=80 width=7)
          Output:["_col0","_col1"]
          Join Operator [JOIN_6] (rows=80 width=7)
            Output:["_col1","_col3"],condition map:[{"":"{\"type\":\"Outer\",\"left\":0,\"right\":1}"}],keys:{"0":"_col0","1":"_col0"}
          <-Map 1 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_4]
              PartitionCols:_col0
              Select Operator [SEL_1] (rows=20 width=84)
                Output:["_col0","_col1"]
                TableScan [TS_0] (rows=20 width=84)
                  default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int"]
          <-Map 3 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_5]
              PartitionCols:_col0
              Select Operator [SEL_3] (rows=20 width=84)
                Output:["_col0","_col1"]
                TableScan [TS_2] (rows=20 width=84)
                  default@cbo_t2,cbo_t2,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int"]

PREHOOK: query: explain select b, cbo_t1.c, cbo_t2.p, q, cbo_t3.c_int from (select key as a, c_int as b, cbo_t1.c_float as c from cbo_t1) cbo_t1 join (select cbo_t2.key as p, cbo_t2.c_int as q, c_float as r from cbo_t2) cbo_t2 on cbo_t1.a=p join cbo_t3 on cbo_t1.a=key
PREHOOK: type: QUERY
POSTHOOK: query: explain select b, cbo_t1.c, cbo_t2.p, q, cbo_t3.c_int from (select key as a, c_int as b, cbo_t1.c_float as c from cbo_t1) cbo_t1 join (select cbo_t2.key as p, cbo_t2.c_int as q, c_float as r from cbo_t2) cbo_t2 on cbo_t1.a=p join cbo_t3 on cbo_t1.a=key
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT), Map 4 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_14]
        Select Operator [SEL_13] (rows=194 width=100)
          Output:["_col0","_col1","_col2","_col3","_col4"]
          Join Operator [JOIN_12] (rows=194 width=100)
            Output:["_col1","_col2","_col4","_col5","_col6"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"},{"":"{\"type\":\"Inner\",\"left\":0,\"right\":2}"}],keys:{"0":"_col0","1":"_col0","2":"_col0"}
          <-Map 1 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_9]
              PartitionCols:_col0
              Select Operator [SEL_2] (rows=18 width=87)
                Output:["_col0","_col1","_col2"]
                Filter Operator [FIL_15] (rows=18 width=87)
                  predicate:key is not null
                  TableScan [TS_0] (rows=20 width=88)
                    default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]
          <-Map 3 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_10]
              PartitionCols:_col0
              Select Operator [SEL_5] (rows=18 width=84)
                Output:["_col0","_col1"]
                Filter Operator [FIL_16] (rows=18 width=84)
                  predicate:key is not null
                  TableScan [TS_3] (rows=20 width=84)
                    default@cbo_t3,cbo_t3,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int"]
          <-Map 4 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_11]
              PartitionCols:_col0
              Select Operator [SEL_8] (rows=18 width=84)
                Output:["_col0","_col1"]
                Filter Operator [FIL_17] (rows=18 width=84)
                  predicate:key is not null
                  TableScan [TS_6] (rows=20 width=84)
                    default@cbo_t2,cbo_t2,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int"]

PREHOOK: query: explain select key, cbo_t1.c_int, cbo_t2.p, q from cbo_t1 join (select cbo_t2.key as p, cbo_t2.c_int as q, c_float as r from cbo_t2) cbo_t2 on cbo_t1.key=p join (select key as a, c_int as b, cbo_t3.c_float as c from cbo_t3)cbo_t3 on cbo_t1.key=a
PREHOOK: type: QUERY
POSTHOOK: query: explain select key, cbo_t1.c_int, cbo_t2.p, q from cbo_t1 join (select cbo_t2.key as p, cbo_t2.c_int as q, c_float as r from cbo_t2) cbo_t2 on cbo_t1.key=p join (select key as a, c_int as b, cbo_t3.c_float as c from cbo_t3)cbo_t3 on cbo_t1.key=a
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT), Map 4 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_14]
        Select Operator [SEL_13] (rows=194 width=177)
          Output:["_col0","_col1","_col2","_col3"]
          Join Operator [JOIN_12] (rows=194 width=177)
            Output:["_col0","_col1","_col3","_col4"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"},{"":"{\"type\":\"Inner\",\"left\":0,\"right\":2}"}],keys:{"0":"_col0","1":"_col0","2":"_col0"}
          <-Map 1 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_9]
              PartitionCols:_col0
              Select Operator [SEL_2] (rows=18 width=84)
                Output:["_col0","_col1"]
                Filter Operator [FIL_15] (rows=18 width=84)
                  predicate:key is not null
                  TableScan [TS_0] (rows=20 width=84)
                    default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int"]
          <-Map 3 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_10]
              PartitionCols:_col0
              Select Operator [SEL_5] (rows=18 width=80)
                Output:["_col0"]
                Filter Operator [FIL_16] (rows=18 width=80)
                  predicate:key is not null
                  TableScan [TS_3] (rows=20 width=80)
                    default@cbo_t3,cbo_t3,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]
          <-Map 4 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_11]
              PartitionCols:_col0
              Select Operator [SEL_8] (rows=18 width=84)
                Output:["_col0","_col1"]
                Filter Operator [FIL_17] (rows=18 width=84)
                  predicate:key is not null
                  TableScan [TS_6] (rows=20 width=84)
                    default@cbo_t2,cbo_t2,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int"]

PREHOOK: query: explain select * from (select q, b, cbo_t2.p, cbo_t1.c, cbo_t3.c_int from (select key as a, c_int as b, cbo_t1.c_float as c from cbo_t1  where (cbo_t1.c_int + 1 == 2) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0)) cbo_t1 full outer join (select cbo_t2.key as p, cbo_t2.c_int as q, c_float as r from cbo_t2  where (cbo_t2.c_int + 1 == 2) and (cbo_t2.c_int > 0 or cbo_t2.c_float >= 0)) cbo_t2 on cbo_t1.a=p join cbo_t3 on cbo_t1.a=key where (b + cbo_t2.q == 2) and (b > 0 or c_int >= 0)) R where  (q + 1 = 2) and (R.b > 0 or c_int >= 0)
PREHOOK: type: QUERY
POSTHOOK: query: explain select * from (select q, b, cbo_t2.p, cbo_t1.c, cbo_t3.c_int from (select key as a, c_int as b, cbo_t1.c_float as c from cbo_t1  where (cbo_t1.c_int + 1 == 2) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0)) cbo_t1 full outer join (select cbo_t2.key as p, cbo_t2.c_int as q, c_float as r from cbo_t2  where (cbo_t2.c_int + 1 == 2) and (cbo_t2.c_int > 0 or cbo_t2.c_float >= 0)) cbo_t2 on cbo_t1.a=p join cbo_t3 on cbo_t1.a=key where (b + cbo_t2.q == 2) and (b > 0 or c_int >= 0)) R where  (q + 1 = 2) and (R.b > 0 or c_int >= 0)
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT), Map 4 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_16]
        Select Operator [SEL_15] (rows=48 width=101)
          Output:["_col0","_col1","_col2","_col3","_col4"]
          Filter Operator [FIL_13] (rows=48 width=101)
            predicate:(((_col1 + _col4) = 2) and ((_col1 > 0) or (_col6 >= 0)))
            Join Operator [JOIN_12] (rows=96 width=100)
              Output:["_col1","_col2","_col3","_col4","_col6"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"},{"":"{\"type\":\"Inner\",\"left\":0,\"right\":2}"}],keys:{"0":"_col0","1":"_col0","2":"_col0"}
            <-Map 1 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_9]
                PartitionCols:_col0
                Select Operator [SEL_2] (rows=8 width=93)
                  Output:["_col0","_col1","_col2"]
                  Filter Operator [FIL_17] (rows=8 width=93)
                    predicate:(((c_int + 1) = 2) and ((c_int > 0) or (c_float >= 0)) and key is not null)
                    TableScan [TS_0] (rows=20 width=88)
                      default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]
            <-Map 3 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_10]
                PartitionCols:_col0
                Select Operator [SEL_5] (rows=8 width=89)
                  Output:["_col0","_col1"]
                  Filter Operator [FIL_18] (rows=8 width=93)
                    predicate:(((c_int + 1) = 2) and ((c_int > 0) or (c_float >= 0)) and key is not null)
                    TableScan [TS_3] (rows=20 width=88)
                      default@cbo_t2,cbo_t2,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]
            <-Map 4 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_11]
                PartitionCols:_col0
                Select Operator [SEL_8] (rows=18 width=84)
                  Output:["_col0","_col1"]
                  Filter Operator [FIL_19] (rows=18 width=84)
                    predicate:key is not null
                    TableScan [TS_6] (rows=20 width=84)
                      default@cbo_t3,cbo_t3,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int"]

PREHOOK: query: explain select * from (select q, b, cbo_t2.p, cbo_t1.c, cbo_t3.c_int from (select key as a, c_int as b, cbo_t1.c_float as c from cbo_t1  where (cbo_t1.c_int + 1 == 2) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0)) cbo_t1 right outer join (select cbo_t2.key as p, cbo_t2.c_int as q, c_float as r from cbo_t2  where (cbo_t2.c_int + 1 == 2) and (cbo_t2.c_int > 0 or cbo_t2.c_float >= 0)) cbo_t2 on cbo_t1.a=p right outer join cbo_t3 on cbo_t1.a=key where (b + cbo_t2.q == 2) and (b > 0 or c_int >= 0)) R where  (q + 1 = 2) and (R.b > 0 or c_int >= 0)
PREHOOK: type: QUERY
POSTHOOK: query: explain select * from (select q, b, cbo_t2.p, cbo_t1.c, cbo_t3.c_int from (select key as a, c_int as b, cbo_t1.c_float as c from cbo_t1  where (cbo_t1.c_int + 1 == 2) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0)) cbo_t1 right outer join (select cbo_t2.key as p, cbo_t2.c_int as q, c_float as r from cbo_t2  where (cbo_t2.c_int + 1 == 2) and (cbo_t2.c_int > 0 or cbo_t2.c_float >= 0)) cbo_t2 on cbo_t1.a=p right outer join cbo_t3 on cbo_t1.a=key where (b + cbo_t2.q == 2) and (b > 0 or c_int >= 0)) R where  (q + 1 = 2) and (R.b > 0 or c_int >= 0)
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT), Map 4 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_16]
        Select Operator [SEL_15] (rows=48 width=101)
          Output:["_col0","_col1","_col2","_col3","_col4"]
          Filter Operator [FIL_13] (rows=48 width=101)
            predicate:(((_col1 + _col4) = 2) and ((_col1 > 0) or (_col6 >= 0)))
            Join Operator [JOIN_12] (rows=96 width=100)
              Output:["_col1","_col2","_col3","_col4","_col6"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"},{"":"{\"type\":\"Inner\",\"left\":0,\"right\":2}"}],keys:{"0":"_col0","1":"_col0","2":"_col0"}
            <-Map 1 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_9]
                PartitionCols:_col0
                Select Operator [SEL_2] (rows=8 width=93)
                  Output:["_col0","_col1","_col2"]
                  Filter Operator [FIL_17] (rows=8 width=93)
                    predicate:(((c_int + 1) = 2) and ((c_int > 0) or (c_float >= 0)) and key is not null)
                    TableScan [TS_0] (rows=20 width=88)
                      default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]
            <-Map 3 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_10]
                PartitionCols:_col0
                Select Operator [SEL_5] (rows=8 width=89)
                  Output:["_col0","_col1"]
                  Filter Operator [FIL_18] (rows=8 width=93)
                    predicate:(((c_int + 1) = 2) and ((c_int > 0) or (c_float >= 0)) and key is not null)
                    TableScan [TS_3] (rows=20 width=88)
                      default@cbo_t2,cbo_t2,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]
            <-Map 4 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_11]
                PartitionCols:_col0
                Select Operator [SEL_8] (rows=18 width=84)
                  Output:["_col0","_col1"]
                  Filter Operator [FIL_19] (rows=18 width=84)
                    predicate:key is not null
                    TableScan [TS_6] (rows=20 width=84)
                      default@cbo_t3,cbo_t3,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int"]

PREHOOK: query: explain select key, (c_int+1)+2 as x, sum(c_int) from cbo_t1 group by c_float, cbo_t1.c_int, key order by x limit 1
PREHOOK: type: QUERY
POSTHOOK: query: explain select key, (c_int+1)+2 as x, sum(c_int) from cbo_t1 group by c_float, cbo_t1.c_int, key order by x limit 1
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP)
Reducer 3 <- Reducer 2 (SORT)

Stage-0
  Fetch Operator
    limit:1
    Stage-1
      Reducer 3
      File Output Operator [FS_9]
        Limit [LIM_8] (rows=1 width=97)
          Number of rows:1
          Select Operator [SEL_7] (rows=10 width=97)
            Output:["_col0","_col1","_col2"]
          <-Reducer 2 [SORT]
            SORT [RS_6]
              Select Operator [SEL_5] (rows=10 width=97)
                Output:["_col0","_col1","_col2"]
                Group By Operator [GBY_4] (rows=10 width=101)
                  Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(VALUE._col0)"],keys:KEY._col0, KEY._col1, KEY._col2
                <-Map 1 [GROUP]
                  GROUP [RS_3]
                    PartitionCols:_col0, _col1, _col2
                    Group By Operator [GBY_2] (rows=10 width=101)
                      Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(c_int)"],keys:key, c_int, c_float
                      Select Operator [SEL_1] (rows=20 width=88)
                        Output:["key","c_int","c_float"]
                        TableScan [TS_0] (rows=20 width=88)
                          default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]

PREHOOK: query: explain select x, y, count(*) from (select key, (c_int+c_float+1+2) as x, sum(c_int) as y from cbo_t1 group by c_float, cbo_t1.c_int, key) R group by y, x order by x,y limit 1
PREHOOK: type: QUERY
POSTHOOK: query: explain select x, y, count(*) from (select key, (c_int+c_float+1+2) as x, sum(c_int) as y from cbo_t1 group by c_float, cbo_t1.c_int, key) R group by y, x order by x,y limit 1
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP)
Reducer 3 <- Reducer 2 (GROUP)
Reducer 4 <- Reducer 3 (SORT)

Stage-0
  Fetch Operator
    limit:1
    Stage-1
      Reducer 4
      File Output Operator [FS_14]
        Limit [LIM_13] (rows=1 width=20)
          Number of rows:1
          Select Operator [SEL_12] (rows=5 width=20)
            Output:["_col0","_col1","_col2"]
          <-Reducer 3 [SORT]
            SORT [RS_11]
              Group By Operator [GBY_9] (rows=5 width=20)
                Output:["_col0","_col1","_col2"],aggregations:["count(VALUE._col0)"],keys:KEY._col0, KEY._col1
              <-Reducer 2 [GROUP]
                GROUP [RS_8]
                  PartitionCols:_col0, _col1
                  Group By Operator [GBY_7] (rows=5 width=20)
                    Output:["_col0","_col1","_col2"],aggregations:["count()"],keys:_col1, _col0
                    Select Operator [SEL_5] (rows=10 width=101)
                      Output:["_col0","_col1"]
                      Group By Operator [GBY_4] (rows=10 width=101)
                        Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(VALUE._col0)"],keys:KEY._col0, KEY._col1, KEY._col2
                      <-Map 1 [GROUP]
                        GROUP [RS_3]
                          PartitionCols:_col0, _col1, _col2
                          Group By Operator [GBY_2] (rows=10 width=101)
                            Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(c_int)"],keys:key, c_int, c_float
                            Select Operator [SEL_1] (rows=20 width=88)
                              Output:["key","c_int","c_float"]
                              TableScan [TS_0] (rows=20 width=88)
                                default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]

PREHOOK: query: explain select key from(select key from (select key from cbo_t1 limit 5)cbo_t2  limit 5)cbo_t3  limit 5
PREHOOK: type: QUERY
POSTHOOK: query: explain select key from(select key from (select key from cbo_t1 limit 5)cbo_t2  limit 5)cbo_t3  limit 5
POSTHOOK: type: QUERY
Plan optimized by CBO.

Stage-0
  Fetch Operator
    limit:5
    Limit [LIM_2]
      Number of rows:5
      Select Operator [SEL_1]
        Output:["_col0"]
        TableScan [TS_0]
          Output:["key"]

PREHOOK: query: explain select key, c_int from(select key, c_int from (select key, c_int from cbo_t1 order by c_int limit 5)cbo_t1  order by c_int limit 5)cbo_t2  order by c_int limit 5
PREHOOK: type: QUERY
POSTHOOK: query: explain select key, c_int from(select key, c_int from (select key, c_int from cbo_t1 order by c_int limit 5)cbo_t1  order by c_int limit 5)cbo_t2  order by c_int limit 5
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (SORT)
Reducer 3 <- Reducer 2 (SORT)
Reducer 4 <- Reducer 3 (SORT)

Stage-0
  Fetch Operator
    limit:5
    Stage-1
      Reducer 4
      File Output Operator [FS_13]
        Limit [LIM_12] (rows=5 width=89)
          Number of rows:5
          Select Operator [SEL_11] (rows=5 width=89)
            Output:["_col0","_col1"]
          <-Reducer 3 [SORT]
            SORT [RS_10]
              Limit [LIM_8] (rows=5 width=89)
                Number of rows:5
                Select Operator [SEL_7] (rows=5 width=89)
                  Output:["_col0","_col1"]
                <-Reducer 2 [SORT]
                  SORT [RS_6]
                    Limit [LIM_4] (rows=5 width=89)
                      Number of rows:5
                      Select Operator [SEL_3] (rows=20 width=84)
                        Output:["_col0","_col1"]
                      <-Map 1 [SORT]
                        SORT [RS_2]
                          Select Operator [SEL_1] (rows=20 width=84)
                            Output:["_col0","_col1"]
                            TableScan [TS_0] (rows=20 width=84)
                              default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int"]

PREHOOK: query: explain select cbo_t3.c_int, c, count(*) from (select key as a, c_int+1 as b, sum(c_int) as c from cbo_t1 where (cbo_t1.c_int + 1 >= 0) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0) group by c_float, cbo_t1.c_int, key order by a limit 5) cbo_t1 join (select key as p, c_int+1 as q, sum(c_int) as r from cbo_t2 where (cbo_t2.c_int + 1 >= 0) and (cbo_t2.c_int > 0 or cbo_t2.c_float >= 0)  group by c_float, cbo_t2.c_int, key order by q/10 desc, r asc limit 5) cbo_t2 on cbo_t1.a=p join cbo_t3 on cbo_t1.a=key where (b + cbo_t2.q >= 0) and (b > 0 or c_int >= 0) group by cbo_t3.c_int, c order by cbo_t3.c_int+c desc, c limit 5
PREHOOK: type: QUERY
POSTHOOK: query: explain select cbo_t3.c_int, c, count(*) from (select key as a, c_int+1 as b, sum(c_int) as c from cbo_t1 where (cbo_t1.c_int + 1 >= 0) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0) group by c_float, cbo_t1.c_int, key order by a limit 5) cbo_t1 join (select key as p, c_int+1 as q, sum(c_int) as r from cbo_t2 where (cbo_t2.c_int + 1 >= 0) and (cbo_t2.c_int > 0 or cbo_t2.c_float >= 0)  group by c_float, cbo_t2.c_int, key order by q/10 desc, r asc limit 5) cbo_t2 on cbo_t1.a=p join cbo_t3 on cbo_t1.a=key where (b + cbo_t2.q >= 0) and (b > 0 or c_int >= 0) group by cbo_t3.c_int, c order by cbo_t3.c_int+c desc, c limit 5
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP)
Reducer 3 <- Reducer 2 (SORT)
Reducer 4 <- Map 10 (PARTITION-LEVEL SORT), Reducer 3 (PARTITION-LEVEL SORT), Reducer 9 (PARTITION-LEVEL SORT)
Reducer 5 <- Reducer 4 (GROUP)
Reducer 6 <- Reducer 5 (SORT)
Reducer 8 <- Map 7 (GROUP)
Reducer 9 <- Reducer 8 (SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 6
      File Output Operator [FS_44]
        Limit [LIM_42] (rows=1 width=28)
          Number of rows:5
          Select Operator [SEL_41] (rows=1 width=28)
            Output:["_col0","_col1","_col2"]
          <-Reducer 5 [SORT]
            SORT [RS_40]
              Select Operator [SEL_39] (rows=1 width=28)
                Output:["_col0","_col1","_col2","_col3"]
                Group By Operator [GBY_38] (rows=1 width=20)
                  Output:["_col0","_col1","_col2"],aggregations:["count(VALUE._col0)"],keys:KEY._col0, KEY._col1
                <-Reducer 4 [GROUP]
                  GROUP [RS_37]
                    PartitionCols:_col0, _col1
                    Group By Operator [GBY_36] (rows=1 width=20)
                      Output:["_col0","_col1","_col2"],aggregations:["count()"],keys:_col4, _col6
                      Select Operator [SEL_35] (rows=2 width=20)
                        Output:["_col4","_col6"]
                        Filter Operator [FIL_33] (rows=2 width=20)
                          predicate:(((_col3 + _col1) >= 0) and ((_col3 > 0) or (_col6 >= 0)))
                          Join Operator [JOIN_32] (rows=6 width=19)
                            Output:["_col1","_col3","_col4","_col6"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"},{"":"{\"type\":\"Inner\",\"left\":1,\"right\":2}"}],keys:{"0":"_col0","1":"_col0","2":"_col0"}
                          <-Map 10 [PARTITION-LEVEL SORT]
                            PARTITION-LEVEL SORT [RS_31]
                              PartitionCols:_col0
                              Select Operator [SEL_28] (rows=18 width=84)
                                Output:["_col0","_col1"]
                                Filter Operator [FIL_47] (rows=18 width=84)
                                  predicate:key is not null
                                  TableScan [TS_26] (rows=20 width=84)
                                    default@cbo_t3,cbo_t3,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int"]
                          <-Reducer 3 [PARTITION-LEVEL SORT]
                            PARTITION-LEVEL SORT [RS_29]
                              PartitionCols:_col0
                              Filter Operator [FIL_11] (rows=2 width=105)
                                predicate:_col0 is not null
                                Limit [LIM_9] (rows=3 width=105)
                                  Number of rows:5
                                  Select Operator [SEL_8] (rows=3 width=105)
                                    Output:["_col0","_col1"]
                                  <-Reducer 2 [SORT]
                                    SORT [RS_7]
                                      Select Operator [SEL_6] (rows=3 width=105)
                                        Output:["_col0","_col1","_col2","_col3"]
                                        Group By Operator [GBY_5] (rows=3 width=101)
                                          Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(VALUE._col0)"],keys:KEY._col0, KEY._col1, KEY._col2
                                        <-Map 1 [GROUP]
                                          GROUP [RS_4]
                                            PartitionCols:_col0, _col1, _col2
                                            Group By Operator [GBY_3] (rows=3 width=101)
                                              Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(c_int)"],keys:key, c_int, c_float
                                              Filter Operator [FIL_45] (rows=6 width=93)
                                                predicate:(((c_int + 1) >= 0) and ((c_int > 0) or (c_float >= 0)))
                                                TableScan [TS_0] (rows=20 width=88)
                                                  default@cbo_t2,cbo_t2,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]
                          <-Reducer 9 [PARTITION-LEVEL SORT]
                            PARTITION-LEVEL SORT [RS_30]
                              PartitionCols:_col0
                              Filter Operator [FIL_24] (rows=2 width=97)
                                predicate:_col0 is not null
                                Limit [LIM_22] (rows=3 width=97)
                                  Number of rows:5
                                  Select Operator [SEL_21] (rows=3 width=97)
                                    Output:["_col0","_col1","_col2"]
                                  <-Reducer 8 [SORT]
                                    SORT [RS_20]
                                      Select Operator [SEL_19] (rows=3 width=97)
                                        Output:["_col0","_col1","_col2"]
                                        Group By Operator [GBY_18] (rows=3 width=101)
                                          Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(VALUE._col0)"],keys:KEY._col0, KEY._col1, KEY._col2
                                        <-Map 7 [GROUP]
                                          GROUP [RS_17]
                                            PartitionCols:_col0, _col1, _col2
                                            Group By Operator [GBY_16] (rows=3 width=101)
                                              Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(c_int)"],keys:key, c_int, c_float
                                              Filter Operator [FIL_46] (rows=6 width=93)
                                                predicate:(((c_int + 1) >= 0) and ((c_int > 0) or (c_float >= 0)))
                                                TableScan [TS_13] (rows=20 width=88)
                                                  default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]

PREHOOK: query: explain select cbo_t1.c_int           from cbo_t1 left semi join   cbo_t2 on cbo_t1.key=cbo_t2.key where (cbo_t1.c_int + 1 == 2) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0)
PREHOOK: type: QUERY
POSTHOOK: query: explain select cbo_t1.c_int           from cbo_t1 left semi join   cbo_t2 on cbo_t1.key=cbo_t2.key where (cbo_t1.c_int + 1 == 2) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0)
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_12]
        Select Operator [SEL_11] (rows=8 width=4)
          Output:["_col0"]
          Join Operator [JOIN_10] (rows=8 width=4)
            Output:["_col1"],condition map:[{"":"{\"type\":\"Left Semi\",\"left\":0,\"right\":1}"}],keys:{"0":"_col0","1":"_col0"}
          <-Map 1 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_8]
              PartitionCols:_col0
              Select Operator [SEL_2] (rows=8 width=93)
                Output:["_col0","_col1"]
                Filter Operator [FIL_13] (rows=8 width=93)
                  predicate:(((c_int + 1) = 2) and ((c_int > 0) or (c_float >= 0)) and key is not null)
                  TableScan [TS_0] (rows=20 width=88)
                    default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]
          <-Map 3 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_9]
              PartitionCols:_col0
              Group By Operator [GBY_7] (rows=6 width=85)
                Output:["_col0"],keys:_col0
                Select Operator [SEL_5] (rows=18 width=80)
                  Output:["_col0"]
                  Filter Operator [FIL_14] (rows=18 width=80)
                    predicate:key is not null
                    TableScan [TS_3] (rows=20 width=80)
                      default@cbo_t2,cbo_t2,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]

PREHOOK: query: explain select * from (select c, b, a from (select key as a, c_int as b, cbo_t1.c_float as c from cbo_t1  where (cbo_t1.c_int + 1 == 2) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0)) cbo_t1 left semi join (select cbo_t2.key as p, cbo_t2.c_int as q, c_float as r from cbo_t2  where (cbo_t2.c_int + 1 == 2) and (cbo_t2.c_int > 0 or cbo_t2.c_float >= 0)) cbo_t2 on cbo_t1.a=p left semi join cbo_t3 on cbo_t1.a=key where (b + 1 == 2) and (b > 0 or c >= 0)) R where  (b + 1 = 2) and (R.b > 0 or c >= 0)
PREHOOK: type: QUERY
POSTHOOK: query: explain select * from (select c, b, a from (select key as a, c_int as b, cbo_t1.c_float as c from cbo_t1  where (cbo_t1.c_int + 1 == 2) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0)) cbo_t1 left semi join (select cbo_t2.key as p, cbo_t2.c_int as q, c_float as r from cbo_t2  where (cbo_t2.c_int + 1 == 2) and (cbo_t2.c_int > 0 or cbo_t2.c_float >= 0)) cbo_t2 on cbo_t1.a=p left semi join cbo_t3 on cbo_t1.a=key where (b + 1 == 2) and (b > 0 or c >= 0)) R where  (b + 1 = 2) and (R.b > 0 or c >= 0)
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT), Map 4 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_18]
        Select Operator [SEL_17] (rows=14 width=93)
          Output:["_col0","_col1","_col2"]
          Join Operator [JOIN_16] (rows=14 width=93)
            Output:["_col0","_col1","_col2"],condition map:[{"":"{\"type\":\"Left Semi\",\"left\":0,\"right\":1}"},{"":"{\"type\":\"Left Semi\",\"left\":0,\"right\":2}"}],keys:{"0":"_col0","1":"_col0","2":"_col0"}
          <-Map 1 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_13]
              PartitionCols:_col0
              Select Operator [SEL_2] (rows=8 width=93)
                Output:["_col0","_col1","_col2"]
                Filter Operator [FIL_19] (rows=8 width=93)
                  predicate:(((c_int + 1) = 2) and ((c_int > 0) or (c_float >= 0)) and key is not null)
                  TableScan [TS_0] (rows=20 width=88)
                    default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]
          <-Map 3 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_14]
              PartitionCols:_col0
              Group By Operator [GBY_10] (rows=3 width=85)
                Output:["_col0"],keys:_col0
                Select Operator [SEL_5] (rows=8 width=85)
                  Output:["_col0"]
                  Filter Operator [FIL_20] (rows=8 width=93)
                    predicate:(((c_int + 1) = 2) and ((c_int > 0) or (c_float >= 0)) and key is not null)
                    TableScan [TS_3] (rows=20 width=88)
                      default@cbo_t2,cbo_t2,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]
          <-Map 4 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_15]
              PartitionCols:_col0
              Group By Operator [GBY_12] (rows=7 width=85)
                Output:["_col0"],keys:_col0
                Select Operator [SEL_8] (rows=18 width=80)
                  Output:["_col0"]
                  Filter Operator [FIL_21] (rows=18 width=80)
                    predicate:key is not null
                    TableScan [TS_6] (rows=20 width=80)
                      default@cbo_t3,cbo_t3,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]

PREHOOK: query: explain select a, c, count(*) from (select key as a, c_int+1 as b, sum(c_int) as c from cbo_t1 where (cbo_t1.c_int + 1 >= 0) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0)  group by c_float, cbo_t1.c_int, key having cbo_t1.c_float > 0 and (c_int >=1 or c_float >= 1) and (c_int + c_float) >= 0 order by a+b desc, c asc) cbo_t1 left semi join (select key as p, c_int+1 as q, sum(c_int) as r from cbo_t2 where (cbo_t2.c_int + 1 >= 0) and (cbo_t2.c_int > 0 or cbo_t2.c_float >= 0)  group by c_float, cbo_t2.c_int, key having cbo_t2.c_float > 0 and (c_int >=1 or c_float >= 1) and (c_int + c_float) >= 0 order by q+r/10 desc, p) cbo_t2 on cbo_t1.a=p left semi join cbo_t3 on cbo_t1.a=key where (b + 1  >= 0) and (b > 0 or a >= 0) group by a, c  having a > 0 and (a >=1 or c >= 1) and (a + c) >= 0 order by c, a
PREHOOK: type: QUERY
POSTHOOK: query: explain select a, c, count(*) from (select key as a, c_int+1 as b, sum(c_int) as c from cbo_t1 where (cbo_t1.c_int + 1 >= 0) and (cbo_t1.c_int > 0 or cbo_t1.c_float >= 0)  group by c_float, cbo_t1.c_int, key having cbo_t1.c_float > 0 and (c_int >=1 or c_float >= 1) and (c_int + c_float) >= 0 order by a+b desc, c asc) cbo_t1 left semi join (select key as p, c_int+1 as q, sum(c_int) as r from cbo_t2 where (cbo_t2.c_int + 1 >= 0) and (cbo_t2.c_int > 0 or cbo_t2.c_float >= 0)  group by c_float, cbo_t2.c_int, key having cbo_t2.c_float > 0 and (c_int >=1 or c_float >= 1) and (c_int + c_float) >= 0 order by q+r/10 desc, p) cbo_t2 on cbo_t1.a=p left semi join cbo_t3 on cbo_t1.a=key where (b + 1  >= 0) and (b > 0 or a >= 0) group by a, c  having a > 0 and (a >=1 or c >= 1) and (a + c) >= 0 order by c, a
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP)
Reducer 3 <- Map 8 (PARTITION-LEVEL SORT), Reducer 2 (PARTITION-LEVEL SORT), Reducer 7 (PARTITION-LEVEL SORT)
Reducer 4 <- Reducer 3 (GROUP)
Reducer 5 <- Reducer 4 (SORT)
Reducer 7 <- Map 6 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 5
      File Output Operator [FS_34]
        Select Operator [SEL_33] (rows=1 width=101)
          Output:["_col0","_col1","_col2"]
        <-Reducer 4 [SORT]
          SORT [RS_32]
            Select Operator [SEL_31] (rows=1 width=101)
              Output:["_col0","_col1","_col2"]
              Group By Operator [GBY_30] (rows=1 width=101)
                Output:["_col0","_col1","_col2"],aggregations:["count(VALUE._col0)"],keys:KEY._col0, KEY._col1
              <-Reducer 3 [GROUP]
                GROUP [RS_29]
                  PartitionCols:_col0, _col1
                  Group By Operator [GBY_28] (rows=1 width=101)
                    Output:["_col0","_col1","_col2"],aggregations:["count()"],keys:_col1, _col0
                    Join Operator [JOIN_26] (rows=1 width=93)
                      Output:["_col0","_col1"],condition map:[{"":"{\"type\":\"Left Semi\",\"left\":0,\"right\":1}"},{"":"{\"type\":\"Left Semi\",\"left\":0,\"right\":2}"}],keys:{"0":"_col0","1":"_col0","2":"_col0"}
                    <-Map 8 [PARTITION-LEVEL SORT]
                      PARTITION-LEVEL SORT [RS_25]
                        PartitionCols:_col0
                        Group By Operator [GBY_22] (rows=3 width=85)
                          Output:["_col0"],keys:_col0
                          Select Operator [SEL_18] (rows=6 width=85)
                            Output:["_col0"]
                            Filter Operator [FIL_37] (rows=6 width=85)
                              predicate:(UDFToDouble(key) > 0.0D)
                              TableScan [TS_16] (rows=20 width=80)
                                default@cbo_t3,cbo_t3,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]
                    <-Reducer 2 [PARTITION-LEVEL SORT]
                      PARTITION-LEVEL SORT [RS_23]
                        PartitionCols:_col0
                        Select Operator [SEL_8] (rows=1 width=93)
                          Output:["_col0","_col1"]
                          Filter Operator [FIL_7] (rows=1 width=101)
                            predicate:(((UDFToDouble(_col2) + UDFToDouble(_col3)) >= 0.0D) and ((UDFToDouble(_col2) >= 1.0D) or (_col3 >= 1L)))
                            Select Operator [SEL_6] (rows=1 width=101)
                              Output:["_col2","_col3"]
                              Group By Operator [GBY_5] (rows=1 width=101)
                                Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(VALUE._col0)"],keys:KEY._col0, KEY._col1, KEY._col2
                              <-Map 1 [GROUP]
                                GROUP [RS_4]
                                  PartitionCols:_col0, _col1, _col2
                                  Group By Operator [GBY_3] (rows=1 width=101)
                                    Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(c_int)"],keys:key, c_int, c_float
                                    Filter Operator [FIL_35] (rows=1 width=93)
                                      predicate:((((c_int + 1) + 1) >= 0) and (((c_int + 1) > 0) or (UDFToDouble(key) >= 0.0D)) and ((UDFToFloat(c_int) + c_float) >= 0) and ((c_int + 1) >= 0) and ((c_int > 0) or (c_float >= 0)) and ((c_int >= 1) or (c_float >= 1)) and (UDFToDouble(key) > 0.0D) and (c_float > 0))
                                      TableScan [TS_0] (rows=20 width=88)
                                        default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]
                    <-Reducer 7 [PARTITION-LEVEL SORT]
                      PARTITION-LEVEL SORT [RS_24]
                        PartitionCols:_col0
                        Group By Operator [GBY_20] (rows=1 width=85)
                          Output:["_col0"],keys:_col0
                          Select Operator [SEL_15] (rows=1 width=85)
                            Output:["_col0"]
                            Group By Operator [GBY_14] (rows=1 width=93)
                              Output:["_col0","_col1","_col2"],keys:KEY._col0, KEY._col1, KEY._col2
                            <-Map 6 [GROUP]
                              GROUP [RS_13]
                                PartitionCols:_col0, _col1, _col2
                                Group By Operator [GBY_12] (rows=1 width=93)
                                  Output:["_col0","_col1","_col2"],keys:key, c_int, c_float
                                  Filter Operator [FIL_36] (rows=1 width=93)
                                    predicate:(((UDFToFloat(c_int) + c_float) >= 0) and ((c_int + 1) >= 0) and ((c_int > 0) or (c_float >= 0)) and ((c_int >= 1) or (c_float >= 1)) and (UDFToDouble(key) > 0.0D) and (c_float > 0))
                                    TableScan [TS_9] (rows=20 width=88)
                                      default@cbo_t2,cbo_t2,Tbl:COMPLETE,Col:COMPLETE,Output:["key","c_int","c_float"]

PREHOOK: query: explain select cbo_t1.key as x, c_int as c_int, (((c_int+c_float)*10)+5) as y from cbo_t1
PREHOOK: type: QUERY
POSTHOOK: query: explain select cbo_t1.key as x, c_int as c_int, (((c_int+c_float)*10)+5) as y from cbo_t1
POSTHOOK: type: QUERY
Plan optimized by CBO.

Stage-0
  Fetch Operator
    limit:-1
    Select Operator [SEL_1]
      Output:["_col0","_col1","_col2"]
      TableScan [TS_0]
        Output:["key","c_int","c_float"]

PREHOOK: query: explain select null from cbo_t1
PREHOOK: type: QUERY
POSTHOOK: query: explain select null from cbo_t1
POSTHOOK: type: QUERY
Plan optimized by CBO.

Stage-0
  Fetch Operator
    limit:-1
    Select Operator [SEL_1]
      Output:["_col0"]
      TableScan [TS_0]

PREHOOK: query: explain select key from cbo_t1 where c_int = -6  or c_int = +6
PREHOOK: type: QUERY
POSTHOOK: query: explain select key from cbo_t1 where c_int = -6  or c_int = +6
POSTHOOK: type: QUERY
Plan optimized by CBO.

Stage-0
  Fetch Operator
    limit:-1
    Select Operator [SEL_2]
      Output:["_col0"]
      Filter Operator [FIL_4]
        predicate:((c_int = -6) or (c_int = 6))
        TableScan [TS_0]
          Output:["key","c_int"]

PREHOOK: query: explain select count(cbo_t1.dt) from cbo_t1 join cbo_t2 on cbo_t1.dt  = cbo_t2.dt  where cbo_t1.dt = '2014'
PREHOOK: type: QUERY
POSTHOOK: query: explain select count(cbo_t1.dt) from cbo_t1 join cbo_t2 on cbo_t1.dt  = cbo_t2.dt  where cbo_t1.dt = '2014'
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 4 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_15]
        Group By Operator [GBY_13] (rows=1 width=8)
          Output:["_col0"],aggregations:["count(VALUE._col0)"]
        <-Reducer 2 [GROUP]
          GROUP [RS_12]
            Group By Operator [GBY_11] (rows=1 width=8)
              Output:["_col0"],aggregations:["count('2014')"]
              Join Operator [JOIN_8] (rows=400 width=8)
                condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"}],keys:{}
              <-Map 1 [PARTITION-LEVEL SORT]
                PARTITION-LEVEL SORT [RS_6]
                  Select Operator [SEL_2] (rows=20 width=88)
                    TableScan [TS_0] (rows=20 width=21)
                      default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE
              <-Map 4 [PARTITION-LEVEL SORT]
                PARTITION-LEVEL SORT [RS_7]
                  Select Operator [SEL_5] (rows=20 width=88)
                    TableScan [TS_3] (rows=20 width=21)
                      default@cbo_t2,cbo_t2,Tbl:COMPLETE,Col:COMPLETE

PREHOOK: query: explain select *
from src_cbo b
where not exists
  (select distinct a.key
  from src_cbo a
  where b.value = a.value and a.value > 'val_2'
  )
PREHOOK: type: QUERY
POSTHOOK: query: explain select *
from src_cbo b
where not exists
  (select distinct a.key
  from src_cbo a
  where b.value = a.value and a.value > 'val_2'
  )
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Reducer 4 (PARTITION-LEVEL SORT)
Reducer 4 <- Map 3 (GROUP PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_19]
        Select Operator [SEL_18] (rows=366 width=178)
          Output:["_col0","_col1"]
          Filter Operator [FIL_17] (rows=366 width=179)
            predicate:_col3 is null
            Join Operator [JOIN_16] (rows=500 width=179)
              Output:["_col0","_col1","_col3"],condition map:[{"":"{\"type\":\"Left Outer\",\"left\":0,\"right\":1}"}],keys:{"0":"_col1","1":"_col0"}
            <-Map 1 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_14]
                PartitionCols:_col1
                Select Operator [SEL_1] (rows=500 width=178)
                  Output:["_col0","_col1"]
                  TableScan [TS_0] (rows=500 width=178)
                    default@src_cbo,b,Tbl:COMPLETE,Col:COMPLETE,Output:["key","value"]
            <-Reducer 4 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_15]
                PartitionCols:_col0
                Select Operator [SEL_13] (rows=83 width=95)
                  Output:["_col0","_col1"]
                  Group By Operator [GBY_12] (rows=83 width=91)
                    Output:["_col0"],keys:_col1
                    Select Operator [SEL_8] (rows=83 width=178)
                      Output:["_col1"]
                      Group By Operator [GBY_7] (rows=83 width=178)
                        Output:["_col0","_col1"],keys:KEY._col0, KEY._col1
                      <-Map 3 [GROUP PARTITION-LEVEL SORT]
                        GROUP PARTITION-LEVEL SORT [RS_6]
                          PartitionCols:_col0
                          Group By Operator [GBY_5] (rows=83 width=178)
                            Output:["_col0","_col1"],keys:value, key
                            Filter Operator [FIL_20] (rows=166 width=178)
                              predicate:(value > 'val_2')
                              TableScan [TS_2] (rows=500 width=178)
                                default@src_cbo,a,Tbl:COMPLETE,Col:COMPLETE,Output:["key","value"]

PREHOOK: query: explain select *
from src_cbo b
group by key, value
having not exists
  (select a.key
  from src_cbo a
  where b.value = a.value  and a.key = b.key and a.value > 'val_12'
  )
PREHOOK: type: QUERY
POSTHOOK: query: explain select *
from src_cbo b
group by key, value
having not exists
  (select a.key
  from src_cbo a
  where b.value = a.value  and a.key = b.key and a.value > 'val_12'
  )
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT), Reducer 5 (PARTITION-LEVEL SORT)
Reducer 5 <- Map 4 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_18]
        Select Operator [SEL_17] (rows=183 width=178)
          Output:["_col0","_col1"]
          Filter Operator [FIL_16] (rows=183 width=179)
            predicate:_col4 is null
            Join Operator [JOIN_15] (rows=250 width=179)
              Output:["_col0","_col1","_col4"],condition map:[{"":"{\"type\":\"Left Outer\",\"left\":0,\"right\":1}"}],keys:{"0":"_col0, _col1","1":"_col0, _col1"}
            <-Reducer 2 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_13]
                PartitionCols:_col0, _col1
                Group By Operator [GBY_4] (rows=250 width=178)
                  Output:["_col0","_col1"],keys:KEY._col0, KEY._col1
                <-Map 1 [GROUP]
                  GROUP [RS_3]
                    PartitionCols:_col0, _col1
                    Group By Operator [GBY_2] (rows=250 width=178)
                      Output:["_col0","_col1"],keys:key, value
                      Select Operator [SEL_1] (rows=500 width=178)
                        Output:["key","value"]
                        TableScan [TS_0] (rows=500 width=178)
                          default@src_cbo,b,Tbl:COMPLETE,Col:COMPLETE,Output:["key","value"]
            <-Reducer 5 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_14]
                PartitionCols:_col0, _col1
                Select Operator [SEL_12] (rows=83 width=182)
                  Output:["_col0","_col1","_col2"]
                  Group By Operator [GBY_11] (rows=83 width=178)
                    Output:["_col0","_col1"],keys:KEY._col0, KEY._col1
                  <-Map 4 [GROUP]
                    GROUP [RS_10]
                      PartitionCols:_col0, _col1
                      Group By Operator [GBY_9] (rows=83 width=178)
                        Output:["_col0","_col1"],keys:key, value
                        Filter Operator [FIL_19] (rows=166 width=178)
                          predicate:((value > 'val_12') and key is not null)
                          TableScan [TS_6] (rows=500 width=178)
                            default@src_cbo,a,Tbl:COMPLETE,Col:COMPLETE,Output:["key","value"]

PREHOOK: query: create view cv1 as
select *
from src_cbo b
where exists
  (select a.key
  from src_cbo a
  where b.value = a.value  and a.key = b.key and a.value > 'val_9')
PREHOOK: type: CREATEVIEW
PREHOOK: Input: default@src_cbo
PREHOOK: Output: database:default
PREHOOK: Output: default@cv1
POSTHOOK: query: create view cv1 as
select *
from src_cbo b
where exists
  (select a.key
  from src_cbo a
  where b.value = a.value  and a.key = b.key and a.value > 'val_9')
POSTHOOK: type: CREATEVIEW
POSTHOOK: Input: default@src_cbo
POSTHOOK: Output: database:default
POSTHOOK: Output: default@cv1
POSTHOOK: Lineage: cv1.key SIMPLE [(src_cbo)b.FieldSchema(name:key, type:string, comment:null), ]
POSTHOOK: Lineage: cv1.value SIMPLE [(src_cbo)b.FieldSchema(name:value, type:string, comment:null), ]
PREHOOK: query: explain select * from cv1
PREHOOK: type: QUERY
POSTHOOK: query: explain select * from cv1
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_12]
        Join Operator [JOIN_10] (rows=133 width=178)
          Output:["_col0","_col1"],condition map:[{"":"{\"type\":\"Left Semi\",\"left\":0,\"right\":1}"}],keys:{"0":"_col0, _col1","1":"_col0, _col1"}
        <-Map 1 [PARTITION-LEVEL SORT]
          PARTITION-LEVEL SORT [RS_8]
            PartitionCols:_col0, _col1
            Select Operator [SEL_2] (rows=166 width=178)
              Output:["_col0","_col1"]
              Filter Operator [FIL_13] (rows=166 width=178)
                predicate:((value > 'val_9') and key is not null)
                TableScan [TS_0] (rows=500 width=178)
                  default@src_cbo,b,Tbl:COMPLETE,Col:COMPLETE,Output:["key","value"],properties:{"insideView":"TRUE"}
        <-Map 3 [PARTITION-LEVEL SORT]
          PARTITION-LEVEL SORT [RS_9]
            PartitionCols:_col0, _col1
            Group By Operator [GBY_7] (rows=83 width=178)
              Output:["_col0","_col1"],keys:_col0, _col1
              Select Operator [SEL_5] (rows=166 width=178)
                Output:["_col0","_col1"]
                Filter Operator [FIL_14] (rows=166 width=178)
                  predicate:((value > 'val_9') and key is not null)
                  TableScan [TS_3] (rows=500 width=178)
                    default@src_cbo,a,Tbl:COMPLETE,Col:COMPLETE,Output:["key","value"]

PREHOOK: query: explain select *
from (select *
      from src_cbo b
      where exists
          (select a.key
          from src_cbo a
          where b.value = a.value  and a.key = b.key and a.value > 'val_9')
     ) a
PREHOOK: type: QUERY
POSTHOOK: query: explain select *
from (select *
      from src_cbo b
      where exists
          (select a.key
          from src_cbo a
          where b.value = a.value  and a.key = b.key and a.value > 'val_9')
     ) a
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_12]
        Join Operator [JOIN_10] (rows=133 width=178)
          Output:["_col0","_col1"],condition map:[{"":"{\"type\":\"Left Semi\",\"left\":0,\"right\":1}"}],keys:{"0":"_col0, _col1","1":"_col0, _col1"}
        <-Map 1 [PARTITION-LEVEL SORT]
          PARTITION-LEVEL SORT [RS_8]
            PartitionCols:_col0, _col1
            Select Operator [SEL_2] (rows=166 width=178)
              Output:["_col0","_col1"]
              Filter Operator [FIL_13] (rows=166 width=178)
                predicate:((value > 'val_9') and key is not null)
                TableScan [TS_0] (rows=500 width=178)
                  default@src_cbo,b,Tbl:COMPLETE,Col:COMPLETE,Output:["key","value"]
        <-Map 3 [PARTITION-LEVEL SORT]
          PARTITION-LEVEL SORT [RS_9]
            PartitionCols:_col0, _col1
            Group By Operator [GBY_7] (rows=83 width=178)
              Output:["_col0","_col1"],keys:_col0, _col1
              Select Operator [SEL_5] (rows=166 width=178)
                Output:["_col0","_col1"]
                Filter Operator [FIL_14] (rows=166 width=178)
                  predicate:((value > 'val_9') and key is not null)
                  TableScan [TS_3] (rows=500 width=178)
                    default@src_cbo,a,Tbl:COMPLETE,Col:COMPLETE,Output:["key","value"]

PREHOOK: query: explain select *
from src_cbo
where src_cbo.key in (select key from src_cbo s1 where s1.key > '9')
PREHOOK: type: QUERY
POSTHOOK: query: explain select *
from src_cbo
where src_cbo.key in (select key from src_cbo s1 where s1.key > '9')
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_12]
        Join Operator [JOIN_10] (rows=133 width=178)
          Output:["_col0","_col1"],condition map:[{"":"{\"type\":\"Left Semi\",\"left\":0,\"right\":1}"}],keys:{"0":"_col0","1":"_col0"}
        <-Map 1 [PARTITION-LEVEL SORT]
          PARTITION-LEVEL SORT [RS_8]
            PartitionCols:_col0
            Select Operator [SEL_2] (rows=166 width=178)
              Output:["_col0","_col1"]
              Filter Operator [FIL_13] (rows=166 width=178)
                predicate:(key > '9')
                TableScan [TS_0] (rows=500 width=178)
                  default@src_cbo,src_cbo,Tbl:COMPLETE,Col:COMPLETE,Output:["key","value"]
        <-Map 3 [PARTITION-LEVEL SORT]
          PARTITION-LEVEL SORT [RS_9]
            PartitionCols:_col0
            Group By Operator [GBY_7] (rows=83 width=87)
              Output:["_col0"],keys:_col0
              Select Operator [SEL_5] (rows=166 width=87)
                Output:["_col0"]
                Filter Operator [FIL_14] (rows=166 width=87)
                  predicate:(key > '9')
                  TableScan [TS_3] (rows=500 width=87)
                    default@src_cbo,s1,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]

PREHOOK: query: explain select p.p_partkey, li.l_suppkey
from (select distinct l_partkey as p_partkey from lineitem) p join lineitem li on p.p_partkey = li.l_partkey
where li.l_linenumber = 1 and
 li.l_orderkey in (select l_orderkey from lineitem where l_shipmode = 'AIR' and l_linenumber = li.l_linenumber)
PREHOOK: type: QUERY
POSTHOOK: query: explain select p.p_partkey, li.l_suppkey
from (select distinct l_partkey as p_partkey from lineitem) p join lineitem li on p.p_partkey = li.l_partkey
where li.l_linenumber = 1 and
 li.l_orderkey in (select l_orderkey from lineitem where l_shipmode = 'AIR' and l_linenumber = li.l_linenumber)
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP)
Reducer 3 <- Map 5 (PARTITION-LEVEL SORT), Reducer 2 (PARTITION-LEVEL SORT)
Reducer 4 <- Map 6 (PARTITION-LEVEL SORT), Reducer 3 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 4
      File Output Operator [FS_22]
        Select Operator [SEL_21] (rows=3 width=8)
          Output:["_col0","_col1"]
          Join Operator [JOIN_20] (rows=3 width=8)
            Output:["_col0","_col3"],condition map:[{"":"{\"type\":\"Left Semi\",\"left\":0,\"right\":1}"}],keys:{"0":"_col1, _col4","1":"_col0, _col1"}
          <-Map 6 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_19]
              PartitionCols:_col0, _col1
              Group By Operator [GBY_17] (rows=1 width=8)
                Output:["_col0","_col1"],keys:_col0, _col1
                Select Operator [SEL_12] (rows=2 width=8)
                  Output:["_col0","_col1"]
                  Filter Operator [FIL_25] (rows=2 width=96)
                    predicate:((l_linenumber = 1) and (l_shipmode = 'AIR') and l_orderkey is not null)
                    TableScan [TS_10] (rows=100 width=96)
                      default@lineitem,lineitem,Tbl:COMPLETE,Col:COMPLETE,Output:["l_orderkey","l_linenumber","l_shipmode"]
          <-Reducer 3 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_18]
              PartitionCols:_col1, _col4
              Join Operator [JOIN_15] (rows=7 width=16)
                Output:["_col0","_col1","_col3","_col4"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"}],keys:{"0":"_col0","1":"_col1"}
              <-Map 5 [PARTITION-LEVEL SORT]
                PARTITION-LEVEL SORT [RS_14]
                  PartitionCols:_col1
                  Select Operator [SEL_9] (rows=14 width=16)
                    Output:["_col0","_col1","_col2","_col3"]
                    Filter Operator [FIL_24] (rows=14 width=16)
                      predicate:((l_linenumber = 1) and l_orderkey is not null and l_partkey is not null)
                      TableScan [TS_7] (rows=100 width=16)
                        default@lineitem,li,Tbl:COMPLETE,Col:COMPLETE,Output:["l_orderkey","l_partkey","l_suppkey","l_linenumber"]
              <-Reducer 2 [PARTITION-LEVEL SORT]
                PARTITION-LEVEL SORT [RS_13]
                  PartitionCols:_col0
                  Group By Operator [GBY_5] (rows=50 width=4)
                    Output:["_col0"],keys:KEY._col0
                  <-Map 1 [GROUP]
                    GROUP [RS_4]
                      PartitionCols:_col0
                      Group By Operator [GBY_3] (rows=50 width=4)
                        Output:["_col0"],keys:l_partkey
                        Filter Operator [FIL_23] (rows=100 width=4)
                          predicate:l_partkey is not null
                          TableScan [TS_0] (rows=100 width=4)
                            default@lineitem,lineitem,Tbl:COMPLETE,Col:COMPLETE,Output:["l_partkey"]

PREHOOK: query: explain select key, value, count(*)
from src_cbo b
where b.key in (select key from src_cbo where src_cbo.key > '8')
group by key, value
having count(*) in (select count(*) from src_cbo s1 where s1.key > '9' group by s1.key )
PREHOOK: type: QUERY
POSTHOOK: query: explain select key, value, count(*)
from src_cbo b
where b.key in (select key from src_cbo where src_cbo.key > '8')
group by key, value
having count(*) in (select count(*) from src_cbo s1 where s1.key > '9' group by s1.key )
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 5 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (GROUP)
Reducer 4 <- Reducer 3 (PARTITION-LEVEL SORT), Reducer 7 (PARTITION-LEVEL SORT)
Reducer 7 <- Map 6 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 4
      File Output Operator [FS_31]
        Join Operator [JOIN_29] (rows=32 width=186)
          Output:["_col0","_col1","_col2"],condition map:[{"":"{\"type\":\"Left Semi\",\"left\":0,\"right\":1}"}],keys:{"0":"_col2","1":"_col0"}
        <-Reducer 3 [PARTITION-LEVEL SORT]
          PARTITION-LEVEL SORT [RS_27]
            PartitionCols:_col2
            Filter Operator [FIL_15] (rows=66 width=186)
              predicate:_col2 is not null
              Group By Operator [GBY_14] (rows=66 width=186)
                Output:["_col0","_col1","_col2"],aggregations:["count(VALUE._col0)"],keys:KEY._col0, KEY._col1
              <-Reducer 2 [GROUP]
                GROUP [RS_13]
                  PartitionCols:_col0, _col1
                  Group By Operator [GBY_12] (rows=66 width=186)
                    Output:["_col0","_col1","_col2"],aggregations:["count()"],keys:_col0, _col1
                    Join Operator [JOIN_10] (rows=133 width=178)
                      Output:["_col0","_col1"],condition map:[{"":"{\"type\":\"Left Semi\",\"left\":0,\"right\":1}"}],keys:{"0":"_col0","1":"_col0"}
                    <-Map 1 [PARTITION-LEVEL SORT]
                      PARTITION-LEVEL SORT [RS_8]
                        PartitionCols:_col0
                        Select Operator [SEL_2] (rows=166 width=178)
                          Output:["_col0","_col1"]
                          Filter Operator [FIL_32] (rows=166 width=178)
                            predicate:(key > '8')
                            TableScan [TS_0] (rows=500 width=178)
                              default@src_cbo,b,Tbl:COMPLETE,Col:COMPLETE,Output:["key","value"]
                    <-Map 5 [PARTITION-LEVEL SORT]
                      PARTITION-LEVEL SORT [RS_9]
                        PartitionCols:_col0
                        Group By Operator [GBY_7] (rows=83 width=87)
                          Output:["_col0"],keys:_col0
                          Select Operator [SEL_5] (rows=166 width=87)
                            Output:["_col0"]
                            Filter Operator [FIL_33] (rows=166 width=87)
                              predicate:(key > '8')
                              TableScan [TS_3] (rows=500 width=87)
                                default@src_cbo,src_cbo,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]
        <-Reducer 7 [PARTITION-LEVEL SORT]
          PARTITION-LEVEL SORT [RS_28]
            PartitionCols:_col0
            Group By Operator [GBY_26] (rows=41 width=8)
              Output:["_col0"],keys:_col0
              Select Operator [SEL_24] (rows=83 width=8)
                Output:["_col0"]
                Filter Operator [FIL_23] (rows=83 width=8)
                  predicate:_col1 is not null
                  Select Operator [SEL_35] (rows=83 width=8)
                    Output:["_col1"]
                    Group By Operator [GBY_22] (rows=83 width=95)
                      Output:["_col0","_col1"],aggregations:["count(VALUE._col0)"],keys:KEY._col0
                    <-Map 6 [GROUP]
                      GROUP [RS_21]
                        PartitionCols:_col0
                        Group By Operator [GBY_20] (rows=83 width=95)
                          Output:["_col0","_col1"],aggregations:["count()"],keys:key
                          Filter Operator [FIL_34] (rows=166 width=87)
                            predicate:(key > '9')
                            TableScan [TS_17] (rows=500 width=87)
                              default@src_cbo,s1,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]

PREHOOK: query: explain select p_mfgr, p_name, avg(p_size)
from part
group by p_mfgr, p_name
having p_name in
  (select first_value(p_name) over(partition by p_mfgr order by p_size) from part)
PREHOOK: type: QUERY
POSTHOOK: query: explain select p_mfgr, p_name, avg(p_size)
from part
group by p_mfgr, p_name
having p_name in
  (select first_value(p_name) over(partition by p_mfgr order by p_size) from part)
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT), Reducer 5 (PARTITION-LEVEL SORT)
Reducer 5 <- Map 4 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_21]
        Join Operator [JOIN_19] (rows=6 width=227)
          Output:["_col0","_col1","_col2"],condition map:[{"":"{\"type\":\"Left Semi\",\"left\":0,\"right\":1}"}],keys:{"0":"_col1","1":"_col0"}
        <-Reducer 2 [PARTITION-LEVEL SORT]
          PARTITION-LEVEL SORT [RS_17]
            PartitionCols:_col1
            Select Operator [SEL_6] (rows=13 width=227)
              Output:["_col0","_col1","_col2"]
              Group By Operator [GBY_5] (rows=13 width=235)
                Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(VALUE._col0)","count(VALUE._col1)"],keys:KEY._col0, KEY._col1
              <-Map 1 [GROUP]
                GROUP [RS_4]
                  PartitionCols:_col0, _col1
                  Group By Operator [GBY_3] (rows=13 width=235)
                    Output:["_col0","_col1","_col2","_col3"],aggregations:["sum(p_size)","count(p_size)"],keys:p_name, p_mfgr
                    Filter Operator [FIL_22] (rows=26 width=223)
                      predicate:p_name is not null
                      TableScan [TS_0] (rows=26 width=223)
                        default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_name","p_mfgr","p_size"]
        <-Reducer 5 [PARTITION-LEVEL SORT]
          PARTITION-LEVEL SORT [RS_18]
            PartitionCols:_col0
            Group By Operator [GBY_16] (rows=13 width=184)
              Output:["_col0"],keys:_col0
              Select Operator [SEL_11] (rows=26 width=184)
                Output:["_col0"]
                Filter Operator [FIL_23] (rows=26 width=491)
                  predicate:first_value_window_0 is not null
                  PTF Operator [PTF_10] (rows=26 width=491)
                    Function definitions:[{},{"name:":"windowingtablefunction","order by:":"_col5 ASC NULLS FIRST","partition by:":"_col2"}]
                    Select Operator [SEL_9] (rows=26 width=491)
                      Output:["_col1","_col2","_col5"]
                    <-Map 4 [PARTITION-LEVEL SORT]
                      PARTITION-LEVEL SORT [RS_8]
                        PartitionCols:p_mfgr
                        TableScan [TS_7] (rows=26 width=223)
                          default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_mfgr","p_name","p_size"]

PREHOOK: query: explain select *
from src_cbo
where src_cbo.key not in
  ( select key  from src_cbo s1
    where s1.key > '2'
  ) order by key
PREHOOK: type: QUERY
POSTHOOK: query: explain select *
from src_cbo
where src_cbo.key not in
  ( select key  from src_cbo s1
    where s1.key > '2'
  ) order by key
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Reducer 6 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT), Reducer 8 (PARTITION-LEVEL SORT)
Reducer 4 <- Reducer 3 (SORT)
Reducer 6 <- Map 5 (GROUP)
Reducer 8 <- Map 7 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 4
      File Output Operator [FS_26]
        Select Operator [SEL_25] (rows=500 width=178)
          Output:["_col0","_col1"]
        <-Reducer 3 [SORT]
          SORT [RS_24]
            Select Operator [SEL_23] (rows=500 width=178)
              Output:["_col0","_col1"]
              Filter Operator [FIL_22] (rows=500 width=195)
                predicate:((_col2 = 0L) or (_col5 is null and _col0 is not null and (_col3 >= _col2)))
                Join Operator [JOIN_21] (rows=500 width=195)
                  Output:["_col0","_col1","_col2","_col3","_col5"],condition map:[{"":"{\"type\":\"Left Outer\",\"left\":0,\"right\":1}"}],keys:{"0":"_col0","1":"_col0"}
                <-Reducer 2 [PARTITION-LEVEL SORT]
                  PARTITION-LEVEL SORT [RS_19]
                    PartitionCols:_col0
                    Join Operator [JOIN_18] (rows=500 width=194)
                      Output:["_col0","_col1","_col2","_col3"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"}],keys:{}
                    <-Map 1 [PARTITION-LEVEL SORT]
                      PARTITION-LEVEL SORT [RS_16]
                        Select Operator [SEL_1] (rows=500 width=178)
                          Output:["_col0","_col1"]
                          TableScan [TS_0] (rows=500 width=178)
                            default@src_cbo,src_cbo,Tbl:COMPLETE,Col:COMPLETE,Output:["key","value"]
                    <-Reducer 6 [PARTITION-LEVEL SORT]
                      PARTITION-LEVEL SORT [RS_17]
                        Group By Operator [GBY_7] (rows=1 width=16)
                          Output:["_col0","_col1"],aggregations:["count(VALUE._col0)","count(VALUE._col1)"]
                        <-Map 5 [GROUP]
                          GROUP [RS_6]
                            Group By Operator [GBY_5] (rows=1 width=16)
                              Output:["_col0","_col1"],aggregations:["count()","count(key)"]
                              Filter Operator [FIL_27] (rows=166 width=87)
                                predicate:(key > '2')
                                TableScan [TS_2] (rows=500 width=87)
                                  default@src_cbo,s1,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]
                <-Reducer 8 [PARTITION-LEVEL SORT]
                  PARTITION-LEVEL SORT [RS_20]
                    PartitionCols:_col0
                    Select Operator [SEL_15] (rows=83 width=91)
                      Output:["_col0","_col1"]
                      Group By Operator [GBY_14] (rows=83 width=87)
                        Output:["_col0"],keys:KEY._col0
                      <-Map 7 [GROUP]
                        GROUP [RS_13]
                          PartitionCols:_col0
                          Group By Operator [GBY_12] (rows=83 width=87)
                            Output:["_col0"],keys:key
                            Filter Operator [FIL_28] (rows=166 width=87)
                              predicate:(key > '2')
                              TableScan [TS_9] (rows=500 width=87)
                                default@src_cbo,s1,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]

PREHOOK: query: explain select p_mfgr, b.p_name, p_size
from part b
where b.p_name not in
  (select p_name
  from (select p_mfgr, p_name, p_size as r from part) a
  where r < 10 and b.p_mfgr = a.p_mfgr
  )
PREHOOK: type: QUERY
POSTHOOK: query: explain select p_mfgr, b.p_name, p_size
from part b
where b.p_name not in
  (select p_name
  from (select p_mfgr, p_name, p_size as r from part) a
  where r < 10 and b.p_mfgr = a.p_mfgr
  )
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Reducer 5 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT), Reducer 7 (PARTITION-LEVEL SORT)
Reducer 5 <- Map 4 (GROUP)
Reducer 7 <- Map 6 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_26]
        Select Operator [SEL_25] (rows=13 width=223)
          Output:["_col0","_col1","_col2"]
          Filter Operator [FIL_24] (rows=13 width=231)
            predicate:(not CASE WHEN ((_col4 = 0L)) THEN (false) WHEN (_col4 is null) THEN (false) WHEN (_col8 is not null) THEN (true) WHEN (_col0 is null) THEN (null) WHEN ((_col5 < _col4)) THEN (true) ELSE (false) END)
            Join Operator [JOIN_23] (rows=26 width=230)
              Output:["_col0","_col1","_col2","_col4","_col5","_col8"],condition map:[{"":"{\"type\":\"Left Outer\",\"left\":0,\"right\":1}"}],keys:{"0":"_col0, _col1","1":"_col0, _col1"}
            <-Reducer 2 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_21]
                PartitionCols:_col0, _col1
                Join Operator [JOIN_20] (rows=26 width=229)
                  Output:["_col0","_col1","_col2","_col4","_col5"],condition map:[{"":"{\"type\":\"Left Outer\",\"left\":0,\"right\":1}"}],keys:{"0":"_col1","1":"_col0"}
                <-Map 1 [PARTITION-LEVEL SORT]
                  PARTITION-LEVEL SORT [RS_18]
                    PartitionCols:_col1
                    Select Operator [SEL_1] (rows=26 width=223)
                      Output:["_col0","_col1","_col2"]
                      TableScan [TS_0] (rows=26 width=223)
                        default@part,b,Tbl:COMPLETE,Col:COMPLETE,Output:["p_name","p_mfgr","p_size"]
                <-Reducer 5 [PARTITION-LEVEL SORT]
                  PARTITION-LEVEL SORT [RS_19]
                    PartitionCols:_col0
                    Group By Operator [GBY_7] (rows=2 width=114)
                      Output:["_col0","_col1","_col2"],aggregations:["count(VALUE._col0)","count(VALUE._col1)"],keys:KEY._col0
                    <-Map 4 [GROUP]
                      GROUP [RS_6]
                        PartitionCols:_col0
                        Group By Operator [GBY_5] (rows=2 width=114)
                          Output:["_col0","_col1","_col2"],aggregations:["count()","count(p_name)"],keys:p_mfgr
                          Select Operator [SEL_4] (rows=8 width=223)
                            Output:["p_name","p_mfgr"]
                            Filter Operator [FIL_27] (rows=8 width=223)
                              predicate:((p_size < 10) and p_mfgr is not null)
                              TableScan [TS_2] (rows=26 width=223)
                                default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_name","p_mfgr","p_size"]
            <-Reducer 7 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_22]
                PartitionCols:_col0, _col1
                Select Operator [SEL_17] (rows=4 width=223)
                  Output:["_col0","_col1","_col2"]
                  Filter Operator [FIL_16] (rows=4 width=219)
                    predicate:_col0 is not null
                    Group By Operator [GBY_14] (rows=4 width=219)
                      Output:["_col0","_col1"],keys:KEY._col0, KEY._col1
                    <-Map 6 [GROUP]
                      GROUP [RS_13]
                        PartitionCols:_col0, _col1
                        Group By Operator [GBY_12] (rows=4 width=219)
                          Output:["_col0","_col1"],keys:p_name, p_mfgr
                          Select Operator [SEL_11] (rows=8 width=223)
                            Output:["p_name","p_mfgr"]
                            Filter Operator [FIL_28] (rows=8 width=223)
                              predicate:((p_size < 10) and p_mfgr is not null)
                              TableScan [TS_9] (rows=26 width=223)
                                default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_name","p_mfgr","p_size"]

PREHOOK: query: explain select p_name, p_size
from
part where part.p_size not in
  (select avg(p_size)
  from (select p_size from part) a
  where p_size < 10
  ) order by p_name
PREHOOK: type: QUERY
POSTHOOK: query: explain select p_name, p_size
from
part where part.p_size not in
  (select avg(p_size)
  from (select p_size from part) a
  where p_size < 10
  ) order by p_name
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Reducer 6 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT), Reducer 8 (PARTITION-LEVEL SORT)
Reducer 4 <- Reducer 3 (SORT)
Reducer 6 <- Map 5 (GROUP)
Reducer 8 <- Map 5 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 4
      File Output Operator [FS_31]
        Select Operator [SEL_30] (rows=26 width=125)
          Output:["_col0","_col1"]
        <-Reducer 3 [SORT]
          SORT [RS_29]
            Select Operator [SEL_28] (rows=26 width=125)
              Output:["_col0","_col1"]
              Filter Operator [FIL_27] (rows=26 width=141)
                predicate:((_col2 = 0L) or (_col5 is null and _col1 is not null and (_col3 >= _col2)))
                Join Operator [JOIN_26] (rows=26 width=141)
                  Output:["_col0","_col1","_col2","_col3","_col5"],condition map:[{"":"{\"type\":\"Left Outer\",\"left\":0,\"right\":1}"}],keys:{"0":"UDFToDouble(_col1)","1":"_col0"}
                <-Reducer 2 [PARTITION-LEVEL SORT]
                  PARTITION-LEVEL SORT [RS_24]
                    PartitionCols:UDFToDouble(_col1)
                    Join Operator [JOIN_23] (rows=26 width=141)
                      Output:["_col0","_col1","_col2","_col3"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"}],keys:{}
                    <-Map 1 [PARTITION-LEVEL SORT]
                      PARTITION-LEVEL SORT [RS_21]
                        Select Operator [SEL_1] (rows=26 width=125)
                          Output:["_col0","_col1"]
                          TableScan [TS_0] (rows=26 width=125)
                            default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_name","p_size"]
                    <-Reducer 6 [PARTITION-LEVEL SORT]
                      PARTITION-LEVEL SORT [RS_22]
                        Group By Operator [GBY_12] (rows=1 width=16)
                          Output:["_col0","_col1"],aggregations:["count()","count(_col0)"]
                          Select Operator [SEL_8] (rows=1 width=16)
                            Output:["_col0"]
                            Group By Operator [GBY_7] (rows=1 width=16)
                              Output:["_col0","_col1"],aggregations:["sum(VALUE._col0)","count(VALUE._col1)"]
                            <-Map 5 [GROUP]
                              GROUP [RS_6]
                                Group By Operator [GBY_5] (rows=1 width=16)
                                  Output:["_col0","_col1"],aggregations:["sum(p_size)","count(p_size)"]
                                  Filter Operator [FIL_32] (rows=8 width=4)
                                    predicate:(p_size < 10)
                                    TableScan [TS_2] (rows=26 width=4)
                                      default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_size"]
                <-Reducer 8 [PARTITION-LEVEL SORT]
                  PARTITION-LEVEL SORT [RS_25]
                    PartitionCols:_col0
                    Select Operator [SEL_20] (rows=1 width=12)
                      Output:["_col0","_col1"]
                      Group By Operator [GBY_19] (rows=1 width=16)
                        Output:["_col0","_col1"],aggregations:["sum(VALUE._col0)","count(VALUE._col1)"]
                      <- Please refer to the previous Map 5 [GROUP]

PREHOOK: query: explain select b.p_mfgr, min(p_retailprice)
from part b
group by b.p_mfgr
having b.p_mfgr not in
  (select p_mfgr
  from (select p_mfgr, min(p_retailprice) l, max(p_retailprice) r, avg(p_retailprice) a from part group by p_mfgr) a
  where min(p_retailprice) = l and r - l > 600
  )
  order by b.p_mfgr
PREHOOK: type: QUERY
POSTHOOK: query: explain select b.p_mfgr, min(p_retailprice)
from part b
group by b.p_mfgr
having b.p_mfgr not in
  (select p_mfgr
  from (select p_mfgr, min(p_retailprice) l, max(p_retailprice) r, avg(p_retailprice) a from part group by p_mfgr) a
  where min(p_retailprice) = l and r - l > 600
  )
  order by b.p_mfgr
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 10 <- Map 6 (GROUP)
Reducer 2 <- Map 1 (GROUP)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT), Reducer 8 (PARTITION-LEVEL SORT)
Reducer 4 <- Reducer 10 (PARTITION-LEVEL SORT), Reducer 3 (PARTITION-LEVEL SORT)
Reducer 5 <- Reducer 4 (SORT)
Reducer 7 <- Map 6 (GROUP)
Reducer 8 <- Reducer 7 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 5
      File Output Operator [FS_37]
        Select Operator [SEL_36] (rows=3 width=106)
          Output:["_col0","_col1"]
        <-Reducer 4 [SORT]
          SORT [RS_35]
            Select Operator [SEL_34] (rows=3 width=106)
              Output:["_col0","_col1"]
              Filter Operator [FIL_33] (rows=3 width=119)
                predicate:(not CASE WHEN ((_col3 = 0L)) THEN (false) WHEN (_col3 is null) THEN (false) WHEN (_col7 is not null) THEN (true) WHEN (_col0 is null) THEN (null) WHEN ((_col4 < _col3)) THEN (true) ELSE (false) END)
                Join Operator [JOIN_32] (rows=5 width=114)
                  Output:["_col0","_col1","_col3","_col4","_col7"],condition map:[{"":"{\"type\":\"Left Outer\",\"left\":0,\"right\":1}"}],keys:{"0":"_col0, _col1","1":"_col0, _col1"}
                <-Reducer 10 [PARTITION-LEVEL SORT]
                  PARTITION-LEVEL SORT [RS_31]
                    PartitionCols:_col0, _col1
                    Select Operator [SEL_26] (rows=1 width=110)
                      Output:["_col0","_col1","_col2"]
                      Filter Operator [FIL_25] (rows=1 width=110)
                        predicate:_col0 is not null
                        Select Operator [SEL_24] (rows=1 width=110)
                          Output:["_col0","_col1"]
                          Filter Operator [FIL_23] (rows=1 width=114)
                            predicate:(((_col2 - _col1) > 600.0D) and _col1 is not null)
                            Group By Operator [GBY_22] (rows=5 width=114)
                              Output:["_col0","_col1","_col2"],aggregations:["min(VALUE._col0)","max(VALUE._col1)"],keys:KEY._col0
                            <-Map 6 [GROUP]
                              GROUP [RS_9]
                                PartitionCols:_col0
                                Group By Operator [GBY_8] (rows=5 width=114)
                                  Output:["_col0","_col1","_col2"],aggregations:["min(p_retailprice)","max(p_retailprice)"],keys:p_mfgr
                                  Select Operator [SEL_7] (rows=26 width=106)
                                    Output:["p_mfgr","p_retailprice"]
                                    TableScan [TS_6] (rows=26 width=106)
                                      default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_mfgr","p_retailprice"]
                <-Reducer 3 [PARTITION-LEVEL SORT]
                  PARTITION-LEVEL SORT [RS_30]
                    PartitionCols:_col0, _col1
                    Join Operator [JOIN_29] (rows=5 width=112)
                      Output:["_col0","_col1","_col3","_col4"],condition map:[{"":"{\"type\":\"Left Outer\",\"left\":0,\"right\":1}"}],keys:{"0":"_col1","1":"_col0"}
                    <-Reducer 2 [PARTITION-LEVEL SORT]
                      PARTITION-LEVEL SORT [RS_27]
                        PartitionCols:_col1
                        Group By Operator [GBY_4] (rows=5 width=106)
                          Output:["_col0","_col1"],aggregations:["min(VALUE._col0)"],keys:KEY._col0
                        <-Map 1 [GROUP]
                          GROUP [RS_3]
                            PartitionCols:_col0
                            Group By Operator [GBY_2] (rows=5 width=106)
                              Output:["_col0","_col1"],aggregations:["min(p_retailprice)"],keys:p_mfgr
                              Select Operator [SEL_1] (rows=26 width=106)
                                Output:["p_mfgr","p_retailprice"]
                                TableScan [TS_0] (rows=26 width=106)
                                  default@part,b,Tbl:COMPLETE,Col:COMPLETE,Output:["p_mfgr","p_retailprice"]
                    <-Reducer 8 [PARTITION-LEVEL SORT]
                      PARTITION-LEVEL SORT [RS_28]
                        PartitionCols:_col0
                        Group By Operator [GBY_16] (rows=1 width=24)
                          Output:["_col0","_col1","_col2"],aggregations:["count(VALUE._col0)","count(VALUE._col1)"],keys:KEY._col0
                        <-Reducer 7 [GROUP]
                          GROUP [RS_15]
                            PartitionCols:_col0
                            Group By Operator [GBY_14] (rows=1 width=24)
                              Output:["_col0","_col1","_col2"],aggregations:["count()","count(_col0)"],keys:_col1
                              Select Operator [SEL_12] (rows=1 width=114)
                                Output:["_col0","_col1"]
                                Filter Operator [FIL_11] (rows=1 width=114)
                                  predicate:(((_col2 - _col1) > 600.0D) and _col1 is not null)
                                  Group By Operator [GBY_10] (rows=5 width=114)
                                    Output:["_col0","_col1","_col2"],aggregations:["min(VALUE._col0)","max(VALUE._col1)"],keys:KEY._col0
                                  <- Please refer to the previous Map 6 [GROUP]

PREHOOK: query: explain select count(c_int) over(), sum(c_float) over(), max(c_int) over(), min(c_int) over(), row_number() over(), rank() over(), dense_rank() over(), percent_rank() over(), lead(c_int, 2, c_int) over(), lag(c_float, 2, c_float) over() from cbo_t1
PREHOOK: type: QUERY
POSTHOOK: query: explain select count(c_int) over(), sum(c_float) over(), max(c_int) over(), min(c_int) over(), row_number() over(), rank() over(), dense_rank() over(), percent_rank() over(), lead(c_int, 2, c_int) over(), lag(c_float, 2, c_float) over() from cbo_t1
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_6]
        Select Operator [SEL_4] (rows=20 width=52)
          Output:["_col0","_col1","_col2","_col3","_col4","_col5","_col6","_col7","_col8","_col9"]
          PTF Operator [PTF_3] (rows=20 width=459)
            Function definitions:[{},{"name:":"windowingtablefunction","order by:":"0 ASC NULLS FIRST","partition by:":"0"}]
            Select Operator [SEL_2] (rows=20 width=459)
              Output:["_col2","_col3"]
            <-Map 1 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_1]
                PartitionCols:0
                TableScan [TS_0] (rows=20 width=7)
                  default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["c_float","c_int"]

PREHOOK: query: explain select * from (select count(c_int) over(), sum(c_float) over(), max(c_int) over(), min(c_int) over(), row_number() over(), rank() over(), dense_rank() over(), percent_rank() over(), lead(c_int, 2, c_int) over(), lag(c_float, 2, c_float) over() from cbo_t1) cbo_t1
PREHOOK: type: QUERY
POSTHOOK: query: explain select * from (select count(c_int) over(), sum(c_float) over(), max(c_int) over(), min(c_int) over(), row_number() over(), rank() over(), dense_rank() over(), percent_rank() over(), lead(c_int, 2, c_int) over(), lag(c_float, 2, c_float) over() from cbo_t1) cbo_t1
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_6]
        Select Operator [SEL_4] (rows=20 width=52)
          Output:["_col0","_col1","_col2","_col3","_col4","_col5","_col6","_col7","_col8","_col9"]
          PTF Operator [PTF_3] (rows=20 width=459)
            Function definitions:[{},{"name:":"windowingtablefunction","order by:":"0 ASC NULLS FIRST","partition by:":"0"}]
            Select Operator [SEL_2] (rows=20 width=459)
              Output:["_col2","_col3"]
            <-Map 1 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_1]
                PartitionCols:0
                TableScan [TS_0] (rows=20 width=7)
                  default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["c_float","c_int"]

PREHOOK: query: explain select i, a, h, b, c, d, e, f, g, a as x, a +1 as y from (select max(c_int) over (partition by key order by value range UNBOUNDED PRECEDING) a, min(c_int) over (partition by key order by value range current row) b, count(c_int) over(partition by key order by value range 1 PRECEDING) c, avg(value) over (partition by key order by value range between unbounded preceding and unbounded following) d, sum(value) over (partition by key order by value range between unbounded preceding and current row) e, avg(c_float) over (partition by key order by value range between 1 preceding and unbounded following) f, sum(c_float) over (partition by key order by value range between 1 preceding and current row) g, max(c_float) over (partition by key order by value range between 1 preceding and unbounded following) h, min(c_float) over (partition by key order by value range between 1 preceding and 1 following) i from cbo_t1) cbo_t1
PREHOOK: type: QUERY
POSTHOOK: query: explain select i, a, h, b, c, d, e, f, g, a as x, a +1 as y from (select max(c_int) over (partition by key order by value range UNBOUNDED PRECEDING) a, min(c_int) over (partition by key order by value range current row) b, count(c_int) over(partition by key order by value range 1 PRECEDING) c, avg(value) over (partition by key order by value range between unbounded preceding and unbounded following) d, sum(value) over (partition by key order by value range between unbounded preceding and current row) e, avg(c_float) over (partition by key order by value range between 1 preceding and unbounded following) f, sum(c_float) over (partition by key order by value range between 1 preceding and current row) g, max(c_float) over (partition by key order by value range between 1 preceding and unbounded following) h, min(c_float) over (partition by key order by value range between 1 preceding and 1 following) i from cbo_t1) cbo_t1
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_6]
        Select Operator [SEL_4] (rows=20 width=64)
          Output:["_col0","_col1","_col2","_col3","_col4","_col5","_col6","_col7","_col8","_col9","_col10"]
          PTF Operator [PTF_3] (rows=20 width=621)
            Function definitions:[{},{"name:":"windowingtablefunction","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col0"}]
            Select Operator [SEL_2] (rows=20 width=621)
              Output:["_col0","_col1","_col2","_col3"]
            <-Map 1 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_1]
                PartitionCols:key
                TableScan [TS_0] (rows=20 width=169)
                  default@cbo_t1,cbo_t1,Tbl:COMPLETE,Col:COMPLETE,Output:["c_float","c_int","key","value"]

PREHOOK: query: explain select *, rank() over(partition by key order by value) as rr from src1
PREHOOK: type: QUERY
POSTHOOK: query: explain select *, rank() over(partition by key order by value) as rr from src1
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_6]
        Select Operator [SEL_4] (rows=25 width=179)
          Output:["_col0","_col1","_col2"]
          PTF Operator [PTF_3] (rows=25 width=443)
            Function definitions:[{},{"name:":"windowingtablefunction","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col0"}]
            Select Operator [SEL_2] (rows=25 width=443)
              Output:["_col0","_col1"]
            <-Map 1 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_1]
                PartitionCols:key
                TableScan [TS_0] (rows=25 width=175)
                  default@src1,src1,Tbl:COMPLETE,Col:COMPLETE,Output:["key","value"]

PREHOOK: query: explain
select SUM(HASH(tmp.key)), SUM(HASH(tmp.cnt))
FROM (select x.key AS key, count(1) AS cnt
      FROM src1 x JOIN src y ON (x.key = y.key)
      GROUP BY x.key) tmp
PREHOOK: type: QUERY
POSTHOOK: query: explain
select SUM(HASH(tmp.key)), SUM(HASH(tmp.cnt))
FROM (select x.key AS key, count(1) AS cnt
      FROM src1 x JOIN src y ON (x.key = y.key)
      GROUP BY x.key) tmp
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 5 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (GROUP)
Reducer 4 <- Reducer 3 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 4
      File Output Operator [FS_19]
        Group By Operator [GBY_17] (rows=1 width=16)
          Output:["_col0","_col1"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)"]
        <-Reducer 3 [GROUP]
          GROUP [RS_16]
            Group By Operator [GBY_15] (rows=1 width=16)
              Output:["_col0","_col1"],aggregations:["sum(_col0)","sum(_col1)"]
              Select Operator [SEL_13] (rows=16 width=94)
                Output:["_col0","_col1"]
                Group By Operator [GBY_12] (rows=16 width=94)
                  Output:["_col0","_col1"],aggregations:["count(VALUE._col0)"],keys:KEY._col0
                <-Reducer 2 [GROUP]
                  GROUP [RS_11]
                    PartitionCols:_col0
                    Group By Operator [GBY_10] (rows=16 width=94)
                      Output:["_col0","_col1"],aggregations:["count()"],keys:_col0
                      Join Operator [JOIN_8] (rows=40 width=86)
                        Output:["_col0"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"}],keys:{"0":"_col0","1":"_col0"}
                      <-Map 1 [PARTITION-LEVEL SORT]
                        PARTITION-LEVEL SORT [RS_6]
                          PartitionCols:_col0
                          Select Operator [SEL_2] (rows=25 width=86)
                            Output:["_col0"]
                            Filter Operator [FIL_20] (rows=25 width=86)
                              predicate:key is not null
                              TableScan [TS_0] (rows=25 width=86)
                                default@src1,x,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]
                      <-Map 5 [PARTITION-LEVEL SORT]
                        PARTITION-LEVEL SORT [RS_7]
                          PartitionCols:_col0
                          Select Operator [SEL_5] (rows=500 width=87)
                            Output:["_col0"]
                            Filter Operator [FIL_21] (rows=500 width=87)
                              predicate:key is not null
                              TableScan [TS_3] (rows=500 width=87)
                                default@src,y,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]

PREHOOK: query: explain
select SUM(HASH(tmp.key)), SUM(HASH(tmp.cnt))
FROM (select x.key AS key, count(1) AS cnt
      FROM src1 x JOIN src y ON (x.key = y.key)
      GROUP BY x.key) tmp
PREHOOK: type: QUERY
POSTHOOK: query: explain
select SUM(HASH(tmp.key)), SUM(HASH(tmp.cnt))
FROM (select x.key AS key, count(1) AS cnt
      FROM src1 x JOIN src y ON (x.key = y.key)
      GROUP BY x.key) tmp
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 5 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (GROUP)
Reducer 4 <- Reducer 3 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 4
      File Output Operator [FS_19]
        Group By Operator [GBY_17] (rows=1 width=16)
          Output:["_col0","_col1"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)"]
        <-Reducer 3 [GROUP]
          GROUP [RS_16]
            Group By Operator [GBY_15] (rows=1 width=16)
              Output:["_col0","_col1"],aggregations:["sum(_col0)","sum(_col1)"]
              Select Operator [SEL_13] (rows=16 width=94)
                Output:["_col0","_col1"]
                Group By Operator [GBY_12] (rows=16 width=94)
                  Output:["_col0","_col1"],aggregations:["count(VALUE._col0)"],keys:KEY._col0
                <-Reducer 2 [GROUP]
                  GROUP [RS_11]
                    PartitionCols:_col0
                    Group By Operator [GBY_10] (rows=16 width=94)
                      Output:["_col0","_col1"],aggregations:["count()"],keys:_col0
                      Join Operator [JOIN_8] (rows=40 width=86)
                        Output:["_col0"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"}],keys:{"0":"_col0","1":"_col0"}
                      <-Map 1 [PARTITION-LEVEL SORT]
                        PARTITION-LEVEL SORT [RS_6]
                          PartitionCols:_col0
                          Select Operator [SEL_2] (rows=25 width=86)
                            Output:["_col0"]
                            Filter Operator [FIL_20] (rows=25 width=86)
                              predicate:key is not null
                              TableScan [TS_0] (rows=25 width=86)
                                default@src1,x,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]
                      <-Map 5 [PARTITION-LEVEL SORT]
                        PARTITION-LEVEL SORT [RS_7]
                          PartitionCols:_col0
                          Select Operator [SEL_5] (rows=500 width=87)
                            Output:["_col0"]
                            Filter Operator [FIL_21] (rows=500 width=87)
                              predicate:key is not null
                              TableScan [TS_3] (rows=500 width=87)
                                default@src,y,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]

PREHOOK: query: explain
select SUM(HASH(tmp.key)), SUM(HASH(tmp.cnt))
FROM (select x.key AS key, count(1) AS cnt
      FROM src1 x JOIN src y ON (x.key = y.key)
      GROUP BY x.key) tmp
PREHOOK: type: QUERY
POSTHOOK: query: explain
select SUM(HASH(tmp.key)), SUM(HASH(tmp.cnt))
FROM (select x.key AS key, count(1) AS cnt
      FROM src1 x JOIN src y ON (x.key = y.key)
      GROUP BY x.key) tmp
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in Stage-1
Reducer 3 <- Map 2 (GROUP)
Reducer 4 <- Reducer 3 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 4
      File Output Operator [FS_19]
        Group By Operator [GBY_17] (rows=1 width=16)
          Output:["_col0","_col1"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)"]
        <-Reducer 3 [GROUP]
          GROUP [RS_16]
            Group By Operator [GBY_15] (rows=1 width=16)
              Output:["_col0","_col1"],aggregations:["sum(_col0)","sum(_col1)"]
              Select Operator [SEL_13] (rows=16 width=94)
                Output:["_col0","_col1"]
                Group By Operator [GBY_12] (rows=16 width=94)
                  Output:["_col0","_col1"],aggregations:["count(VALUE._col0)"],keys:KEY._col0
                <-Map 2 [GROUP]
                  GROUP [RS_11]
                    PartitionCols:_col0
                    Group By Operator [GBY_10] (rows=16 width=94)
                      Output:["_col0","_col1"],aggregations:["count()"],keys:_col0
                      Map Join Operator [MAPJOIN_22] (rows=40 width=86)
                        Conds:SEL_5._col0=SEL_5._col0(Inner),Output:["_col0"]
                      <-Select Operator [SEL_5] (rows=500 width=87)
                          Output:["_col0"]
                          Filter Operator [FIL_21] (rows=500 width=87)
                            predicate:key is not null
                            TableScan [TS_3] (rows=500 width=87)
                              default@src,y,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]
                  Map Reduce Local Work
        Stage-2
          Map 1
          keys: [HASHTABLESINK_24]
            0_col0,1_col0
            Select Operator [SEL_2] (rows=25 width=86)
              Output:["_col0"]
              Filter Operator [FIL_20] (rows=25 width=86)
                predicate:key is not null
                TableScan [TS_0] (rows=25 width=86)
                  default@src1,x,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]
          Map Reduce Local Work

PREHOOK: query: explain
select SUM(HASH(tmp.key)), SUM(HASH(tmp.cnt))
FROM (select x.key AS key, count(1) AS cnt
      FROM src1 x LEFT SEMI JOIN src y ON (x.key = y.key)
      GROUP BY x.key) tmp
PREHOOK: type: QUERY
POSTHOOK: query: explain
select SUM(HASH(tmp.key)), SUM(HASH(tmp.cnt))
FROM (select x.key AS key, count(1) AS cnt
      FROM src1 x LEFT SEMI JOIN src y ON (x.key = y.key)
      GROUP BY x.key) tmp
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 5 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (GROUP)
Reducer 4 <- Reducer 3 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 4
      File Output Operator [FS_21]
        Group By Operator [GBY_19] (rows=1 width=16)
          Output:["_col0","_col1"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)"]
        <-Reducer 3 [GROUP]
          GROUP [RS_18]
            Group By Operator [GBY_17] (rows=1 width=16)
              Output:["_col0","_col1"],aggregations:["sum(_col0)","sum(_col1)"]
              Select Operator [SEL_15] (rows=10 width=94)
                Output:["_col0","_col1"]
                Group By Operator [GBY_14] (rows=10 width=94)
                  Output:["_col0","_col1"],aggregations:["count(VALUE._col0)"],keys:KEY._col0
                <-Reducer 2 [GROUP]
                  GROUP [RS_13]
                    PartitionCols:_col0
                    Group By Operator [GBY_12] (rows=10 width=94)
                      Output:["_col0","_col1"],aggregations:["count()"],keys:_col0
                      Join Operator [JOIN_10] (rows=20 width=86)
                        Output:["_col0"],condition map:[{"":"{\"type\":\"Left Semi\",\"left\":0,\"right\":1}"}],keys:{"0":"_col0","1":"_col0"}
                      <-Map 1 [PARTITION-LEVEL SORT]
                        PARTITION-LEVEL SORT [RS_8]
                          PartitionCols:_col0
                          Select Operator [SEL_2] (rows=25 width=86)
                            Output:["_col0"]
                            Filter Operator [FIL_22] (rows=25 width=86)
                              predicate:key is not null
                              TableScan [TS_0] (rows=25 width=86)
                                default@src1,x,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]
                      <-Map 5 [PARTITION-LEVEL SORT]
                        PARTITION-LEVEL SORT [RS_9]
                          PartitionCols:_col0
                          Group By Operator [GBY_7] (rows=250 width=87)
                            Output:["_col0"],keys:_col0
                            Select Operator [SEL_5] (rows=500 width=87)
                              Output:["_col0"]
                              Filter Operator [FIL_23] (rows=500 width=87)
                                predicate:key is not null
                                TableScan [TS_3] (rows=500 width=87)
                                  default@src,y,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]

PREHOOK: query: explain create table abcd (a int, b int, c int, d int)
PREHOOK: type: CREATETABLE
POSTHOOK: query: explain create table abcd (a int, b int, c int, d int)
POSTHOOK: type: CREATETABLE
Stage-0
  Create Table Operator:
    name:default.abcd

PREHOOK: query: create table abcd (a int, b int, c int, d int)
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@abcd
POSTHOOK: query: create table abcd (a int, b int, c int, d int)
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@abcd
PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/in4.txt' INTO TABLE abcd
PREHOOK: type: LOAD
#### A masked pattern was here ####
PREHOOK: Output: default@abcd
POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/in4.txt' INTO TABLE abcd
POSTHOOK: type: LOAD
#### A masked pattern was here ####
POSTHOOK: Output: default@abcd
PREHOOK: query: explain select a, count(distinct b), count(distinct c), sum(d) from abcd group by a
PREHOOK: type: QUERY
POSTHOOK: query: explain select a, count(distinct b), count(distinct c), sum(d) from abcd group by a
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_6]
        Group By Operator [GBY_4] (rows=1 width=16)
          Output:["_col0","_col1","_col2","_col3"],aggregations:["count(DISTINCT KEY._col1:0._col0)","count(DISTINCT KEY._col1:1._col0)","sum(VALUE._col2)"],keys:KEY._col0
        <-Map 1 [GROUP PARTITION-LEVEL SORT]
          GROUP PARTITION-LEVEL SORT [RS_3]
            PartitionCols:_col0
            Group By Operator [GBY_2] (rows=1 width=16)
              Output:["_col0","_col1","_col2","_col3","_col4","_col5"],aggregations:["count(DISTINCT b)","count(DISTINCT c)","sum(d)"],keys:a, b, c
              Select Operator [SEL_1] (rows=1 width=16)
                Output:["a","b","c","d"]
                TableScan [TS_0] (rows=1 width=16)
                  default@abcd,abcd,Tbl:COMPLETE,Col:NONE,Output:["a","b","c","d"]

PREHOOK: query: explain select a, count(distinct b), count(distinct c), sum(d) from abcd group by a
PREHOOK: type: QUERY
POSTHOOK: query: explain select a, count(distinct b), count(distinct c), sum(d) from abcd group by a
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_5]
        Group By Operator [GBY_3] (rows=1 width=16)
          Output:["_col0","_col1","_col2","_col3"],aggregations:["count(DISTINCT KEY._col1:0._col0)","count(DISTINCT KEY._col1:1._col0)","sum(VALUE._col0)"],keys:KEY._col0
        <-Map 1 [GROUP PARTITION-LEVEL SORT]
          GROUP PARTITION-LEVEL SORT [RS_2]
            PartitionCols:a
            Select Operator [SEL_1] (rows=1 width=16)
              Output:["a","b","c","d"]
              TableScan [TS_0] (rows=1 width=16)
                default@abcd,abcd,Tbl:COMPLETE,Col:NONE,Output:["a","b","c","d"]

PREHOOK: query: explain create table src_rc_merge_test(key int, value string) stored as rcfile
PREHOOK: type: CREATETABLE
POSTHOOK: query: explain create table src_rc_merge_test(key int, value string) stored as rcfile
POSTHOOK: type: CREATETABLE
Stage-0
  Create Table Operator:
    name:default.src_rc_merge_test

PREHOOK: query: create table src_rc_merge_test(key int, value string) stored as rcfile
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@src_rc_merge_test
POSTHOOK: query: create table src_rc_merge_test(key int, value string) stored as rcfile
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@src_rc_merge_test
PREHOOK: query: load data local inpath '../../data/files/smbbucket_1.rc' into table src_rc_merge_test
PREHOOK: type: LOAD
#### A masked pattern was here ####
PREHOOK: Output: default@src_rc_merge_test
POSTHOOK: query: load data local inpath '../../data/files/smbbucket_1.rc' into table src_rc_merge_test
POSTHOOK: type: LOAD
#### A masked pattern was here ####
POSTHOOK: Output: default@src_rc_merge_test
PREHOOK: query: explain create table tgt_rc_merge_test(key int, value string) stored as rcfile
PREHOOK: type: CREATETABLE
POSTHOOK: query: explain create table tgt_rc_merge_test(key int, value string) stored as rcfile
POSTHOOK: type: CREATETABLE
Stage-0
  Create Table Operator:
    name:default.tgt_rc_merge_test

PREHOOK: query: create table tgt_rc_merge_test(key int, value string) stored as rcfile
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@tgt_rc_merge_test
POSTHOOK: query: create table tgt_rc_merge_test(key int, value string) stored as rcfile
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@tgt_rc_merge_test
PREHOOK: query: insert into table tgt_rc_merge_test select * from src_rc_merge_test
PREHOOK: type: QUERY
PREHOOK: Input: default@src_rc_merge_test
PREHOOK: Output: default@tgt_rc_merge_test
POSTHOOK: query: insert into table tgt_rc_merge_test select * from src_rc_merge_test
POSTHOOK: type: QUERY
POSTHOOK: Input: default@src_rc_merge_test
POSTHOOK: Output: default@tgt_rc_merge_test
POSTHOOK: Lineage: tgt_rc_merge_test.key SIMPLE [(src_rc_merge_test)src_rc_merge_test.FieldSchema(name:key, type:int, comment:null), ]
POSTHOOK: Lineage: tgt_rc_merge_test.value SIMPLE [(src_rc_merge_test)src_rc_merge_test.FieldSchema(name:value, type:string, comment:null), ]
PREHOOK: query: show table extended like `tgt_rc_merge_test`
PREHOOK: type: SHOW_TABLESTATUS
POSTHOOK: query: show table extended like `tgt_rc_merge_test`
POSTHOOK: type: SHOW_TABLESTATUS
tableName:tgt_rc_merge_test
#### A masked pattern was here ####
location:hdfs://### HDFS PATH ###
inputformat:org.apache.hadoop.hive.ql.io.RCFileInputFormat
outputformat:org.apache.hadoop.hive.ql.io.RCFileOutputFormat
columns:struct columns { i32 key, string value}
partitioned:false
partitionColumns:
totalNumberFiles:1
totalFileSize:171
maxFileSize:171
minFileSize:171
#### A masked pattern was here ####

PREHOOK: query: explain select count(1) from tgt_rc_merge_test
PREHOOK: type: QUERY
POSTHOOK: query: explain select count(1) from tgt_rc_merge_test
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_5]
        Group By Operator [GBY_3] (rows=1 width=8)
          Output:["_col0"],aggregations:["count()"]
        <-Map 1 [GROUP]
          GROUP [RS_2]
            Select Operator [SEL_1] (rows=5 width=6)
              TableScan [TS_0] (rows=5 width=6)
                default@tgt_rc_merge_test,tgt_rc_merge_test,Tbl:COMPLETE,Col:COMPLETE

PREHOOK: query: explain select sum(hash(key)), sum(hash(value)) from tgt_rc_merge_test
PREHOOK: type: QUERY
POSTHOOK: query: explain select sum(hash(key)), sum(hash(value)) from tgt_rc_merge_test
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_6]
        Group By Operator [GBY_4] (rows=1 width=204)
          Output:["_col0","_col1"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)"]
        <-Map 1 [GROUP]
          GROUP [RS_3]
            Select Operator [SEL_1] (rows=5 width=188)
              Output:["_col0","_col1"]
              TableScan [TS_0] (rows=5 width=188)
                default@tgt_rc_merge_test,tgt_rc_merge_test,Tbl:COMPLETE,Col:NONE,Output:["key","value"]

PREHOOK: query: alter table tgt_rc_merge_test concatenate
PREHOOK: type: ALTER_TABLE_MERGE
PREHOOK: Input: default@tgt_rc_merge_test
PREHOOK: Output: default@tgt_rc_merge_test
POSTHOOK: query: alter table tgt_rc_merge_test concatenate
POSTHOOK: type: ALTER_TABLE_MERGE
POSTHOOK: Input: default@tgt_rc_merge_test
POSTHOOK: Output: default@tgt_rc_merge_test
PREHOOK: query: show table extended like `tgt_rc_merge_test`
PREHOOK: type: SHOW_TABLESTATUS
POSTHOOK: query: show table extended like `tgt_rc_merge_test`
POSTHOOK: type: SHOW_TABLESTATUS
tableName:tgt_rc_merge_test
#### A masked pattern was here ####
location:hdfs://### HDFS PATH ###
inputformat:org.apache.hadoop.hive.ql.io.RCFileInputFormat
outputformat:org.apache.hadoop.hive.ql.io.RCFileOutputFormat
columns:struct columns { i32 key, string value}
partitioned:false
partitionColumns:
totalNumberFiles:1
totalFileSize:171
maxFileSize:171
minFileSize:171
#### A masked pattern was here ####

PREHOOK: query: explain select count(1) from tgt_rc_merge_test
PREHOOK: type: QUERY
POSTHOOK: query: explain select count(1) from tgt_rc_merge_test
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_5]
        Group By Operator [GBY_3] (rows=1 width=8)
          Output:["_col0"],aggregations:["count()"]
        <-Map 1 [GROUP]
          GROUP [RS_2]
            Select Operator [SEL_1] (rows=5 width=6)
              TableScan [TS_0] (rows=5 width=6)
                default@tgt_rc_merge_test,tgt_rc_merge_test,Tbl:COMPLETE,Col:COMPLETE

PREHOOK: query: explain select sum(hash(key)), sum(hash(value)) from tgt_rc_merge_test
PREHOOK: type: QUERY
POSTHOOK: query: explain select sum(hash(key)), sum(hash(value)) from tgt_rc_merge_test
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_6]
        Group By Operator [GBY_4] (rows=1 width=204)
          Output:["_col0","_col1"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)"]
        <-Map 1 [GROUP]
          GROUP [RS_3]
            Select Operator [SEL_1] (rows=5 width=188)
              Output:["_col0","_col1"]
              TableScan [TS_0] (rows=5 width=188)
                default@tgt_rc_merge_test,tgt_rc_merge_test,Tbl:COMPLETE,Col:NONE,Output:["key","value"]

PREHOOK: query: drop table src_rc_merge_test
PREHOOK: type: DROPTABLE
PREHOOK: Input: default@src_rc_merge_test
PREHOOK: Output: default@src_rc_merge_test
POSTHOOK: query: drop table src_rc_merge_test
POSTHOOK: type: DROPTABLE
POSTHOOK: Input: default@src_rc_merge_test
POSTHOOK: Output: default@src_rc_merge_test
PREHOOK: query: drop table tgt_rc_merge_test
PREHOOK: type: DROPTABLE
PREHOOK: Input: default@tgt_rc_merge_test
PREHOOK: Output: default@tgt_rc_merge_test
POSTHOOK: query: drop table tgt_rc_merge_test
POSTHOOK: type: DROPTABLE
POSTHOOK: Input: default@tgt_rc_merge_test
POSTHOOK: Output: default@tgt_rc_merge_test
PREHOOK: query: explain select src.key from src cross join src src2
PREHOOK: type: QUERY
POSTHOOK: query: explain select src.key from src cross join src src2
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_8]
        Join Operator [JOIN_6] (rows=250000 width=87)
          Output:["_col0"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"}],keys:{}
        <-Map 1 [PARTITION-LEVEL SORT]
          PARTITION-LEVEL SORT [RS_4]
            Select Operator [SEL_1] (rows=500 width=87)
              Output:["_col0"]
              TableScan [TS_0] (rows=500 width=87)
                default@src,src,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]
        <-Map 3 [PARTITION-LEVEL SORT]
          PARTITION-LEVEL SORT [RS_5]
            Select Operator [SEL_3] (rows=500 width=4)
              TableScan [TS_2] (rows=500 width=10)
                default@src,src2,Tbl:COMPLETE,Col:COMPLETE

PREHOOK: query: explain create table nzhang_Tmp(a int, b string)
PREHOOK: type: CREATETABLE
POSTHOOK: query: explain create table nzhang_Tmp(a int, b string)
POSTHOOK: type: CREATETABLE
Stage-0
  Create Table Operator:
    name:default.nzhang_Tmp

PREHOOK: query: create table nzhang_Tmp(a int, b string)
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@nzhang_Tmp
POSTHOOK: query: create table nzhang_Tmp(a int, b string)
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@nzhang_Tmp
PREHOOK: query: explain create table nzhang_CTAS1 as select key k, value from src sort by k, value limit 10
PREHOOK: type: CREATETABLE_AS_SELECT
POSTHOOK: query: explain create table nzhang_CTAS1 as select key k, value from src sort by k, value limit 10
POSTHOOK: type: CREATETABLE_AS_SELECT
Plan not optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT)

Stage-2
  Stats Work{}
    Stage-3
      Create Table Operator:
        name:default.nzhang_CTAS1
        Stage-0
          Move Operator
            Stage-1
              Reducer 3
              File Output Operator [FS_8]
                table:{"name:":"default.nzhang_CTAS1"}
                Limit [LIM_7] (rows=10 width=178)
                  Number of rows:10
                  Select Operator [SEL_6] (rows=10 width=178)
                    Output:["_col0","_col1"]
                  <-Reducer 2 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_5]
                      Limit [LIM_4] (rows=10 width=178)
                        Number of rows:10
                        Select Operator [SEL_3] (rows=500 width=178)
                          Output:["_col0","_col1"]
                        <-Map 1 [PARTITION-LEVEL SORT]
                          PARTITION-LEVEL SORT [RS_2]
                            Select Operator [SEL_1] (rows=500 width=178)
                              Output:["_col0","_col1"]
                              TableScan [TS_0] (rows=500 width=178)
                                default@src,src,Tbl:COMPLETE,Col:COMPLETE,Output:["key","value"]

PREHOOK: query: create table nzhang_CTAS1 as select key k, value from src sort by k, value limit 10
PREHOOK: type: CREATETABLE_AS_SELECT
PREHOOK: Input: default@src
PREHOOK: Output: database:default
PREHOOK: Output: default@nzhang_CTAS1
POSTHOOK: query: create table nzhang_CTAS1 as select key k, value from src sort by k, value limit 10
POSTHOOK: type: CREATETABLE_AS_SELECT
POSTHOOK: Input: default@src
POSTHOOK: Output: database:default
POSTHOOK: Output: default@nzhang_CTAS1
POSTHOOK: Lineage: nzhang_ctas1.k SIMPLE [(src)src.FieldSchema(name:key, type:string, comment:default), ]
POSTHOOK: Lineage: nzhang_ctas1.value SIMPLE [(src)src.FieldSchema(name:value, type:string, comment:default), ]
PREHOOK: query: explain create table nzhang_ctas3 row format serde "org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe" stored as RCFile as select key/2 half_key, concat(value, "_con") conb  from src sort by half_key, conb limit 10
PREHOOK: type: CREATETABLE_AS_SELECT
POSTHOOK: query: explain create table nzhang_ctas3 row format serde "org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe" stored as RCFile as select key/2 half_key, concat(value, "_con") conb  from src sort by half_key, conb limit 10
POSTHOOK: type: CREATETABLE_AS_SELECT
Plan not optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT)

Stage-2
  Stats Work{}
    Stage-3
      Create Table Operator:
        name:default.nzhang_ctas3
        Stage-0
          Move Operator
            Stage-1
              Reducer 3
              File Output Operator [FS_8]
                table:{"name:":"default.nzhang_ctas3"}
                Limit [LIM_7] (rows=10 width=192)
                  Number of rows:10
                  Select Operator [SEL_6] (rows=10 width=192)
                    Output:["_col0","_col1"]
                  <-Reducer 2 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_5]
                      Limit [LIM_4] (rows=10 width=192)
                        Number of rows:10
                        Select Operator [SEL_3] (rows=500 width=192)
                          Output:["_col0","_col1"]
                        <-Map 1 [PARTITION-LEVEL SORT]
                          PARTITION-LEVEL SORT [RS_2]
                            Select Operator [SEL_1] (rows=500 width=192)
                              Output:["_col0","_col1"]
                              TableScan [TS_0] (rows=500 width=178)
                                default@src,src,Tbl:COMPLETE,Col:COMPLETE,Output:["key","value"]

PREHOOK: query: create table nzhang_ctas3 row format serde "org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe" stored as RCFile as select key/2 half_key, concat(value, "_con") conb  from src sort by half_key, conb limit 10
PREHOOK: type: CREATETABLE_AS_SELECT
PREHOOK: Input: default@src
PREHOOK: Output: database:default
PREHOOK: Output: default@nzhang_ctas3
POSTHOOK: query: create table nzhang_ctas3 row format serde "org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe" stored as RCFile as select key/2 half_key, concat(value, "_con") conb  from src sort by half_key, conb limit 10
POSTHOOK: type: CREATETABLE_AS_SELECT
POSTHOOK: Input: default@src
POSTHOOK: Output: database:default
POSTHOOK: Output: default@nzhang_ctas3
POSTHOOK: Lineage: nzhang_ctas3.conb EXPRESSION [(src)src.FieldSchema(name:value, type:string, comment:default), ]
POSTHOOK: Lineage: nzhang_ctas3.half_key EXPRESSION [(src)src.FieldSchema(name:key, type:string, comment:default), ]
PREHOOK: query: explain create table if not exists nzhang_ctas3 as select key, value from src sort by key, value limit 2
PREHOOK: type: CREATETABLE_AS_SELECT
POSTHOOK: query: explain create table if not exists nzhang_ctas3 as select key, value from src sort by key, value limit 2
POSTHOOK: type: CREATETABLE_AS_SELECT

PREHOOK: query: create table if not exists nzhang_ctas3 as select key, value from src sort by key, value limit 2
PREHOOK: type: CREATETABLE_AS_SELECT
POSTHOOK: query: create table if not exists nzhang_ctas3 as select key, value from src sort by key, value limit 2
POSTHOOK: type: CREATETABLE_AS_SELECT
PREHOOK: query: explain create temporary table acid_dtt(a int, b varchar(128)) clustered by (a) into 2 buckets stored as orc TBLPROPERTIES ('transactional'='true')
PREHOOK: type: CREATETABLE
POSTHOOK: query: explain create temporary table acid_dtt(a int, b varchar(128)) clustered by (a) into 2 buckets stored as orc TBLPROPERTIES ('transactional'='true')
POSTHOOK: type: CREATETABLE
Stage-0
  Create Table Operator:
    name:default.acid_dtt

PREHOOK: query: create temporary table acid_dtt(a int, b varchar(128)) clustered by (a) into 2 buckets stored as orc TBLPROPERTIES ('transactional'='true')
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@acid_dtt
POSTHOOK: query: create temporary table acid_dtt(a int, b varchar(128)) clustered by (a) into 2 buckets stored as orc TBLPROPERTIES ('transactional'='true')
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@acid_dtt
PREHOOK: query: explain
select src1.key as k1, src1.value as v1,
       src2.key as k2, src2.value as v2 FROM
  (select * FROM src WHERE src.key < 10) src1
    JOIN
  (select * FROM src WHERE src.key < 10) src2
  SORT BY k1, v1, k2, v2
PREHOOK: type: QUERY
POSTHOOK: query: explain
select src1.key as k1, src1.value as v1,
       src2.key as k2, src2.value as v2 FROM
  (select * FROM src WHERE src.key < 10) src1
    JOIN
  (select * FROM src WHERE src.key < 10) src2
  SORT BY k1, v1, k2, v2
POSTHOOK: type: QUERY
Plan not optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 4 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_12]
        Select Operator [SEL_11] (rows=27556 width=356)
          Output:["_col0","_col1","_col2","_col3"]
        <-Reducer 2 [PARTITION-LEVEL SORT]
          PARTITION-LEVEL SORT [RS_10]
            Join Operator [JOIN_8] (rows=27556 width=356)
              Output:["_col0","_col1","_col2","_col3"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"}],keys:{}
            <-Map 1 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_6]
                Select Operator [SEL_2] (rows=166 width=178)
                  Output:["_col0","_col1"]
                  Filter Operator [FIL_13] (rows=166 width=178)
                    predicate:(key < 10)
                    TableScan [TS_0] (rows=500 width=178)
                      default@src,src,Tbl:COMPLETE,Col:COMPLETE,Output:["key","value"]
            <-Map 4 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_7]
                Select Operator [SEL_5] (rows=166 width=178)
                  Output:["_col0","_col1"]
                  Filter Operator [FIL_14] (rows=166 width=178)
                    predicate:(key < 10)
                    TableScan [TS_3] (rows=500 width=178)
                      default@src,src,Tbl:COMPLETE,Col:COMPLETE,Output:["key","value"]

PREHOOK: query: CREATE TABLE myinput1(key int, value int)
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@myinput1
POSTHOOK: query: CREATE TABLE myinput1(key int, value int)
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@myinput1
PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/in8.txt' INTO TABLE myinput1
PREHOOK: type: LOAD
#### A masked pattern was here ####
PREHOOK: Output: default@myinput1
POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/in8.txt' INTO TABLE myinput1
POSTHOOK: type: LOAD
#### A masked pattern was here ####
POSTHOOK: Output: default@myinput1
PREHOOK: query: explain select * from myinput1 a join myinput1 b on a.key<=>b.value
PREHOOK: type: QUERY
POSTHOOK: query: explain select * from myinput1 a join myinput1 b on a.key<=>b.value
POSTHOOK: type: QUERY
Plan not optimized by CBO due to missing feature [Less_than_equal_greater_than].

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_6]
        Select Operator [SEL_5] (rows=1 width=8)
          Output:["_col0","_col1","_col2","_col3"]
          Join Operator [JOIN_4] (rows=1 width=8)
            Output:["_col0","_col1","_col5","_col6"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"}],keys:{"0":"key","1":"value"}
          <-Map 1 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_2]
              PartitionCols:key
              TableScan [TS_0] (rows=1 width=8)
                default@myinput1,a,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
          <-Map 3 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_3]
              PartitionCols:value
              TableScan [TS_1] (rows=1 width=8)
                default@myinput1,b,Tbl:COMPLETE,Col:NONE,Output:["key","value"]

PREHOOK: query: explain select * from myinput1 a join myinput1 b on a.key<=>b.value join myinput1 c on a.key=c.key
PREHOOK: type: QUERY
POSTHOOK: query: explain select * from myinput1 a join myinput1 b on a.key<=>b.value join myinput1 c on a.key=c.key
POSTHOOK: type: QUERY
Plan not optimized by CBO due to missing feature [Less_than_equal_greater_than].

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT), Map 4 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_11]
        Select Operator [SEL_10] (rows=2 width=8)
          Output:["_col0","_col1","_col2","_col3","_col4","_col5"]
          Join Operator [JOIN_9] (rows=2 width=8)
            Output:["_col0","_col1","_col5","_col6","_col10","_col11"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"},{"":"{\"type\":\"Inner\",\"left\":0,\"right\":2}"}],keys:{"0":"key","1":"value","2":"key"}
          <-Map 1 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_4]
              PartitionCols:key
              Filter Operator [FIL_12] (rows=1 width=8)
                predicate:key is not null
                TableScan [TS_0] (rows=1 width=8)
                  default@myinput1,a,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
          <-Map 3 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_6]
              PartitionCols:value
              Filter Operator [FIL_13] (rows=1 width=8)
                predicate:value is not null
                TableScan [TS_1] (rows=1 width=8)
                  default@myinput1,b,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
          <-Map 4 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_8]
              PartitionCols:key
              Filter Operator [FIL_14] (rows=1 width=8)
                predicate:key is not null
                TableScan [TS_2] (rows=1 width=8)
                  default@myinput1,c,Tbl:COMPLETE,Col:NONE,Output:["key","value"]

PREHOOK: query: explain select * from myinput1 a join myinput1 b on a.key<=>b.value join myinput1 c on a.key<=>c.key
PREHOOK: type: QUERY
POSTHOOK: query: explain select * from myinput1 a join myinput1 b on a.key<=>b.value join myinput1 c on a.key<=>c.key
POSTHOOK: type: QUERY
Plan not optimized by CBO due to missing feature [Less_than_equal_greater_than].

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT), Map 4 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_8]
        Select Operator [SEL_7] (rows=2 width=8)
          Output:["_col0","_col1","_col2","_col3","_col4","_col5"]
          Join Operator [JOIN_6] (rows=2 width=8)
            Output:["_col0","_col1","_col5","_col6","_col10","_col11"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"},{"":"{\"type\":\"Inner\",\"left\":0,\"right\":2}"}],keys:{"0":"key","1":"value","2":"key"}
          <-Map 1 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_3]
              PartitionCols:key
              TableScan [TS_0] (rows=1 width=8)
                default@myinput1,a,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
          <-Map 3 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_4]
              PartitionCols:value
              TableScan [TS_1] (rows=1 width=8)
                default@myinput1,b,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
          <-Map 4 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_5]
              PartitionCols:key
              TableScan [TS_2] (rows=1 width=8)
                default@myinput1,c,Tbl:COMPLETE,Col:NONE,Output:["key","value"]

PREHOOK: query: explain select * from myinput1 a join myinput1 b on a.key<=>b.value AND a.value=b.key join myinput1 c on a.key<=>c.key AND a.value=c.value
PREHOOK: type: QUERY
POSTHOOK: query: explain select * from myinput1 a join myinput1 b on a.key<=>b.value AND a.value=b.key join myinput1 c on a.key<=>c.key AND a.value=c.value
POSTHOOK: type: QUERY
Plan not optimized by CBO due to missing feature [Less_than_equal_greater_than].

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT), Map 4 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_11]
        Select Operator [SEL_10] (rows=2 width=8)
          Output:["_col0","_col1","_col2","_col3","_col4","_col5"]
          Join Operator [JOIN_9] (rows=2 width=8)
            Output:["_col0","_col1","_col5","_col6","_col10","_col11"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"},{"":"{\"type\":\"Inner\",\"left\":0,\"right\":2}"}],keys:{"0":"key, value","1":"value, key","2":"key, value"}
          <-Map 1 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_4]
              PartitionCols:key, value
              Filter Operator [FIL_12] (rows=1 width=8)
                predicate:value is not null
                TableScan [TS_0] (rows=1 width=8)
                  default@myinput1,a,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
          <-Map 3 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_6]
              PartitionCols:value, key
              Filter Operator [FIL_13] (rows=1 width=8)
                predicate:key is not null
                TableScan [TS_1] (rows=1 width=8)
                  default@myinput1,b,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
          <-Map 4 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_8]
              PartitionCols:key, value
              Filter Operator [FIL_14] (rows=1 width=8)
                predicate:value is not null
                TableScan [TS_2] (rows=1 width=8)
                  default@myinput1,c,Tbl:COMPLETE,Col:NONE,Output:["key","value"]

PREHOOK: query: explain select * from myinput1 a join myinput1 b on a.key<=>b.value AND a.value<=>b.key join myinput1 c on a.key<=>c.key AND a.value<=>c.value
PREHOOK: type: QUERY
POSTHOOK: query: explain select * from myinput1 a join myinput1 b on a.key<=>b.value AND a.value<=>b.key join myinput1 c on a.key<=>c.key AND a.value<=>c.value
POSTHOOK: type: QUERY
Plan not optimized by CBO due to missing feature [Less_than_equal_greater_than].

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT), Map 4 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_8]
        Select Operator [SEL_7] (rows=2 width=8)
          Output:["_col0","_col1","_col2","_col3","_col4","_col5"]
          Join Operator [JOIN_6] (rows=2 width=8)
            Output:["_col0","_col1","_col5","_col6","_col10","_col11"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"},{"":"{\"type\":\"Inner\",\"left\":0,\"right\":2}"}],keys:{"0":"key, value","1":"value, key","2":"key, value"}
          <-Map 1 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_3]
              PartitionCols:key, value
              TableScan [TS_0] (rows=1 width=8)
                default@myinput1,a,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
          <-Map 3 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_4]
              PartitionCols:value, key
              TableScan [TS_1] (rows=1 width=8)
                default@myinput1,b,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
          <-Map 4 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_5]
              PartitionCols:key, value
              TableScan [TS_2] (rows=1 width=8)
                default@myinput1,c,Tbl:COMPLETE,Col:NONE,Output:["key","value"]

PREHOOK: query: explain select * FROM myinput1 a LEFT OUTER JOIN myinput1 b ON a.key<=>b.value
PREHOOK: type: QUERY
POSTHOOK: query: explain select * FROM myinput1 a LEFT OUTER JOIN myinput1 b ON a.key<=>b.value
POSTHOOK: type: QUERY
Plan not optimized by CBO due to missing feature [Less_than_equal_greater_than].

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_6]
        Select Operator [SEL_5] (rows=1 width=8)
          Output:["_col0","_col1","_col2","_col3"]
          Join Operator [JOIN_4] (rows=1 width=8)
            Output:["_col0","_col1","_col5","_col6"],condition map:[{"":"{\"type\":\"Left Outer\",\"left\":0,\"right\":1}"}],keys:{"0":"key","1":"value"}
          <-Map 1 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_2]
              PartitionCols:key
              TableScan [TS_0] (rows=1 width=8)
                default@myinput1,a,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
          <-Map 3 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_3]
              PartitionCols:value
              TableScan [TS_1] (rows=1 width=8)
                default@myinput1,b,Tbl:COMPLETE,Col:NONE,Output:["key","value"]

PREHOOK: query: explain select * FROM myinput1 a RIGHT OUTER JOIN myinput1 b ON a.key<=>b.value
PREHOOK: type: QUERY
POSTHOOK: query: explain select * FROM myinput1 a RIGHT OUTER JOIN myinput1 b ON a.key<=>b.value
POSTHOOK: type: QUERY
Plan not optimized by CBO due to missing feature [Less_than_equal_greater_than].

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_6]
        Select Operator [SEL_5] (rows=1 width=8)
          Output:["_col0","_col1","_col2","_col3"]
          Join Operator [JOIN_4] (rows=1 width=8)
            Output:["_col0","_col1","_col5","_col6"],condition map:[{"":"{\"type\":\"Right Outer\",\"left\":0,\"right\":1}"}],keys:{"0":"key","1":"value"}
          <-Map 1 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_2]
              PartitionCols:key
              TableScan [TS_0] (rows=1 width=8)
                default@myinput1,a,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
          <-Map 3 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_3]
              PartitionCols:value
              TableScan [TS_1] (rows=1 width=8)
                default@myinput1,b,Tbl:COMPLETE,Col:NONE,Output:["key","value"]

PREHOOK: query: explain select * FROM myinput1 a FULL OUTER JOIN myinput1 b ON a.key<=>b.value
PREHOOK: type: QUERY
POSTHOOK: query: explain select * FROM myinput1 a FULL OUTER JOIN myinput1 b ON a.key<=>b.value
POSTHOOK: type: QUERY
Plan not optimized by CBO due to missing feature [Less_than_equal_greater_than].

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_6]
        Select Operator [SEL_5] (rows=1 width=8)
          Output:["_col0","_col1","_col2","_col3"]
          Join Operator [JOIN_4] (rows=1 width=8)
            Output:["_col0","_col1","_col5","_col6"],condition map:[{"":"{\"type\":\"Outer\",\"left\":0,\"right\":1}"}],keys:{"0":"key","1":"value"}
          <-Map 1 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_2]
              PartitionCols:key
              TableScan [TS_0] (rows=1 width=8)
                default@myinput1,a,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
          <-Map 3 [PARTITION-LEVEL SORT]
            PARTITION-LEVEL SORT [RS_3]
              PartitionCols:value
              TableScan [TS_1] (rows=1 width=8)
                default@myinput1,b,Tbl:COMPLETE,Col:NONE,Output:["key","value"]

PREHOOK: query: explain select /*+ MAPJOIN(b) */ * FROM myinput1 a JOIN myinput1 b ON a.key<=>b.value
PREHOOK: type: QUERY
POSTHOOK: query: explain select /*+ MAPJOIN(b) */ * FROM myinput1 a JOIN myinput1 b ON a.key<=>b.value
POSTHOOK: type: QUERY
Plan not optimized by CBO due to missing feature [Less_than_equal_greater_than].

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Map 1
      File Output Operator [FS_6]
        Select Operator [SEL_8] (rows=1 width=8)
          Output:["_col0","_col1","_col2","_col3"]
          Map Join Operator [MAPJOIN_7] (rows=1 width=8)
            Conds:TS_0.key=TS_0.value(Inner),Output:["_col0","_col1","_col5","_col6"]
          <-TableScan [TS_0] (rows=1 width=8)
              default@myinput1,a,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
      Map Reduce Local Work
        Stage-2
          Map 2
          keys: [HASHTABLESINK_10]
            0key,1value
            TableScan [TS_1] (rows=1 width=8)
              default@myinput1,b,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
          Map Reduce Local Work

PREHOOK: query: CREATE TABLE smb_input(key int, value int)
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@smb_input
POSTHOOK: query: CREATE TABLE smb_input(key int, value int)
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@smb_input
PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/in4.txt' into table smb_input
PREHOOK: type: LOAD
#### A masked pattern was here ####
PREHOOK: Output: default@smb_input
POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/in4.txt' into table smb_input
POSTHOOK: type: LOAD
#### A masked pattern was here ####
POSTHOOK: Output: default@smb_input
PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/in5.txt' into table smb_input
PREHOOK: type: LOAD
#### A masked pattern was here ####
PREHOOK: Output: default@smb_input
POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/in5.txt' into table smb_input
POSTHOOK: type: LOAD
#### A masked pattern was here ####
POSTHOOK: Output: default@smb_input
PREHOOK: query: CREATE TABLE smb_input1(key int, value int) CLUSTERED BY (key) SORTED BY (key) INTO 2 BUCKETS
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@smb_input1
POSTHOOK: query: CREATE TABLE smb_input1(key int, value int) CLUSTERED BY (key) SORTED BY (key) INTO 2 BUCKETS
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@smb_input1
PREHOOK: query: CREATE TABLE smb_input2(key int, value int) CLUSTERED BY (value) SORTED BY (value) INTO 2 BUCKETS
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@smb_input2
POSTHOOK: query: CREATE TABLE smb_input2(key int, value int) CLUSTERED BY (value) SORTED BY (value) INTO 2 BUCKETS
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@smb_input2
PREHOOK: query: from smb_input
insert overwrite table smb_input1 select *
insert overwrite table smb_input2 select *
PREHOOK: type: QUERY
PREHOOK: Input: default@smb_input
PREHOOK: Output: default@smb_input1
PREHOOK: Output: default@smb_input2
POSTHOOK: query: from smb_input
insert overwrite table smb_input1 select *
insert overwrite table smb_input2 select *
POSTHOOK: type: QUERY
POSTHOOK: Input: default@smb_input
POSTHOOK: Output: default@smb_input1
POSTHOOK: Output: default@smb_input2
POSTHOOK: Lineage: smb_input1.key SIMPLE [(smb_input)smb_input.FieldSchema(name:key, type:int, comment:null), ]
POSTHOOK: Lineage: smb_input1.value SIMPLE [(smb_input)smb_input.FieldSchema(name:value, type:int, comment:null), ]
POSTHOOK: Lineage: smb_input2.key SIMPLE [(smb_input)smb_input.FieldSchema(name:key, type:int, comment:null), ]
POSTHOOK: Lineage: smb_input2.value SIMPLE [(smb_input)smb_input.FieldSchema(name:value, type:int, comment:null), ]
PREHOOK: query: analyze table smb_input1 compute statistics
PREHOOK: type: QUERY
PREHOOK: Input: default@smb_input1
PREHOOK: Output: default@smb_input1
POSTHOOK: query: analyze table smb_input1 compute statistics
POSTHOOK: type: QUERY
POSTHOOK: Input: default@smb_input1
POSTHOOK: Output: default@smb_input1
PREHOOK: query: explain select /*+ MAPJOIN(a) */ * FROM smb_input1 a JOIN smb_input1 b ON a.key <=> b.key
PREHOOK: type: QUERY
POSTHOOK: query: explain select /*+ MAPJOIN(a) */ * FROM smb_input1 a JOIN smb_input1 b ON a.key <=> b.key
POSTHOOK: type: QUERY
Plan not optimized by CBO due to missing feature [Less_than_equal_greater_than].

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Map 1
      File Output Operator [FS_6]
        Select Operator [SEL_8] (rows=28 width=8)
          Output:["_col0","_col1","_col2","_col3"]
          Sorted Merge Bucket Map Join Operator [MAPJOIN_7] (rows=28 width=8)
            BucketMapJoin:true,Conds:TS_1.key=TS_1.key(Inner),Output:["_col0","_col1","_col5","_col6"]
          <-TableScan [TS_1] (rows=26 width=8)
              default@smb_input1,b,Tbl:COMPLETE,Col:NONE,Output:["key","value"]

PREHOOK: query: explain select /*+ MAPJOIN(a) */ * FROM smb_input1 a JOIN smb_input1 b ON a.key <=> b.key AND a.value <=> b.value
PREHOOK: type: QUERY
POSTHOOK: query: explain select /*+ MAPJOIN(a) */ * FROM smb_input1 a JOIN smb_input1 b ON a.key <=> b.key AND a.value <=> b.value
POSTHOOK: type: QUERY
Plan not optimized by CBO due to missing feature [Less_than_equal_greater_than].

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Map 2
      File Output Operator [FS_6]
        Select Operator [SEL_8] (rows=28 width=8)
          Output:["_col0","_col1","_col2","_col3"]
          Map Join Operator [MAPJOIN_7] (rows=28 width=8)
            BucketMapJoin:true,Conds:TS_1.key, value=TS_1.key, value(Inner),Output:["_col0","_col1","_col5","_col6"]
          <-TableScan [TS_1] (rows=26 width=8)
              default@smb_input1,b,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
      Map Reduce Local Work
        Stage-2
          Map 1
          keys: [HASHTABLESINK_10]
            0key, value,1key, value
            TableScan [TS_0] (rows=26 width=8)
              default@smb_input1,a,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
          Map Reduce Local Work

PREHOOK: query: explain select /*+ MAPJOIN(a) */ * FROM smb_input1 a RIGHT OUTER JOIN smb_input1 b ON a.key <=> b.key
PREHOOK: type: QUERY
POSTHOOK: query: explain select /*+ MAPJOIN(a) */ * FROM smb_input1 a RIGHT OUTER JOIN smb_input1 b ON a.key <=> b.key
POSTHOOK: type: QUERY
Plan not optimized by CBO due to missing feature [Less_than_equal_greater_than].

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Map 1
      File Output Operator [FS_6]
        Select Operator [SEL_8] (rows=28 width=8)
          Output:["_col0","_col1","_col2","_col3"]
          Sorted Merge Bucket Map Join Operator [MAPJOIN_7] (rows=28 width=8)
            BucketMapJoin:true,Conds:TS_1.key=TS_1.key(Right Outer),Output:["_col0","_col1","_col5","_col6"]
          <-TableScan [TS_1] (rows=26 width=8)
              default@smb_input1,b,Tbl:COMPLETE,Col:NONE,Output:["key","value"]

PREHOOK: query: explain select /*+ MAPJOIN(b) */ * FROM smb_input1 a JOIN smb_input1 b ON a.key <=> b.key
PREHOOK: type: QUERY
POSTHOOK: query: explain select /*+ MAPJOIN(b) */ * FROM smb_input1 a JOIN smb_input1 b ON a.key <=> b.key
POSTHOOK: type: QUERY
Plan not optimized by CBO due to missing feature [Less_than_equal_greater_than].

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Map 1
      File Output Operator [FS_6]
        Select Operator [SEL_8] (rows=28 width=8)
          Output:["_col0","_col1","_col2","_col3"]
          Sorted Merge Bucket Map Join Operator [MAPJOIN_7] (rows=28 width=8)
            BucketMapJoin:true,Conds:TS_0.key=TS_0.key(Inner),Output:["_col0","_col1","_col5","_col6"]
          <-TableScan [TS_0] (rows=26 width=8)
              default@smb_input1,a,Tbl:COMPLETE,Col:NONE,Output:["key","value"]

PREHOOK: query: explain select /*+ MAPJOIN(b) */ * FROM smb_input1 a LEFT OUTER JOIN smb_input1 b ON a.key <=> b.key
PREHOOK: type: QUERY
POSTHOOK: query: explain select /*+ MAPJOIN(b) */ * FROM smb_input1 a LEFT OUTER JOIN smb_input1 b ON a.key <=> b.key
POSTHOOK: type: QUERY
Plan not optimized by CBO due to missing feature [Less_than_equal_greater_than].

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Map 1
      File Output Operator [FS_6]
        Select Operator [SEL_8] (rows=28 width=8)
          Output:["_col0","_col1","_col2","_col3"]
          Sorted Merge Bucket Map Join Operator [MAPJOIN_7] (rows=28 width=8)
            BucketMapJoin:true,Conds:TS_0.key=TS_0.key(Left Outer),Output:["_col0","_col1","_col5","_col6"]
          <-TableScan [TS_0] (rows=26 width=8)
              default@smb_input1,a,Tbl:COMPLETE,Col:NONE,Output:["key","value"]

PREHOOK: query: drop table sales
PREHOOK: type: DROPTABLE
POSTHOOK: query: drop table sales
POSTHOOK: type: DROPTABLE
PREHOOK: query: drop table things
PREHOOK: type: DROPTABLE
POSTHOOK: query: drop table things
POSTHOOK: type: DROPTABLE
PREHOOK: query: CREATE TABLE sales (name STRING, id INT)
ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t'
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@sales
POSTHOOK: query: CREATE TABLE sales (name STRING, id INT)
ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t'
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@sales
PREHOOK: query: CREATE TABLE things (id INT, name STRING) partitioned by (ds string)
ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t'
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@things
POSTHOOK: query: CREATE TABLE things (id INT, name STRING) partitioned by (ds string)
ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t'
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@things
PREHOOK: query: load data local inpath '../../data/files/sales.txt' INTO TABLE sales
PREHOOK: type: LOAD
#### A masked pattern was here ####
PREHOOK: Output: default@sales
POSTHOOK: query: load data local inpath '../../data/files/sales.txt' INTO TABLE sales
POSTHOOK: type: LOAD
#### A masked pattern was here ####
POSTHOOK: Output: default@sales
PREHOOK: query: load data local inpath '../../data/files/things.txt' INTO TABLE things partition(ds='2011-10-23')
PREHOOK: type: LOAD
#### A masked pattern was here ####
PREHOOK: Output: default@things
POSTHOOK: query: load data local inpath '../../data/files/things.txt' INTO TABLE things partition(ds='2011-10-23')
POSTHOOK: type: LOAD
#### A masked pattern was here ####
POSTHOOK: Output: default@things
POSTHOOK: Output: default@things@ds=2011-10-23
PREHOOK: query: load data local inpath '../../data/files/things2.txt' INTO TABLE things partition(ds='2011-10-24')
PREHOOK: type: LOAD
#### A masked pattern was here ####
PREHOOK: Output: default@things
POSTHOOK: query: load data local inpath '../../data/files/things2.txt' INTO TABLE things partition(ds='2011-10-24')
POSTHOOK: type: LOAD
#### A masked pattern was here ####
POSTHOOK: Output: default@things
POSTHOOK: Output: default@things@ds=2011-10-24
PREHOOK: query: explain select name,id FROM sales LEFT SEMI JOIN things ON (sales.id = things.id)
PREHOOK: type: QUERY
POSTHOOK: query: explain select name,id FROM sales LEFT SEMI JOIN things ON (sales.id = things.id)
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      File Output Operator [FS_12]
        Join Operator [JOIN_10] (rows=1 width=206)
          Output:["_col0","_col1"],condition map:[{"":"{\"type\":\"Left Semi\",\"left\":0,\"right\":1}"}],keys:{"0":"_col1","1":"_col0"}
        <-Map 1 [PARTITION-LEVEL SORT]
          PARTITION-LEVEL SORT [RS_8]
            PartitionCols:_col1
            Select Operator [SEL_2] (rows=1 width=188)
              Output:["_col0","_col1"]
              Filter Operator [FIL_13] (rows=1 width=188)
                predicate:id is not null
                TableScan [TS_0] (rows=1 width=188)
                  default@sales,sales,Tbl:COMPLETE,Col:NONE,Output:["name","id"]
        <-Map 3 [PARTITION-LEVEL SORT]
          PARTITION-LEVEL SORT [RS_9]
            PartitionCols:_col0
            Group By Operator [GBY_7] (rows=1 width=124)
              Output:["_col0"],keys:_col0
              Select Operator [SEL_5] (rows=1 width=124)
                Output:["_col0"]
                Filter Operator [FIL_14] (rows=1 width=124)
                  predicate:id is not null
                  TableScan [TS_3] (rows=1 width=124)
                    default@things,things,Tbl:PARTIAL,Col:NONE,Output:["id"]

PREHOOK: query: drop table sales
PREHOOK: type: DROPTABLE
PREHOOK: Input: default@sales
PREHOOK: Output: default@sales
POSTHOOK: query: drop table sales
POSTHOOK: type: DROPTABLE
POSTHOOK: Input: default@sales
POSTHOOK: Output: default@sales
PREHOOK: query: drop table things
PREHOOK: type: DROPTABLE
PREHOOK: Input: default@things
PREHOOK: Output: default@things
POSTHOOK: query: drop table things
POSTHOOK: type: DROPTABLE
POSTHOOK: Input: default@things
POSTHOOK: Output: default@things
PREHOOK: query: explain select srcpart.key from srcpart join src on (srcpart.value=src.value) join src1 on (srcpart.key=src1.key) where srcpart.value > 'val_450'
PREHOOK: type: QUERY
POSTHOOK: query: explain select srcpart.key from srcpart join src on (srcpart.value=src.value) join src1 on (srcpart.key=src1.key) where srcpart.value > 'val_450'
POSTHOOK: type: QUERY
Plan optimized by CBO.

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Map 1
      File Output Operator [FS_16]
        Map Join Operator [MAPJOIN_20] (rows=805 width=10)
          Conds:MAPJOIN_21._col1=MAPJOIN_21._col0(Inner),Output:["_col0"]
        <-Map Join Operator [MAPJOIN_21] (rows=732 width=10)
            Conds:SEL_2._col0=SEL_2._col0(Inner),Output:["_col0","_col1"]
          <-Select Operator [SEL_2] (rows=666 width=10)
              Output:["_col0","_col1"]
              Filter Operator [FIL_17] (rows=666 width=10)
                predicate:((value > 'val_450') and key is not null)
                TableScan [TS_0] (rows=2000 width=10)
                  default@srcpart,srcpart,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
      Map Reduce Local Work
        Stage-2
          Map 2
          keys: [HASHTABLESINK_23]
            0_col0,1_col0
            Select Operator [SEL_5] (rows=25 width=7)
              Output:["_col0"]
              Filter Operator [FIL_18] (rows=25 width=7)
                predicate:key is not null
                TableScan [TS_3] (rows=25 width=7)
                  default@src1,src1,Tbl:COMPLETE,Col:NONE,Output:["key"]
          Map Reduce Local Work
          Map 3
          keys: [HASHTABLESINK_26]
            0_col1,1_col0
            Select Operator [SEL_8] (rows=166 width=10)
              Output:["_col0"]
              Filter Operator [FIL_19] (rows=166 width=10)
                predicate:(value > 'val_450')
                TableScan [TS_6] (rows=500 width=10)
                  default@src,src,Tbl:COMPLETE,Col:NONE,Output:["value"]
          Map Reduce Local Work

PREHOOK: query: explain select srcpart.key from srcpart join src on (srcpart.value=src.value) join src1 on (srcpart.key=src1.key) where srcpart.value > 'val_450'
PREHOOK: type: QUERY
POSTHOOK: query: explain select srcpart.key from srcpart join src on (srcpart.value=src.value) join src1 on (srcpart.key=src1.key) where srcpart.value > 'val_450'
POSTHOOK: type: QUERY
Plan optimized by CBO.

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Map 1
      File Output Operator [FS_16]
        Map Join Operator [MAPJOIN_20] (rows=805 width=10)
          Conds:MAPJOIN_21._col1=MAPJOIN_21._col0(Inner),Output:["_col0"]
        <-Map Join Operator [MAPJOIN_21] (rows=732 width=10)
            Conds:SEL_2._col0=SEL_2._col0(Inner),Output:["_col0","_col1"]
          <-Select Operator [SEL_2] (rows=666 width=10)
              Output:["_col0","_col1"]
              Filter Operator [FIL_17] (rows=666 width=10)
                predicate:((value > 'val_450') and key is not null)
                TableScan [TS_0] (rows=2000 width=10)
                  default@srcpart,srcpart,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
      Map Reduce Local Work
        Stage-2
          Map 2
          keys: [HASHTABLESINK_23]
            0_col0,1_col0
            Select Operator [SEL_5] (rows=25 width=7)
              Output:["_col0"]
              Filter Operator [FIL_18] (rows=25 width=7)
                predicate:key is not null
                TableScan [TS_3] (rows=25 width=7)
                  default@src1,src1,Tbl:COMPLETE,Col:NONE,Output:["key"]
          Map Reduce Local Work
          Map 3
          keys: [HASHTABLESINK_26]
            0_col1,1_col0
            Select Operator [SEL_8] (rows=166 width=10)
              Output:["_col0"]
              Filter Operator [FIL_19] (rows=166 width=10)
                predicate:(value > 'val_450')
                TableScan [TS_6] (rows=500 width=10)
                  default@src,src,Tbl:COMPLETE,Col:NONE,Output:["value"]
          Map Reduce Local Work

PREHOOK: query: explain
select p_mfgr, p_name, p_size,
rank() over (partition by p_mfgr order by p_name) as r,
dense_rank() over (partition by p_mfgr order by p_name) as dr,
sum(p_retailprice) over (partition by p_mfgr order by p_name rows between unbounded preceding and current row) as s1
from noop(on part
  partition by p_mfgr
  order by p_name
  )
PREHOOK: type: QUERY
POSTHOOK: query: explain
select p_mfgr, p_name, p_size,
rank() over (partition by p_mfgr order by p_name) as r,
dense_rank() over (partition by p_mfgr order by p_name) as dr,
sum(p_retailprice) over (partition by p_mfgr order by p_name rows between unbounded preceding and current row) as s1
from noop(on part
  partition by p_mfgr
  order by p_name
  )
POSTHOOK: type: QUERY
Plan not optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_9]
        Select Operator [SEL_7] (rows=26 width=239)
          Output:["_col0","_col1","_col2","_col3","_col4","_col5"]
          PTF Operator [PTF_6] (rows=26 width=499)
            Function definitions:[{},{"name:":"windowingtablefunction","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}]
            Select Operator [SEL_5] (rows=26 width=499)
              Output:["_col1","_col2","_col5","_col7"]
            <-Reducer 2 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_4]
                PartitionCols:_col2
                PTF Operator [PTF_3] (rows=26 width=499)
                  Function definitions:[{},{"Partition table definition":{"name:":"noop","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}}]
                  Select Operator [SEL_2] (rows=26 width=499)
                    Output:["_col1","_col2","_col5","_col7"]
                  <-Map 1 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_1]
                      PartitionCols:p_mfgr
                      TableScan [TS_0] (rows=26 width=231)
                        default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_mfgr","p_name","p_retailprice","p_size"]

PREHOOK: query: explain
select p_mfgr, p_name,
p_size, p_size - lag(p_size,1,p_size) over (partition by p_mfgr order by p_name) as deltaSz
from noop (on (select p1.* from part p1 join part p2 on p1.p_partkey = p2.p_partkey) j
distribute by j.p_mfgr
sort by j.p_name)
PREHOOK: type: QUERY
POSTHOOK: query: explain
select p_mfgr, p_name,
p_size, p_size - lag(p_size,1,p_size) over (partition by p_mfgr order by p_name) as deltaSz
from noop (on (select p1.* from part p1 join part p2 on p1.p_partkey = p2.p_partkey) j
distribute by j.p_mfgr
sort by j.p_name)
POSTHOOK: type: QUERY
Plan not optimized by CBO.

Vertex dependency in Stage-1
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_16]
        Select Operator [SEL_14] (rows=27 width=227)
          Output:["_col0","_col1","_col2","_col3"]
          PTF Operator [PTF_13] (rows=27 width=223)
            Function definitions:[{},{"name:":"windowingtablefunction","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}]
            Select Operator [SEL_12] (rows=27 width=223)
              Output:["_col1","_col2","_col5"]
            <-Reducer 2 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_11]
                PartitionCols:_col2
                PTF Operator [PTF_10] (rows=27 width=223)
                  Function definitions:[{},{"Partition table definition":{"name:":"noop","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}}]
                  Select Operator [SEL_9] (rows=27 width=223)
                    Output:["_col1","_col2","_col5"]
                  <-Map 1 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_8]
                      PartitionCols:_col2
                      Map Join Operator [MAPJOIN_19] (rows=27 width=223)
                        Conds:FIL_17.p_partkey=FIL_17.p_partkey(Inner),Output:["_col1","_col2","_col5"]
                      <-Filter Operator [FIL_17] (rows=26 width=227)
                          predicate:p_partkey is not null
                          TableScan [TS_0] (rows=26 width=227)
                            default@part,p1,Tbl:COMPLETE,Col:COMPLETE,Output:["p_partkey","p_name","p_mfgr","p_size"]
                    Map Reduce Local Work
        Stage-2
          Map 4
          keys: [HASHTABLESINK_21]
            0p_partkey,1p_partkey
            Filter Operator [FIL_18] (rows=26 width=4)
              predicate:p_partkey is not null
              TableScan [TS_1] (rows=26 width=4)
                default@part,p2,Tbl:COMPLETE,Col:COMPLETE,Output:["p_partkey"]
          Map Reduce Local Work

PREHOOK: query: explain
select p_mfgr, p_name, p_size,
rank() over (partition by p_mfgr order by p_name) as r,
dense_rank() over (partition by p_mfgr order by p_name) as dr,
sum(p_retailprice) over (partition by p_mfgr order by p_name rows between unbounded preceding and current row) as s1
from noop(on part
  partition by p_mfgr
  order by p_name
  ) abc
PREHOOK: type: QUERY
POSTHOOK: query: explain
select p_mfgr, p_name, p_size,
rank() over (partition by p_mfgr order by p_name) as r,
dense_rank() over (partition by p_mfgr order by p_name) as dr,
sum(p_retailprice) over (partition by p_mfgr order by p_name rows between unbounded preceding and current row) as s1
from noop(on part
  partition by p_mfgr
  order by p_name
  ) abc
POSTHOOK: type: QUERY
Plan not optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_9]
        Select Operator [SEL_7] (rows=26 width=239)
          Output:["_col0","_col1","_col2","_col3","_col4","_col5"]
          PTF Operator [PTF_6] (rows=26 width=499)
            Function definitions:[{},{"name:":"windowingtablefunction","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}]
            Select Operator [SEL_5] (rows=26 width=499)
              Output:["_col1","_col2","_col5","_col7"]
            <-Reducer 2 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_4]
                PartitionCols:_col2
                PTF Operator [PTF_3] (rows=26 width=499)
                  Function definitions:[{},{"Partition table definition":{"name:":"noop","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}}]
                  Select Operator [SEL_2] (rows=26 width=499)
                    Output:["_col1","_col2","_col5","_col7"]
                  <-Map 1 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_1]
                      PartitionCols:p_mfgr
                      TableScan [TS_0] (rows=26 width=231)
                        default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_mfgr","p_name","p_retailprice","p_size"]

PREHOOK: query: explain
select p_mfgr, p_name, p_size,
rank() over (partition by p_mfgr order by p_name) as r,
dense_rank() over (partition by p_mfgr order by p_name) as dr,
p_size, p_size - lag(p_size,1,p_size) over (partition by p_mfgr order by p_name) as deltaSz
from noop(on part
          partition by p_mfgr
          order by p_name
          )
PREHOOK: type: QUERY
POSTHOOK: query: explain
select p_mfgr, p_name, p_size,
rank() over (partition by p_mfgr order by p_name) as r,
dense_rank() over (partition by p_mfgr order by p_name) as dr,
p_size, p_size - lag(p_size,1,p_size) over (partition by p_mfgr order by p_name) as deltaSz
from noop(on part
          partition by p_mfgr
          order by p_name
          )
POSTHOOK: type: QUERY
Plan not optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_9]
        Select Operator [SEL_7] (rows=26 width=239)
          Output:["_col0","_col1","_col2","_col3","_col4","_col5","_col6"]
          PTF Operator [PTF_6] (rows=26 width=491)
            Function definitions:[{},{"name:":"windowingtablefunction","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}]
            Select Operator [SEL_5] (rows=26 width=491)
              Output:["_col1","_col2","_col5"]
            <-Reducer 2 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_4]
                PartitionCols:_col2
                PTF Operator [PTF_3] (rows=26 width=491)
                  Function definitions:[{},{"Partition table definition":{"name:":"noop","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}}]
                  Select Operator [SEL_2] (rows=26 width=491)
                    Output:["_col1","_col2","_col5"]
                  <-Map 1 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_1]
                      PartitionCols:p_mfgr
                      TableScan [TS_0] (rows=26 width=223)
                        default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_mfgr","p_name","p_size"]

PREHOOK: query: explain
select p_mfgr, p_name, p_size,
rank() over (partition by p_mfgr order by p_name) as r,
dense_rank() over (partition by p_mfgr order by p_name) as dr,
p_size, p_size - lag(p_size,1,p_size) over (partition by p_mfgr order by p_name) as deltaSz
from noop(on part
          partition by p_mfgr
          order by p_name
          )
group by p_mfgr, p_name, p_size
PREHOOK: type: QUERY
POSTHOOK: query: explain
select p_mfgr, p_name, p_size,
rank() over (partition by p_mfgr order by p_name) as r,
dense_rank() over (partition by p_mfgr order by p_name) as dr,
p_size, p_size - lag(p_size,1,p_size) over (partition by p_mfgr order by p_name) as deltaSz
from noop(on part
          partition by p_mfgr
          order by p_name
          )
group by p_mfgr, p_name, p_size
POSTHOOK: type: QUERY
Plan not optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (GROUP PARTITION-LEVEL SORT)
Reducer 4 <- Reducer 3 (GROUP PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 4
      File Output Operator [FS_14]
        Select Operator [SEL_12] (rows=26 width=239)
          Output:["_col0","_col1","_col2","_col3","_col4","_col5","_col6"]
          PTF Operator [PTF_11] (rows=26 width=223)
            Function definitions:[{},{"name:":"windowingtablefunction","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col0"}]
            Group By Operator [GBY_8] (rows=26 width=223)
              Output:["_col0","_col1","_col2"],keys:KEY._col0, KEY._col1, KEY._col2
            <-Reducer 3 [GROUP PARTITION-LEVEL SORT]
              GROUP PARTITION-LEVEL SORT [RS_7]
                PartitionCols:_col0
                Group By Operator [GBY_6] (rows=26 width=223)
                  Output:["_col0","_col1","_col2"],keys:KEY._col0, KEY._col1, KEY._col2
                <-Reducer 2 [GROUP PARTITION-LEVEL SORT]
                  GROUP PARTITION-LEVEL SORT [RS_5]
                    PartitionCols:rand()
                    Select Operator [SEL_4] (rows=26 width=491)
                      Output:["_col1","_col2","_col5"]
                      PTF Operator [PTF_3] (rows=26 width=491)
                        Function definitions:[{},{"Partition table definition":{"name:":"noop","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}}]
                        Select Operator [SEL_2] (rows=26 width=491)
                          Output:["_col1","_col2","_col5"]
                        <-Map 1 [PARTITION-LEVEL SORT]
                          PARTITION-LEVEL SORT [RS_1]
                            PartitionCols:p_mfgr
                            TableScan [TS_0] (rows=26 width=223)
                              default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_mfgr","p_name","p_size"]

PREHOOK: query: explain
select abc.*
from noop(on part
partition by p_mfgr
order by p_name
) abc join part p1 on abc.p_partkey = p1.p_partkey
PREHOOK: type: QUERY
POSTHOOK: query: explain
select abc.*
from noop(on part
partition by p_mfgr
order by p_name
) abc join part p1 on abc.p_partkey = p1.p_partkey
POSTHOOK: type: QUERY
Plan not optimized by CBO.

Vertex dependency in Stage-1
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2
      Map Reduce Local Work
      <-Map 1 [PARTITION-LEVEL SORT]
        PARTITION-LEVEL SORT [RS_2]
          PartitionCols:p_mfgr
          TableScan [TS_0] (rows=26 width=619)
            default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_brand","p_comment","p_container","p_mfgr","p_name","p_partkey","p_retailprice","p_size","p_type"]
      File Output Operator [FS_11]
        Map Join Operator [MAPJOIN_14] (rows=27 width=619)
          Conds:FIL_12._col0=FIL_12.p_partkey(Inner),Output:["_col0","_col1","_col2","_col3","_col4","_col5","_col6","_col7","_col8"]
        <-Filter Operator [FIL_12] (rows=26 width=887)
            predicate:_col0 is not null
            PTF Operator [PTF_4] (rows=26 width=887)
              Function definitions:[{},{"Partition table definition":{"name:":"noop","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}}]
              Select Operator [SEL_3] (rows=26 width=887)
                Output:["_col0","_col1","_col2","_col3","_col4","_col5","_col6","_col7","_col8"]
              <- Please refer to the previous Map 1 [PARTITION-LEVEL SORT]
        Stage-2
          Map 3
          keys: [HASHTABLESINK_16]
            0_col0,1p_partkey
            Filter Operator [FIL_13] (rows=26 width=4)
              predicate:p_partkey is not null
              TableScan [TS_1] (rows=26 width=4)
                default@part,p1,Tbl:COMPLETE,Col:COMPLETE,Output:["p_partkey"]
          Map Reduce Local Work

PREHOOK: query: explain
select p_mfgr, p_name, p_size,
rank() over (partition by p_mfgr order by p_name, p_size desc) as r
from noopwithmap(on part
partition by p_mfgr
order by p_name, p_size desc)
PREHOOK: type: QUERY
POSTHOOK: query: explain
select p_mfgr, p_name, p_size,
rank() over (partition by p_mfgr order by p_name, p_size desc) as r
from noopwithmap(on part
partition by p_mfgr
order by p_name, p_size desc)
POSTHOOK: type: QUERY
Plan not optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_10]
        Select Operator [SEL_8] (rows=26 width=227)
          Output:["_col0","_col1","_col2","_col3"]
          PTF Operator [PTF_7] (rows=26 width=491)
            Function definitions:[{},{"name:":"windowingtablefunction","order by:":"_col1 ASC NULLS FIRST, _col5 DESC NULLS LAST","partition by:":"_col2"}]
            Select Operator [SEL_6] (rows=26 width=491)
              Output:["_col1","_col2","_col5"]
            <-Reducer 2 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_5]
                PartitionCols:_col2
                PTF Operator [PTF_4] (rows=26 width=491)
                  Function definitions:[{},{"Partition table definition":{"name:":"noopwithmap","order by:":"_col1 ASC NULLS FIRST, _col5 DESC NULLS LAST","partition by:":"_col2"}}]
                  Select Operator [SEL_3] (rows=26 width=491)
                    Output:["_col1","_col2","_col5"]
                  <-Map 1 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_2]
                      PartitionCols:p_mfgr
                      PTF Operator [PTF_1] (rows=26 width=223)
                        Function definitions:[{},{"Partition table definition":{"name:":"noopwithmap","order by:":"p_name ASC NULLS FIRST, p_size DESC NULLS LAST","partition by:":"p_mfgr"}}]
                        TableScan [TS_0] (rows=26 width=223)
                          default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_name","p_mfgr","p_size"]

PREHOOK: query: explain
select p_mfgr, p_name, p_size,
rank() over (partition by p_mfgr order by p_name) as r,
dense_rank() over (partition by p_mfgr order by p_name) as dr,
sum(p_retailprice) over (partition by p_mfgr order by p_name rows between unbounded preceding and current row) as s1
from noopwithmap(on part
  partition by p_mfgr
  order by p_name)
PREHOOK: type: QUERY
POSTHOOK: query: explain
select p_mfgr, p_name, p_size,
rank() over (partition by p_mfgr order by p_name) as r,
dense_rank() over (partition by p_mfgr order by p_name) as dr,
sum(p_retailprice) over (partition by p_mfgr order by p_name rows between unbounded preceding and current row) as s1
from noopwithmap(on part
  partition by p_mfgr
  order by p_name)
POSTHOOK: type: QUERY
Plan not optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_10]
        Select Operator [SEL_8] (rows=26 width=239)
          Output:["_col0","_col1","_col2","_col3","_col4","_col5"]
          PTF Operator [PTF_7] (rows=26 width=499)
            Function definitions:[{},{"name:":"windowingtablefunction","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}]
            Select Operator [SEL_6] (rows=26 width=499)
              Output:["_col1","_col2","_col5","_col7"]
            <-Reducer 2 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_5]
                PartitionCols:_col2
                PTF Operator [PTF_4] (rows=26 width=499)
                  Function definitions:[{},{"Partition table definition":{"name:":"noopwithmap","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}}]
                  Select Operator [SEL_3] (rows=26 width=499)
                    Output:["_col1","_col2","_col5","_col7"]
                  <-Map 1 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_2]
                      PartitionCols:p_mfgr
                      PTF Operator [PTF_1] (rows=26 width=231)
                        Function definitions:[{},{"Partition table definition":{"name:":"noopwithmap","order by:":"p_name ASC NULLS FIRST","partition by:":"p_mfgr"}}]
                        TableScan [TS_0] (rows=26 width=231)
                          default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_name","p_mfgr","p_size","p_retailprice"]

PREHOOK: query: explain
select p_mfgr, p_name, p_size,
rank() over (partition by p_mfgr order by p_name) as r,
dense_rank() over (partition by p_mfgr order by p_name) as dr,
sum(p_retailprice) over (partition by p_mfgr order by p_name rows between unbounded preceding and current row) as s1
from noop(on part
partition by p_mfgr
order by p_name)
PREHOOK: type: QUERY
POSTHOOK: query: explain
select p_mfgr, p_name, p_size,
rank() over (partition by p_mfgr order by p_name) as r,
dense_rank() over (partition by p_mfgr order by p_name) as dr,
sum(p_retailprice) over (partition by p_mfgr order by p_name rows between unbounded preceding and current row) as s1
from noop(on part
partition by p_mfgr
order by p_name)
POSTHOOK: type: QUERY
Plan not optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_9]
        Select Operator [SEL_7] (rows=26 width=239)
          Output:["_col0","_col1","_col2","_col3","_col4","_col5"]
          PTF Operator [PTF_6] (rows=26 width=499)
            Function definitions:[{},{"name:":"windowingtablefunction","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}]
            Select Operator [SEL_5] (rows=26 width=499)
              Output:["_col1","_col2","_col5","_col7"]
            <-Reducer 2 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_4]
                PartitionCols:_col2
                PTF Operator [PTF_3] (rows=26 width=499)
                  Function definitions:[{},{"Partition table definition":{"name:":"noop","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}}]
                  Select Operator [SEL_2] (rows=26 width=499)
                    Output:["_col1","_col2","_col5","_col7"]
                  <-Map 1 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_1]
                      PartitionCols:p_mfgr
                      TableScan [TS_0] (rows=26 width=231)
                        default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_mfgr","p_name","p_retailprice","p_size"]

PREHOOK: query: explain
select p_mfgr, p_name, p_size,
rank() over (partition by p_mfgr order by p_name) as r,
dense_rank() over (partition by p_mfgr order by p_name) as dr,
sum(p_retailprice) over (partition by p_mfgr order by p_name rows between unbounded preceding and current row)  as s1
from noop(on noopwithmap(on noop(on part
partition by p_mfgr
order by p_mfgr DESC, p_name
)))
PREHOOK: type: QUERY
POSTHOOK: query: explain
select p_mfgr, p_name, p_size,
rank() over (partition by p_mfgr order by p_name) as r,
dense_rank() over (partition by p_mfgr order by p_name) as dr,
sum(p_retailprice) over (partition by p_mfgr order by p_name rows between unbounded preceding and current row)  as s1
from noop(on noopwithmap(on noop(on part
partition by p_mfgr
order by p_mfgr DESC, p_name
)))
POSTHOOK: type: QUERY
Plan not optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT)
Reducer 4 <- Reducer 3 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 4
      File Output Operator [FS_13]
        Select Operator [SEL_11] (rows=26 width=239)
          Output:["_col0","_col1","_col2","_col3","_col4","_col5"]
          PTF Operator [PTF_10] (rows=26 width=499)
            Function definitions:[{},{"name:":"windowingtablefunction","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}]
            Select Operator [SEL_9] (rows=26 width=499)
              Output:["_col1","_col2","_col5","_col7"]
            <-Reducer 3 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_8]
                PartitionCols:_col2
                PTF Operator [PTF_7] (rows=26 width=499)
                  Function definitions:[{},{"Partition table definition":{"name:":"noopwithmap","order by:":"_col2 DESC NULLS LAST, _col1 ASC NULLS FIRST","partition by:":"_col2"}},{"Partition table definition":{"name:":"noop","order by:":"_col2 DESC NULLS LAST, _col1 ASC NULLS FIRST","partition by:":"_col2"}}]
                  Select Operator [SEL_6] (rows=26 width=499)
                    Output:["_col1","_col2","_col5","_col7"]
                  <-Reducer 2 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_5]
                      PartitionCols:_col2
                      PTF Operator [PTF_4] (rows=26 width=499)
                        Function definitions:[{},{"Partition table definition":{"name:":"noopwithmap","order by:":"_col2 DESC NULLS LAST, _col1 ASC NULLS FIRST","partition by:":"_col2"}},{"Partition table definition":{"name:":"noop","order by:":"_col2 DESC NULLS LAST, _col1 ASC NULLS FIRST","partition by:":"_col2"}}]
                        PTF Operator [PTF_3] (rows=26 width=499)
                          Function definitions:[{},{"Partition table definition":{"name:":"noop","order by:":"_col2 DESC NULLS LAST, _col1 ASC NULLS FIRST","partition by:":"_col2"}}]
                          Select Operator [SEL_2] (rows=26 width=499)
                            Output:["_col1","_col2","_col5","_col7"]
                          <-Map 1 [PARTITION-LEVEL SORT]
                            PARTITION-LEVEL SORT [RS_1]
                              PartitionCols:p_mfgr
                              TableScan [TS_0] (rows=26 width=231)
                                default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_mfgr","p_name","p_retailprice","p_size"]

PREHOOK: query: explain
select p_mfgr, p_name,
sub1.cd, sub1.s1
from (select p_mfgr, p_name,
count(p_size) over (partition by p_mfgr order by p_name) as cd,
p_retailprice,
sum(p_retailprice) over w1  as s1
from noop(on part
partition by p_mfgr
order by p_name)
window w1 as (partition by p_mfgr order by p_name rows between 2 preceding and 2 following)
) sub1
PREHOOK: type: QUERY
POSTHOOK: query: explain
select p_mfgr, p_name,
sub1.cd, sub1.s1
from (select p_mfgr, p_name,
count(p_size) over (partition by p_mfgr order by p_name) as cd,
p_retailprice,
sum(p_retailprice) over w1  as s1
from noop(on part
partition by p_mfgr
order by p_name)
window w1 as (partition by p_mfgr order by p_name rows between 2 preceding and 2 following)
) sub1
POSTHOOK: type: QUERY
Plan not optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_10]
        Select Operator [SEL_7] (rows=26 width=235)
          Output:["_col0","_col1","_col2","_col3"]
          PTF Operator [PTF_6] (rows=26 width=499)
            Function definitions:[{},{"name:":"windowingtablefunction","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}]
            Select Operator [SEL_5] (rows=26 width=499)
              Output:["_col1","_col2","_col5","_col7"]
            <-Reducer 2 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_4]
                PartitionCols:_col2
                PTF Operator [PTF_3] (rows=26 width=499)
                  Function definitions:[{},{"Partition table definition":{"name:":"noop","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}}]
                  Select Operator [SEL_2] (rows=26 width=499)
                    Output:["_col1","_col2","_col5","_col7"]
                  <-Map 1 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_1]
                      PartitionCols:p_mfgr
                      TableScan [TS_0] (rows=26 width=231)
                        default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_mfgr","p_name","p_retailprice","p_size"]

PREHOOK: query: explain
select abc.p_mfgr, abc.p_name,
rank() over (distribute by abc.p_mfgr sort by abc.p_name) as r,
dense_rank() over (distribute by abc.p_mfgr sort by abc.p_name) as dr,
count(abc.p_name) over (distribute by abc.p_mfgr sort by abc.p_name) as cd,
abc.p_retailprice, sum(abc.p_retailprice) over (distribute by abc.p_mfgr sort by abc.p_name rows between unbounded preceding and current row) as s1,
abc.p_size, abc.p_size - lag(abc.p_size,1,abc.p_size) over (distribute by abc.p_mfgr sort by abc.p_name) as deltaSz
from noop(on part
partition by p_mfgr
order by p_name
) abc join part p1 on abc.p_partkey = p1.p_partkey
PREHOOK: type: QUERY
POSTHOOK: query: explain
select abc.p_mfgr, abc.p_name,
rank() over (distribute by abc.p_mfgr sort by abc.p_name) as r,
dense_rank() over (distribute by abc.p_mfgr sort by abc.p_name) as dr,
count(abc.p_name) over (distribute by abc.p_mfgr sort by abc.p_name) as cd,
abc.p_retailprice, sum(abc.p_retailprice) over (distribute by abc.p_mfgr sort by abc.p_name rows between unbounded preceding and current row) as s1,
abc.p_size, abc.p_size - lag(abc.p_size,1,abc.p_size) over (distribute by abc.p_mfgr sort by abc.p_name) as deltaSz
from noop(on part
partition by p_mfgr
order by p_name
) abc join part p1 on abc.p_partkey = p1.p_partkey
POSTHOOK: type: QUERY
Plan not optimized by CBO.

Vertex dependency in Stage-1
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_15]
        Select Operator [SEL_13] (rows=27 width=259)
          Output:["_col0","_col1","_col2","_col3","_col4","_col5","_col6","_col7","_col8"]
          PTF Operator [PTF_12] (rows=27 width=767)
            Function definitions:[{},{"name:":"windowingtablefunction","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}]
            Select Operator [SEL_11] (rows=27 width=767)
              Output:["_col1","_col2","_col5","_col7"]
            <-Reducer 2 [PARTITION-LEVEL SORT]
              Map Reduce Local Work
              <-Map 1 [PARTITION-LEVEL SORT]
                PARTITION-LEVEL SORT [RS_2]
                  PartitionCols:p_mfgr
                  TableScan [TS_0] (rows=26 width=235)
                    default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_mfgr","p_name","p_partkey","p_retailprice","p_size"]
              PARTITION-LEVEL SORT [RS_10]
                PartitionCols:_col2
                Map Join Operator [MAPJOIN_18] (rows=27 width=231)
                  Conds:FIL_16._col0=FIL_16.p_partkey(Inner),Output:["_col1","_col2","_col5","_col7"]
                <-Filter Operator [FIL_16] (rows=26 width=503)
                    predicate:_col0 is not null
                    PTF Operator [PTF_4] (rows=26 width=503)
                      Function definitions:[{},{"Partition table definition":{"name:":"noop","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}}]
                      Select Operator [SEL_3] (rows=26 width=503)
                        Output:["_col0","_col1","_col2","_col5","_col7"]
                      <- Please refer to the previous Map 1 [PARTITION-LEVEL SORT]
        Stage-2
          Map 4
          keys: [HASHTABLESINK_20]
            0_col0,1p_partkey
            Filter Operator [FIL_17] (rows=26 width=4)
              predicate:p_partkey is not null
              TableScan [TS_1] (rows=26 width=4)
                default@part,p1,Tbl:COMPLETE,Col:COMPLETE,Output:["p_partkey"]
          Map Reduce Local Work

PREHOOK: query: explain create view IF NOT EXISTS mfgr_price_view as
select p_mfgr, p_brand,
sum(p_retailprice) as s
from part
group by p_mfgr, p_brand
PREHOOK: type: CREATEVIEW
POSTHOOK: query: explain create view IF NOT EXISTS mfgr_price_view as
select p_mfgr, p_brand,
sum(p_retailprice) as s
from part
group by p_mfgr, p_brand
POSTHOOK: type: CREATEVIEW
Plan optimized by CBO.

Stage-1
  Create View Operator:
    name:default.mfgr_price_view,original text:select p_mfgr, p_brand,
sum(p_retailprice) as s
from part
group by p_mfgr, p_brand

PREHOOK: query: CREATE TABLE part_4(
p_mfgr STRING,
p_name STRING,
p_size INT,
r INT,
dr INT,
s DOUBLE)
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@part_4
POSTHOOK: query: CREATE TABLE part_4(
p_mfgr STRING,
p_name STRING,
p_size INT,
r INT,
dr INT,
s DOUBLE)
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@part_4
PREHOOK: query: CREATE TABLE part_5(
p_mfgr STRING,
p_name STRING,
p_size INT,
s2 INT,
r INT,
dr INT,
cud DOUBLE,
fv1 INT)
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@part_5
POSTHOOK: query: CREATE TABLE part_5(
p_mfgr STRING,
p_name STRING,
p_size INT,
s2 INT,
r INT,
dr INT,
cud DOUBLE,
fv1 INT)
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@part_5
PREHOOK: query: explain
from noop(on part
partition by p_mfgr
order by p_name)
INSERT OVERWRITE TABLE part_4 select p_mfgr, p_name, p_size,
rank() over (distribute by p_mfgr sort by p_name) as r,
dense_rank() over (distribute by p_mfgr sort by p_name) as dr,
sum(p_retailprice) over (distribute by p_mfgr sort by p_name rows between unbounded preceding and current row)  as s
INSERT OVERWRITE TABLE part_5 select  p_mfgr,p_name, p_size,
round(sum(p_size) over (distribute by p_mfgr sort by p_size range between 5 preceding and current row),1) as s2,
rank() over (distribute by p_mfgr sort by p_mfgr, p_name) as r,
dense_rank() over (distribute by p_mfgr sort by p_mfgr, p_name) as dr,
cume_dist() over (distribute by p_mfgr sort by p_mfgr, p_name) as cud,
first_value(p_size, true) over w1  as fv1
window w1 as (distribute by p_mfgr sort by p_mfgr, p_name rows between 2 preceding and 2 following)
PREHOOK: type: QUERY
POSTHOOK: query: explain
from noop(on part
partition by p_mfgr
order by p_name)
INSERT OVERWRITE TABLE part_4 select p_mfgr, p_name, p_size,
rank() over (distribute by p_mfgr sort by p_name) as r,
dense_rank() over (distribute by p_mfgr sort by p_name) as dr,
sum(p_retailprice) over (distribute by p_mfgr sort by p_name rows between unbounded preceding and current row)  as s
INSERT OVERWRITE TABLE part_5 select  p_mfgr,p_name, p_size,
round(sum(p_size) over (distribute by p_mfgr sort by p_size range between 5 preceding and current row),1) as s2,
rank() over (distribute by p_mfgr sort by p_mfgr, p_name) as r,
dense_rank() over (distribute by p_mfgr sort by p_mfgr, p_name) as dr,
cume_dist() over (distribute by p_mfgr sort by p_mfgr, p_name) as cud,
first_value(p_size, true) over w1  as fv1
window w1 as (distribute by p_mfgr sort by p_mfgr, p_name rows between 2 preceding and 2 following)
POSTHOOK: type: QUERY
Plan not optimized by CBO.

Vertex dependency in root stage
Reducer 3 <- Reducer 6 (PARTITION-LEVEL SORT)
Reducer 4 <- Reducer 7 (PARTITION-LEVEL SORT)
Reducer 5 <- Reducer 4 (PARTITION-LEVEL SORT)
Reducer 6 <- Map 1 (PARTITION-LEVEL SORT)
Reducer 7 <- Map 1 (PARTITION-LEVEL SORT)

Stage-3
  Stats Work{}
    Stage-0
      Move Operator
        table:{"name:":"default.part_4"}
        Stage-2
          Reducer 3
          File Output Operator [FS_9]
            table:{"name:":"default.part_4"}
            Select Operator [SEL_7] (rows=26 width=239)
              Output:["_col0","_col1","_col2","_col3","_col4","_col5"]
              PTF Operator [PTF_6] (rows=26 width=499)
                Function definitions:[{},{"name:":"windowingtablefunction","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}]
                Select Operator [SEL_5] (rows=26 width=499)
                  Output:["_col1","_col2","_col5","_col7"]
                <-Reducer 6 [PARTITION-LEVEL SORT]
                  PARTITION-LEVEL SORT [RS_4]
                    PartitionCols:_col2
                    PTF Operator [PTF_3] (rows=26 width=499)
                      Function definitions:[{},{"Partition table definition":{"name:":"noop","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}}]
                      Select Operator [SEL_2] (rows=26 width=499)
                        Output:["_col1","_col2","_col5","_col7"]
                      <-Map 1 [PARTITION-LEVEL SORT]
                        PARTITION-LEVEL SORT [RS_1]
                          PartitionCols:p_mfgr
                          TableScan [TS_0] (rows=26 width=231)
                            default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_mfgr","p_name","p_retailprice","p_size"]
          Reducer 5
          File Output Operator [FS_20]
            table:{"name:":"default.part_5"}
            Select Operator [SEL_17] (rows=26 width=247)
              Output:["_col0","_col1","_col2","_col3","_col4","_col5","_col6","_col7"]
              PTF Operator [PTF_16] (rows=26 width=499)
                Function definitions:[{},{"name:":"windowingtablefunction","order by:":"_col3 ASC NULLS FIRST, _col2 ASC NULLS FIRST","partition by:":"_col3"}]
                Select Operator [SEL_15] (rows=26 width=499)
                  Output:["_col0","_col2","_col3","_col6"]
                <-Reducer 4 [PARTITION-LEVEL SORT]
                  PARTITION-LEVEL SORT [RS_14]
                    PartitionCols:_col2
                    Select Operator [SEL_13] (rows=26 width=491)
                      Output:["sum_window_0","_col1","_col2","_col5"]
                      PTF Operator [PTF_12] (rows=26 width=491)
                        Function definitions:[{},{"name:":"windowingtablefunction","order by:":"_col5 ASC NULLS FIRST","partition by:":"_col2"}]
                        Select Operator [SEL_11] (rows=26 width=491)
                          Output:["_col1","_col2","_col5"]
                        <-Reducer 7 [PARTITION-LEVEL SORT]
                          PARTITION-LEVEL SORT [RS_10]
                            PartitionCols:_col2
                            PTF Operator [PTF_3] (rows=26 width=499)
                              Function definitions:[{},{"Partition table definition":{"name:":"noop","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}}]
                              Select Operator [SEL_2] (rows=26 width=499)
                                Output:["_col1","_col2","_col5","_col7"]
                              <- Please refer to the previous Map 1 [PARTITION-LEVEL SORT]
Stage-4
  Stats Work{}
    Stage-1
      Move Operator
        table:{"name:":"default.part_5"}
         Please refer to the previous Stage-2

PREHOOK: query: explain
select p_mfgr, p_name,
rank() over (partition by p_mfgr,p_name) as r,
dense_rank() over (partition by p_mfgr,p_name) as dr,
p_size, sum(p_size) over (partition by p_mfgr,p_name rows between unbounded preceding and current row)  as s1
from noop(on
        noopwithmap(on
          noop(on
              noop(on part
              partition by p_mfgr
              order by p_mfgr)
            )
          partition by p_mfgr,p_name
          order by p_mfgr,p_name)
        partition by p_mfgr,p_name
        order by p_mfgr,p_name)
PREHOOK: type: QUERY
POSTHOOK: query: explain
select p_mfgr, p_name,
rank() over (partition by p_mfgr,p_name) as r,
dense_rank() over (partition by p_mfgr,p_name) as dr,
p_size, sum(p_size) over (partition by p_mfgr,p_name rows between unbounded preceding and current row)  as s1
from noop(on
        noopwithmap(on
          noop(on
              noop(on part
              partition by p_mfgr
              order by p_mfgr)
            )
          partition by p_mfgr,p_name
          order by p_mfgr,p_name)
        partition by p_mfgr,p_name
        order by p_mfgr,p_name)
POSTHOOK: type: QUERY
Plan not optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT)
Reducer 4 <- Reducer 3 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 4
      File Output Operator [FS_13]
        Select Operator [SEL_11] (rows=26 width=239)
          Output:["_col0","_col1","_col2","_col3","_col4","_col5"]
          PTF Operator [PTF_10] (rows=26 width=491)
            Function definitions:[{},{"name:":"windowingtablefunction","order by:":"_col2 ASC NULLS FIRST, _col1 ASC NULLS FIRST","partition by:":"_col2, _col1"}]
            Select Operator [SEL_9] (rows=26 width=491)
              Output:["_col1","_col2","_col5"]
            <-Reducer 3 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_8]
                PartitionCols:_col2, _col1
                PTF Operator [PTF_7] (rows=26 width=491)
                  Function definitions:[{},{"Partition table definition":{"name:":"noopwithmap","order by:":"_col2 ASC NULLS FIRST, _col1 ASC NULLS FIRST","partition by:":"_col2, _col1"}},{"Partition table definition":{"name:":"noop","order by:":"_col2 ASC NULLS FIRST, _col1 ASC NULLS FIRST","partition by:":"_col2, _col1"}}]
                  Select Operator [SEL_6] (rows=26 width=491)
                    Output:["_col1","_col2","_col5"]
                  <-Reducer 2 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_5]
                      PartitionCols:_col2, _col1
                      PTF Operator [PTF_4] (rows=26 width=491)
                        Function definitions:[{},{"Partition table definition":{"name:":"noopwithmap","order by:":"_col2 ASC NULLS FIRST, _col1 ASC NULLS FIRST","partition by:":"_col2, _col1"}},{"Partition table definition":{"name:":"noop","order by:":"_col2 ASC NULLS FIRST, _col1 ASC NULLS FIRST","partition by:":"_col2, _col1"}}]
                        PTF Operator [PTF_3] (rows=26 width=491)
                          Function definitions:[{},{"Partition table definition":{"name:":"noop","order by:":"_col2 ASC NULLS FIRST","partition by:":"_col2"}},{"Partition table definition":{"name:":"noop","order by:":"_col2 ASC NULLS FIRST","partition by:":"_col2"}}]
                          Select Operator [SEL_2] (rows=26 width=491)
                            Output:["_col1","_col2","_col5"]
                          <-Map 1 [PARTITION-LEVEL SORT]
                            PARTITION-LEVEL SORT [RS_1]
                              PartitionCols:p_mfgr
                              TableScan [TS_0] (rows=26 width=223)
                                default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_mfgr","p_name","p_size"]

PREHOOK: query: explain
select p_mfgr, p_name,
rank() over (partition by p_mfgr order by p_name) as r,
dense_rank() over (partition by p_mfgr order by p_name) as dr,
p_size, sum(p_size) over (partition by p_mfgr order by p_name rows between unbounded preceding and current row)  as s1
from noop(on
        noop(on
          noop(on
              noop(on part
              partition by p_mfgr
              order by p_mfgr)
            )
          partition by p_mfgr,p_name
          order by p_mfgr,p_name)
        partition by p_mfgr
        order by p_mfgr )
PREHOOK: type: QUERY
POSTHOOK: query: explain
select p_mfgr, p_name,
rank() over (partition by p_mfgr order by p_name) as r,
dense_rank() over (partition by p_mfgr order by p_name) as dr,
p_size, sum(p_size) over (partition by p_mfgr order by p_name rows between unbounded preceding and current row)  as s1
from noop(on
        noop(on
          noop(on
              noop(on part
              partition by p_mfgr
              order by p_mfgr)
            )
          partition by p_mfgr,p_name
          order by p_mfgr,p_name)
        partition by p_mfgr
        order by p_mfgr )
POSTHOOK: type: QUERY
Plan not optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT)
Reducer 4 <- Reducer 3 (PARTITION-LEVEL SORT)
Reducer 5 <- Reducer 4 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 5
      File Output Operator [FS_15]
        Select Operator [SEL_13] (rows=26 width=239)
          Output:["_col0","_col1","_col2","_col3","_col4","_col5"]
          PTF Operator [PTF_12] (rows=26 width=491)
            Function definitions:[{},{"name:":"windowingtablefunction","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}]
            Select Operator [SEL_11] (rows=26 width=491)
              Output:["_col1","_col2","_col5"]
            <-Reducer 4 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_10]
                PartitionCols:_col2
                PTF Operator [PTF_9] (rows=26 width=491)
                  Function definitions:[{},{"Partition table definition":{"name:":"noop","order by:":"_col2 ASC NULLS FIRST","partition by:":"_col2"}}]
                  Select Operator [SEL_8] (rows=26 width=491)
                    Output:["_col1","_col2","_col5"]
                  <-Reducer 3 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_7]
                      PartitionCols:_col2
                      PTF Operator [PTF_6] (rows=26 width=491)
                        Function definitions:[{},{"Partition table definition":{"name:":"noop","order by:":"_col2 ASC NULLS FIRST, _col1 ASC NULLS FIRST","partition by:":"_col2, _col1"}}]
                        Select Operator [SEL_5] (rows=26 width=491)
                          Output:["_col1","_col2","_col5"]
                        <-Reducer 2 [PARTITION-LEVEL SORT]
                          PARTITION-LEVEL SORT [RS_4]
                            PartitionCols:_col2, _col1
                            PTF Operator [PTF_3] (rows=26 width=491)
                              Function definitions:[{},{"Partition table definition":{"name:":"noop","order by:":"_col2 ASC NULLS FIRST","partition by:":"_col2"}},{"Partition table definition":{"name:":"noop","order by:":"_col2 ASC NULLS FIRST","partition by:":"_col2"}}]
                              Select Operator [SEL_2] (rows=26 width=491)
                                Output:["_col1","_col2","_col5"]
                              <-Map 1 [PARTITION-LEVEL SORT]
                                PARTITION-LEVEL SORT [RS_1]
                                  PartitionCols:p_mfgr
                                  TableScan [TS_0] (rows=26 width=223)
                                    default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_mfgr","p_name","p_size"]

PREHOOK: query: explain
select p_mfgr, p_name,
rank() over (partition by p_mfgr order by p_name) as r,
dense_rank() over (partition by p_mfgr order by p_name) as dr,
p_size, sum(p_size) over (partition by p_mfgr order by p_name) as s1
from noop(on
        noop(on
          noop(on
              noop(on part
              partition by p_mfgr,p_name
              order by p_mfgr,p_name)
            )
          partition by p_mfgr
          order by p_mfgr))
PREHOOK: type: QUERY
POSTHOOK: query: explain
select p_mfgr, p_name,
rank() over (partition by p_mfgr order by p_name) as r,
dense_rank() over (partition by p_mfgr order by p_name) as dr,
p_size, sum(p_size) over (partition by p_mfgr order by p_name) as s1
from noop(on
        noop(on
          noop(on
              noop(on part
              partition by p_mfgr,p_name
              order by p_mfgr,p_name)
            )
          partition by p_mfgr
          order by p_mfgr))
POSTHOOK: type: QUERY
Plan not optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (PARTITION-LEVEL SORT)
Reducer 4 <- Reducer 3 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 4
      File Output Operator [FS_12]
        Select Operator [SEL_10] (rows=26 width=239)
          Output:["_col0","_col1","_col2","_col3","_col4","_col5"]
          PTF Operator [PTF_9] (rows=26 width=491)
            Function definitions:[{},{"name:":"windowingtablefunction","order by:":"_col1 ASC NULLS FIRST","partition by:":"_col2"}]
            Select Operator [SEL_8] (rows=26 width=491)
              Output:["_col1","_col2","_col5"]
            <-Reducer 3 [PARTITION-LEVEL SORT]
              PARTITION-LEVEL SORT [RS_7]
                PartitionCols:_col2
                PTF Operator [PTF_6] (rows=26 width=491)
                  Function definitions:[{},{"Partition table definition":{"name:":"noop","order by:":"_col2 ASC NULLS FIRST","partition by:":"_col2"}},{"Partition table definition":{"name:":"noop","order by:":"_col2 ASC NULLS FIRST","partition by:":"_col2"}}]
                  Select Operator [SEL_5] (rows=26 width=491)
                    Output:["_col1","_col2","_col5"]
                  <-Reducer 2 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_4]
                      PartitionCols:_col2
                      PTF Operator [PTF_3] (rows=26 width=491)
                        Function definitions:[{},{"Partition table definition":{"name:":"noop","order by:":"_col2 ASC NULLS FIRST, _col1 ASC NULLS FIRST","partition by:":"_col2, _col1"}},{"Partition table definition":{"name:":"noop","order by:":"_col2 ASC NULLS FIRST, _col1 ASC NULLS FIRST","partition by:":"_col2, _col1"}}]
                        Select Operator [SEL_2] (rows=26 width=491)
                          Output:["_col1","_col2","_col5"]
                        <-Map 1 [PARTITION-LEVEL SORT]
                          PARTITION-LEVEL SORT [RS_1]
                            PartitionCols:p_mfgr, p_name
                            TableScan [TS_0] (rows=26 width=223)
                              default@part,part,Tbl:COMPLETE,Col:COMPLETE,Output:["p_mfgr","p_name","p_size"]

PREHOOK: query: explain select distinct src.* from src
PREHOOK: type: QUERY
POSTHOOK: query: explain select distinct src.* from src
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (GROUP PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_7]
        Group By Operator [GBY_5] (rows=500 width=178)
          Output:["_col0","_col1"],keys:KEY._col0, KEY._col1
        <-Reducer 2 [GROUP]
          GROUP [RS_4]
            PartitionCols:_col0, _col1
            Group By Operator [GBY_3] (rows=500 width=178)
              Output:["_col0","_col1"],keys:KEY._col0, KEY._col1
            <-Map 1 [GROUP PARTITION-LEVEL SORT]
              GROUP PARTITION-LEVEL SORT [RS_2]
                PartitionCols:rand()
                Select Operator [SEL_1] (rows=500 width=178)
                  Output:["key","value"]
                  TableScan [TS_0] (rows=500 width=178)
                    default@src,src,Tbl:COMPLETE,Col:COMPLETE,Output:["key","value"]

PREHOOK: query: explain select explode(array('a', 'b'))
PREHOOK: type: QUERY
POSTHOOK: query: explain select explode(array('a', 'b'))
POSTHOOK: type: QUERY
Plan optimized by CBO.

Stage-0
  Fetch Operator
    limit:-1
    Select Operator [SEL_3]
      Output:["_col0"]
      UDTF Operator [UDTF_2]
        function name:explode
        Select Operator [SEL_1]
          Output:["_col0"]
          TableScan [TS_0]

PREHOOK: query: CREATE TABLE T1(key STRING, val STRING) STORED AS TEXTFILE
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@T1
POSTHOOK: query: CREATE TABLE T1(key STRING, val STRING) STORED AS TEXTFILE
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@T1
PREHOOK: query: CREATE TABLE T2(key STRING, val STRING) STORED AS TEXTFILE
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@T2
POSTHOOK: query: CREATE TABLE T2(key STRING, val STRING) STORED AS TEXTFILE
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@T2
PREHOOK: query: CREATE TABLE T3(key STRING, val STRING) STORED AS TEXTFILE
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@T3
POSTHOOK: query: CREATE TABLE T3(key STRING, val STRING) STORED AS TEXTFILE
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@T3
PREHOOK: query: CREATE TABLE T4(key STRING, val STRING) STORED AS TEXTFILE
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@T4
POSTHOOK: query: CREATE TABLE T4(key STRING, val STRING) STORED AS TEXTFILE
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@T4
PREHOOK: query: CREATE TABLE dest_j1(key INT, value STRING) STORED AS TEXTFILE
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@dest_j1
POSTHOOK: query: CREATE TABLE dest_j1(key INT, value STRING) STORED AS TEXTFILE
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@dest_j1
PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/T1.txt' INTO TABLE T1
PREHOOK: type: LOAD
#### A masked pattern was here ####
PREHOOK: Output: default@t1
POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/T1.txt' INTO TABLE T1
POSTHOOK: type: LOAD
#### A masked pattern was here ####
POSTHOOK: Output: default@t1
PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/T2.txt' INTO TABLE T2
PREHOOK: type: LOAD
#### A masked pattern was here ####
PREHOOK: Output: default@t2
POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/T2.txt' INTO TABLE T2
POSTHOOK: type: LOAD
#### A masked pattern was here ####
POSTHOOK: Output: default@t2
PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/T3.txt' INTO TABLE T3
PREHOOK: type: LOAD
#### A masked pattern was here ####
PREHOOK: Output: default@t3
POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/T3.txt' INTO TABLE T3
POSTHOOK: type: LOAD
#### A masked pattern was here ####
POSTHOOK: Output: default@t3
PREHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/T1.txt' INTO TABLE T4
PREHOOK: type: LOAD
#### A masked pattern was here ####
PREHOOK: Output: default@t4
POSTHOOK: query: LOAD DATA LOCAL INPATH '../../data/files/T1.txt' INTO TABLE T4
POSTHOOK: type: LOAD
#### A masked pattern was here ####
POSTHOOK: Output: default@t4
PREHOOK: query: explain
FROM src src1 JOIN src src2 ON (src1.key = src2.key)
INSERT OVERWRITE TABLE dest_j1 select src1.key, src2.value
PREHOOK: type: QUERY
POSTHOOK: query: explain
FROM src src1 JOIN src src2 ON (src1.key = src2.key)
INSERT OVERWRITE TABLE dest_j1 select src1.key, src2.value
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT)

Stage-2
  Stats Work{}
    Stage-0(CONDITIONAL)
      Move Operator
        table:{"name:":"default.dest_j1"}
        Stage-4(CONDITIONAL CHILD TASKS: Stage-5, Stage-0)
          Conditional Operator
            Stage-1
              Reducer 2
              File Output Operator [FS_11]
                table:{"name:":"default.dest_j1"}
                Select Operator [SEL_9] (rows=809 width=95)
                  Output:["_col0","_col1"]
                  Join Operator [JOIN_8] (rows=809 width=178)
                    Output:["_col0","_col2"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"}],keys:{"0":"_col0","1":"_col0"}
                  <-Map 1 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_6]
                      PartitionCols:_col0
                      Select Operator [SEL_2] (rows=500 width=87)
                        Output:["_col0"]
                        Filter Operator [FIL_12] (rows=500 width=87)
                          predicate:key is not null
                          TableScan [TS_0] (rows=500 width=87)
                            default@src,src1,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]
                  <-Map 3 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_7]
                      PartitionCols:_col0
                      Select Operator [SEL_5] (rows=500 width=178)
                        Output:["_col0","_col1"]
                        Filter Operator [FIL_13] (rows=500 width=178)
                          predicate:key is not null
                          TableScan [TS_3] (rows=500 width=178)
                            default@src,src2,Tbl:COMPLETE,Col:COMPLETE,Output:["key","value"]
        Stage-3
          Map 4
          File Output Operator [FS_11]
            table:{"name:":"default.dest_j1"}
            Select Operator [SEL_9] (rows=809 width=95)
              Output:["_col0","_col1"]
              Map Join Operator [MAPJOIN_16]
                Conds:TS_14.reducesinkkey0=TS_14.reducesinkkey0(Inner),Output:["_col0","_col2"]
              <-TableScan [TS_14]
                  Output:["0_VALUE_0","reducesinkkey0"]
          Map Reduce Local Work
            Stage-5(CONDITIONAL)
              Map 5
              keys: [HASHTABLESINK_18]
                0reducesinkkey0,1reducesinkkey0
                TableScan [TS_15]
                  Output:["1_VALUE_0","reducesinkkey0"]
              Map Reduce Local Work
                 Please refer to the previous Stage-4(CONDITIONAL CHILD TASKS: Stage-5, Stage-0)

PREHOOK: query: FROM src src1 JOIN src src2 ON (src1.key = src2.key)
INSERT OVERWRITE TABLE dest_j1 select src1.key, src2.value
PREHOOK: type: QUERY
PREHOOK: Input: default@src
PREHOOK: Output: default@dest_j1
POSTHOOK: query: FROM src src1 JOIN src src2 ON (src1.key = src2.key)
INSERT OVERWRITE TABLE dest_j1 select src1.key, src2.value
POSTHOOK: type: QUERY
POSTHOOK: Input: default@src
POSTHOOK: Output: default@dest_j1
POSTHOOK: Lineage: dest_j1.key EXPRESSION [(src)src1.FieldSchema(name:key, type:string, comment:default), ]
POSTHOOK: Lineage: dest_j1.value SIMPLE [(src)src2.FieldSchema(name:value, type:string, comment:default), ]
PREHOOK: query: explain
select /*+ STREAMTABLE(a) */ *
FROM T1 a JOIN T2 b ON a.key = b.key
          JOIN T3 c ON b.key = c.key
          JOIN T4 d ON c.key = d.key
PREHOOK: type: QUERY
POSTHOOK: query: explain
select /*+ STREAMTABLE(a) */ *
FROM T1 a JOIN T2 b ON a.key = b.key
          JOIN T3 c ON b.key = c.key
          JOIN T4 d ON c.key = d.key
POSTHOOK: type: QUERY
Plan optimized by CBO.

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Map 3
      File Output Operator [FS_21]
        Map Join Operator [MAPJOIN_26] (rows=2 width=404)
          Conds:MAPJOIN_27._col0=MAPJOIN_27._col0(Inner),MAPJOIN_27._col0=MAPJOIN_27._col0(Inner),Output:["_col0","_col1","_col2","_col3","_col4","_col5","_col6","_col7"]
        <-Map Join Operator [MAPJOIN_27] (rows=1 width=404)
            Conds:SEL_8._col0=SEL_8._col0(Inner),Output:["_col0","_col1","_col2","_col3"]
          <-Select Operator [SEL_8] (rows=1 width=368)
              Output:["_col0","_col1"]
              Filter Operator [FIL_24] (rows=1 width=368)
                predicate:key is not null
                TableScan [TS_6] (rows=1 width=368)
                  default@t3,c,Tbl:COMPLETE,Col:NONE,Output:["key","val"]
      Map Reduce Local Work
        Stage-2
          Map 1
          keys: [HASHTABLESINK_29]
            0_col0,1_col0,2_col0
            Select Operator [SEL_2] (rows=1 width=368)
              Output:["_col0","_col1"]
              Filter Operator [FIL_22] (rows=1 width=368)
                predicate:key is not null
                TableScan [TS_0] (rows=1 width=368)
                  default@t1,a,Tbl:COMPLETE,Col:NONE,Output:["key","val"]
          Map Reduce Local Work
          Map 2
          keys: [HASHTABLESINK_32]
            0_col0,1_col0,2_col0
            Select Operator [SEL_5] (rows=1 width=368)
              Output:["_col0","_col1"]
              Filter Operator [FIL_23] (rows=1 width=368)
                predicate:key is not null
                TableScan [TS_3] (rows=1 width=368)
                  default@t2,b,Tbl:COMPLETE,Col:NONE,Output:["key","val"]
          Map Reduce Local Work
          Map 4
          keys: [HASHTABLESINK_35]
            0_col0,1_col0
            Select Operator [SEL_11] (rows=1 width=368)
              Output:["_col0","_col1"]
              Filter Operator [FIL_25] (rows=1 width=368)
                predicate:key is not null
                TableScan [TS_9] (rows=1 width=368)
                  default@t4,d,Tbl:COMPLETE,Col:NONE,Output:["key","val"]
          Map Reduce Local Work

PREHOOK: query: explain
select /*+ STREAMTABLE(a,c) */ *
FROM T1 a JOIN T2 b ON a.key = b.key
          JOIN T3 c ON b.key = c.key
          JOIN T4 d ON c.key = d.key
PREHOOK: type: QUERY
POSTHOOK: query: explain
select /*+ STREAMTABLE(a,c) */ *
FROM T1 a JOIN T2 b ON a.key = b.key
          JOIN T3 c ON b.key = c.key
          JOIN T4 d ON c.key = d.key
POSTHOOK: type: QUERY
Plan optimized by CBO.

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Map 3
      File Output Operator [FS_21]
        Map Join Operator [MAPJOIN_26] (rows=2 width=404)
          Conds:MAPJOIN_27._col0=MAPJOIN_27._col0(Inner),MAPJOIN_27._col0=MAPJOIN_27._col0(Inner),Output:["_col0","_col1","_col2","_col3","_col4","_col5","_col6","_col7"]
        <-Map Join Operator [MAPJOIN_27] (rows=1 width=404)
            Conds:SEL_8._col0=SEL_8._col0(Inner),Output:["_col0","_col1","_col2","_col3"]
          <-Select Operator [SEL_8] (rows=1 width=368)
              Output:["_col0","_col1"]
              Filter Operator [FIL_24] (rows=1 width=368)
                predicate:key is not null
                TableScan [TS_6] (rows=1 width=368)
                  default@t3,c,Tbl:COMPLETE,Col:NONE,Output:["key","val"]
      Map Reduce Local Work
        Stage-2
          Map 1
          keys: [HASHTABLESINK_29]
            0_col0,1_col0,2_col0
            Select Operator [SEL_2] (rows=1 width=368)
              Output:["_col0","_col1"]
              Filter Operator [FIL_22] (rows=1 width=368)
                predicate:key is not null
                TableScan [TS_0] (rows=1 width=368)
                  default@t1,a,Tbl:COMPLETE,Col:NONE,Output:["key","val"]
          Map Reduce Local Work
          Map 2
          keys: [HASHTABLESINK_32]
            0_col0,1_col0,2_col0
            Select Operator [SEL_5] (rows=1 width=368)
              Output:["_col0","_col1"]
              Filter Operator [FIL_23] (rows=1 width=368)
                predicate:key is not null
                TableScan [TS_3] (rows=1 width=368)
                  default@t2,b,Tbl:COMPLETE,Col:NONE,Output:["key","val"]
          Map Reduce Local Work
          Map 4
          keys: [HASHTABLESINK_35]
            0_col0,1_col0
            Select Operator [SEL_11] (rows=1 width=368)
              Output:["_col0","_col1"]
              Filter Operator [FIL_25] (rows=1 width=368)
                predicate:key is not null
                TableScan [TS_9] (rows=1 width=368)
                  default@t4,d,Tbl:COMPLETE,Col:NONE,Output:["key","val"]
          Map Reduce Local Work

PREHOOK: query: explain FROM T1 a JOIN src c ON c.key+1=a.key select /*+ STREAMTABLE(a) */ sum(hash(a.key)), sum(hash(a.val)), sum(hash(c.key))
PREHOOK: type: QUERY
POSTHOOK: query: explain FROM T1 a JOIN src c ON c.key+1=a.key select /*+ STREAMTABLE(a) */ sum(hash(a.key)), sum(hash(a.val)), sum(hash(c.key))
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in Stage-1
Reducer 3 <- Map 2 (GROUP)
Reducer 4 <- Reducer 3 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 4
      File Output Operator [FS_16]
        Group By Operator [GBY_14] (rows=1 width=24)
          Output:["_col0","_col1","_col2"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)","sum(VALUE._col2)"]
        <-Reducer 3 [GROUP]
          GROUP [RS_13]
            Group By Operator [GBY_12] (rows=1 width=24)
              Output:["_col0","_col1","_col2"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)","sum(VALUE._col2)"]
            <-Map 2 [GROUP]
              GROUP [RS_11]
                PartitionCols:rand()
                Select Operator [SEL_9] (rows=550 width=87)
                  Output:["_col0","_col1","_col2"]
                  Map Join Operator [MAPJOIN_19] (rows=550 width=87)
                    Conds:SEL_5.UDFToDouble(_col0)=SEL_5.(UDFToDouble(_col0) + 1.0D)(Inner),Output:["_col0","_col1","_col2"]
                  <-Select Operator [SEL_5] (rows=500 width=87)
                      Output:["_col0"]
                      Filter Operator [FIL_18] (rows=500 width=87)
                        predicate:key is not null
                        TableScan [TS_3] (rows=500 width=87)
                          default@src,c,Tbl:COMPLETE,Col:COMPLETE,Output:["key"]
              Map Reduce Local Work
        Stage-2
          Map 1
          keys: [HASHTABLESINK_21]
            0UDFToDouble(_col0),1(UDFToDouble(_col0) + 1.0D)
            Select Operator [SEL_2] (rows=1 width=368)
              Output:["_col0","_col1"]
              Filter Operator [FIL_17] (rows=1 width=368)
                predicate:key is not null
                TableScan [TS_0] (rows=1 width=368)
                  default@t1,a,Tbl:COMPLETE,Col:NONE,Output:["key","val"]
          Map Reduce Local Work

PREHOOK: query: FROM T1 a JOIN src c ON c.key+1=a.key select /*+ STREAMTABLE(a) */ sum(hash(a.key)), sum(hash(a.val)), sum(hash(c.key))
PREHOOK: type: QUERY
PREHOOK: Input: default@src
PREHOOK: Input: default@t1
PREHOOK: Output: hdfs://### HDFS PATH ###
POSTHOOK: query: FROM T1 a JOIN src c ON c.key+1=a.key select /*+ STREAMTABLE(a) */ sum(hash(a.key)), sum(hash(a.val)), sum(hash(c.key))
POSTHOOK: type: QUERY
POSTHOOK: Input: default@src
POSTHOOK: Input: default@t1
POSTHOOK: Output: hdfs://### HDFS PATH ###
198	6274	194
PREHOOK: query: explain
select * FROM
(select src.* FROM src) x
JOIN
(select src.* FROM src) Y
ON (x.key = Y.key)
PREHOOK: type: QUERY
POSTHOOK: query: explain
select * FROM
(select src.* FROM src) x
JOIN
(select src.* FROM src) Y
ON (x.key = Y.key)
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 3 (PARTITION-LEVEL SORT)

Stage-0
  Fetch Operator
    limit:-1
    Stage-2
      Map 4
      File Output Operator [FS_10]
        Map Join Operator [MAPJOIN_15]
          Conds:TS_13.reducesinkkey0=TS_13.reducesinkkey0(Inner),Output:["_col0","_col1","_col2","_col3"]
        <-TableScan [TS_13]
            Output:["0_VALUE_0","0_VALUE_1","reducesinkkey0"]
      Map Reduce Local Work
        Stage-4(CONDITIONAL)
          Map 5
          keys: [HASHTABLESINK_17]
            0reducesinkkey0,1reducesinkkey0
            TableScan [TS_14]
              Output:["1_VALUE_0","1_VALUE_1","reducesinkkey0"]
          Map Reduce Local Work
            Stage-3(CONDITIONAL CHILD TASKS: Stage-4)
              Conditional Operator
                Stage-1
                  Reducer 2
                  File Output Operator [FS_10]
                    Join Operator [JOIN_8] (rows=809 width=356)
                      Output:["_col0","_col1","_col2","_col3"],condition map:[{"":"{\"type\":\"Inner\",\"left\":0,\"right\":1}"}],keys:{"0":"_col0","1":"_col0"}
                    <-Map 1 [PARTITION-LEVEL SORT]
                      PARTITION-LEVEL SORT [RS_6]
                        PartitionCols:_col0
                        Select Operator [SEL_2] (rows=500 width=178)
                          Output:["_col0","_col1"]
                          Filter Operator [FIL_11] (rows=500 width=178)
                            predicate:key is not null
                            TableScan [TS_0] (rows=500 width=178)
                              default@src,src,Tbl:COMPLETE,Col:COMPLETE,Output:["key","value"]
                    <-Map 3 [PARTITION-LEVEL SORT]
                      PARTITION-LEVEL SORT [RS_7]
                        PartitionCols:_col0
                        Select Operator [SEL_5] (rows=500 width=178)
                          Output:["_col0","_col1"]
                          Filter Operator [FIL_12] (rows=500 width=178)
                            predicate:key is not null
                            TableScan [TS_3] (rows=500 width=178)
                              default@src,src,Tbl:COMPLETE,Col:COMPLETE,Output:["key","value"]

PREHOOK: query: explain select /*+ mapjoin(k)*/ sum(hash(k.key)), sum(hash(v.val)) from T1 k join T1 v on k.key=v.val
PREHOOK: type: QUERY
POSTHOOK: query: explain select /*+ mapjoin(k)*/ sum(hash(k.key)), sum(hash(v.val)) from T1 k join T1 v on k.key=v.val
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in Stage-1
Reducer 2 <- Map 1 (GROUP)
Reducer 3 <- Reducer 2 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_16]
        Group By Operator [GBY_14] (rows=1 width=16)
          Output:["_col0","_col1"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)"]
        <-Reducer 2 [GROUP]
          GROUP [RS_13]
            Group By Operator [GBY_12] (rows=1 width=16)
              Output:["_col0","_col1"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)"]
            <-Map 1 [GROUP]
              GROUP [RS_11]
                PartitionCols:rand()
                Select Operator [SEL_9] (rows=1 width=202)
                  Output:["_col0","_col1"]
                  Map Join Operator [MAPJOIN_19] (rows=1 width=202)
                    Conds:SEL_2._col0=SEL_2._col0(Inner),Output:["_col0","_col1"]
                  <-Select Operator [SEL_2] (rows=1 width=184)
                      Output:["_col0"]
                      Filter Operator [FIL_17] (rows=1 width=184)
                        predicate:key is not null
                        TableScan [TS_0] (rows=1 width=184)
                          default@t1,k,Tbl:COMPLETE,Col:NONE,Output:["key"]
              Map Reduce Local Work
        Stage-2
          Map 4
          keys: [HASHTABLESINK_21]
            0_col0,1_col0
            Select Operator [SEL_5] (rows=1 width=184)
              Output:["_col0"]
              Filter Operator [FIL_18] (rows=1 width=184)
                predicate:val is not null
                TableScan [TS_3] (rows=1 width=184)
                  default@t1,v,Tbl:COMPLETE,Col:NONE,Output:["val"]
          Map Reduce Local Work

PREHOOK: query: explain select sum(hash(k.key)), sum(hash(v.val)) from T1 k join T1 v on k.key=v.key
PREHOOK: type: QUERY
POSTHOOK: query: explain select sum(hash(k.key)), sum(hash(v.val)) from T1 k join T1 v on k.key=v.key
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in Stage-1
Reducer 3 <- Map 2 (GROUP)
Reducer 4 <- Reducer 3 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 4
      File Output Operator [FS_16]
        Group By Operator [GBY_14] (rows=1 width=16)
          Output:["_col0","_col1"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)"]
        <-Reducer 3 [GROUP]
          GROUP [RS_13]
            Group By Operator [GBY_12] (rows=1 width=16)
              Output:["_col0","_col1"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)"]
            <-Map 2 [GROUP]
              GROUP [RS_11]
                PartitionCols:rand()
                Select Operator [SEL_9] (rows=1 width=202)
                  Output:["_col0","_col1"]
                  Map Join Operator [MAPJOIN_19] (rows=1 width=202)
                    Conds:SEL_5._col0=SEL_5._col0(Inner),Output:["_col0","_col2"]
                  <-Select Operator [SEL_5] (rows=1 width=368)
                      Output:["_col0","_col1"]
                      Filter Operator [FIL_18] (rows=1 width=368)
                        predicate:key is not null
                        TableScan [TS_3] (rows=1 width=368)
                          default@t1,v,Tbl:COMPLETE,Col:NONE,Output:["key","val"]
              Map Reduce Local Work
        Stage-2
          Map 1
          keys: [HASHTABLESINK_21]
            0_col0,1_col0
            Select Operator [SEL_2] (rows=1 width=184)
              Output:["_col0"]
              Filter Operator [FIL_17] (rows=1 width=184)
                predicate:key is not null
                TableScan [TS_0] (rows=1 width=184)
                  default@t1,k,Tbl:COMPLETE,Col:NONE,Output:["key"]
          Map Reduce Local Work

PREHOOK: query: explain select count(1) from  T1 a join T1 b on a.key = b.key
PREHOOK: type: QUERY
POSTHOOK: query: explain select count(1) from  T1 a join T1 b on a.key = b.key
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in Stage-1
Reducer 2 <- Map 1 (GROUP)
Reducer 3 <- Reducer 2 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_15]
        Group By Operator [GBY_13] (rows=1 width=8)
          Output:["_col0"],aggregations:["count(VALUE._col0)"]
        <-Reducer 2 [GROUP]
          GROUP [RS_12]
            Group By Operator [GBY_11] (rows=1 width=8)
              Output:["_col0"],aggregations:["count()"]
            <-Map 1 [GROUP]
              GROUP [RS_10]
                PartitionCols:rand()
                Map Join Operator [MAPJOIN_18] (rows=1 width=202)
                  Conds:SEL_2._col0=SEL_2._col0(Inner)
                <-Select Operator [SEL_2] (rows=1 width=184)
                    Output:["_col0"]
                    Filter Operator [FIL_16] (rows=1 width=184)
                      predicate:key is not null
                      TableScan [TS_0] (rows=1 width=184)
                        default@t1,a,Tbl:COMPLETE,Col:NONE,Output:["key"]
              Map Reduce Local Work
        Stage-2
          Map 4
          keys: [HASHTABLESINK_20]
            0_col0,1_col0
            Select Operator [SEL_5] (rows=1 width=184)
              Output:["_col0"]
              Filter Operator [FIL_17] (rows=1 width=184)
                predicate:key is not null
                TableScan [TS_3] (rows=1 width=184)
                  default@t1,b,Tbl:COMPLETE,Col:NONE,Output:["key"]
          Map Reduce Local Work

PREHOOK: query: explain FROM T1 a LEFT OUTER JOIN T2 c ON c.key+1=a.key select sum(hash(a.key)), sum(hash(a.val)), sum(hash(c.key))
PREHOOK: type: QUERY
POSTHOOK: query: explain FROM T1 a LEFT OUTER JOIN T2 c ON c.key+1=a.key select sum(hash(a.key)), sum(hash(a.val)), sum(hash(c.key))
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in Stage-1
Reducer 2 <- Map 1 (GROUP)
Reducer 3 <- Reducer 2 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_14]
        Group By Operator [GBY_12] (rows=1 width=24)
          Output:["_col0","_col1","_col2"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)","sum(VALUE._col2)"]
        <-Reducer 2 [GROUP]
          GROUP [RS_11]
            Group By Operator [GBY_10] (rows=1 width=24)
              Output:["_col0","_col1","_col2"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)","sum(VALUE._col2)"]
            <-Map 1 [GROUP]
              GROUP [RS_9]
                PartitionCols:rand()
                Select Operator [SEL_7] (rows=1 width=404)
                  Output:["_col0","_col1","_col2"]
                  Map Join Operator [MAPJOIN_15] (rows=1 width=404)
                    Conds:SEL_1.UDFToDouble(_col0)=SEL_1.(UDFToDouble(_col0) + 1.0D)(Left Outer),Output:["_col0","_col1","_col2"]
                  <-Select Operator [SEL_1] (rows=1 width=368)
                      Output:["_col0","_col1"]
                      TableScan [TS_0] (rows=1 width=368)
                        default@t1,a,Tbl:COMPLETE,Col:NONE,Output:["key","val"]
              Map Reduce Local Work
        Stage-2
          Map 4
          keys: [HASHTABLESINK_17]
            0UDFToDouble(_col0),1(UDFToDouble(_col0) + 1.0D)
            Select Operator [SEL_3] (rows=1 width=184)
              Output:["_col0"]
              TableScan [TS_2] (rows=1 width=184)
                default@t2,c,Tbl:COMPLETE,Col:NONE,Output:["key"]
          Map Reduce Local Work

PREHOOK: query: explain FROM T1 a RIGHT OUTER JOIN T2 c ON c.key+1=a.key select /*+ STREAMTABLE(a) */ sum(hash(a.key)), sum(hash(a.val)), sum(hash(c.key))
PREHOOK: type: QUERY
POSTHOOK: query: explain FROM T1 a RIGHT OUTER JOIN T2 c ON c.key+1=a.key select /*+ STREAMTABLE(a) */ sum(hash(a.key)), sum(hash(a.val)), sum(hash(c.key))
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in Stage-1
Reducer 3 <- Map 2 (GROUP)
Reducer 4 <- Reducer 3 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 4
      File Output Operator [FS_14]
        Group By Operator [GBY_12] (rows=1 width=24)
          Output:["_col0","_col1","_col2"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)","sum(VALUE._col2)"]
        <-Reducer 3 [GROUP]
          GROUP [RS_11]
            Group By Operator [GBY_10] (rows=1 width=24)
              Output:["_col0","_col1","_col2"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)","sum(VALUE._col2)"]
            <-Map 2 [GROUP]
              GROUP [RS_9]
                PartitionCols:rand()
                Select Operator [SEL_7] (rows=1 width=404)
                  Output:["_col0","_col1","_col2"]
                  Map Join Operator [MAPJOIN_15] (rows=1 width=404)
                    Conds:SEL_3.UDFToDouble(_col0)=SEL_3.(UDFToDouble(_col0) + 1.0D)(Right Outer),Output:["_col0","_col1","_col2"]
                  <-Select Operator [SEL_3] (rows=1 width=184)
                      Output:["_col0"]
                      TableScan [TS_2] (rows=1 width=184)
                        default@t2,c,Tbl:COMPLETE,Col:NONE,Output:["key"]
              Map Reduce Local Work
        Stage-2
          Map 1
          keys: [HASHTABLESINK_17]
            0UDFToDouble(_col0),1(UDFToDouble(_col0) + 1.0D)
            Select Operator [SEL_1] (rows=1 width=368)
              Output:["_col0","_col1"]
              TableScan [TS_0] (rows=1 width=368)
                default@t1,a,Tbl:COMPLETE,Col:NONE,Output:["key","val"]
          Map Reduce Local Work

PREHOOK: query: explain FROM T1 a FULL OUTER JOIN T2 c ON c.key+1=a.key select /*+ STREAMTABLE(a) */ sum(hash(a.key)), sum(hash(a.val)), sum(hash(c.key))
PREHOOK: type: QUERY
POSTHOOK: query: explain FROM T1 a FULL OUTER JOIN T2 c ON c.key+1=a.key select /*+ STREAMTABLE(a) */ sum(hash(a.key)), sum(hash(a.val)), sum(hash(c.key))
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (PARTITION-LEVEL SORT), Map 5 (PARTITION-LEVEL SORT)
Reducer 3 <- Reducer 2 (GROUP)
Reducer 4 <- Reducer 3 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 4
      File Output Operator [FS_14]
        Group By Operator [GBY_12] (rows=1 width=24)
          Output:["_col0","_col1","_col2"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)","sum(VALUE._col2)"]
        <-Reducer 3 [GROUP]
          GROUP [RS_11]
            Group By Operator [GBY_10] (rows=1 width=24)
              Output:["_col0","_col1","_col2"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)","sum(VALUE._col2)"]
            <-Reducer 2 [GROUP]
              GROUP [RS_9]
                PartitionCols:rand()
                Select Operator [SEL_7] (rows=1 width=404)
                  Output:["_col0","_col1","_col2"]
                  Join Operator [JOIN_6] (rows=1 width=404)
                    Output:["_col0","_col1","_col2"],condition map:[{"":"{\"type\":\"Outer\",\"left\":0,\"right\":1}"}],keys:{"0":"UDFToDouble(_col0)","1":"(UDFToDouble(_col0) + 1.0D)"}
                  <-Map 1 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_4]
                      PartitionCols:UDFToDouble(_col0)
                      Select Operator [SEL_1] (rows=1 width=368)
                        Output:["_col0","_col1"]
                        TableScan [TS_0] (rows=1 width=368)
                          default@t1,a,Tbl:COMPLETE,Col:NONE,Output:["key","val"]
                  <-Map 5 [PARTITION-LEVEL SORT]
                    PARTITION-LEVEL SORT [RS_5]
                      PartitionCols:(UDFToDouble(_col0) + 1.0D)
                      Select Operator [SEL_3] (rows=1 width=184)
                        Output:["_col0"]
                        TableScan [TS_2] (rows=1 width=184)
                          default@t2,c,Tbl:COMPLETE,Col:NONE,Output:["key"]

PREHOOK: query: explain select /*+ mapjoin(v)*/ sum(hash(k.key)), sum(hash(v.val)) from T1 k left outer join T1 v on k.key+1=v.key
PREHOOK: type: QUERY
POSTHOOK: query: explain select /*+ mapjoin(v)*/ sum(hash(k.key)), sum(hash(v.val)) from T1 k left outer join T1 v on k.key+1=v.key
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in Stage-1
Reducer 2 <- Map 1 (GROUP)
Reducer 3 <- Reducer 2 (GROUP)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_14]
        Group By Operator [GBY_12] (rows=1 width=16)
          Output:["_col0","_col1"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)"]
        <-Reducer 2 [GROUP]
          GROUP [RS_11]
            Group By Operator [GBY_10] (rows=1 width=16)
              Output:["_col0","_col1"],aggregations:["sum(VALUE._col0)","sum(VALUE._col1)"]
            <-Map 1 [GROUP]
              GROUP [RS_9]
                PartitionCols:rand()
                Select Operator [SEL_7] (rows=1 width=202)
                  Output:["_col0","_col1"]
                  Map Join Operator [MAPJOIN_15] (rows=1 width=202)
                    Conds:SEL_1.(UDFToDouble(_col0) + 1.0D)=SEL_1.UDFToDouble(_col0)(Left Outer),Output:["_col0","_col2"]
                  <-Select Operator [SEL_1] (rows=1 width=184)
                      Output:["_col0"]
                      TableScan [TS_0] (rows=1 width=184)
                        default@t1,k,Tbl:COMPLETE,Col:NONE,Output:["key"]
              Map Reduce Local Work
        Stage-2
          Map 4
          keys: [HASHTABLESINK_17]
            0(UDFToDouble(_col0) + 1.0D),1UDFToDouble(_col0)
            Select Operator [SEL_3] (rows=1 width=368)
              Output:["_col0","_col1"]
              TableScan [TS_2] (rows=1 width=368)
                default@t1,v,Tbl:COMPLETE,Col:NONE,Output:["key","val"]
          Map Reduce Local Work

