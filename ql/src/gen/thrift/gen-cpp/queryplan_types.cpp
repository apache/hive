/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "queryplan_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace Apache { namespace Hadoop { namespace Hive {

int _kAdjacencyTypeValues[] = {
  AdjacencyType::CONJUNCTIVE,
  AdjacencyType::DISJUNCTIVE
};
const char* _kAdjacencyTypeNames[] = {
  "CONJUNCTIVE",
  "DISJUNCTIVE"
};
const std::map<int, const char*> _AdjacencyType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kAdjacencyTypeValues, _kAdjacencyTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kNodeTypeValues[] = {
  NodeType::OPERATOR,
  NodeType::STAGE
};
const char* _kNodeTypeNames[] = {
  "OPERATOR",
  "STAGE"
};
const std::map<int, const char*> _NodeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kNodeTypeValues, _kNodeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kOperatorTypeValues[] = {
  OperatorType::JOIN,
  OperatorType::MAPJOIN,
  OperatorType::EXTRACT,
  OperatorType::FILTER,
  OperatorType::FORWARD,
  OperatorType::GROUPBY,
  OperatorType::LIMIT,
  OperatorType::SCRIPT,
  OperatorType::SELECT,
  OperatorType::TABLESCAN,
  OperatorType::FILESINK,
  OperatorType::REDUCESINK,
  OperatorType::UNION,
  OperatorType::UDTF,
  OperatorType::LATERALVIEWJOIN,
  OperatorType::LATERALVIEWFORWARD,
  OperatorType::HASHTABLESINK,
  OperatorType::HASHTABLEDUMMY,
  OperatorType::PTF,
  OperatorType::MUX,
  OperatorType::DEMUX,
  OperatorType::EVENT,
  OperatorType::ORCFILEMERGE,
  OperatorType::RCFILEMERGE,
  OperatorType::MERGEJOIN,
  OperatorType::SPARKPRUNINGSINK
};
const char* _kOperatorTypeNames[] = {
  "JOIN",
  "MAPJOIN",
  "EXTRACT",
  "FILTER",
  "FORWARD",
  "GROUPBY",
  "LIMIT",
  "SCRIPT",
  "SELECT",
  "TABLESCAN",
  "FILESINK",
  "REDUCESINK",
  "UNION",
  "UDTF",
  "LATERALVIEWJOIN",
  "LATERALVIEWFORWARD",
  "HASHTABLESINK",
  "HASHTABLEDUMMY",
  "PTF",
  "MUX",
  "DEMUX",
  "EVENT",
  "ORCFILEMERGE",
  "RCFILEMERGE",
  "MERGEJOIN",
  "SPARKPRUNINGSINK"
};
const std::map<int, const char*> _OperatorType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(26, _kOperatorTypeValues, _kOperatorTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTaskTypeValues[] = {
  TaskType::MAP,
  TaskType::REDUCE,
  TaskType::OTHER
};
const char* _kTaskTypeNames[] = {
  "MAP",
  "REDUCE",
  "OTHER"
};
const std::map<int, const char*> _TaskType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTaskTypeValues, _kTaskTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kStageTypeValues[] = {
  StageType::CONDITIONAL,
  StageType::COPY,
  StageType::DDL,
  StageType::MAPRED,
  StageType::EXPLAIN,
  StageType::FETCH,
  StageType::FUNC,
  StageType::MAPREDLOCAL,
  StageType::MOVE,
  StageType::STATS,
  StageType::DEPENDENCY_COLLECTION,
  StageType::COLUMNSTATS,
  StageType::REPL_DUMP,
  StageType::REPL_BOOTSTRAP_LOAD,
  StageType::REPL_STATE_LOG
};
const char* _kStageTypeNames[] = {
  "CONDITIONAL",
  "COPY",
  "DDL",
  "MAPRED",
  "EXPLAIN",
  "FETCH",
  "FUNC",
  "MAPREDLOCAL",
  "MOVE",
  "STATS",
  "DEPENDENCY_COLLECTION",
  "COLUMNSTATS",
  "REPL_DUMP",
  "REPL_BOOTSTRAP_LOAD",
  "REPL_STATE_LOG"
};
const std::map<int, const char*> _StageType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(15, _kStageTypeValues, _kStageTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


Adjacency::~Adjacency() throw() {
}


void Adjacency::__set_node(const std::string& val) {
  this->node = val;
}

void Adjacency::__set_children(const std::vector<std::string> & val) {
  this->children = val;
}

void Adjacency::__set_adjacencyType(const AdjacencyType::type val) {
  this->adjacencyType = val;
}

uint32_t Adjacency::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->node);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->children.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->children.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readString(this->children[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.children = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->adjacencyType = (AdjacencyType::type)ecast5;
          this->__isset.adjacencyType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Adjacency::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Adjacency");

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->node);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("children", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->children.size()));
    std::vector<std::string> ::const_iterator _iter6;
    for (_iter6 = this->children.begin(); _iter6 != this->children.end(); ++_iter6)
    {
      xfer += oprot->writeString((*_iter6));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("adjacencyType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->adjacencyType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Adjacency &a, Adjacency &b) {
  using ::std::swap;
  swap(a.node, b.node);
  swap(a.children, b.children);
  swap(a.adjacencyType, b.adjacencyType);
  swap(a.__isset, b.__isset);
}

Adjacency::Adjacency(const Adjacency& other7) {
  node = other7.node;
  children = other7.children;
  adjacencyType = other7.adjacencyType;
  __isset = other7.__isset;
}
Adjacency& Adjacency::operator=(const Adjacency& other8) {
  node = other8.node;
  children = other8.children;
  adjacencyType = other8.adjacencyType;
  __isset = other8.__isset;
  return *this;
}
void Adjacency::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Adjacency(";
  out << "node=" << to_string(node);
  out << ", " << "children=" << to_string(children);
  out << ", " << "adjacencyType=" << to_string(adjacencyType);
  out << ")";
}


Graph::~Graph() throw() {
}


void Graph::__set_nodeType(const NodeType::type val) {
  this->nodeType = val;
}

void Graph::__set_roots(const std::vector<std::string> & val) {
  this->roots = val;
}

void Graph::__set_adjacencyList(const std::vector<Adjacency> & val) {
  this->adjacencyList = val;
}

uint32_t Graph::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast9;
          xfer += iprot->readI32(ecast9);
          this->nodeType = (NodeType::type)ecast9;
          this->__isset.nodeType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->roots.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->roots.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += iprot->readString(this->roots[_i14]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.roots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->adjacencyList.clear();
            uint32_t _size15;
            ::apache::thrift::protocol::TType _etype18;
            xfer += iprot->readListBegin(_etype18, _size15);
            this->adjacencyList.resize(_size15);
            uint32_t _i19;
            for (_i19 = 0; _i19 < _size15; ++_i19)
            {
              xfer += this->adjacencyList[_i19].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.adjacencyList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Graph::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Graph");

  xfer += oprot->writeFieldBegin("nodeType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->nodeType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roots", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->roots.size()));
    std::vector<std::string> ::const_iterator _iter20;
    for (_iter20 = this->roots.begin(); _iter20 != this->roots.end(); ++_iter20)
    {
      xfer += oprot->writeString((*_iter20));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("adjacencyList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->adjacencyList.size()));
    std::vector<Adjacency> ::const_iterator _iter21;
    for (_iter21 = this->adjacencyList.begin(); _iter21 != this->adjacencyList.end(); ++_iter21)
    {
      xfer += (*_iter21).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Graph &a, Graph &b) {
  using ::std::swap;
  swap(a.nodeType, b.nodeType);
  swap(a.roots, b.roots);
  swap(a.adjacencyList, b.adjacencyList);
  swap(a.__isset, b.__isset);
}

Graph::Graph(const Graph& other22) {
  nodeType = other22.nodeType;
  roots = other22.roots;
  adjacencyList = other22.adjacencyList;
  __isset = other22.__isset;
}
Graph& Graph::operator=(const Graph& other23) {
  nodeType = other23.nodeType;
  roots = other23.roots;
  adjacencyList = other23.adjacencyList;
  __isset = other23.__isset;
  return *this;
}
void Graph::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Graph(";
  out << "nodeType=" << to_string(nodeType);
  out << ", " << "roots=" << to_string(roots);
  out << ", " << "adjacencyList=" << to_string(adjacencyList);
  out << ")";
}


Operator::~Operator() throw() {
}


void Operator::__set_operatorId(const std::string& val) {
  this->operatorId = val;
}

void Operator::__set_operatorType(const OperatorType::type val) {
  this->operatorType = val;
}

void Operator::__set_operatorAttributes(const std::map<std::string, std::string> & val) {
  this->operatorAttributes = val;
}

void Operator::__set_operatorCounters(const std::map<std::string, int64_t> & val) {
  this->operatorCounters = val;
}

void Operator::__set_done(const bool val) {
  this->done = val;
}

void Operator::__set_started(const bool val) {
  this->started = val;
}

uint32_t Operator::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->operatorId);
          this->__isset.operatorId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast24;
          xfer += iprot->readI32(ecast24);
          this->operatorType = (OperatorType::type)ecast24;
          this->__isset.operatorType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->operatorAttributes.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _ktype26;
            ::apache::thrift::protocol::TType _vtype27;
            xfer += iprot->readMapBegin(_ktype26, _vtype27, _size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              std::string _key30;
              xfer += iprot->readString(_key30);
              std::string& _val31 = this->operatorAttributes[_key30];
              xfer += iprot->readString(_val31);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.operatorAttributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->operatorCounters.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _ktype33;
            ::apache::thrift::protocol::TType _vtype34;
            xfer += iprot->readMapBegin(_ktype33, _vtype34, _size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              std::string _key37;
              xfer += iprot->readString(_key37);
              int64_t& _val38 = this->operatorCounters[_key37];
              xfer += iprot->readI64(_val38);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.operatorCounters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->done);
          this->__isset.done = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->started);
          this->__isset.started = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Operator::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Operator");

  xfer += oprot->writeFieldBegin("operatorId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->operatorId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("operatorType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->operatorType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("operatorAttributes", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->operatorAttributes.size()));
    std::map<std::string, std::string> ::const_iterator _iter39;
    for (_iter39 = this->operatorAttributes.begin(); _iter39 != this->operatorAttributes.end(); ++_iter39)
    {
      xfer += oprot->writeString(_iter39->first);
      xfer += oprot->writeString(_iter39->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("operatorCounters", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->operatorCounters.size()));
    std::map<std::string, int64_t> ::const_iterator _iter40;
    for (_iter40 = this->operatorCounters.begin(); _iter40 != this->operatorCounters.end(); ++_iter40)
    {
      xfer += oprot->writeString(_iter40->first);
      xfer += oprot->writeI64(_iter40->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("done", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->done);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("started", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->started);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Operator &a, Operator &b) {
  using ::std::swap;
  swap(a.operatorId, b.operatorId);
  swap(a.operatorType, b.operatorType);
  swap(a.operatorAttributes, b.operatorAttributes);
  swap(a.operatorCounters, b.operatorCounters);
  swap(a.done, b.done);
  swap(a.started, b.started);
  swap(a.__isset, b.__isset);
}

Operator::Operator(const Operator& other41) {
  operatorId = other41.operatorId;
  operatorType = other41.operatorType;
  operatorAttributes = other41.operatorAttributes;
  operatorCounters = other41.operatorCounters;
  done = other41.done;
  started = other41.started;
  __isset = other41.__isset;
}
Operator& Operator::operator=(const Operator& other42) {
  operatorId = other42.operatorId;
  operatorType = other42.operatorType;
  operatorAttributes = other42.operatorAttributes;
  operatorCounters = other42.operatorCounters;
  done = other42.done;
  started = other42.started;
  __isset = other42.__isset;
  return *this;
}
void Operator::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Operator(";
  out << "operatorId=" << to_string(operatorId);
  out << ", " << "operatorType=" << to_string(operatorType);
  out << ", " << "operatorAttributes=" << to_string(operatorAttributes);
  out << ", " << "operatorCounters=" << to_string(operatorCounters);
  out << ", " << "done=" << to_string(done);
  out << ", " << "started=" << to_string(started);
  out << ")";
}


Task::~Task() throw() {
}


void Task::__set_taskId(const std::string& val) {
  this->taskId = val;
}

void Task::__set_taskType(const TaskType::type val) {
  this->taskType = val;
}

void Task::__set_taskAttributes(const std::map<std::string, std::string> & val) {
  this->taskAttributes = val;
}

void Task::__set_taskCounters(const std::map<std::string, int64_t> & val) {
  this->taskCounters = val;
}

void Task::__set_operatorGraph(const Graph& val) {
  this->operatorGraph = val;
__isset.operatorGraph = true;
}

void Task::__set_operatorList(const std::vector<Operator> & val) {
  this->operatorList = val;
__isset.operatorList = true;
}

void Task::__set_done(const bool val) {
  this->done = val;
}

void Task::__set_started(const bool val) {
  this->started = val;
}

uint32_t Task::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->taskId);
          this->__isset.taskId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast43;
          xfer += iprot->readI32(ecast43);
          this->taskType = (TaskType::type)ecast43;
          this->__isset.taskType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->taskAttributes.clear();
            uint32_t _size44;
            ::apache::thrift::protocol::TType _ktype45;
            ::apache::thrift::protocol::TType _vtype46;
            xfer += iprot->readMapBegin(_ktype45, _vtype46, _size44);
            uint32_t _i48;
            for (_i48 = 0; _i48 < _size44; ++_i48)
            {
              std::string _key49;
              xfer += iprot->readString(_key49);
              std::string& _val50 = this->taskAttributes[_key49];
              xfer += iprot->readString(_val50);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.taskAttributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->taskCounters.clear();
            uint32_t _size51;
            ::apache::thrift::protocol::TType _ktype52;
            ::apache::thrift::protocol::TType _vtype53;
            xfer += iprot->readMapBegin(_ktype52, _vtype53, _size51);
            uint32_t _i55;
            for (_i55 = 0; _i55 < _size51; ++_i55)
            {
              std::string _key56;
              xfer += iprot->readString(_key56);
              int64_t& _val57 = this->taskCounters[_key56];
              xfer += iprot->readI64(_val57);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.taskCounters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operatorGraph.read(iprot);
          this->__isset.operatorGraph = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->operatorList.clear();
            uint32_t _size58;
            ::apache::thrift::protocol::TType _etype61;
            xfer += iprot->readListBegin(_etype61, _size58);
            this->operatorList.resize(_size58);
            uint32_t _i62;
            for (_i62 = 0; _i62 < _size58; ++_i62)
            {
              xfer += this->operatorList[_i62].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.operatorList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->done);
          this->__isset.done = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->started);
          this->__isset.started = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Task::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Task");

  xfer += oprot->writeFieldBegin("taskId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->taskId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("taskType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->taskType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("taskAttributes", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->taskAttributes.size()));
    std::map<std::string, std::string> ::const_iterator _iter63;
    for (_iter63 = this->taskAttributes.begin(); _iter63 != this->taskAttributes.end(); ++_iter63)
    {
      xfer += oprot->writeString(_iter63->first);
      xfer += oprot->writeString(_iter63->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("taskCounters", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->taskCounters.size()));
    std::map<std::string, int64_t> ::const_iterator _iter64;
    for (_iter64 = this->taskCounters.begin(); _iter64 != this->taskCounters.end(); ++_iter64)
    {
      xfer += oprot->writeString(_iter64->first);
      xfer += oprot->writeI64(_iter64->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operatorGraph) {
    xfer += oprot->writeFieldBegin("operatorGraph", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->operatorGraph.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.operatorList) {
    xfer += oprot->writeFieldBegin("operatorList", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->operatorList.size()));
      std::vector<Operator> ::const_iterator _iter65;
      for (_iter65 = this->operatorList.begin(); _iter65 != this->operatorList.end(); ++_iter65)
      {
        xfer += (*_iter65).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("done", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->done);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("started", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->started);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Task &a, Task &b) {
  using ::std::swap;
  swap(a.taskId, b.taskId);
  swap(a.taskType, b.taskType);
  swap(a.taskAttributes, b.taskAttributes);
  swap(a.taskCounters, b.taskCounters);
  swap(a.operatorGraph, b.operatorGraph);
  swap(a.operatorList, b.operatorList);
  swap(a.done, b.done);
  swap(a.started, b.started);
  swap(a.__isset, b.__isset);
}

Task::Task(const Task& other66) {
  taskId = other66.taskId;
  taskType = other66.taskType;
  taskAttributes = other66.taskAttributes;
  taskCounters = other66.taskCounters;
  operatorGraph = other66.operatorGraph;
  operatorList = other66.operatorList;
  done = other66.done;
  started = other66.started;
  __isset = other66.__isset;
}
Task& Task::operator=(const Task& other67) {
  taskId = other67.taskId;
  taskType = other67.taskType;
  taskAttributes = other67.taskAttributes;
  taskCounters = other67.taskCounters;
  operatorGraph = other67.operatorGraph;
  operatorList = other67.operatorList;
  done = other67.done;
  started = other67.started;
  __isset = other67.__isset;
  return *this;
}
void Task::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Task(";
  out << "taskId=" << to_string(taskId);
  out << ", " << "taskType=" << to_string(taskType);
  out << ", " << "taskAttributes=" << to_string(taskAttributes);
  out << ", " << "taskCounters=" << to_string(taskCounters);
  out << ", " << "operatorGraph="; (__isset.operatorGraph ? (out << to_string(operatorGraph)) : (out << "<null>"));
  out << ", " << "operatorList="; (__isset.operatorList ? (out << to_string(operatorList)) : (out << "<null>"));
  out << ", " << "done=" << to_string(done);
  out << ", " << "started=" << to_string(started);
  out << ")";
}


Stage::~Stage() throw() {
}


void Stage::__set_stageId(const std::string& val) {
  this->stageId = val;
}

void Stage::__set_stageType(const StageType::type val) {
  this->stageType = val;
}

void Stage::__set_stageAttributes(const std::map<std::string, std::string> & val) {
  this->stageAttributes = val;
}

void Stage::__set_stageCounters(const std::map<std::string, int64_t> & val) {
  this->stageCounters = val;
}

void Stage::__set_taskList(const std::vector<Task> & val) {
  this->taskList = val;
}

void Stage::__set_done(const bool val) {
  this->done = val;
}

void Stage::__set_started(const bool val) {
  this->started = val;
}

uint32_t Stage::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->stageId);
          this->__isset.stageId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast68;
          xfer += iprot->readI32(ecast68);
          this->stageType = (StageType::type)ecast68;
          this->__isset.stageType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->stageAttributes.clear();
            uint32_t _size69;
            ::apache::thrift::protocol::TType _ktype70;
            ::apache::thrift::protocol::TType _vtype71;
            xfer += iprot->readMapBegin(_ktype70, _vtype71, _size69);
            uint32_t _i73;
            for (_i73 = 0; _i73 < _size69; ++_i73)
            {
              std::string _key74;
              xfer += iprot->readString(_key74);
              std::string& _val75 = this->stageAttributes[_key74];
              xfer += iprot->readString(_val75);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.stageAttributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->stageCounters.clear();
            uint32_t _size76;
            ::apache::thrift::protocol::TType _ktype77;
            ::apache::thrift::protocol::TType _vtype78;
            xfer += iprot->readMapBegin(_ktype77, _vtype78, _size76);
            uint32_t _i80;
            for (_i80 = 0; _i80 < _size76; ++_i80)
            {
              std::string _key81;
              xfer += iprot->readString(_key81);
              int64_t& _val82 = this->stageCounters[_key81];
              xfer += iprot->readI64(_val82);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.stageCounters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->taskList.clear();
            uint32_t _size83;
            ::apache::thrift::protocol::TType _etype86;
            xfer += iprot->readListBegin(_etype86, _size83);
            this->taskList.resize(_size83);
            uint32_t _i87;
            for (_i87 = 0; _i87 < _size83; ++_i87)
            {
              xfer += this->taskList[_i87].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.taskList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->done);
          this->__isset.done = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->started);
          this->__isset.started = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Stage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Stage");

  xfer += oprot->writeFieldBegin("stageId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->stageId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stageType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->stageType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stageAttributes", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->stageAttributes.size()));
    std::map<std::string, std::string> ::const_iterator _iter88;
    for (_iter88 = this->stageAttributes.begin(); _iter88 != this->stageAttributes.end(); ++_iter88)
    {
      xfer += oprot->writeString(_iter88->first);
      xfer += oprot->writeString(_iter88->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stageCounters", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->stageCounters.size()));
    std::map<std::string, int64_t> ::const_iterator _iter89;
    for (_iter89 = this->stageCounters.begin(); _iter89 != this->stageCounters.end(); ++_iter89)
    {
      xfer += oprot->writeString(_iter89->first);
      xfer += oprot->writeI64(_iter89->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("taskList", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->taskList.size()));
    std::vector<Task> ::const_iterator _iter90;
    for (_iter90 = this->taskList.begin(); _iter90 != this->taskList.end(); ++_iter90)
    {
      xfer += (*_iter90).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("done", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->done);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("started", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->started);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Stage &a, Stage &b) {
  using ::std::swap;
  swap(a.stageId, b.stageId);
  swap(a.stageType, b.stageType);
  swap(a.stageAttributes, b.stageAttributes);
  swap(a.stageCounters, b.stageCounters);
  swap(a.taskList, b.taskList);
  swap(a.done, b.done);
  swap(a.started, b.started);
  swap(a.__isset, b.__isset);
}

Stage::Stage(const Stage& other91) {
  stageId = other91.stageId;
  stageType = other91.stageType;
  stageAttributes = other91.stageAttributes;
  stageCounters = other91.stageCounters;
  taskList = other91.taskList;
  done = other91.done;
  started = other91.started;
  __isset = other91.__isset;
}
Stage& Stage::operator=(const Stage& other92) {
  stageId = other92.stageId;
  stageType = other92.stageType;
  stageAttributes = other92.stageAttributes;
  stageCounters = other92.stageCounters;
  taskList = other92.taskList;
  done = other92.done;
  started = other92.started;
  __isset = other92.__isset;
  return *this;
}
void Stage::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Stage(";
  out << "stageId=" << to_string(stageId);
  out << ", " << "stageType=" << to_string(stageType);
  out << ", " << "stageAttributes=" << to_string(stageAttributes);
  out << ", " << "stageCounters=" << to_string(stageCounters);
  out << ", " << "taskList=" << to_string(taskList);
  out << ", " << "done=" << to_string(done);
  out << ", " << "started=" << to_string(started);
  out << ")";
}


Query::~Query() throw() {
}


void Query::__set_queryId(const std::string& val) {
  this->queryId = val;
}

void Query::__set_queryType(const std::string& val) {
  this->queryType = val;
}

void Query::__set_queryAttributes(const std::map<std::string, std::string> & val) {
  this->queryAttributes = val;
}

void Query::__set_queryCounters(const std::map<std::string, int64_t> & val) {
  this->queryCounters = val;
}

void Query::__set_stageGraph(const Graph& val) {
  this->stageGraph = val;
}

void Query::__set_stageList(const std::vector<Stage> & val) {
  this->stageList = val;
}

void Query::__set_done(const bool val) {
  this->done = val;
}

void Query::__set_started(const bool val) {
  this->started = val;
}

uint32_t Query::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->queryId);
          this->__isset.queryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->queryType);
          this->__isset.queryType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->queryAttributes.clear();
            uint32_t _size93;
            ::apache::thrift::protocol::TType _ktype94;
            ::apache::thrift::protocol::TType _vtype95;
            xfer += iprot->readMapBegin(_ktype94, _vtype95, _size93);
            uint32_t _i97;
            for (_i97 = 0; _i97 < _size93; ++_i97)
            {
              std::string _key98;
              xfer += iprot->readString(_key98);
              std::string& _val99 = this->queryAttributes[_key98];
              xfer += iprot->readString(_val99);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.queryAttributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->queryCounters.clear();
            uint32_t _size100;
            ::apache::thrift::protocol::TType _ktype101;
            ::apache::thrift::protocol::TType _vtype102;
            xfer += iprot->readMapBegin(_ktype101, _vtype102, _size100);
            uint32_t _i104;
            for (_i104 = 0; _i104 < _size100; ++_i104)
            {
              std::string _key105;
              xfer += iprot->readString(_key105);
              int64_t& _val106 = this->queryCounters[_key105];
              xfer += iprot->readI64(_val106);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.queryCounters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stageGraph.read(iprot);
          this->__isset.stageGraph = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stageList.clear();
            uint32_t _size107;
            ::apache::thrift::protocol::TType _etype110;
            xfer += iprot->readListBegin(_etype110, _size107);
            this->stageList.resize(_size107);
            uint32_t _i111;
            for (_i111 = 0; _i111 < _size107; ++_i111)
            {
              xfer += this->stageList[_i111].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.stageList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->done);
          this->__isset.done = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->started);
          this->__isset.started = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Query::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Query");

  xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->queryId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryType", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->queryType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryAttributes", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->queryAttributes.size()));
    std::map<std::string, std::string> ::const_iterator _iter112;
    for (_iter112 = this->queryAttributes.begin(); _iter112 != this->queryAttributes.end(); ++_iter112)
    {
      xfer += oprot->writeString(_iter112->first);
      xfer += oprot->writeString(_iter112->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryCounters", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->queryCounters.size()));
    std::map<std::string, int64_t> ::const_iterator _iter113;
    for (_iter113 = this->queryCounters.begin(); _iter113 != this->queryCounters.end(); ++_iter113)
    {
      xfer += oprot->writeString(_iter113->first);
      xfer += oprot->writeI64(_iter113->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stageGraph", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->stageGraph.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stageList", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->stageList.size()));
    std::vector<Stage> ::const_iterator _iter114;
    for (_iter114 = this->stageList.begin(); _iter114 != this->stageList.end(); ++_iter114)
    {
      xfer += (*_iter114).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("done", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->done);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("started", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->started);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Query &a, Query &b) {
  using ::std::swap;
  swap(a.queryId, b.queryId);
  swap(a.queryType, b.queryType);
  swap(a.queryAttributes, b.queryAttributes);
  swap(a.queryCounters, b.queryCounters);
  swap(a.stageGraph, b.stageGraph);
  swap(a.stageList, b.stageList);
  swap(a.done, b.done);
  swap(a.started, b.started);
  swap(a.__isset, b.__isset);
}

Query::Query(const Query& other115) {
  queryId = other115.queryId;
  queryType = other115.queryType;
  queryAttributes = other115.queryAttributes;
  queryCounters = other115.queryCounters;
  stageGraph = other115.stageGraph;
  stageList = other115.stageList;
  done = other115.done;
  started = other115.started;
  __isset = other115.__isset;
}
Query& Query::operator=(const Query& other116) {
  queryId = other116.queryId;
  queryType = other116.queryType;
  queryAttributes = other116.queryAttributes;
  queryCounters = other116.queryCounters;
  stageGraph = other116.stageGraph;
  stageList = other116.stageList;
  done = other116.done;
  started = other116.started;
  __isset = other116.__isset;
  return *this;
}
void Query::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Query(";
  out << "queryId=" << to_string(queryId);
  out << ", " << "queryType=" << to_string(queryType);
  out << ", " << "queryAttributes=" << to_string(queryAttributes);
  out << ", " << "queryCounters=" << to_string(queryCounters);
  out << ", " << "stageGraph=" << to_string(stageGraph);
  out << ", " << "stageList=" << to_string(stageList);
  out << ", " << "done=" << to_string(done);
  out << ", " << "started=" << to_string(started);
  out << ")";
}


QueryPlan::~QueryPlan() throw() {
}


void QueryPlan::__set_queries(const std::vector<Query> & val) {
  this->queries = val;
}

void QueryPlan::__set_done(const bool val) {
  this->done = val;
}

void QueryPlan::__set_started(const bool val) {
  this->started = val;
}

uint32_t QueryPlan::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->queries.clear();
            uint32_t _size117;
            ::apache::thrift::protocol::TType _etype120;
            xfer += iprot->readListBegin(_etype120, _size117);
            this->queries.resize(_size117);
            uint32_t _i121;
            for (_i121 = 0; _i121 < _size117; ++_i121)
            {
              xfer += this->queries[_i121].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.queries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->done);
          this->__isset.done = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->started);
          this->__isset.started = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t QueryPlan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("QueryPlan");

  xfer += oprot->writeFieldBegin("queries", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->queries.size()));
    std::vector<Query> ::const_iterator _iter122;
    for (_iter122 = this->queries.begin(); _iter122 != this->queries.end(); ++_iter122)
    {
      xfer += (*_iter122).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("done", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->done);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("started", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->started);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(QueryPlan &a, QueryPlan &b) {
  using ::std::swap;
  swap(a.queries, b.queries);
  swap(a.done, b.done);
  swap(a.started, b.started);
  swap(a.__isset, b.__isset);
}

QueryPlan::QueryPlan(const QueryPlan& other123) {
  queries = other123.queries;
  done = other123.done;
  started = other123.started;
  __isset = other123.__isset;
}
QueryPlan& QueryPlan::operator=(const QueryPlan& other124) {
  queries = other124.queries;
  done = other124.done;
  started = other124.started;
  __isset = other124.__isset;
  return *this;
}
void QueryPlan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "QueryPlan(";
  out << "queries=" << to_string(queries);
  out << ", " << "done=" << to_string(done);
  out << ", " << "started=" << to_string(started);
  out << ")";
}

}}} // namespace
