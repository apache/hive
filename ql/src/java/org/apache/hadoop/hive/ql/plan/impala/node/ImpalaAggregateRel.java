/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.hadoop.hive.ql.plan.impala.node;

import java.util.List;

import com.google.common.base.Preconditions;
import org.apache.calcite.rel.RelWriter;
import org.apache.calcite.rel.core.AggregateCall;
import org.apache.calcite.rel.type.RelDataType;
import org.apache.calcite.sql.SqlAggFunction;
import org.apache.calcite.sql.type.SqlTypeName;
import org.apache.hadoop.hive.metastore.api.MetaException;
import org.apache.hadoop.hive.ql.metadata.HiveException;
import org.apache.hadoop.hive.ql.optimizer.calcite.reloperators.HiveAggregate;
import org.apache.hadoop.hive.ql.plan.impala.ImpalaPlannerContext;
import org.apache.hadoop.hive.ql.plan.impala.expr.ImpalaFunctionCallExpr;
import org.apache.hadoop.hive.ql.plan.impala.funcmapper.*;
import org.apache.impala.analysis.*;
import org.apache.impala.catalog.*;
import org.apache.impala.common.ImpalaException;
import org.apache.impala.planner.PlanNode;
import org.apache.impala.thrift.TPrimitiveType;

import com.google.common.collect.Lists;
import org.apache.impala.planner.PlanNodeId;

public class ImpalaAggregateRel extends ImpalaPlanRel {
  public final HiveAggregate aggregate;

  public PlanNode aggNode;

  public ImpalaAggregateRel(HiveAggregate aggregate) {
    super(aggregate.getCluster(), aggregate.getTraitSet(), aggregate.getInputs(),
        aggregate.getRowType());
    this.aggregate = aggregate;
  }

  /**
   * Convert the Aggregation Rel Node into an Impala Plan Node.
   * Impala has its aggregate structure called MultiAggregateInfo. This structure
   * needs to be analyzed before converting it into the Impala aggregate node.
   * After analyzing, the final output expressions are retrieved through the
   * AggregateInfo structure.
   */
  @Override
  public PlanNode getPlanNode(ImpalaPlannerContext ctx) throws ImpalaException, HiveException, MetaException {
    PlanNodeId nodeId = ctx.getNextNodeId();

    Preconditions.checkState(getInputs().size() == 1);
    PlanNode input = getImpalaRelInput(0).getPlanNode(ctx);

    Analyzer analyzer = ctx.getRootAnalyzer();

    // MultiAggregateInfo class is the Impala class that holds all the analyzed aggregate
    // information that needs to be passed into the planner. One exaple of a complexitiy it
    // handles is the case where there are multiple distinct aggregate clauses.
    MultiAggregateInfo multiAggInfo =
        new MultiAggregateInfo(getGroupingExprs(), getAggregateExprs(ctx));
    multiAggInfo.analyze(analyzer);
    //  CDPD-8480: need to handle when there is more than 1 aggclass.
    if (multiAggInfo.getAggClasses().size() != 1) {
      throw new HiveException("Multiple aggregate classes are not currently supported.");
    }
    // Impala pushes expressions up the stack, but Calcite has already done this.
    // So all expressions generated by Calcite are materialized and this method
    // takes care of that.
    multiAggInfo.materializeRequiredSlots(analyzer, new ExprSubstitutionMap());

    this.nodeInfo = new ImpalaNodeInfo();
    aggNode =
        new ImpalaAggNode(nodeId, input, multiAggInfo, MultiAggregateInfo.AggPhase.FIRST, nodeInfo, ctx);
    aggNode.init(analyzer);
    AggregateInfo aggInfo = multiAggInfo.getAggClasses().get(0);
    this.outputExprs = createOutputExprs(aggInfo.getOutputTupleDesc().getSlots());

    return aggNode;
  }

  private List<Expr> getGroupingExprs() {
    List<Expr> exprs = Lists.newArrayList();

    Preconditions.checkState(getInputs().size() == 1);
    ImpalaPlanRel input = getImpalaRelInput(0);
    for (int group : this.aggregate.getGroupSet()) {
      exprs.add(input.getExpr(group));
    }
    return exprs;
  }

  private List<FunctionCallExpr> getAggregateExprs(ImpalaPlannerContext ctx) throws HiveException {
    List<FunctionCallExpr> exprs = Lists.newArrayList();
    ImpalaPlanRel input = getImpalaRelInput(0);
    for (AggregateCall aggCall : this.aggregate.getAggCallList()) {
      List<Integer> indexes = aggCall.getArgList();
      // index size should be 1, but could be 0 in the case of count(*)
      Preconditions.checkState(indexes.size() <= 1);
      List<Expr> operands = Lists.newArrayList();
      if (indexes.size() == 1) {
        operands.add(input.getExpr(indexes.get(0)));
      }
      Function fn = getFunction(aggCall);

      Type impalaRetType = ImpalaTypeConverter.getImpalaType(aggCall.getType());
      exprs.add(new ImpalaFunctionCallExpr(ctx.getRootAnalyzer(), fn, operands, null, impalaRetType));
    }
    return exprs;
  }

  private Function getFunction(AggregateCall aggCall) {
    RelDataType retType = aggCall.getType();
    SqlAggFunction aggFunction = aggCall.getAggregation();
    List<SqlTypeName> operandTypes = Lists.newArrayList();
    ImpalaPlanRel input = getImpalaRelInput(0);
    for (int i : aggCall.getArgList()) {
      RelDataType relDataType = input.getRowType().getFieldList().get(i).getType();
      operandTypes.add(relDataType.getSqlTypeName());
    }
    AggFunctionDetails funcDetails =
        AggFunctionDetails.get(aggFunction.getName(), retType.getSqlTypeName(), operandTypes);

    FunctionName impalaFuncName = new FunctionName(BuiltinsDb.NAME, aggFunction.getName());
    List<Type> argTypes = ImpalaTypeConverter.getImpalaTypesList(funcDetails.argTypes);
    Type impalaRetType =
        ImpalaTypeConverter.getImpalaType(funcDetails.retType, retType.getPrecision(), retType.getScale());
    Type intermediateType =
        ImpalaTypeConverter.getImpalaType(funcDetails.intermediateType, retType.getPrecision(), retType.getScale());
    return new AggregateFunction(impalaFuncName, argTypes, impalaRetType, intermediateType, null,
            funcDetails.updateFnSymbol, funcDetails.initFnSymbol, funcDetails.serializeFnSymbol,
            funcDetails.mergeFnSymbol, funcDetails.getValueFnSymbol, funcDetails.removeFnSymbol,
            funcDetails.finalizeFnSymbol);
  }
}
