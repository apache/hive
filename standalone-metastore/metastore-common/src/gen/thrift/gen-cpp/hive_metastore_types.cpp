/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "hive_metastore_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace Apache { namespace Hadoop { namespace Hive {

int _kHiveObjectTypeValues[] = {
  HiveObjectType::GLOBAL,
  HiveObjectType::DATABASE,
  HiveObjectType::TABLE,
  HiveObjectType::PARTITION,
  HiveObjectType::COLUMN,
  HiveObjectType::DATACONNECTOR
};
const char* _kHiveObjectTypeNames[] = {
  "GLOBAL",
  "DATABASE",
  "TABLE",
  "PARTITION",
  "COLUMN",
  "DATACONNECTOR"
};
const std::map<int, const char*> _HiveObjectType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kHiveObjectTypeValues, _kHiveObjectTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const HiveObjectType::type& val) {
  std::map<int, const char*>::const_iterator it = _HiveObjectType_VALUES_TO_NAMES.find(val);
  if (it != _HiveObjectType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const HiveObjectType::type& val) {
  std::map<int, const char*>::const_iterator it = _HiveObjectType_VALUES_TO_NAMES.find(val);
  if (it != _HiveObjectType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kPrincipalTypeValues[] = {
  PrincipalType::USER,
  PrincipalType::ROLE,
  PrincipalType::GROUP
};
const char* _kPrincipalTypeNames[] = {
  "USER",
  "ROLE",
  "GROUP"
};
const std::map<int, const char*> _PrincipalType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kPrincipalTypeValues, _kPrincipalTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const PrincipalType::type& val) {
  std::map<int, const char*>::const_iterator it = _PrincipalType_VALUES_TO_NAMES.find(val);
  if (it != _PrincipalType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PrincipalType::type& val) {
  std::map<int, const char*>::const_iterator it = _PrincipalType_VALUES_TO_NAMES.find(val);
  if (it != _PrincipalType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kPartitionEventTypeValues[] = {
  PartitionEventType::LOAD_DONE
};
const char* _kPartitionEventTypeNames[] = {
  "LOAD_DONE"
};
const std::map<int, const char*> _PartitionEventType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kPartitionEventTypeValues, _kPartitionEventTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const PartitionEventType::type& val) {
  std::map<int, const char*>::const_iterator it = _PartitionEventType_VALUES_TO_NAMES.find(val);
  if (it != _PartitionEventType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PartitionEventType::type& val) {
  std::map<int, const char*>::const_iterator it = _PartitionEventType_VALUES_TO_NAMES.find(val);
  if (it != _PartitionEventType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTxnStateValues[] = {
  TxnState::COMMITTED,
  TxnState::ABORTED,
  TxnState::OPEN
};
const char* _kTxnStateNames[] = {
  "COMMITTED",
  "ABORTED",
  "OPEN"
};
const std::map<int, const char*> _TxnState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTxnStateValues, _kTxnStateNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TxnState::type& val) {
  std::map<int, const char*>::const_iterator it = _TxnState_VALUES_TO_NAMES.find(val);
  if (it != _TxnState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TxnState::type& val) {
  std::map<int, const char*>::const_iterator it = _TxnState_VALUES_TO_NAMES.find(val);
  if (it != _TxnState_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kLockLevelValues[] = {
  LockLevel::DB,
  LockLevel::TABLE,
  LockLevel::PARTITION
};
const char* _kLockLevelNames[] = {
  "DB",
  "TABLE",
  "PARTITION"
};
const std::map<int, const char*> _LockLevel_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kLockLevelValues, _kLockLevelNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const LockLevel::type& val) {
  std::map<int, const char*>::const_iterator it = _LockLevel_VALUES_TO_NAMES.find(val);
  if (it != _LockLevel_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const LockLevel::type& val) {
  std::map<int, const char*>::const_iterator it = _LockLevel_VALUES_TO_NAMES.find(val);
  if (it != _LockLevel_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kLockStateValues[] = {
  LockState::ACQUIRED,
  LockState::WAITING,
  LockState::ABORT,
  LockState::NOT_ACQUIRED
};
const char* _kLockStateNames[] = {
  "ACQUIRED",
  "WAITING",
  "ABORT",
  "NOT_ACQUIRED"
};
const std::map<int, const char*> _LockState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kLockStateValues, _kLockStateNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const LockState::type& val) {
  std::map<int, const char*>::const_iterator it = _LockState_VALUES_TO_NAMES.find(val);
  if (it != _LockState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const LockState::type& val) {
  std::map<int, const char*>::const_iterator it = _LockState_VALUES_TO_NAMES.find(val);
  if (it != _LockState_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kLockTypeValues[] = {
  LockType::SHARED_READ,
  LockType::SHARED_WRITE,
  LockType::EXCLUSIVE,
  LockType::EXCL_WRITE
};
const char* _kLockTypeNames[] = {
  "SHARED_READ",
  "SHARED_WRITE",
  "EXCLUSIVE",
  "EXCL_WRITE"
};
const std::map<int, const char*> _LockType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kLockTypeValues, _kLockTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const LockType::type& val) {
  std::map<int, const char*>::const_iterator it = _LockType_VALUES_TO_NAMES.find(val);
  if (it != _LockType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const LockType::type& val) {
  std::map<int, const char*>::const_iterator it = _LockType_VALUES_TO_NAMES.find(val);
  if (it != _LockType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCompactionTypeValues[] = {
  CompactionType::MINOR,
  CompactionType::MAJOR,
  CompactionType::REBALANCE
};
const char* _kCompactionTypeNames[] = {
  "MINOR",
  "MAJOR",
  "REBALANCE"
};
const std::map<int, const char*> _CompactionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kCompactionTypeValues, _kCompactionTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const CompactionType::type& val) {
  std::map<int, const char*>::const_iterator it = _CompactionType_VALUES_TO_NAMES.find(val);
  if (it != _CompactionType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const CompactionType::type& val) {
  std::map<int, const char*>::const_iterator it = _CompactionType_VALUES_TO_NAMES.find(val);
  if (it != _CompactionType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kGrantRevokeTypeValues[] = {
  GrantRevokeType::GRANT,
  GrantRevokeType::REVOKE
};
const char* _kGrantRevokeTypeNames[] = {
  "GRANT",
  "REVOKE"
};
const std::map<int, const char*> _GrantRevokeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kGrantRevokeTypeValues, _kGrantRevokeTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const GrantRevokeType::type& val) {
  std::map<int, const char*>::const_iterator it = _GrantRevokeType_VALUES_TO_NAMES.find(val);
  if (it != _GrantRevokeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const GrantRevokeType::type& val) {
  std::map<int, const char*>::const_iterator it = _GrantRevokeType_VALUES_TO_NAMES.find(val);
  if (it != _GrantRevokeType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kDataOperationTypeValues[] = {
  DataOperationType::SELECT,
  DataOperationType::INSERT,
  DataOperationType::UPDATE,
  DataOperationType::DELETE,
  DataOperationType::UNSET,
  DataOperationType::NO_TXN
};
const char* _kDataOperationTypeNames[] = {
  "SELECT",
  "INSERT",
  "UPDATE",
  "DELETE",
  "UNSET",
  "NO_TXN"
};
const std::map<int, const char*> _DataOperationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kDataOperationTypeValues, _kDataOperationTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const DataOperationType::type& val) {
  std::map<int, const char*>::const_iterator it = _DataOperationType_VALUES_TO_NAMES.find(val);
  if (it != _DataOperationType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const DataOperationType::type& val) {
  std::map<int, const char*>::const_iterator it = _DataOperationType_VALUES_TO_NAMES.find(val);
  if (it != _DataOperationType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kEventRequestTypeValues[] = {
  EventRequestType::INSERT,
  EventRequestType::UPDATE,
  EventRequestType::DELETE
};
const char* _kEventRequestTypeNames[] = {
  "INSERT",
  "UPDATE",
  "DELETE"
};
const std::map<int, const char*> _EventRequestType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kEventRequestTypeValues, _kEventRequestTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const EventRequestType::type& val) {
  std::map<int, const char*>::const_iterator it = _EventRequestType_VALUES_TO_NAMES.find(val);
  if (it != _EventRequestType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const EventRequestType::type& val) {
  std::map<int, const char*>::const_iterator it = _EventRequestType_VALUES_TO_NAMES.find(val);
  if (it != _EventRequestType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSerdeTypeValues[] = {
  SerdeType::HIVE,
  SerdeType::SCHEMA_REGISTRY
};
const char* _kSerdeTypeNames[] = {
  "HIVE",
  "SCHEMA_REGISTRY"
};
const std::map<int, const char*> _SerdeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kSerdeTypeValues, _kSerdeTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SerdeType::type& val) {
  std::map<int, const char*>::const_iterator it = _SerdeType_VALUES_TO_NAMES.find(val);
  if (it != _SerdeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SerdeType::type& val) {
  std::map<int, const char*>::const_iterator it = _SerdeType_VALUES_TO_NAMES.find(val);
  if (it != _SerdeType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSchemaTypeValues[] = {
  SchemaType::HIVE,
  SchemaType::AVRO
};
const char* _kSchemaTypeNames[] = {
  "HIVE",
  "AVRO"
};
const std::map<int, const char*> _SchemaType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kSchemaTypeValues, _kSchemaTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SchemaType::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaType_VALUES_TO_NAMES.find(val);
  if (it != _SchemaType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SchemaType::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaType_VALUES_TO_NAMES.find(val);
  if (it != _SchemaType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSchemaCompatibilityValues[] = {
  SchemaCompatibility::NONE,
  SchemaCompatibility::BACKWARD,
  SchemaCompatibility::FORWARD,
  SchemaCompatibility::BOTH
};
const char* _kSchemaCompatibilityNames[] = {
  "NONE",
  "BACKWARD",
  "FORWARD",
  "BOTH"
};
const std::map<int, const char*> _SchemaCompatibility_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kSchemaCompatibilityValues, _kSchemaCompatibilityNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SchemaCompatibility::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaCompatibility_VALUES_TO_NAMES.find(val);
  if (it != _SchemaCompatibility_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SchemaCompatibility::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaCompatibility_VALUES_TO_NAMES.find(val);
  if (it != _SchemaCompatibility_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSchemaValidationValues[] = {
  SchemaValidation::LATEST,
  SchemaValidation::ALL
};
const char* _kSchemaValidationNames[] = {
  "LATEST",
  "ALL"
};
const std::map<int, const char*> _SchemaValidation_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kSchemaValidationValues, _kSchemaValidationNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SchemaValidation::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaValidation_VALUES_TO_NAMES.find(val);
  if (it != _SchemaValidation_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SchemaValidation::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaValidation_VALUES_TO_NAMES.find(val);
  if (it != _SchemaValidation_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSchemaVersionStateValues[] = {
  SchemaVersionState::INITIATED,
  SchemaVersionState::START_REVIEW,
  SchemaVersionState::CHANGES_REQUIRED,
  SchemaVersionState::REVIEWED,
  SchemaVersionState::ENABLED,
  SchemaVersionState::DISABLED,
  SchemaVersionState::ARCHIVED,
  SchemaVersionState::DELETED
};
const char* _kSchemaVersionStateNames[] = {
  "INITIATED",
  "START_REVIEW",
  "CHANGES_REQUIRED",
  "REVIEWED",
  "ENABLED",
  "DISABLED",
  "ARCHIVED",
  "DELETED"
};
const std::map<int, const char*> _SchemaVersionState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kSchemaVersionStateValues, _kSchemaVersionStateNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SchemaVersionState::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaVersionState_VALUES_TO_NAMES.find(val);
  if (it != _SchemaVersionState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SchemaVersionState::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaVersionState_VALUES_TO_NAMES.find(val);
  if (it != _SchemaVersionState_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kDatabaseTypeValues[] = {
  DatabaseType::NATIVE,
  DatabaseType::REMOTE
};
const char* _kDatabaseTypeNames[] = {
  "NATIVE",
  "REMOTE"
};
const std::map<int, const char*> _DatabaseType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kDatabaseTypeValues, _kDatabaseTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const DatabaseType::type& val) {
  std::map<int, const char*>::const_iterator it = _DatabaseType_VALUES_TO_NAMES.find(val);
  if (it != _DatabaseType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const DatabaseType::type& val) {
  std::map<int, const char*>::const_iterator it = _DatabaseType_VALUES_TO_NAMES.find(val);
  if (it != _DatabaseType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kFunctionTypeValues[] = {
  FunctionType::JAVA
};
const char* _kFunctionTypeNames[] = {
  "JAVA"
};
const std::map<int, const char*> _FunctionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kFunctionTypeValues, _kFunctionTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const FunctionType::type& val) {
  std::map<int, const char*>::const_iterator it = _FunctionType_VALUES_TO_NAMES.find(val);
  if (it != _FunctionType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const FunctionType::type& val) {
  std::map<int, const char*>::const_iterator it = _FunctionType_VALUES_TO_NAMES.find(val);
  if (it != _FunctionType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kResourceTypeValues[] = {
  ResourceType::JAR,
  ResourceType::FILE,
  ResourceType::ARCHIVE
};
const char* _kResourceTypeNames[] = {
  "JAR",
  "FILE",
  "ARCHIVE"
};
const std::map<int, const char*> _ResourceType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kResourceTypeValues, _kResourceTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ResourceType::type& val) {
  std::map<int, const char*>::const_iterator it = _ResourceType_VALUES_TO_NAMES.find(val);
  if (it != _ResourceType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ResourceType::type& val) {
  std::map<int, const char*>::const_iterator it = _ResourceType_VALUES_TO_NAMES.find(val);
  if (it != _ResourceType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTxnTypeValues[] = {
  TxnType::DEFAULT,
  TxnType::REPL_CREATED,
  TxnType::READ_ONLY,
  TxnType::COMPACTION,
  TxnType::MATER_VIEW_REBUILD,
  TxnType::SOFT_DELETE,
  TxnType::REBALANCE_COMPACTION
};
const char* _kTxnTypeNames[] = {
  "DEFAULT",
  "REPL_CREATED",
  "READ_ONLY",
  "COMPACTION",
  "MATER_VIEW_REBUILD",
  "SOFT_DELETE",
  "REBALANCE_COMPACTION"
};
const std::map<int, const char*> _TxnType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kTxnTypeValues, _kTxnTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TxnType::type& val) {
  std::map<int, const char*>::const_iterator it = _TxnType_VALUES_TO_NAMES.find(val);
  if (it != _TxnType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TxnType::type& val) {
  std::map<int, const char*>::const_iterator it = _TxnType_VALUES_TO_NAMES.find(val);
  if (it != _TxnType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kGetTablesExtRequestFieldsValues[] = {
  GetTablesExtRequestFields::ACCESS_TYPE,
  GetTablesExtRequestFields::PROCESSOR_CAPABILITIES,
  GetTablesExtRequestFields::ALL
};
const char* _kGetTablesExtRequestFieldsNames[] = {
  "ACCESS_TYPE",
  "PROCESSOR_CAPABILITIES",
  "ALL"
};
const std::map<int, const char*> _GetTablesExtRequestFields_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kGetTablesExtRequestFieldsValues, _kGetTablesExtRequestFieldsNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const GetTablesExtRequestFields::type& val) {
  std::map<int, const char*>::const_iterator it = _GetTablesExtRequestFields_VALUES_TO_NAMES.find(val);
  if (it != _GetTablesExtRequestFields_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const GetTablesExtRequestFields::type& val) {
  std::map<int, const char*>::const_iterator it = _GetTablesExtRequestFields_VALUES_TO_NAMES.find(val);
  if (it != _GetTablesExtRequestFields_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCompactionMetricsMetricTypeValues[] = {
  CompactionMetricsMetricType::NUM_OBSOLETE_DELTAS,
  CompactionMetricsMetricType::NUM_DELTAS,
  CompactionMetricsMetricType::NUM_SMALL_DELTAS
};
const char* _kCompactionMetricsMetricTypeNames[] = {
  "NUM_OBSOLETE_DELTAS",
  "NUM_DELTAS",
  "NUM_SMALL_DELTAS"
};
const std::map<int, const char*> _CompactionMetricsMetricType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kCompactionMetricsMetricTypeValues, _kCompactionMetricsMetricTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const CompactionMetricsMetricType::type& val) {
  std::map<int, const char*>::const_iterator it = _CompactionMetricsMetricType_VALUES_TO_NAMES.find(val);
  if (it != _CompactionMetricsMetricType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const CompactionMetricsMetricType::type& val) {
  std::map<int, const char*>::const_iterator it = _CompactionMetricsMetricType_VALUES_TO_NAMES.find(val);
  if (it != _CompactionMetricsMetricType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kFileMetadataExprTypeValues[] = {
  FileMetadataExprType::ORC_SARG
};
const char* _kFileMetadataExprTypeNames[] = {
  "ORC_SARG"
};
const std::map<int, const char*> _FileMetadataExprType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kFileMetadataExprTypeValues, _kFileMetadataExprTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const FileMetadataExprType::type& val) {
  std::map<int, const char*>::const_iterator it = _FileMetadataExprType_VALUES_TO_NAMES.find(val);
  if (it != _FileMetadataExprType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const FileMetadataExprType::type& val) {
  std::map<int, const char*>::const_iterator it = _FileMetadataExprType_VALUES_TO_NAMES.find(val);
  if (it != _FileMetadataExprType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kClientCapabilityValues[] = {
  ClientCapability::TEST_CAPABILITY,
  ClientCapability::INSERT_ONLY_TABLES
};
const char* _kClientCapabilityNames[] = {
  "TEST_CAPABILITY",
  "INSERT_ONLY_TABLES"
};
const std::map<int, const char*> _ClientCapability_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kClientCapabilityValues, _kClientCapabilityNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ClientCapability::type& val) {
  std::map<int, const char*>::const_iterator it = _ClientCapability_VALUES_TO_NAMES.find(val);
  if (it != _ClientCapability_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ClientCapability::type& val) {
  std::map<int, const char*>::const_iterator it = _ClientCapability_VALUES_TO_NAMES.find(val);
  if (it != _ClientCapability_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kWMResourcePlanStatusValues[] = {
  WMResourcePlanStatus::ACTIVE,
  WMResourcePlanStatus::ENABLED,
  WMResourcePlanStatus::DISABLED
};
const char* _kWMResourcePlanStatusNames[] = {
  "ACTIVE",
  "ENABLED",
  "DISABLED"
};
const std::map<int, const char*> _WMResourcePlanStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kWMResourcePlanStatusValues, _kWMResourcePlanStatusNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const WMResourcePlanStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _WMResourcePlanStatus_VALUES_TO_NAMES.find(val);
  if (it != _WMResourcePlanStatus_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const WMResourcePlanStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _WMResourcePlanStatus_VALUES_TO_NAMES.find(val);
  if (it != _WMResourcePlanStatus_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kWMPoolSchedulingPolicyValues[] = {
  WMPoolSchedulingPolicy::FAIR,
  WMPoolSchedulingPolicy::FIFO
};
const char* _kWMPoolSchedulingPolicyNames[] = {
  "FAIR",
  "FIFO"
};
const std::map<int, const char*> _WMPoolSchedulingPolicy_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kWMPoolSchedulingPolicyValues, _kWMPoolSchedulingPolicyNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const WMPoolSchedulingPolicy::type& val) {
  std::map<int, const char*>::const_iterator it = _WMPoolSchedulingPolicy_VALUES_TO_NAMES.find(val);
  if (it != _WMPoolSchedulingPolicy_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const WMPoolSchedulingPolicy::type& val) {
  std::map<int, const char*>::const_iterator it = _WMPoolSchedulingPolicy_VALUES_TO_NAMES.find(val);
  if (it != _WMPoolSchedulingPolicy_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kScheduledQueryMaintenanceRequestTypeValues[] = {
  ScheduledQueryMaintenanceRequestType::CREATE,
  ScheduledQueryMaintenanceRequestType::ALTER,
  ScheduledQueryMaintenanceRequestType::DROP
};
const char* _kScheduledQueryMaintenanceRequestTypeNames[] = {
  "CREATE",
  "ALTER",
  "DROP"
};
const std::map<int, const char*> _ScheduledQueryMaintenanceRequestType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kScheduledQueryMaintenanceRequestTypeValues, _kScheduledQueryMaintenanceRequestTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ScheduledQueryMaintenanceRequestType::type& val) {
  std::map<int, const char*>::const_iterator it = _ScheduledQueryMaintenanceRequestType_VALUES_TO_NAMES.find(val);
  if (it != _ScheduledQueryMaintenanceRequestType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ScheduledQueryMaintenanceRequestType::type& val) {
  std::map<int, const char*>::const_iterator it = _ScheduledQueryMaintenanceRequestType_VALUES_TO_NAMES.find(val);
  if (it != _ScheduledQueryMaintenanceRequestType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kQueryStateValues[] = {
  QueryState::INITED,
  QueryState::EXECUTING,
  QueryState::FAILED,
  QueryState::FINISHED,
  QueryState::TIMED_OUT,
  QueryState::AUTO_DISABLED
};
const char* _kQueryStateNames[] = {
  "INITED",
  "EXECUTING",
  "FAILED",
  "FINISHED",
  "TIMED_OUT",
  "AUTO_DISABLED"
};
const std::map<int, const char*> _QueryState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kQueryStateValues, _kQueryStateNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const QueryState::type& val) {
  std::map<int, const char*>::const_iterator it = _QueryState_VALUES_TO_NAMES.find(val);
  if (it != _QueryState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const QueryState::type& val) {
  std::map<int, const char*>::const_iterator it = _QueryState_VALUES_TO_NAMES.find(val);
  if (it != _QueryState_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kPartitionFilterModeValues[] = {
  PartitionFilterMode::BY_NAMES,
  PartitionFilterMode::BY_VALUES,
  PartitionFilterMode::BY_EXPR
};
const char* _kPartitionFilterModeNames[] = {
  "BY_NAMES",
  "BY_VALUES",
  "BY_EXPR"
};
const std::map<int, const char*> _PartitionFilterMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kPartitionFilterModeValues, _kPartitionFilterModeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const PartitionFilterMode::type& val) {
  std::map<int, const char*>::const_iterator it = _PartitionFilterMode_VALUES_TO_NAMES.find(val);
  if (it != _PartitionFilterMode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PartitionFilterMode::type& val) {
  std::map<int, const char*>::const_iterator it = _PartitionFilterMode_VALUES_TO_NAMES.find(val);
  if (it != _PartitionFilterMode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


Version::~Version() noexcept {
}


void Version::__set_version(const std::string& val) {
  this->version = val;
}

void Version::__set_comments(const std::string& val) {
  this->comments = val;
}
std::ostream& operator<<(std::ostream& out, const Version& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Version::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comments);
          this->__isset.comments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Version::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Version");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comments", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->comments);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Version &a, Version &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.comments, b.comments);
  swap(a.__isset, b.__isset);
}

Version::Version(const Version& other0) {
  version = other0.version;
  comments = other0.comments;
  __isset = other0.__isset;
}
Version& Version::operator=(const Version& other1) {
  version = other1.version;
  comments = other1.comments;
  __isset = other1.__isset;
  return *this;
}
void Version::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Version(";
  out << "version=" << to_string(version);
  out << ", " << "comments=" << to_string(comments);
  out << ")";
}


FieldSchema::~FieldSchema() noexcept {
}


void FieldSchema::__set_name(const std::string& val) {
  this->name = val;
}

void FieldSchema::__set_type(const std::string& val) {
  this->type = val;
}

void FieldSchema::__set_comment(const std::string& val) {
  this->comment = val;
}
std::ostream& operator<<(std::ostream& out, const FieldSchema& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FieldSchema::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FieldSchema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FieldSchema");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->comment);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FieldSchema &a, FieldSchema &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

FieldSchema::FieldSchema(const FieldSchema& other2) {
  name = other2.name;
  type = other2.type;
  comment = other2.comment;
  __isset = other2.__isset;
}
FieldSchema& FieldSchema::operator=(const FieldSchema& other3) {
  name = other3.name;
  type = other3.type;
  comment = other3.comment;
  __isset = other3.__isset;
  return *this;
}
void FieldSchema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FieldSchema(";
  out << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "comment=" << to_string(comment);
  out << ")";
}


EnvironmentContext::~EnvironmentContext() noexcept {
}


void EnvironmentContext::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
}
std::ostream& operator<<(std::ostream& out, const EnvironmentContext& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t EnvironmentContext::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _ktype5;
            ::apache::thrift::protocol::TType _vtype6;
            xfer += iprot->readMapBegin(_ktype5, _vtype6, _size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              std::string _key9;
              xfer += iprot->readString(_key9);
              std::string& _val10 = this->properties[_key9];
              xfer += iprot->readString(_val10);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EnvironmentContext::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EnvironmentContext");

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter11;
    for (_iter11 = this->properties.begin(); _iter11 != this->properties.end(); ++_iter11)
    {
      xfer += oprot->writeString(_iter11->first);
      xfer += oprot->writeString(_iter11->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EnvironmentContext &a, EnvironmentContext &b) {
  using ::std::swap;
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

EnvironmentContext::EnvironmentContext(const EnvironmentContext& other12) {
  properties = other12.properties;
  __isset = other12.__isset;
}
EnvironmentContext& EnvironmentContext::operator=(const EnvironmentContext& other13) {
  properties = other13.properties;
  __isset = other13.__isset;
  return *this;
}
void EnvironmentContext::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EnvironmentContext(";
  out << "properties=" << to_string(properties);
  out << ")";
}


SQLPrimaryKey::~SQLPrimaryKey() noexcept {
}


void SQLPrimaryKey::__set_table_db(const std::string& val) {
  this->table_db = val;
}

void SQLPrimaryKey::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void SQLPrimaryKey::__set_column_name(const std::string& val) {
  this->column_name = val;
}

void SQLPrimaryKey::__set_key_seq(const int32_t val) {
  this->key_seq = val;
}

void SQLPrimaryKey::__set_pk_name(const std::string& val) {
  this->pk_name = val;
}

void SQLPrimaryKey::__set_enable_cstr(const bool val) {
  this->enable_cstr = val;
}

void SQLPrimaryKey::__set_validate_cstr(const bool val) {
  this->validate_cstr = val;
}

void SQLPrimaryKey::__set_rely_cstr(const bool val) {
  this->rely_cstr = val;
}

void SQLPrimaryKey::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}
std::ostream& operator<<(std::ostream& out, const SQLPrimaryKey& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SQLPrimaryKey::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_db);
          this->__isset.table_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->key_seq);
          this->__isset.key_seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pk_name);
          this->__isset.pk_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable_cstr);
          this->__isset.enable_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->validate_cstr);
          this->__isset.validate_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rely_cstr);
          this->__isset.rely_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SQLPrimaryKey::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SQLPrimaryKey");

  xfer += oprot->writeFieldBegin("table_db", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->table_db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_seq", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->key_seq);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pk_name", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->pk_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable_cstr", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->enable_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validate_cstr", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->validate_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rely_cstr", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->rely_cstr);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SQLPrimaryKey &a, SQLPrimaryKey &b) {
  using ::std::swap;
  swap(a.table_db, b.table_db);
  swap(a.table_name, b.table_name);
  swap(a.column_name, b.column_name);
  swap(a.key_seq, b.key_seq);
  swap(a.pk_name, b.pk_name);
  swap(a.enable_cstr, b.enable_cstr);
  swap(a.validate_cstr, b.validate_cstr);
  swap(a.rely_cstr, b.rely_cstr);
  swap(a.catName, b.catName);
  swap(a.__isset, b.__isset);
}

SQLPrimaryKey::SQLPrimaryKey(const SQLPrimaryKey& other14) {
  table_db = other14.table_db;
  table_name = other14.table_name;
  column_name = other14.column_name;
  key_seq = other14.key_seq;
  pk_name = other14.pk_name;
  enable_cstr = other14.enable_cstr;
  validate_cstr = other14.validate_cstr;
  rely_cstr = other14.rely_cstr;
  catName = other14.catName;
  __isset = other14.__isset;
}
SQLPrimaryKey& SQLPrimaryKey::operator=(const SQLPrimaryKey& other15) {
  table_db = other15.table_db;
  table_name = other15.table_name;
  column_name = other15.column_name;
  key_seq = other15.key_seq;
  pk_name = other15.pk_name;
  enable_cstr = other15.enable_cstr;
  validate_cstr = other15.validate_cstr;
  rely_cstr = other15.rely_cstr;
  catName = other15.catName;
  __isset = other15.__isset;
  return *this;
}
void SQLPrimaryKey::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SQLPrimaryKey(";
  out << "table_db=" << to_string(table_db);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "column_name=" << to_string(column_name);
  out << ", " << "key_seq=" << to_string(key_seq);
  out << ", " << "pk_name=" << to_string(pk_name);
  out << ", " << "enable_cstr=" << to_string(enable_cstr);
  out << ", " << "validate_cstr=" << to_string(validate_cstr);
  out << ", " << "rely_cstr=" << to_string(rely_cstr);
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ")";
}


SQLForeignKey::~SQLForeignKey() noexcept {
}


void SQLForeignKey::__set_pktable_db(const std::string& val) {
  this->pktable_db = val;
}

void SQLForeignKey::__set_pktable_name(const std::string& val) {
  this->pktable_name = val;
}

void SQLForeignKey::__set_pkcolumn_name(const std::string& val) {
  this->pkcolumn_name = val;
}

void SQLForeignKey::__set_fktable_db(const std::string& val) {
  this->fktable_db = val;
}

void SQLForeignKey::__set_fktable_name(const std::string& val) {
  this->fktable_name = val;
}

void SQLForeignKey::__set_fkcolumn_name(const std::string& val) {
  this->fkcolumn_name = val;
}

void SQLForeignKey::__set_key_seq(const int32_t val) {
  this->key_seq = val;
}

void SQLForeignKey::__set_update_rule(const int32_t val) {
  this->update_rule = val;
}

void SQLForeignKey::__set_delete_rule(const int32_t val) {
  this->delete_rule = val;
}

void SQLForeignKey::__set_fk_name(const std::string& val) {
  this->fk_name = val;
}

void SQLForeignKey::__set_pk_name(const std::string& val) {
  this->pk_name = val;
}

void SQLForeignKey::__set_enable_cstr(const bool val) {
  this->enable_cstr = val;
}

void SQLForeignKey::__set_validate_cstr(const bool val) {
  this->validate_cstr = val;
}

void SQLForeignKey::__set_rely_cstr(const bool val) {
  this->rely_cstr = val;
}

void SQLForeignKey::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}
std::ostream& operator<<(std::ostream& out, const SQLForeignKey& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SQLForeignKey::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pktable_db);
          this->__isset.pktable_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pktable_name);
          this->__isset.pktable_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pkcolumn_name);
          this->__isset.pkcolumn_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fktable_db);
          this->__isset.fktable_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fktable_name);
          this->__isset.fktable_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fkcolumn_name);
          this->__isset.fkcolumn_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->key_seq);
          this->__isset.key_seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->update_rule);
          this->__isset.update_rule = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->delete_rule);
          this->__isset.delete_rule = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fk_name);
          this->__isset.fk_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pk_name);
          this->__isset.pk_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable_cstr);
          this->__isset.enable_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->validate_cstr);
          this->__isset.validate_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rely_cstr);
          this->__isset.rely_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SQLForeignKey::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SQLForeignKey");

  xfer += oprot->writeFieldBegin("pktable_db", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->pktable_db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pktable_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->pktable_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pkcolumn_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->pkcolumn_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fktable_db", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->fktable_db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fktable_name", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->fktable_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fkcolumn_name", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->fkcolumn_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_seq", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->key_seq);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_rule", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->update_rule);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_rule", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->delete_rule);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fk_name", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->fk_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pk_name", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->pk_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable_cstr", ::apache::thrift::protocol::T_BOOL, 12);
  xfer += oprot->writeBool(this->enable_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validate_cstr", ::apache::thrift::protocol::T_BOOL, 13);
  xfer += oprot->writeBool(this->validate_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rely_cstr", ::apache::thrift::protocol::T_BOOL, 14);
  xfer += oprot->writeBool(this->rely_cstr);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SQLForeignKey &a, SQLForeignKey &b) {
  using ::std::swap;
  swap(a.pktable_db, b.pktable_db);
  swap(a.pktable_name, b.pktable_name);
  swap(a.pkcolumn_name, b.pkcolumn_name);
  swap(a.fktable_db, b.fktable_db);
  swap(a.fktable_name, b.fktable_name);
  swap(a.fkcolumn_name, b.fkcolumn_name);
  swap(a.key_seq, b.key_seq);
  swap(a.update_rule, b.update_rule);
  swap(a.delete_rule, b.delete_rule);
  swap(a.fk_name, b.fk_name);
  swap(a.pk_name, b.pk_name);
  swap(a.enable_cstr, b.enable_cstr);
  swap(a.validate_cstr, b.validate_cstr);
  swap(a.rely_cstr, b.rely_cstr);
  swap(a.catName, b.catName);
  swap(a.__isset, b.__isset);
}

SQLForeignKey::SQLForeignKey(const SQLForeignKey& other16) {
  pktable_db = other16.pktable_db;
  pktable_name = other16.pktable_name;
  pkcolumn_name = other16.pkcolumn_name;
  fktable_db = other16.fktable_db;
  fktable_name = other16.fktable_name;
  fkcolumn_name = other16.fkcolumn_name;
  key_seq = other16.key_seq;
  update_rule = other16.update_rule;
  delete_rule = other16.delete_rule;
  fk_name = other16.fk_name;
  pk_name = other16.pk_name;
  enable_cstr = other16.enable_cstr;
  validate_cstr = other16.validate_cstr;
  rely_cstr = other16.rely_cstr;
  catName = other16.catName;
  __isset = other16.__isset;
}
SQLForeignKey& SQLForeignKey::operator=(const SQLForeignKey& other17) {
  pktable_db = other17.pktable_db;
  pktable_name = other17.pktable_name;
  pkcolumn_name = other17.pkcolumn_name;
  fktable_db = other17.fktable_db;
  fktable_name = other17.fktable_name;
  fkcolumn_name = other17.fkcolumn_name;
  key_seq = other17.key_seq;
  update_rule = other17.update_rule;
  delete_rule = other17.delete_rule;
  fk_name = other17.fk_name;
  pk_name = other17.pk_name;
  enable_cstr = other17.enable_cstr;
  validate_cstr = other17.validate_cstr;
  rely_cstr = other17.rely_cstr;
  catName = other17.catName;
  __isset = other17.__isset;
  return *this;
}
void SQLForeignKey::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SQLForeignKey(";
  out << "pktable_db=" << to_string(pktable_db);
  out << ", " << "pktable_name=" << to_string(pktable_name);
  out << ", " << "pkcolumn_name=" << to_string(pkcolumn_name);
  out << ", " << "fktable_db=" << to_string(fktable_db);
  out << ", " << "fktable_name=" << to_string(fktable_name);
  out << ", " << "fkcolumn_name=" << to_string(fkcolumn_name);
  out << ", " << "key_seq=" << to_string(key_seq);
  out << ", " << "update_rule=" << to_string(update_rule);
  out << ", " << "delete_rule=" << to_string(delete_rule);
  out << ", " << "fk_name=" << to_string(fk_name);
  out << ", " << "pk_name=" << to_string(pk_name);
  out << ", " << "enable_cstr=" << to_string(enable_cstr);
  out << ", " << "validate_cstr=" << to_string(validate_cstr);
  out << ", " << "rely_cstr=" << to_string(rely_cstr);
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ")";
}


SQLUniqueConstraint::~SQLUniqueConstraint() noexcept {
}


void SQLUniqueConstraint::__set_catName(const std::string& val) {
  this->catName = val;
}

void SQLUniqueConstraint::__set_table_db(const std::string& val) {
  this->table_db = val;
}

void SQLUniqueConstraint::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void SQLUniqueConstraint::__set_column_name(const std::string& val) {
  this->column_name = val;
}

void SQLUniqueConstraint::__set_key_seq(const int32_t val) {
  this->key_seq = val;
}

void SQLUniqueConstraint::__set_uk_name(const std::string& val) {
  this->uk_name = val;
}

void SQLUniqueConstraint::__set_enable_cstr(const bool val) {
  this->enable_cstr = val;
}

void SQLUniqueConstraint::__set_validate_cstr(const bool val) {
  this->validate_cstr = val;
}

void SQLUniqueConstraint::__set_rely_cstr(const bool val) {
  this->rely_cstr = val;
}
std::ostream& operator<<(std::ostream& out, const SQLUniqueConstraint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SQLUniqueConstraint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_db);
          this->__isset.table_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->key_seq);
          this->__isset.key_seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uk_name);
          this->__isset.uk_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable_cstr);
          this->__isset.enable_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->validate_cstr);
          this->__isset.validate_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rely_cstr);
          this->__isset.rely_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SQLUniqueConstraint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SQLUniqueConstraint");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_db", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_seq", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->key_seq);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uk_name", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->uk_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable_cstr", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->enable_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validate_cstr", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->validate_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rely_cstr", ::apache::thrift::protocol::T_BOOL, 9);
  xfer += oprot->writeBool(this->rely_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SQLUniqueConstraint &a, SQLUniqueConstraint &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.table_db, b.table_db);
  swap(a.table_name, b.table_name);
  swap(a.column_name, b.column_name);
  swap(a.key_seq, b.key_seq);
  swap(a.uk_name, b.uk_name);
  swap(a.enable_cstr, b.enable_cstr);
  swap(a.validate_cstr, b.validate_cstr);
  swap(a.rely_cstr, b.rely_cstr);
  swap(a.__isset, b.__isset);
}

SQLUniqueConstraint::SQLUniqueConstraint(const SQLUniqueConstraint& other18) {
  catName = other18.catName;
  table_db = other18.table_db;
  table_name = other18.table_name;
  column_name = other18.column_name;
  key_seq = other18.key_seq;
  uk_name = other18.uk_name;
  enable_cstr = other18.enable_cstr;
  validate_cstr = other18.validate_cstr;
  rely_cstr = other18.rely_cstr;
  __isset = other18.__isset;
}
SQLUniqueConstraint& SQLUniqueConstraint::operator=(const SQLUniqueConstraint& other19) {
  catName = other19.catName;
  table_db = other19.table_db;
  table_name = other19.table_name;
  column_name = other19.column_name;
  key_seq = other19.key_seq;
  uk_name = other19.uk_name;
  enable_cstr = other19.enable_cstr;
  validate_cstr = other19.validate_cstr;
  rely_cstr = other19.rely_cstr;
  __isset = other19.__isset;
  return *this;
}
void SQLUniqueConstraint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SQLUniqueConstraint(";
  out << "catName=" << to_string(catName);
  out << ", " << "table_db=" << to_string(table_db);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "column_name=" << to_string(column_name);
  out << ", " << "key_seq=" << to_string(key_seq);
  out << ", " << "uk_name=" << to_string(uk_name);
  out << ", " << "enable_cstr=" << to_string(enable_cstr);
  out << ", " << "validate_cstr=" << to_string(validate_cstr);
  out << ", " << "rely_cstr=" << to_string(rely_cstr);
  out << ")";
}


SQLNotNullConstraint::~SQLNotNullConstraint() noexcept {
}


void SQLNotNullConstraint::__set_catName(const std::string& val) {
  this->catName = val;
}

void SQLNotNullConstraint::__set_table_db(const std::string& val) {
  this->table_db = val;
}

void SQLNotNullConstraint::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void SQLNotNullConstraint::__set_column_name(const std::string& val) {
  this->column_name = val;
}

void SQLNotNullConstraint::__set_nn_name(const std::string& val) {
  this->nn_name = val;
}

void SQLNotNullConstraint::__set_enable_cstr(const bool val) {
  this->enable_cstr = val;
}

void SQLNotNullConstraint::__set_validate_cstr(const bool val) {
  this->validate_cstr = val;
}

void SQLNotNullConstraint::__set_rely_cstr(const bool val) {
  this->rely_cstr = val;
}
std::ostream& operator<<(std::ostream& out, const SQLNotNullConstraint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SQLNotNullConstraint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_db);
          this->__isset.table_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nn_name);
          this->__isset.nn_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable_cstr);
          this->__isset.enable_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->validate_cstr);
          this->__isset.validate_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rely_cstr);
          this->__isset.rely_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SQLNotNullConstraint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SQLNotNullConstraint");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_db", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nn_name", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->nn_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable_cstr", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->enable_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validate_cstr", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->validate_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rely_cstr", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->rely_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SQLNotNullConstraint &a, SQLNotNullConstraint &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.table_db, b.table_db);
  swap(a.table_name, b.table_name);
  swap(a.column_name, b.column_name);
  swap(a.nn_name, b.nn_name);
  swap(a.enable_cstr, b.enable_cstr);
  swap(a.validate_cstr, b.validate_cstr);
  swap(a.rely_cstr, b.rely_cstr);
  swap(a.__isset, b.__isset);
}

SQLNotNullConstraint::SQLNotNullConstraint(const SQLNotNullConstraint& other20) {
  catName = other20.catName;
  table_db = other20.table_db;
  table_name = other20.table_name;
  column_name = other20.column_name;
  nn_name = other20.nn_name;
  enable_cstr = other20.enable_cstr;
  validate_cstr = other20.validate_cstr;
  rely_cstr = other20.rely_cstr;
  __isset = other20.__isset;
}
SQLNotNullConstraint& SQLNotNullConstraint::operator=(const SQLNotNullConstraint& other21) {
  catName = other21.catName;
  table_db = other21.table_db;
  table_name = other21.table_name;
  column_name = other21.column_name;
  nn_name = other21.nn_name;
  enable_cstr = other21.enable_cstr;
  validate_cstr = other21.validate_cstr;
  rely_cstr = other21.rely_cstr;
  __isset = other21.__isset;
  return *this;
}
void SQLNotNullConstraint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SQLNotNullConstraint(";
  out << "catName=" << to_string(catName);
  out << ", " << "table_db=" << to_string(table_db);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "column_name=" << to_string(column_name);
  out << ", " << "nn_name=" << to_string(nn_name);
  out << ", " << "enable_cstr=" << to_string(enable_cstr);
  out << ", " << "validate_cstr=" << to_string(validate_cstr);
  out << ", " << "rely_cstr=" << to_string(rely_cstr);
  out << ")";
}


SQLDefaultConstraint::~SQLDefaultConstraint() noexcept {
}


void SQLDefaultConstraint::__set_catName(const std::string& val) {
  this->catName = val;
}

void SQLDefaultConstraint::__set_table_db(const std::string& val) {
  this->table_db = val;
}

void SQLDefaultConstraint::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void SQLDefaultConstraint::__set_column_name(const std::string& val) {
  this->column_name = val;
}

void SQLDefaultConstraint::__set_default_value(const std::string& val) {
  this->default_value = val;
}

void SQLDefaultConstraint::__set_dc_name(const std::string& val) {
  this->dc_name = val;
}

void SQLDefaultConstraint::__set_enable_cstr(const bool val) {
  this->enable_cstr = val;
}

void SQLDefaultConstraint::__set_validate_cstr(const bool val) {
  this->validate_cstr = val;
}

void SQLDefaultConstraint::__set_rely_cstr(const bool val) {
  this->rely_cstr = val;
}
std::ostream& operator<<(std::ostream& out, const SQLDefaultConstraint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SQLDefaultConstraint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_db);
          this->__isset.table_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->default_value);
          this->__isset.default_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dc_name);
          this->__isset.dc_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable_cstr);
          this->__isset.enable_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->validate_cstr);
          this->__isset.validate_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rely_cstr);
          this->__isset.rely_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SQLDefaultConstraint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SQLDefaultConstraint");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_db", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("default_value", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->default_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dc_name", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->dc_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable_cstr", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->enable_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validate_cstr", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->validate_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rely_cstr", ::apache::thrift::protocol::T_BOOL, 9);
  xfer += oprot->writeBool(this->rely_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SQLDefaultConstraint &a, SQLDefaultConstraint &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.table_db, b.table_db);
  swap(a.table_name, b.table_name);
  swap(a.column_name, b.column_name);
  swap(a.default_value, b.default_value);
  swap(a.dc_name, b.dc_name);
  swap(a.enable_cstr, b.enable_cstr);
  swap(a.validate_cstr, b.validate_cstr);
  swap(a.rely_cstr, b.rely_cstr);
  swap(a.__isset, b.__isset);
}

SQLDefaultConstraint::SQLDefaultConstraint(const SQLDefaultConstraint& other22) {
  catName = other22.catName;
  table_db = other22.table_db;
  table_name = other22.table_name;
  column_name = other22.column_name;
  default_value = other22.default_value;
  dc_name = other22.dc_name;
  enable_cstr = other22.enable_cstr;
  validate_cstr = other22.validate_cstr;
  rely_cstr = other22.rely_cstr;
  __isset = other22.__isset;
}
SQLDefaultConstraint& SQLDefaultConstraint::operator=(const SQLDefaultConstraint& other23) {
  catName = other23.catName;
  table_db = other23.table_db;
  table_name = other23.table_name;
  column_name = other23.column_name;
  default_value = other23.default_value;
  dc_name = other23.dc_name;
  enable_cstr = other23.enable_cstr;
  validate_cstr = other23.validate_cstr;
  rely_cstr = other23.rely_cstr;
  __isset = other23.__isset;
  return *this;
}
void SQLDefaultConstraint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SQLDefaultConstraint(";
  out << "catName=" << to_string(catName);
  out << ", " << "table_db=" << to_string(table_db);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "column_name=" << to_string(column_name);
  out << ", " << "default_value=" << to_string(default_value);
  out << ", " << "dc_name=" << to_string(dc_name);
  out << ", " << "enable_cstr=" << to_string(enable_cstr);
  out << ", " << "validate_cstr=" << to_string(validate_cstr);
  out << ", " << "rely_cstr=" << to_string(rely_cstr);
  out << ")";
}


SQLCheckConstraint::~SQLCheckConstraint() noexcept {
}


void SQLCheckConstraint::__set_catName(const std::string& val) {
  this->catName = val;
}

void SQLCheckConstraint::__set_table_db(const std::string& val) {
  this->table_db = val;
}

void SQLCheckConstraint::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void SQLCheckConstraint::__set_column_name(const std::string& val) {
  this->column_name = val;
}

void SQLCheckConstraint::__set_check_expression(const std::string& val) {
  this->check_expression = val;
}

void SQLCheckConstraint::__set_dc_name(const std::string& val) {
  this->dc_name = val;
}

void SQLCheckConstraint::__set_enable_cstr(const bool val) {
  this->enable_cstr = val;
}

void SQLCheckConstraint::__set_validate_cstr(const bool val) {
  this->validate_cstr = val;
}

void SQLCheckConstraint::__set_rely_cstr(const bool val) {
  this->rely_cstr = val;
}
std::ostream& operator<<(std::ostream& out, const SQLCheckConstraint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SQLCheckConstraint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_db);
          this->__isset.table_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->check_expression);
          this->__isset.check_expression = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dc_name);
          this->__isset.dc_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable_cstr);
          this->__isset.enable_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->validate_cstr);
          this->__isset.validate_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rely_cstr);
          this->__isset.rely_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SQLCheckConstraint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SQLCheckConstraint");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_db", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("check_expression", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->check_expression);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dc_name", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->dc_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable_cstr", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->enable_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validate_cstr", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->validate_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rely_cstr", ::apache::thrift::protocol::T_BOOL, 9);
  xfer += oprot->writeBool(this->rely_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SQLCheckConstraint &a, SQLCheckConstraint &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.table_db, b.table_db);
  swap(a.table_name, b.table_name);
  swap(a.column_name, b.column_name);
  swap(a.check_expression, b.check_expression);
  swap(a.dc_name, b.dc_name);
  swap(a.enable_cstr, b.enable_cstr);
  swap(a.validate_cstr, b.validate_cstr);
  swap(a.rely_cstr, b.rely_cstr);
  swap(a.__isset, b.__isset);
}

SQLCheckConstraint::SQLCheckConstraint(const SQLCheckConstraint& other24) {
  catName = other24.catName;
  table_db = other24.table_db;
  table_name = other24.table_name;
  column_name = other24.column_name;
  check_expression = other24.check_expression;
  dc_name = other24.dc_name;
  enable_cstr = other24.enable_cstr;
  validate_cstr = other24.validate_cstr;
  rely_cstr = other24.rely_cstr;
  __isset = other24.__isset;
}
SQLCheckConstraint& SQLCheckConstraint::operator=(const SQLCheckConstraint& other25) {
  catName = other25.catName;
  table_db = other25.table_db;
  table_name = other25.table_name;
  column_name = other25.column_name;
  check_expression = other25.check_expression;
  dc_name = other25.dc_name;
  enable_cstr = other25.enable_cstr;
  validate_cstr = other25.validate_cstr;
  rely_cstr = other25.rely_cstr;
  __isset = other25.__isset;
  return *this;
}
void SQLCheckConstraint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SQLCheckConstraint(";
  out << "catName=" << to_string(catName);
  out << ", " << "table_db=" << to_string(table_db);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "column_name=" << to_string(column_name);
  out << ", " << "check_expression=" << to_string(check_expression);
  out << ", " << "dc_name=" << to_string(dc_name);
  out << ", " << "enable_cstr=" << to_string(enable_cstr);
  out << ", " << "validate_cstr=" << to_string(validate_cstr);
  out << ", " << "rely_cstr=" << to_string(rely_cstr);
  out << ")";
}


SQLAllTableConstraints::~SQLAllTableConstraints() noexcept {
}


void SQLAllTableConstraints::__set_primaryKeys(const std::vector<SQLPrimaryKey> & val) {
  this->primaryKeys = val;
__isset.primaryKeys = true;
}

void SQLAllTableConstraints::__set_foreignKeys(const std::vector<SQLForeignKey> & val) {
  this->foreignKeys = val;
__isset.foreignKeys = true;
}

void SQLAllTableConstraints::__set_uniqueConstraints(const std::vector<SQLUniqueConstraint> & val) {
  this->uniqueConstraints = val;
__isset.uniqueConstraints = true;
}

void SQLAllTableConstraints::__set_notNullConstraints(const std::vector<SQLNotNullConstraint> & val) {
  this->notNullConstraints = val;
__isset.notNullConstraints = true;
}

void SQLAllTableConstraints::__set_defaultConstraints(const std::vector<SQLDefaultConstraint> & val) {
  this->defaultConstraints = val;
__isset.defaultConstraints = true;
}

void SQLAllTableConstraints::__set_checkConstraints(const std::vector<SQLCheckConstraint> & val) {
  this->checkConstraints = val;
__isset.checkConstraints = true;
}
std::ostream& operator<<(std::ostream& out, const SQLAllTableConstraints& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SQLAllTableConstraints::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->primaryKeys.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->primaryKeys.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += this->primaryKeys[_i30].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.primaryKeys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->foreignKeys.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->foreignKeys.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              xfer += this->foreignKeys[_i35].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.foreignKeys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->uniqueConstraints.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->uniqueConstraints.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += this->uniqueConstraints[_i40].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.uniqueConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->notNullConstraints.clear();
            uint32_t _size41;
            ::apache::thrift::protocol::TType _etype44;
            xfer += iprot->readListBegin(_etype44, _size41);
            this->notNullConstraints.resize(_size41);
            uint32_t _i45;
            for (_i45 = 0; _i45 < _size41; ++_i45)
            {
              xfer += this->notNullConstraints[_i45].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.notNullConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->defaultConstraints.clear();
            uint32_t _size46;
            ::apache::thrift::protocol::TType _etype49;
            xfer += iprot->readListBegin(_etype49, _size46);
            this->defaultConstraints.resize(_size46);
            uint32_t _i50;
            for (_i50 = 0; _i50 < _size46; ++_i50)
            {
              xfer += this->defaultConstraints[_i50].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.defaultConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->checkConstraints.clear();
            uint32_t _size51;
            ::apache::thrift::protocol::TType _etype54;
            xfer += iprot->readListBegin(_etype54, _size51);
            this->checkConstraints.resize(_size51);
            uint32_t _i55;
            for (_i55 = 0; _i55 < _size51; ++_i55)
            {
              xfer += this->checkConstraints[_i55].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.checkConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SQLAllTableConstraints::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SQLAllTableConstraints");

  if (this->__isset.primaryKeys) {
    xfer += oprot->writeFieldBegin("primaryKeys", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->primaryKeys.size()));
      std::vector<SQLPrimaryKey> ::const_iterator _iter56;
      for (_iter56 = this->primaryKeys.begin(); _iter56 != this->primaryKeys.end(); ++_iter56)
      {
        xfer += (*_iter56).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.foreignKeys) {
    xfer += oprot->writeFieldBegin("foreignKeys", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->foreignKeys.size()));
      std::vector<SQLForeignKey> ::const_iterator _iter57;
      for (_iter57 = this->foreignKeys.begin(); _iter57 != this->foreignKeys.end(); ++_iter57)
      {
        xfer += (*_iter57).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.uniqueConstraints) {
    xfer += oprot->writeFieldBegin("uniqueConstraints", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->uniqueConstraints.size()));
      std::vector<SQLUniqueConstraint> ::const_iterator _iter58;
      for (_iter58 = this->uniqueConstraints.begin(); _iter58 != this->uniqueConstraints.end(); ++_iter58)
      {
        xfer += (*_iter58).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.notNullConstraints) {
    xfer += oprot->writeFieldBegin("notNullConstraints", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->notNullConstraints.size()));
      std::vector<SQLNotNullConstraint> ::const_iterator _iter59;
      for (_iter59 = this->notNullConstraints.begin(); _iter59 != this->notNullConstraints.end(); ++_iter59)
      {
        xfer += (*_iter59).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.defaultConstraints) {
    xfer += oprot->writeFieldBegin("defaultConstraints", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->defaultConstraints.size()));
      std::vector<SQLDefaultConstraint> ::const_iterator _iter60;
      for (_iter60 = this->defaultConstraints.begin(); _iter60 != this->defaultConstraints.end(); ++_iter60)
      {
        xfer += (*_iter60).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.checkConstraints) {
    xfer += oprot->writeFieldBegin("checkConstraints", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->checkConstraints.size()));
      std::vector<SQLCheckConstraint> ::const_iterator _iter61;
      for (_iter61 = this->checkConstraints.begin(); _iter61 != this->checkConstraints.end(); ++_iter61)
      {
        xfer += (*_iter61).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SQLAllTableConstraints &a, SQLAllTableConstraints &b) {
  using ::std::swap;
  swap(a.primaryKeys, b.primaryKeys);
  swap(a.foreignKeys, b.foreignKeys);
  swap(a.uniqueConstraints, b.uniqueConstraints);
  swap(a.notNullConstraints, b.notNullConstraints);
  swap(a.defaultConstraints, b.defaultConstraints);
  swap(a.checkConstraints, b.checkConstraints);
  swap(a.__isset, b.__isset);
}

SQLAllTableConstraints::SQLAllTableConstraints(const SQLAllTableConstraints& other62) {
  primaryKeys = other62.primaryKeys;
  foreignKeys = other62.foreignKeys;
  uniqueConstraints = other62.uniqueConstraints;
  notNullConstraints = other62.notNullConstraints;
  defaultConstraints = other62.defaultConstraints;
  checkConstraints = other62.checkConstraints;
  __isset = other62.__isset;
}
SQLAllTableConstraints& SQLAllTableConstraints::operator=(const SQLAllTableConstraints& other63) {
  primaryKeys = other63.primaryKeys;
  foreignKeys = other63.foreignKeys;
  uniqueConstraints = other63.uniqueConstraints;
  notNullConstraints = other63.notNullConstraints;
  defaultConstraints = other63.defaultConstraints;
  checkConstraints = other63.checkConstraints;
  __isset = other63.__isset;
  return *this;
}
void SQLAllTableConstraints::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SQLAllTableConstraints(";
  out << "primaryKeys="; (__isset.primaryKeys ? (out << to_string(primaryKeys)) : (out << "<null>"));
  out << ", " << "foreignKeys="; (__isset.foreignKeys ? (out << to_string(foreignKeys)) : (out << "<null>"));
  out << ", " << "uniqueConstraints="; (__isset.uniqueConstraints ? (out << to_string(uniqueConstraints)) : (out << "<null>"));
  out << ", " << "notNullConstraints="; (__isset.notNullConstraints ? (out << to_string(notNullConstraints)) : (out << "<null>"));
  out << ", " << "defaultConstraints="; (__isset.defaultConstraints ? (out << to_string(defaultConstraints)) : (out << "<null>"));
  out << ", " << "checkConstraints="; (__isset.checkConstraints ? (out << to_string(checkConstraints)) : (out << "<null>"));
  out << ")";
}


Type::~Type() noexcept {
}


void Type::__set_name(const std::string& val) {
  this->name = val;
}

void Type::__set_type1(const std::string& val) {
  this->type1 = val;
__isset.type1 = true;
}

void Type::__set_type2(const std::string& val) {
  this->type2 = val;
__isset.type2 = true;
}

void Type::__set_fields(const std::vector<FieldSchema> & val) {
  this->fields = val;
__isset.fields = true;
}
std::ostream& operator<<(std::ostream& out, const Type& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Type::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type1);
          this->__isset.type1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type2);
          this->__isset.type2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fields.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _etype67;
            xfer += iprot->readListBegin(_etype67, _size64);
            this->fields.resize(_size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              xfer += this->fields[_i68].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Type::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Type");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.type1) {
    xfer += oprot->writeFieldBegin("type1", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->type1);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type2) {
    xfer += oprot->writeFieldBegin("type2", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->type2);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fields) {
    xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fields.size()));
      std::vector<FieldSchema> ::const_iterator _iter69;
      for (_iter69 = this->fields.begin(); _iter69 != this->fields.end(); ++_iter69)
      {
        xfer += (*_iter69).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Type &a, Type &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.type1, b.type1);
  swap(a.type2, b.type2);
  swap(a.fields, b.fields);
  swap(a.__isset, b.__isset);
}

Type::Type(const Type& other70) {
  name = other70.name;
  type1 = other70.type1;
  type2 = other70.type2;
  fields = other70.fields;
  __isset = other70.__isset;
}
Type& Type::operator=(const Type& other71) {
  name = other71.name;
  type1 = other71.type1;
  type2 = other71.type2;
  fields = other71.fields;
  __isset = other71.__isset;
  return *this;
}
void Type::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Type(";
  out << "name=" << to_string(name);
  out << ", " << "type1="; (__isset.type1 ? (out << to_string(type1)) : (out << "<null>"));
  out << ", " << "type2="; (__isset.type2 ? (out << to_string(type2)) : (out << "<null>"));
  out << ", " << "fields="; (__isset.fields ? (out << to_string(fields)) : (out << "<null>"));
  out << ")";
}


HiveObjectRef::~HiveObjectRef() noexcept {
}


void HiveObjectRef::__set_objectType(const HiveObjectType::type val) {
  this->objectType = val;
}

void HiveObjectRef::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void HiveObjectRef::__set_objectName(const std::string& val) {
  this->objectName = val;
}

void HiveObjectRef::__set_partValues(const std::vector<std::string> & val) {
  this->partValues = val;
}

void HiveObjectRef::__set_columnName(const std::string& val) {
  this->columnName = val;
}

void HiveObjectRef::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}
std::ostream& operator<<(std::ostream& out, const HiveObjectRef& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HiveObjectRef::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast72;
          xfer += iprot->readI32(ecast72);
          this->objectType = static_cast<HiveObjectType::type>(ecast72);
          this->__isset.objectType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->objectName);
          this->__isset.objectName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partValues.clear();
            uint32_t _size73;
            ::apache::thrift::protocol::TType _etype76;
            xfer += iprot->readListBegin(_etype76, _size73);
            this->partValues.resize(_size73);
            uint32_t _i77;
            for (_i77 = 0; _i77 < _size73; ++_i77)
            {
              xfer += iprot->readString(this->partValues[_i77]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnName);
          this->__isset.columnName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HiveObjectRef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HiveObjectRef");

  xfer += oprot->writeFieldBegin("objectType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->objectType));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("objectName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->objectName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partValues", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partValues.size()));
    std::vector<std::string> ::const_iterator _iter78;
    for (_iter78 = this->partValues.begin(); _iter78 != this->partValues.end(); ++_iter78)
    {
      xfer += oprot->writeString((*_iter78));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columnName", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->columnName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HiveObjectRef &a, HiveObjectRef &b) {
  using ::std::swap;
  swap(a.objectType, b.objectType);
  swap(a.dbName, b.dbName);
  swap(a.objectName, b.objectName);
  swap(a.partValues, b.partValues);
  swap(a.columnName, b.columnName);
  swap(a.catName, b.catName);
  swap(a.__isset, b.__isset);
}

HiveObjectRef::HiveObjectRef(const HiveObjectRef& other79) {
  objectType = other79.objectType;
  dbName = other79.dbName;
  objectName = other79.objectName;
  partValues = other79.partValues;
  columnName = other79.columnName;
  catName = other79.catName;
  __isset = other79.__isset;
}
HiveObjectRef& HiveObjectRef::operator=(const HiveObjectRef& other80) {
  objectType = other80.objectType;
  dbName = other80.dbName;
  objectName = other80.objectName;
  partValues = other80.partValues;
  columnName = other80.columnName;
  catName = other80.catName;
  __isset = other80.__isset;
  return *this;
}
void HiveObjectRef::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HiveObjectRef(";
  out << "objectType=" << to_string(objectType);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "objectName=" << to_string(objectName);
  out << ", " << "partValues=" << to_string(partValues);
  out << ", " << "columnName=" << to_string(columnName);
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ")";
}


PrivilegeGrantInfo::~PrivilegeGrantInfo() noexcept {
}


void PrivilegeGrantInfo::__set_privilege(const std::string& val) {
  this->privilege = val;
}

void PrivilegeGrantInfo::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void PrivilegeGrantInfo::__set_grantor(const std::string& val) {
  this->grantor = val;
}

void PrivilegeGrantInfo::__set_grantorType(const PrincipalType::type val) {
  this->grantorType = val;
}

void PrivilegeGrantInfo::__set_grantOption(const bool val) {
  this->grantOption = val;
}
std::ostream& operator<<(std::ostream& out, const PrivilegeGrantInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PrivilegeGrantInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->privilege);
          this->__isset.privilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->grantor);
          this->__isset.grantor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast81;
          xfer += iprot->readI32(ecast81);
          this->grantorType = static_cast<PrincipalType::type>(ecast81);
          this->__isset.grantorType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->grantOption);
          this->__isset.grantOption = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PrivilegeGrantInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PrivilegeGrantInfo");

  xfer += oprot->writeFieldBegin("privilege", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->privilege);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantor", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->grantor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantorType", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(static_cast<int32_t>(this->grantorType));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantOption", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->grantOption);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PrivilegeGrantInfo &a, PrivilegeGrantInfo &b) {
  using ::std::swap;
  swap(a.privilege, b.privilege);
  swap(a.createTime, b.createTime);
  swap(a.grantor, b.grantor);
  swap(a.grantorType, b.grantorType);
  swap(a.grantOption, b.grantOption);
  swap(a.__isset, b.__isset);
}

PrivilegeGrantInfo::PrivilegeGrantInfo(const PrivilegeGrantInfo& other82) {
  privilege = other82.privilege;
  createTime = other82.createTime;
  grantor = other82.grantor;
  grantorType = other82.grantorType;
  grantOption = other82.grantOption;
  __isset = other82.__isset;
}
PrivilegeGrantInfo& PrivilegeGrantInfo::operator=(const PrivilegeGrantInfo& other83) {
  privilege = other83.privilege;
  createTime = other83.createTime;
  grantor = other83.grantor;
  grantorType = other83.grantorType;
  grantOption = other83.grantOption;
  __isset = other83.__isset;
  return *this;
}
void PrivilegeGrantInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PrivilegeGrantInfo(";
  out << "privilege=" << to_string(privilege);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "grantor=" << to_string(grantor);
  out << ", " << "grantorType=" << to_string(grantorType);
  out << ", " << "grantOption=" << to_string(grantOption);
  out << ")";
}


HiveObjectPrivilege::~HiveObjectPrivilege() noexcept {
}


void HiveObjectPrivilege::__set_hiveObject(const HiveObjectRef& val) {
  this->hiveObject = val;
}

void HiveObjectPrivilege::__set_principalName(const std::string& val) {
  this->principalName = val;
}

void HiveObjectPrivilege::__set_principalType(const PrincipalType::type val) {
  this->principalType = val;
}

void HiveObjectPrivilege::__set_grantInfo(const PrivilegeGrantInfo& val) {
  this->grantInfo = val;
}

void HiveObjectPrivilege::__set_authorizer(const std::string& val) {
  this->authorizer = val;
}
std::ostream& operator<<(std::ostream& out, const HiveObjectPrivilege& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HiveObjectPrivilege::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hiveObject.read(iprot);
          this->__isset.hiveObject = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principalName);
          this->__isset.principalName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast84;
          xfer += iprot->readI32(ecast84);
          this->principalType = static_cast<PrincipalType::type>(ecast84);
          this->__isset.principalType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->grantInfo.read(iprot);
          this->__isset.grantInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authorizer);
          this->__isset.authorizer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HiveObjectPrivilege::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HiveObjectPrivilege");

  xfer += oprot->writeFieldBegin("hiveObject", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->hiveObject.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->principalName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(static_cast<int32_t>(this->principalType));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantInfo", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->grantInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authorizer", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->authorizer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HiveObjectPrivilege &a, HiveObjectPrivilege &b) {
  using ::std::swap;
  swap(a.hiveObject, b.hiveObject);
  swap(a.principalName, b.principalName);
  swap(a.principalType, b.principalType);
  swap(a.grantInfo, b.grantInfo);
  swap(a.authorizer, b.authorizer);
  swap(a.__isset, b.__isset);
}

HiveObjectPrivilege::HiveObjectPrivilege(const HiveObjectPrivilege& other85) {
  hiveObject = other85.hiveObject;
  principalName = other85.principalName;
  principalType = other85.principalType;
  grantInfo = other85.grantInfo;
  authorizer = other85.authorizer;
  __isset = other85.__isset;
}
HiveObjectPrivilege& HiveObjectPrivilege::operator=(const HiveObjectPrivilege& other86) {
  hiveObject = other86.hiveObject;
  principalName = other86.principalName;
  principalType = other86.principalType;
  grantInfo = other86.grantInfo;
  authorizer = other86.authorizer;
  __isset = other86.__isset;
  return *this;
}
void HiveObjectPrivilege::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HiveObjectPrivilege(";
  out << "hiveObject=" << to_string(hiveObject);
  out << ", " << "principalName=" << to_string(principalName);
  out << ", " << "principalType=" << to_string(principalType);
  out << ", " << "grantInfo=" << to_string(grantInfo);
  out << ", " << "authorizer=" << to_string(authorizer);
  out << ")";
}


PrivilegeBag::~PrivilegeBag() noexcept {
}


void PrivilegeBag::__set_privileges(const std::vector<HiveObjectPrivilege> & val) {
  this->privileges = val;
}
std::ostream& operator<<(std::ostream& out, const PrivilegeBag& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PrivilegeBag::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->privileges.clear();
            uint32_t _size87;
            ::apache::thrift::protocol::TType _etype90;
            xfer += iprot->readListBegin(_etype90, _size87);
            this->privileges.resize(_size87);
            uint32_t _i91;
            for (_i91 = 0; _i91 < _size87; ++_i91)
            {
              xfer += this->privileges[_i91].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PrivilegeBag::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PrivilegeBag");

  xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->privileges.size()));
    std::vector<HiveObjectPrivilege> ::const_iterator _iter92;
    for (_iter92 = this->privileges.begin(); _iter92 != this->privileges.end(); ++_iter92)
    {
      xfer += (*_iter92).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PrivilegeBag &a, PrivilegeBag &b) {
  using ::std::swap;
  swap(a.privileges, b.privileges);
  swap(a.__isset, b.__isset);
}

PrivilegeBag::PrivilegeBag(const PrivilegeBag& other93) {
  privileges = other93.privileges;
  __isset = other93.__isset;
}
PrivilegeBag& PrivilegeBag::operator=(const PrivilegeBag& other94) {
  privileges = other94.privileges;
  __isset = other94.__isset;
  return *this;
}
void PrivilegeBag::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PrivilegeBag(";
  out << "privileges=" << to_string(privileges);
  out << ")";
}


PrincipalPrivilegeSet::~PrincipalPrivilegeSet() noexcept {
}


void PrincipalPrivilegeSet::__set_userPrivileges(const std::map<std::string, std::vector<PrivilegeGrantInfo> > & val) {
  this->userPrivileges = val;
}

void PrincipalPrivilegeSet::__set_groupPrivileges(const std::map<std::string, std::vector<PrivilegeGrantInfo> > & val) {
  this->groupPrivileges = val;
}

void PrincipalPrivilegeSet::__set_rolePrivileges(const std::map<std::string, std::vector<PrivilegeGrantInfo> > & val) {
  this->rolePrivileges = val;
}
std::ostream& operator<<(std::ostream& out, const PrincipalPrivilegeSet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PrincipalPrivilegeSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->userPrivileges.clear();
            uint32_t _size95;
            ::apache::thrift::protocol::TType _ktype96;
            ::apache::thrift::protocol::TType _vtype97;
            xfer += iprot->readMapBegin(_ktype96, _vtype97, _size95);
            uint32_t _i99;
            for (_i99 = 0; _i99 < _size95; ++_i99)
            {
              std::string _key100;
              xfer += iprot->readString(_key100);
              std::vector<PrivilegeGrantInfo> & _val101 = this->userPrivileges[_key100];
              {
                _val101.clear();
                uint32_t _size102;
                ::apache::thrift::protocol::TType _etype105;
                xfer += iprot->readListBegin(_etype105, _size102);
                _val101.resize(_size102);
                uint32_t _i106;
                for (_i106 = 0; _i106 < _size102; ++_i106)
                {
                  xfer += _val101[_i106].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.userPrivileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->groupPrivileges.clear();
            uint32_t _size107;
            ::apache::thrift::protocol::TType _ktype108;
            ::apache::thrift::protocol::TType _vtype109;
            xfer += iprot->readMapBegin(_ktype108, _vtype109, _size107);
            uint32_t _i111;
            for (_i111 = 0; _i111 < _size107; ++_i111)
            {
              std::string _key112;
              xfer += iprot->readString(_key112);
              std::vector<PrivilegeGrantInfo> & _val113 = this->groupPrivileges[_key112];
              {
                _val113.clear();
                uint32_t _size114;
                ::apache::thrift::protocol::TType _etype117;
                xfer += iprot->readListBegin(_etype117, _size114);
                _val113.resize(_size114);
                uint32_t _i118;
                for (_i118 = 0; _i118 < _size114; ++_i118)
                {
                  xfer += _val113[_i118].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.groupPrivileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->rolePrivileges.clear();
            uint32_t _size119;
            ::apache::thrift::protocol::TType _ktype120;
            ::apache::thrift::protocol::TType _vtype121;
            xfer += iprot->readMapBegin(_ktype120, _vtype121, _size119);
            uint32_t _i123;
            for (_i123 = 0; _i123 < _size119; ++_i123)
            {
              std::string _key124;
              xfer += iprot->readString(_key124);
              std::vector<PrivilegeGrantInfo> & _val125 = this->rolePrivileges[_key124];
              {
                _val125.clear();
                uint32_t _size126;
                ::apache::thrift::protocol::TType _etype129;
                xfer += iprot->readListBegin(_etype129, _size126);
                _val125.resize(_size126);
                uint32_t _i130;
                for (_i130 = 0; _i130 < _size126; ++_i130)
                {
                  xfer += _val125[_i130].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.rolePrivileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PrincipalPrivilegeSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PrincipalPrivilegeSet");

  xfer += oprot->writeFieldBegin("userPrivileges", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->userPrivileges.size()));
    std::map<std::string, std::vector<PrivilegeGrantInfo> > ::const_iterator _iter131;
    for (_iter131 = this->userPrivileges.begin(); _iter131 != this->userPrivileges.end(); ++_iter131)
    {
      xfer += oprot->writeString(_iter131->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter131->second.size()));
        std::vector<PrivilegeGrantInfo> ::const_iterator _iter132;
        for (_iter132 = _iter131->second.begin(); _iter132 != _iter131->second.end(); ++_iter132)
        {
          xfer += (*_iter132).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groupPrivileges", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->groupPrivileges.size()));
    std::map<std::string, std::vector<PrivilegeGrantInfo> > ::const_iterator _iter133;
    for (_iter133 = this->groupPrivileges.begin(); _iter133 != this->groupPrivileges.end(); ++_iter133)
    {
      xfer += oprot->writeString(_iter133->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter133->second.size()));
        std::vector<PrivilegeGrantInfo> ::const_iterator _iter134;
        for (_iter134 = _iter133->second.begin(); _iter134 != _iter133->second.end(); ++_iter134)
        {
          xfer += (*_iter134).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rolePrivileges", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->rolePrivileges.size()));
    std::map<std::string, std::vector<PrivilegeGrantInfo> > ::const_iterator _iter135;
    for (_iter135 = this->rolePrivileges.begin(); _iter135 != this->rolePrivileges.end(); ++_iter135)
    {
      xfer += oprot->writeString(_iter135->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter135->second.size()));
        std::vector<PrivilegeGrantInfo> ::const_iterator _iter136;
        for (_iter136 = _iter135->second.begin(); _iter136 != _iter135->second.end(); ++_iter136)
        {
          xfer += (*_iter136).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PrincipalPrivilegeSet &a, PrincipalPrivilegeSet &b) {
  using ::std::swap;
  swap(a.userPrivileges, b.userPrivileges);
  swap(a.groupPrivileges, b.groupPrivileges);
  swap(a.rolePrivileges, b.rolePrivileges);
  swap(a.__isset, b.__isset);
}

PrincipalPrivilegeSet::PrincipalPrivilegeSet(const PrincipalPrivilegeSet& other137) {
  userPrivileges = other137.userPrivileges;
  groupPrivileges = other137.groupPrivileges;
  rolePrivileges = other137.rolePrivileges;
  __isset = other137.__isset;
}
PrincipalPrivilegeSet& PrincipalPrivilegeSet::operator=(const PrincipalPrivilegeSet& other138) {
  userPrivileges = other138.userPrivileges;
  groupPrivileges = other138.groupPrivileges;
  rolePrivileges = other138.rolePrivileges;
  __isset = other138.__isset;
  return *this;
}
void PrincipalPrivilegeSet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PrincipalPrivilegeSet(";
  out << "userPrivileges=" << to_string(userPrivileges);
  out << ", " << "groupPrivileges=" << to_string(groupPrivileges);
  out << ", " << "rolePrivileges=" << to_string(rolePrivileges);
  out << ")";
}


GrantRevokePrivilegeRequest::~GrantRevokePrivilegeRequest() noexcept {
}


void GrantRevokePrivilegeRequest::__set_requestType(const GrantRevokeType::type val) {
  this->requestType = val;
}

void GrantRevokePrivilegeRequest::__set_privileges(const PrivilegeBag& val) {
  this->privileges = val;
}

void GrantRevokePrivilegeRequest::__set_revokeGrantOption(const bool val) {
  this->revokeGrantOption = val;
__isset.revokeGrantOption = true;
}
std::ostream& operator<<(std::ostream& out, const GrantRevokePrivilegeRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GrantRevokePrivilegeRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast139;
          xfer += iprot->readI32(ecast139);
          this->requestType = static_cast<GrantRevokeType::type>(ecast139);
          this->__isset.requestType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->revokeGrantOption);
          this->__isset.revokeGrantOption = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GrantRevokePrivilegeRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GrantRevokePrivilegeRequest");

  xfer += oprot->writeFieldBegin("requestType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->requestType));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->privileges.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.revokeGrantOption) {
    xfer += oprot->writeFieldBegin("revokeGrantOption", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->revokeGrantOption);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GrantRevokePrivilegeRequest &a, GrantRevokePrivilegeRequest &b) {
  using ::std::swap;
  swap(a.requestType, b.requestType);
  swap(a.privileges, b.privileges);
  swap(a.revokeGrantOption, b.revokeGrantOption);
  swap(a.__isset, b.__isset);
}

GrantRevokePrivilegeRequest::GrantRevokePrivilegeRequest(const GrantRevokePrivilegeRequest& other140) {
  requestType = other140.requestType;
  privileges = other140.privileges;
  revokeGrantOption = other140.revokeGrantOption;
  __isset = other140.__isset;
}
GrantRevokePrivilegeRequest& GrantRevokePrivilegeRequest::operator=(const GrantRevokePrivilegeRequest& other141) {
  requestType = other141.requestType;
  privileges = other141.privileges;
  revokeGrantOption = other141.revokeGrantOption;
  __isset = other141.__isset;
  return *this;
}
void GrantRevokePrivilegeRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GrantRevokePrivilegeRequest(";
  out << "requestType=" << to_string(requestType);
  out << ", " << "privileges=" << to_string(privileges);
  out << ", " << "revokeGrantOption="; (__isset.revokeGrantOption ? (out << to_string(revokeGrantOption)) : (out << "<null>"));
  out << ")";
}


GrantRevokePrivilegeResponse::~GrantRevokePrivilegeResponse() noexcept {
}


void GrantRevokePrivilegeResponse::__set_success(const bool val) {
  this->success = val;
__isset.success = true;
}
std::ostream& operator<<(std::ostream& out, const GrantRevokePrivilegeResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GrantRevokePrivilegeResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GrantRevokePrivilegeResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GrantRevokePrivilegeResponse");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GrantRevokePrivilegeResponse &a, GrantRevokePrivilegeResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.__isset, b.__isset);
}

GrantRevokePrivilegeResponse::GrantRevokePrivilegeResponse(const GrantRevokePrivilegeResponse& other142) noexcept {
  success = other142.success;
  __isset = other142.__isset;
}
GrantRevokePrivilegeResponse& GrantRevokePrivilegeResponse::operator=(const GrantRevokePrivilegeResponse& other143) noexcept {
  success = other143.success;
  __isset = other143.__isset;
  return *this;
}
void GrantRevokePrivilegeResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GrantRevokePrivilegeResponse(";
  out << "success="; (__isset.success ? (out << to_string(success)) : (out << "<null>"));
  out << ")";
}


TruncateTableRequest::~TruncateTableRequest() noexcept {
}


void TruncateTableRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void TruncateTableRequest::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void TruncateTableRequest::__set_partNames(const std::vector<std::string> & val) {
  this->partNames = val;
__isset.partNames = true;
}

void TruncateTableRequest::__set_writeId(const int64_t val) {
  this->writeId = val;
__isset.writeId = true;
}

void TruncateTableRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void TruncateTableRequest::__set_environmentContext(const EnvironmentContext& val) {
  this->environmentContext = val;
__isset.environmentContext = true;
}
std::ostream& operator<<(std::ostream& out, const TruncateTableRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TruncateTableRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tableName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partNames.clear();
            uint32_t _size144;
            ::apache::thrift::protocol::TType _etype147;
            xfer += iprot->readListBegin(_etype147, _size144);
            this->partNames.resize(_size144);
            uint32_t _i148;
            for (_i148 = 0; _i148 < _size144; ++_i148)
            {
              xfer += iprot->readString(this->partNames[_i148]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          this->__isset.writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->environmentContext.read(iprot);
          this->__isset.environmentContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TruncateTableRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TruncateTableRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partNames) {
    xfer += oprot->writeFieldBegin("partNames", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partNames.size()));
      std::vector<std::string> ::const_iterator _iter149;
      for (_iter149 = this->partNames.begin(); _iter149 != this->partNames.end(); ++_iter149)
      {
        xfer += oprot->writeString((*_iter149));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writeId) {
    xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->writeId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.environmentContext) {
    xfer += oprot->writeFieldBegin("environmentContext", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->environmentContext.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TruncateTableRequest &a, TruncateTableRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.partNames, b.partNames);
  swap(a.writeId, b.writeId);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.environmentContext, b.environmentContext);
  swap(a.__isset, b.__isset);
}

TruncateTableRequest::TruncateTableRequest(const TruncateTableRequest& other150) {
  dbName = other150.dbName;
  tableName = other150.tableName;
  partNames = other150.partNames;
  writeId = other150.writeId;
  validWriteIdList = other150.validWriteIdList;
  environmentContext = other150.environmentContext;
  __isset = other150.__isset;
}
TruncateTableRequest& TruncateTableRequest::operator=(const TruncateTableRequest& other151) {
  dbName = other151.dbName;
  tableName = other151.tableName;
  partNames = other151.partNames;
  writeId = other151.writeId;
  validWriteIdList = other151.validWriteIdList;
  environmentContext = other151.environmentContext;
  __isset = other151.__isset;
  return *this;
}
void TruncateTableRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TruncateTableRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "partNames="; (__isset.partNames ? (out << to_string(partNames)) : (out << "<null>"));
  out << ", " << "writeId="; (__isset.writeId ? (out << to_string(writeId)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "environmentContext="; (__isset.environmentContext ? (out << to_string(environmentContext)) : (out << "<null>"));
  out << ")";
}


TruncateTableResponse::~TruncateTableResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const TruncateTableResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TruncateTableResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TruncateTableResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TruncateTableResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TruncateTableResponse &a, TruncateTableResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TruncateTableResponse::TruncateTableResponse(const TruncateTableResponse& other152) noexcept {
  (void) other152;
}
TruncateTableResponse& TruncateTableResponse::operator=(const TruncateTableResponse& other153) noexcept {
  (void) other153;
  return *this;
}
void TruncateTableResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TruncateTableResponse(";
  out << ")";
}


Role::~Role() noexcept {
}


void Role::__set_roleName(const std::string& val) {
  this->roleName = val;
}

void Role::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void Role::__set_ownerName(const std::string& val) {
  this->ownerName = val;
}
std::ostream& operator<<(std::ostream& out, const Role& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Role::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roleName);
          this->__isset.roleName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Role::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Role");

  xfer += oprot->writeFieldBegin("roleName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->roleName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ownerName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Role &a, Role &b) {
  using ::std::swap;
  swap(a.roleName, b.roleName);
  swap(a.createTime, b.createTime);
  swap(a.ownerName, b.ownerName);
  swap(a.__isset, b.__isset);
}

Role::Role(const Role& other154) {
  roleName = other154.roleName;
  createTime = other154.createTime;
  ownerName = other154.ownerName;
  __isset = other154.__isset;
}
Role& Role::operator=(const Role& other155) {
  roleName = other155.roleName;
  createTime = other155.createTime;
  ownerName = other155.ownerName;
  __isset = other155.__isset;
  return *this;
}
void Role::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Role(";
  out << "roleName=" << to_string(roleName);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "ownerName=" << to_string(ownerName);
  out << ")";
}


RolePrincipalGrant::~RolePrincipalGrant() noexcept {
}


void RolePrincipalGrant::__set_roleName(const std::string& val) {
  this->roleName = val;
}

void RolePrincipalGrant::__set_principalName(const std::string& val) {
  this->principalName = val;
}

void RolePrincipalGrant::__set_principalType(const PrincipalType::type val) {
  this->principalType = val;
}

void RolePrincipalGrant::__set_grantOption(const bool val) {
  this->grantOption = val;
}

void RolePrincipalGrant::__set_grantTime(const int32_t val) {
  this->grantTime = val;
}

void RolePrincipalGrant::__set_grantorName(const std::string& val) {
  this->grantorName = val;
}

void RolePrincipalGrant::__set_grantorPrincipalType(const PrincipalType::type val) {
  this->grantorPrincipalType = val;
}
std::ostream& operator<<(std::ostream& out, const RolePrincipalGrant& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RolePrincipalGrant::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roleName);
          this->__isset.roleName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principalName);
          this->__isset.principalName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast156;
          xfer += iprot->readI32(ecast156);
          this->principalType = static_cast<PrincipalType::type>(ecast156);
          this->__isset.principalType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->grantOption);
          this->__isset.grantOption = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->grantTime);
          this->__isset.grantTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->grantorName);
          this->__isset.grantorName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast157;
          xfer += iprot->readI32(ecast157);
          this->grantorPrincipalType = static_cast<PrincipalType::type>(ecast157);
          this->__isset.grantorPrincipalType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RolePrincipalGrant::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RolePrincipalGrant");

  xfer += oprot->writeFieldBegin("roleName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->roleName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->principalName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(static_cast<int32_t>(this->principalType));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantOption", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->grantOption);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantTime", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->grantTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantorName", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->grantorName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantorPrincipalType", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(static_cast<int32_t>(this->grantorPrincipalType));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RolePrincipalGrant &a, RolePrincipalGrant &b) {
  using ::std::swap;
  swap(a.roleName, b.roleName);
  swap(a.principalName, b.principalName);
  swap(a.principalType, b.principalType);
  swap(a.grantOption, b.grantOption);
  swap(a.grantTime, b.grantTime);
  swap(a.grantorName, b.grantorName);
  swap(a.grantorPrincipalType, b.grantorPrincipalType);
  swap(a.__isset, b.__isset);
}

RolePrincipalGrant::RolePrincipalGrant(const RolePrincipalGrant& other158) {
  roleName = other158.roleName;
  principalName = other158.principalName;
  principalType = other158.principalType;
  grantOption = other158.grantOption;
  grantTime = other158.grantTime;
  grantorName = other158.grantorName;
  grantorPrincipalType = other158.grantorPrincipalType;
  __isset = other158.__isset;
}
RolePrincipalGrant& RolePrincipalGrant::operator=(const RolePrincipalGrant& other159) {
  roleName = other159.roleName;
  principalName = other159.principalName;
  principalType = other159.principalType;
  grantOption = other159.grantOption;
  grantTime = other159.grantTime;
  grantorName = other159.grantorName;
  grantorPrincipalType = other159.grantorPrincipalType;
  __isset = other159.__isset;
  return *this;
}
void RolePrincipalGrant::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RolePrincipalGrant(";
  out << "roleName=" << to_string(roleName);
  out << ", " << "principalName=" << to_string(principalName);
  out << ", " << "principalType=" << to_string(principalType);
  out << ", " << "grantOption=" << to_string(grantOption);
  out << ", " << "grantTime=" << to_string(grantTime);
  out << ", " << "grantorName=" << to_string(grantorName);
  out << ", " << "grantorPrincipalType=" << to_string(grantorPrincipalType);
  out << ")";
}


GetRoleGrantsForPrincipalRequest::~GetRoleGrantsForPrincipalRequest() noexcept {
}


void GetRoleGrantsForPrincipalRequest::__set_principal_name(const std::string& val) {
  this->principal_name = val;
}

void GetRoleGrantsForPrincipalRequest::__set_principal_type(const PrincipalType::type val) {
  this->principal_type = val;
}
std::ostream& operator<<(std::ostream& out, const GetRoleGrantsForPrincipalRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetRoleGrantsForPrincipalRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_principal_name = false;
  bool isset_principal_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principal_name);
          isset_principal_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast160;
          xfer += iprot->readI32(ecast160);
          this->principal_type = static_cast<PrincipalType::type>(ecast160);
          isset_principal_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_principal_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_principal_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetRoleGrantsForPrincipalRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetRoleGrantsForPrincipalRequest");

  xfer += oprot->writeFieldBegin("principal_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->principal_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principal_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->principal_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetRoleGrantsForPrincipalRequest &a, GetRoleGrantsForPrincipalRequest &b) {
  using ::std::swap;
  swap(a.principal_name, b.principal_name);
  swap(a.principal_type, b.principal_type);
}

GetRoleGrantsForPrincipalRequest::GetRoleGrantsForPrincipalRequest(const GetRoleGrantsForPrincipalRequest& other161) {
  principal_name = other161.principal_name;
  principal_type = other161.principal_type;
}
GetRoleGrantsForPrincipalRequest& GetRoleGrantsForPrincipalRequest::operator=(const GetRoleGrantsForPrincipalRequest& other162) {
  principal_name = other162.principal_name;
  principal_type = other162.principal_type;
  return *this;
}
void GetRoleGrantsForPrincipalRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetRoleGrantsForPrincipalRequest(";
  out << "principal_name=" << to_string(principal_name);
  out << ", " << "principal_type=" << to_string(principal_type);
  out << ")";
}


GetRoleGrantsForPrincipalResponse::~GetRoleGrantsForPrincipalResponse() noexcept {
}


void GetRoleGrantsForPrincipalResponse::__set_principalGrants(const std::vector<RolePrincipalGrant> & val) {
  this->principalGrants = val;
}
std::ostream& operator<<(std::ostream& out, const GetRoleGrantsForPrincipalResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetRoleGrantsForPrincipalResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_principalGrants = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->principalGrants.clear();
            uint32_t _size163;
            ::apache::thrift::protocol::TType _etype166;
            xfer += iprot->readListBegin(_etype166, _size163);
            this->principalGrants.resize(_size163);
            uint32_t _i167;
            for (_i167 = 0; _i167 < _size163; ++_i167)
            {
              xfer += this->principalGrants[_i167].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_principalGrants = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_principalGrants)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetRoleGrantsForPrincipalResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetRoleGrantsForPrincipalResponse");

  xfer += oprot->writeFieldBegin("principalGrants", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->principalGrants.size()));
    std::vector<RolePrincipalGrant> ::const_iterator _iter168;
    for (_iter168 = this->principalGrants.begin(); _iter168 != this->principalGrants.end(); ++_iter168)
    {
      xfer += (*_iter168).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetRoleGrantsForPrincipalResponse &a, GetRoleGrantsForPrincipalResponse &b) {
  using ::std::swap;
  swap(a.principalGrants, b.principalGrants);
}

GetRoleGrantsForPrincipalResponse::GetRoleGrantsForPrincipalResponse(const GetRoleGrantsForPrincipalResponse& other169) {
  principalGrants = other169.principalGrants;
}
GetRoleGrantsForPrincipalResponse& GetRoleGrantsForPrincipalResponse::operator=(const GetRoleGrantsForPrincipalResponse& other170) {
  principalGrants = other170.principalGrants;
  return *this;
}
void GetRoleGrantsForPrincipalResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetRoleGrantsForPrincipalResponse(";
  out << "principalGrants=" << to_string(principalGrants);
  out << ")";
}


GetPrincipalsInRoleRequest::~GetPrincipalsInRoleRequest() noexcept {
}


void GetPrincipalsInRoleRequest::__set_roleName(const std::string& val) {
  this->roleName = val;
}
std::ostream& operator<<(std::ostream& out, const GetPrincipalsInRoleRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPrincipalsInRoleRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_roleName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roleName);
          isset_roleName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_roleName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPrincipalsInRoleRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPrincipalsInRoleRequest");

  xfer += oprot->writeFieldBegin("roleName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->roleName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPrincipalsInRoleRequest &a, GetPrincipalsInRoleRequest &b) {
  using ::std::swap;
  swap(a.roleName, b.roleName);
}

GetPrincipalsInRoleRequest::GetPrincipalsInRoleRequest(const GetPrincipalsInRoleRequest& other171) {
  roleName = other171.roleName;
}
GetPrincipalsInRoleRequest& GetPrincipalsInRoleRequest::operator=(const GetPrincipalsInRoleRequest& other172) {
  roleName = other172.roleName;
  return *this;
}
void GetPrincipalsInRoleRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPrincipalsInRoleRequest(";
  out << "roleName=" << to_string(roleName);
  out << ")";
}


GetPrincipalsInRoleResponse::~GetPrincipalsInRoleResponse() noexcept {
}


void GetPrincipalsInRoleResponse::__set_principalGrants(const std::vector<RolePrincipalGrant> & val) {
  this->principalGrants = val;
}
std::ostream& operator<<(std::ostream& out, const GetPrincipalsInRoleResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPrincipalsInRoleResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_principalGrants = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->principalGrants.clear();
            uint32_t _size173;
            ::apache::thrift::protocol::TType _etype176;
            xfer += iprot->readListBegin(_etype176, _size173);
            this->principalGrants.resize(_size173);
            uint32_t _i177;
            for (_i177 = 0; _i177 < _size173; ++_i177)
            {
              xfer += this->principalGrants[_i177].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_principalGrants = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_principalGrants)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPrincipalsInRoleResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPrincipalsInRoleResponse");

  xfer += oprot->writeFieldBegin("principalGrants", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->principalGrants.size()));
    std::vector<RolePrincipalGrant> ::const_iterator _iter178;
    for (_iter178 = this->principalGrants.begin(); _iter178 != this->principalGrants.end(); ++_iter178)
    {
      xfer += (*_iter178).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPrincipalsInRoleResponse &a, GetPrincipalsInRoleResponse &b) {
  using ::std::swap;
  swap(a.principalGrants, b.principalGrants);
}

GetPrincipalsInRoleResponse::GetPrincipalsInRoleResponse(const GetPrincipalsInRoleResponse& other179) {
  principalGrants = other179.principalGrants;
}
GetPrincipalsInRoleResponse& GetPrincipalsInRoleResponse::operator=(const GetPrincipalsInRoleResponse& other180) {
  principalGrants = other180.principalGrants;
  return *this;
}
void GetPrincipalsInRoleResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPrincipalsInRoleResponse(";
  out << "principalGrants=" << to_string(principalGrants);
  out << ")";
}


GrantRevokeRoleRequest::~GrantRevokeRoleRequest() noexcept {
}


void GrantRevokeRoleRequest::__set_requestType(const GrantRevokeType::type val) {
  this->requestType = val;
}

void GrantRevokeRoleRequest::__set_roleName(const std::string& val) {
  this->roleName = val;
}

void GrantRevokeRoleRequest::__set_principalName(const std::string& val) {
  this->principalName = val;
}

void GrantRevokeRoleRequest::__set_principalType(const PrincipalType::type val) {
  this->principalType = val;
}

void GrantRevokeRoleRequest::__set_grantor(const std::string& val) {
  this->grantor = val;
__isset.grantor = true;
}

void GrantRevokeRoleRequest::__set_grantorType(const PrincipalType::type val) {
  this->grantorType = val;
__isset.grantorType = true;
}

void GrantRevokeRoleRequest::__set_grantOption(const bool val) {
  this->grantOption = val;
__isset.grantOption = true;
}
std::ostream& operator<<(std::ostream& out, const GrantRevokeRoleRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GrantRevokeRoleRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast181;
          xfer += iprot->readI32(ecast181);
          this->requestType = static_cast<GrantRevokeType::type>(ecast181);
          this->__isset.requestType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roleName);
          this->__isset.roleName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principalName);
          this->__isset.principalName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast182;
          xfer += iprot->readI32(ecast182);
          this->principalType = static_cast<PrincipalType::type>(ecast182);
          this->__isset.principalType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->grantor);
          this->__isset.grantor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast183;
          xfer += iprot->readI32(ecast183);
          this->grantorType = static_cast<PrincipalType::type>(ecast183);
          this->__isset.grantorType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->grantOption);
          this->__isset.grantOption = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GrantRevokeRoleRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GrantRevokeRoleRequest");

  xfer += oprot->writeFieldBegin("requestType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->requestType));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roleName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->roleName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->principalName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalType", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(static_cast<int32_t>(this->principalType));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.grantor) {
    xfer += oprot->writeFieldBegin("grantor", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->grantor);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.grantorType) {
    xfer += oprot->writeFieldBegin("grantorType", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(static_cast<int32_t>(this->grantorType));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.grantOption) {
    xfer += oprot->writeFieldBegin("grantOption", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->grantOption);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GrantRevokeRoleRequest &a, GrantRevokeRoleRequest &b) {
  using ::std::swap;
  swap(a.requestType, b.requestType);
  swap(a.roleName, b.roleName);
  swap(a.principalName, b.principalName);
  swap(a.principalType, b.principalType);
  swap(a.grantor, b.grantor);
  swap(a.grantorType, b.grantorType);
  swap(a.grantOption, b.grantOption);
  swap(a.__isset, b.__isset);
}

GrantRevokeRoleRequest::GrantRevokeRoleRequest(const GrantRevokeRoleRequest& other184) {
  requestType = other184.requestType;
  roleName = other184.roleName;
  principalName = other184.principalName;
  principalType = other184.principalType;
  grantor = other184.grantor;
  grantorType = other184.grantorType;
  grantOption = other184.grantOption;
  __isset = other184.__isset;
}
GrantRevokeRoleRequest& GrantRevokeRoleRequest::operator=(const GrantRevokeRoleRequest& other185) {
  requestType = other185.requestType;
  roleName = other185.roleName;
  principalName = other185.principalName;
  principalType = other185.principalType;
  grantor = other185.grantor;
  grantorType = other185.grantorType;
  grantOption = other185.grantOption;
  __isset = other185.__isset;
  return *this;
}
void GrantRevokeRoleRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GrantRevokeRoleRequest(";
  out << "requestType=" << to_string(requestType);
  out << ", " << "roleName=" << to_string(roleName);
  out << ", " << "principalName=" << to_string(principalName);
  out << ", " << "principalType=" << to_string(principalType);
  out << ", " << "grantor="; (__isset.grantor ? (out << to_string(grantor)) : (out << "<null>"));
  out << ", " << "grantorType="; (__isset.grantorType ? (out << to_string(grantorType)) : (out << "<null>"));
  out << ", " << "grantOption="; (__isset.grantOption ? (out << to_string(grantOption)) : (out << "<null>"));
  out << ")";
}


GrantRevokeRoleResponse::~GrantRevokeRoleResponse() noexcept {
}


void GrantRevokeRoleResponse::__set_success(const bool val) {
  this->success = val;
__isset.success = true;
}
std::ostream& operator<<(std::ostream& out, const GrantRevokeRoleResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GrantRevokeRoleResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GrantRevokeRoleResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GrantRevokeRoleResponse");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GrantRevokeRoleResponse &a, GrantRevokeRoleResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.__isset, b.__isset);
}

GrantRevokeRoleResponse::GrantRevokeRoleResponse(const GrantRevokeRoleResponse& other186) noexcept {
  success = other186.success;
  __isset = other186.__isset;
}
GrantRevokeRoleResponse& GrantRevokeRoleResponse::operator=(const GrantRevokeRoleResponse& other187) noexcept {
  success = other187.success;
  __isset = other187.__isset;
  return *this;
}
void GrantRevokeRoleResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GrantRevokeRoleResponse(";
  out << "success="; (__isset.success ? (out << to_string(success)) : (out << "<null>"));
  out << ")";
}


Catalog::~Catalog() noexcept {
}


void Catalog::__set_name(const std::string& val) {
  this->name = val;
}

void Catalog::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void Catalog::__set_locationUri(const std::string& val) {
  this->locationUri = val;
}

void Catalog::__set_createTime(const int32_t val) {
  this->createTime = val;
__isset.createTime = true;
}
std::ostream& operator<<(std::ostream& out, const Catalog& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Catalog::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->locationUri);
          this->__isset.locationUri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Catalog::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Catalog");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("locationUri", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->locationUri);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.createTime) {
    xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->createTime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Catalog &a, Catalog &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.description, b.description);
  swap(a.locationUri, b.locationUri);
  swap(a.createTime, b.createTime);
  swap(a.__isset, b.__isset);
}

Catalog::Catalog(const Catalog& other188) {
  name = other188.name;
  description = other188.description;
  locationUri = other188.locationUri;
  createTime = other188.createTime;
  __isset = other188.__isset;
}
Catalog& Catalog::operator=(const Catalog& other189) {
  name = other189.name;
  description = other189.description;
  locationUri = other189.locationUri;
  createTime = other189.createTime;
  __isset = other189.__isset;
  return *this;
}
void Catalog::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Catalog(";
  out << "name=" << to_string(name);
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "locationUri=" << to_string(locationUri);
  out << ", " << "createTime="; (__isset.createTime ? (out << to_string(createTime)) : (out << "<null>"));
  out << ")";
}


CreateCatalogRequest::~CreateCatalogRequest() noexcept {
}


void CreateCatalogRequest::__set_catalog(const Catalog& val) {
  this->catalog = val;
}
std::ostream& operator<<(std::ostream& out, const CreateCatalogRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateCatalogRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalog.read(iprot);
          this->__isset.catalog = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateCatalogRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateCatalogRequest");

  xfer += oprot->writeFieldBegin("catalog", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->catalog.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateCatalogRequest &a, CreateCatalogRequest &b) {
  using ::std::swap;
  swap(a.catalog, b.catalog);
  swap(a.__isset, b.__isset);
}

CreateCatalogRequest::CreateCatalogRequest(const CreateCatalogRequest& other190) {
  catalog = other190.catalog;
  __isset = other190.__isset;
}
CreateCatalogRequest& CreateCatalogRequest::operator=(const CreateCatalogRequest& other191) {
  catalog = other191.catalog;
  __isset = other191.__isset;
  return *this;
}
void CreateCatalogRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateCatalogRequest(";
  out << "catalog=" << to_string(catalog);
  out << ")";
}


AlterCatalogRequest::~AlterCatalogRequest() noexcept {
}


void AlterCatalogRequest::__set_name(const std::string& val) {
  this->name = val;
}

void AlterCatalogRequest::__set_newCat(const Catalog& val) {
  this->newCat = val;
}
std::ostream& operator<<(std::ostream& out, const AlterCatalogRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AlterCatalogRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->newCat.read(iprot);
          this->__isset.newCat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlterCatalogRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AlterCatalogRequest");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newCat", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->newCat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlterCatalogRequest &a, AlterCatalogRequest &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.newCat, b.newCat);
  swap(a.__isset, b.__isset);
}

AlterCatalogRequest::AlterCatalogRequest(const AlterCatalogRequest& other192) {
  name = other192.name;
  newCat = other192.newCat;
  __isset = other192.__isset;
}
AlterCatalogRequest& AlterCatalogRequest::operator=(const AlterCatalogRequest& other193) {
  name = other193.name;
  newCat = other193.newCat;
  __isset = other193.__isset;
  return *this;
}
void AlterCatalogRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AlterCatalogRequest(";
  out << "name=" << to_string(name);
  out << ", " << "newCat=" << to_string(newCat);
  out << ")";
}


GetCatalogRequest::~GetCatalogRequest() noexcept {
}


void GetCatalogRequest::__set_name(const std::string& val) {
  this->name = val;
}
std::ostream& operator<<(std::ostream& out, const GetCatalogRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetCatalogRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetCatalogRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetCatalogRequest");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetCatalogRequest &a, GetCatalogRequest &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

GetCatalogRequest::GetCatalogRequest(const GetCatalogRequest& other194) {
  name = other194.name;
  __isset = other194.__isset;
}
GetCatalogRequest& GetCatalogRequest::operator=(const GetCatalogRequest& other195) {
  name = other195.name;
  __isset = other195.__isset;
  return *this;
}
void GetCatalogRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetCatalogRequest(";
  out << "name=" << to_string(name);
  out << ")";
}


GetCatalogResponse::~GetCatalogResponse() noexcept {
}


void GetCatalogResponse::__set_catalog(const Catalog& val) {
  this->catalog = val;
}
std::ostream& operator<<(std::ostream& out, const GetCatalogResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetCatalogResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalog.read(iprot);
          this->__isset.catalog = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetCatalogResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetCatalogResponse");

  xfer += oprot->writeFieldBegin("catalog", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->catalog.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetCatalogResponse &a, GetCatalogResponse &b) {
  using ::std::swap;
  swap(a.catalog, b.catalog);
  swap(a.__isset, b.__isset);
}

GetCatalogResponse::GetCatalogResponse(const GetCatalogResponse& other196) {
  catalog = other196.catalog;
  __isset = other196.__isset;
}
GetCatalogResponse& GetCatalogResponse::operator=(const GetCatalogResponse& other197) {
  catalog = other197.catalog;
  __isset = other197.__isset;
  return *this;
}
void GetCatalogResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetCatalogResponse(";
  out << "catalog=" << to_string(catalog);
  out << ")";
}


GetCatalogsResponse::~GetCatalogsResponse() noexcept {
}


void GetCatalogsResponse::__set_names(const std::vector<std::string> & val) {
  this->names = val;
}
std::ostream& operator<<(std::ostream& out, const GetCatalogsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetCatalogsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size198;
            ::apache::thrift::protocol::TType _etype201;
            xfer += iprot->readListBegin(_etype201, _size198);
            this->names.resize(_size198);
            uint32_t _i202;
            for (_i202 = 0; _i202 < _size198; ++_i202)
            {
              xfer += iprot->readString(this->names[_i202]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetCatalogsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetCatalogsResponse");

  xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->names.size()));
    std::vector<std::string> ::const_iterator _iter203;
    for (_iter203 = this->names.begin(); _iter203 != this->names.end(); ++_iter203)
    {
      xfer += oprot->writeString((*_iter203));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetCatalogsResponse &a, GetCatalogsResponse &b) {
  using ::std::swap;
  swap(a.names, b.names);
  swap(a.__isset, b.__isset);
}

GetCatalogsResponse::GetCatalogsResponse(const GetCatalogsResponse& other204) {
  names = other204.names;
  __isset = other204.__isset;
}
GetCatalogsResponse& GetCatalogsResponse::operator=(const GetCatalogsResponse& other205) {
  names = other205.names;
  __isset = other205.__isset;
  return *this;
}
void GetCatalogsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetCatalogsResponse(";
  out << "names=" << to_string(names);
  out << ")";
}


DropCatalogRequest::~DropCatalogRequest() noexcept {
}


void DropCatalogRequest::__set_name(const std::string& val) {
  this->name = val;
}
std::ostream& operator<<(std::ostream& out, const DropCatalogRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropCatalogRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DropCatalogRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropCatalogRequest");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropCatalogRequest &a, DropCatalogRequest &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

DropCatalogRequest::DropCatalogRequest(const DropCatalogRequest& other206) {
  name = other206.name;
  __isset = other206.__isset;
}
DropCatalogRequest& DropCatalogRequest::operator=(const DropCatalogRequest& other207) {
  name = other207.name;
  __isset = other207.__isset;
  return *this;
}
void DropCatalogRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropCatalogRequest(";
  out << "name=" << to_string(name);
  out << ")";
}


Database::~Database() noexcept {
}


void Database::__set_name(const std::string& val) {
  this->name = val;
}

void Database::__set_description(const std::string& val) {
  this->description = val;
}

void Database::__set_locationUri(const std::string& val) {
  this->locationUri = val;
}

void Database::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void Database::__set_privileges(const PrincipalPrivilegeSet& val) {
  this->privileges = val;
__isset.privileges = true;
}

void Database::__set_ownerName(const std::string& val) {
  this->ownerName = val;
__isset.ownerName = true;
}

void Database::__set_ownerType(const PrincipalType::type val) {
  this->ownerType = val;
__isset.ownerType = true;
}

void Database::__set_catalogName(const std::string& val) {
  this->catalogName = val;
__isset.catalogName = true;
}

void Database::__set_createTime(const int32_t val) {
  this->createTime = val;
__isset.createTime = true;
}

void Database::__set_managedLocationUri(const std::string& val) {
  this->managedLocationUri = val;
__isset.managedLocationUri = true;
}

void Database::__set_type(const DatabaseType::type val) {
  this->type = val;
__isset.type = true;
}

void Database::__set_connector_name(const std::string& val) {
  this->connector_name = val;
__isset.connector_name = true;
}

void Database::__set_remote_dbname(const std::string& val) {
  this->remote_dbname = val;
__isset.remote_dbname = true;
}
std::ostream& operator<<(std::ostream& out, const Database& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Database::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->locationUri);
          this->__isset.locationUri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size208;
            ::apache::thrift::protocol::TType _ktype209;
            ::apache::thrift::protocol::TType _vtype210;
            xfer += iprot->readMapBegin(_ktype209, _vtype210, _size208);
            uint32_t _i212;
            for (_i212 = 0; _i212 < _size208; ++_i212)
            {
              std::string _key213;
              xfer += iprot->readString(_key213);
              std::string& _val214 = this->parameters[_key213];
              xfer += iprot->readString(_val214);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast215;
          xfer += iprot->readI32(ecast215);
          this->ownerType = static_cast<PrincipalType::type>(ecast215);
          this->__isset.ownerType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogName);
          this->__isset.catalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->managedLocationUri);
          this->__isset.managedLocationUri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast216;
          xfer += iprot->readI32(ecast216);
          this->type = static_cast<DatabaseType::type>(ecast216);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->connector_name);
          this->__isset.connector_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->remote_dbname);
          this->__isset.remote_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Database::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Database");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->description);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("locationUri", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->locationUri);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter217;
    for (_iter217 = this->parameters.begin(); _iter217 != this->parameters.end(); ++_iter217)
    {
      xfer += oprot->writeString(_iter217->first);
      xfer += oprot->writeString(_iter217->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.privileges) {
    xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->privileges.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ownerName) {
    xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->ownerName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ownerType) {
    xfer += oprot->writeFieldBegin("ownerType", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(static_cast<int32_t>(this->ownerType));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalogName) {
    xfer += oprot->writeFieldBegin("catalogName", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->catalogName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTime) {
    xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->createTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.managedLocationUri) {
    xfer += oprot->writeFieldBegin("managedLocationUri", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->managedLocationUri);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(static_cast<int32_t>(this->type));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connector_name) {
    xfer += oprot->writeFieldBegin("connector_name", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->connector_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.remote_dbname) {
    xfer += oprot->writeFieldBegin("remote_dbname", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->remote_dbname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Database &a, Database &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.description, b.description);
  swap(a.locationUri, b.locationUri);
  swap(a.parameters, b.parameters);
  swap(a.privileges, b.privileges);
  swap(a.ownerName, b.ownerName);
  swap(a.ownerType, b.ownerType);
  swap(a.catalogName, b.catalogName);
  swap(a.createTime, b.createTime);
  swap(a.managedLocationUri, b.managedLocationUri);
  swap(a.type, b.type);
  swap(a.connector_name, b.connector_name);
  swap(a.remote_dbname, b.remote_dbname);
  swap(a.__isset, b.__isset);
}

Database::Database(const Database& other218) {
  name = other218.name;
  description = other218.description;
  locationUri = other218.locationUri;
  parameters = other218.parameters;
  privileges = other218.privileges;
  ownerName = other218.ownerName;
  ownerType = other218.ownerType;
  catalogName = other218.catalogName;
  createTime = other218.createTime;
  managedLocationUri = other218.managedLocationUri;
  type = other218.type;
  connector_name = other218.connector_name;
  remote_dbname = other218.remote_dbname;
  __isset = other218.__isset;
}
Database& Database::operator=(const Database& other219) {
  name = other219.name;
  description = other219.description;
  locationUri = other219.locationUri;
  parameters = other219.parameters;
  privileges = other219.privileges;
  ownerName = other219.ownerName;
  ownerType = other219.ownerType;
  catalogName = other219.catalogName;
  createTime = other219.createTime;
  managedLocationUri = other219.managedLocationUri;
  type = other219.type;
  connector_name = other219.connector_name;
  remote_dbname = other219.remote_dbname;
  __isset = other219.__isset;
  return *this;
}
void Database::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Database(";
  out << "name=" << to_string(name);
  out << ", " << "description=" << to_string(description);
  out << ", " << "locationUri=" << to_string(locationUri);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "privileges="; (__isset.privileges ? (out << to_string(privileges)) : (out << "<null>"));
  out << ", " << "ownerName="; (__isset.ownerName ? (out << to_string(ownerName)) : (out << "<null>"));
  out << ", " << "ownerType="; (__isset.ownerType ? (out << to_string(ownerType)) : (out << "<null>"));
  out << ", " << "catalogName="; (__isset.catalogName ? (out << to_string(catalogName)) : (out << "<null>"));
  out << ", " << "createTime="; (__isset.createTime ? (out << to_string(createTime)) : (out << "<null>"));
  out << ", " << "managedLocationUri="; (__isset.managedLocationUri ? (out << to_string(managedLocationUri)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "connector_name="; (__isset.connector_name ? (out << to_string(connector_name)) : (out << "<null>"));
  out << ", " << "remote_dbname="; (__isset.remote_dbname ? (out << to_string(remote_dbname)) : (out << "<null>"));
  out << ")";
}


SerDeInfo::~SerDeInfo() noexcept {
}


void SerDeInfo::__set_name(const std::string& val) {
  this->name = val;
}

void SerDeInfo::__set_serializationLib(const std::string& val) {
  this->serializationLib = val;
}

void SerDeInfo::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void SerDeInfo::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void SerDeInfo::__set_serializerClass(const std::string& val) {
  this->serializerClass = val;
__isset.serializerClass = true;
}

void SerDeInfo::__set_deserializerClass(const std::string& val) {
  this->deserializerClass = val;
__isset.deserializerClass = true;
}

void SerDeInfo::__set_serdeType(const SerdeType::type val) {
  this->serdeType = val;
__isset.serdeType = true;
}
std::ostream& operator<<(std::ostream& out, const SerDeInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SerDeInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serializationLib);
          this->__isset.serializationLib = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size220;
            ::apache::thrift::protocol::TType _ktype221;
            ::apache::thrift::protocol::TType _vtype222;
            xfer += iprot->readMapBegin(_ktype221, _vtype222, _size220);
            uint32_t _i224;
            for (_i224 = 0; _i224 < _size220; ++_i224)
            {
              std::string _key225;
              xfer += iprot->readString(_key225);
              std::string& _val226 = this->parameters[_key225];
              xfer += iprot->readString(_val226);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serializerClass);
          this->__isset.serializerClass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deserializerClass);
          this->__isset.deserializerClass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast227;
          xfer += iprot->readI32(ecast227);
          this->serdeType = static_cast<SerdeType::type>(ecast227);
          this->__isset.serdeType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SerDeInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SerDeInfo");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serializationLib", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->serializationLib);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter228;
    for (_iter228 = this->parameters.begin(); _iter228 != this->parameters.end(); ++_iter228)
    {
      xfer += oprot->writeString(_iter228->first);
      xfer += oprot->writeString(_iter228->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.serializerClass) {
    xfer += oprot->writeFieldBegin("serializerClass", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->serializerClass);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deserializerClass) {
    xfer += oprot->writeFieldBegin("deserializerClass", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->deserializerClass);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.serdeType) {
    xfer += oprot->writeFieldBegin("serdeType", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(static_cast<int32_t>(this->serdeType));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SerDeInfo &a, SerDeInfo &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.serializationLib, b.serializationLib);
  swap(a.parameters, b.parameters);
  swap(a.description, b.description);
  swap(a.serializerClass, b.serializerClass);
  swap(a.deserializerClass, b.deserializerClass);
  swap(a.serdeType, b.serdeType);
  swap(a.__isset, b.__isset);
}

SerDeInfo::SerDeInfo(const SerDeInfo& other229) {
  name = other229.name;
  serializationLib = other229.serializationLib;
  parameters = other229.parameters;
  description = other229.description;
  serializerClass = other229.serializerClass;
  deserializerClass = other229.deserializerClass;
  serdeType = other229.serdeType;
  __isset = other229.__isset;
}
SerDeInfo& SerDeInfo::operator=(const SerDeInfo& other230) {
  name = other230.name;
  serializationLib = other230.serializationLib;
  parameters = other230.parameters;
  description = other230.description;
  serializerClass = other230.serializerClass;
  deserializerClass = other230.deserializerClass;
  serdeType = other230.serdeType;
  __isset = other230.__isset;
  return *this;
}
void SerDeInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SerDeInfo(";
  out << "name=" << to_string(name);
  out << ", " << "serializationLib=" << to_string(serializationLib);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "serializerClass="; (__isset.serializerClass ? (out << to_string(serializerClass)) : (out << "<null>"));
  out << ", " << "deserializerClass="; (__isset.deserializerClass ? (out << to_string(deserializerClass)) : (out << "<null>"));
  out << ", " << "serdeType="; (__isset.serdeType ? (out << to_string(serdeType)) : (out << "<null>"));
  out << ")";
}


Order::~Order() noexcept {
}


void Order::__set_col(const std::string& val) {
  this->col = val;
}

void Order::__set_order(const int32_t val) {
  this->order = val;
}
std::ostream& operator<<(std::ostream& out, const Order& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Order::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->col);
          this->__isset.col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->order);
          this->__isset.order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Order::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Order");

  xfer += oprot->writeFieldBegin("col", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->col);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("order", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->order);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Order &a, Order &b) {
  using ::std::swap;
  swap(a.col, b.col);
  swap(a.order, b.order);
  swap(a.__isset, b.__isset);
}

Order::Order(const Order& other231) {
  col = other231.col;
  order = other231.order;
  __isset = other231.__isset;
}
Order& Order::operator=(const Order& other232) {
  col = other232.col;
  order = other232.order;
  __isset = other232.__isset;
  return *this;
}
void Order::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Order(";
  out << "col=" << to_string(col);
  out << ", " << "order=" << to_string(order);
  out << ")";
}


SkewedInfo::~SkewedInfo() noexcept {
}


void SkewedInfo::__set_skewedColNames(const std::vector<std::string> & val) {
  this->skewedColNames = val;
}

void SkewedInfo::__set_skewedColValues(const std::vector<std::vector<std::string> > & val) {
  this->skewedColValues = val;
}

void SkewedInfo::__set_skewedColValueLocationMaps(const std::map<std::vector<std::string> , std::string> & val) {
  this->skewedColValueLocationMaps = val;
}
std::ostream& operator<<(std::ostream& out, const SkewedInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SkewedInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->skewedColNames.clear();
            uint32_t _size233;
            ::apache::thrift::protocol::TType _etype236;
            xfer += iprot->readListBegin(_etype236, _size233);
            this->skewedColNames.resize(_size233);
            uint32_t _i237;
            for (_i237 = 0; _i237 < _size233; ++_i237)
            {
              xfer += iprot->readString(this->skewedColNames[_i237]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.skewedColNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->skewedColValues.clear();
            uint32_t _size238;
            ::apache::thrift::protocol::TType _etype241;
            xfer += iprot->readListBegin(_etype241, _size238);
            this->skewedColValues.resize(_size238);
            uint32_t _i242;
            for (_i242 = 0; _i242 < _size238; ++_i242)
            {
              {
                this->skewedColValues[_i242].clear();
                uint32_t _size243;
                ::apache::thrift::protocol::TType _etype246;
                xfer += iprot->readListBegin(_etype246, _size243);
                this->skewedColValues[_i242].resize(_size243);
                uint32_t _i247;
                for (_i247 = 0; _i247 < _size243; ++_i247)
                {
                  xfer += iprot->readString(this->skewedColValues[_i242][_i247]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.skewedColValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->skewedColValueLocationMaps.clear();
            uint32_t _size248;
            ::apache::thrift::protocol::TType _ktype249;
            ::apache::thrift::protocol::TType _vtype250;
            xfer += iprot->readMapBegin(_ktype249, _vtype250, _size248);
            uint32_t _i252;
            for (_i252 = 0; _i252 < _size248; ++_i252)
            {
              std::vector<std::string>  _key253;
              {
                _key253.clear();
                uint32_t _size255;
                ::apache::thrift::protocol::TType _etype258;
                xfer += iprot->readListBegin(_etype258, _size255);
                _key253.resize(_size255);
                uint32_t _i259;
                for (_i259 = 0; _i259 < _size255; ++_i259)
                {
                  xfer += iprot->readString(_key253[_i259]);
                }
                xfer += iprot->readListEnd();
              }
              std::string& _val254 = this->skewedColValueLocationMaps[_key253];
              xfer += iprot->readString(_val254);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.skewedColValueLocationMaps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SkewedInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SkewedInfo");

  xfer += oprot->writeFieldBegin("skewedColNames", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->skewedColNames.size()));
    std::vector<std::string> ::const_iterator _iter260;
    for (_iter260 = this->skewedColNames.begin(); _iter260 != this->skewedColNames.end(); ++_iter260)
    {
      xfer += oprot->writeString((*_iter260));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skewedColValues", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->skewedColValues.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter261;
    for (_iter261 = this->skewedColValues.begin(); _iter261 != this->skewedColValues.end(); ++_iter261)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter261).size()));
        std::vector<std::string> ::const_iterator _iter262;
        for (_iter262 = (*_iter261).begin(); _iter262 != (*_iter261).end(); ++_iter262)
        {
          xfer += oprot->writeString((*_iter262));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skewedColValueLocationMaps", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_LIST, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->skewedColValueLocationMaps.size()));
    std::map<std::vector<std::string> , std::string> ::const_iterator _iter263;
    for (_iter263 = this->skewedColValueLocationMaps.begin(); _iter263 != this->skewedColValueLocationMaps.end(); ++_iter263)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter263->first.size()));
        std::vector<std::string> ::const_iterator _iter264;
        for (_iter264 = _iter263->first.begin(); _iter264 != _iter263->first.end(); ++_iter264)
        {
          xfer += oprot->writeString((*_iter264));
        }
        xfer += oprot->writeListEnd();
      }
      xfer += oprot->writeString(_iter263->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SkewedInfo &a, SkewedInfo &b) {
  using ::std::swap;
  swap(a.skewedColNames, b.skewedColNames);
  swap(a.skewedColValues, b.skewedColValues);
  swap(a.skewedColValueLocationMaps, b.skewedColValueLocationMaps);
  swap(a.__isset, b.__isset);
}

SkewedInfo::SkewedInfo(const SkewedInfo& other265) {
  skewedColNames = other265.skewedColNames;
  skewedColValues = other265.skewedColValues;
  skewedColValueLocationMaps = other265.skewedColValueLocationMaps;
  __isset = other265.__isset;
}
SkewedInfo& SkewedInfo::operator=(const SkewedInfo& other266) {
  skewedColNames = other266.skewedColNames;
  skewedColValues = other266.skewedColValues;
  skewedColValueLocationMaps = other266.skewedColValueLocationMaps;
  __isset = other266.__isset;
  return *this;
}
void SkewedInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SkewedInfo(";
  out << "skewedColNames=" << to_string(skewedColNames);
  out << ", " << "skewedColValues=" << to_string(skewedColValues);
  out << ", " << "skewedColValueLocationMaps=" << to_string(skewedColValueLocationMaps);
  out << ")";
}


StorageDescriptor::~StorageDescriptor() noexcept {
}


void StorageDescriptor::__set_cols(const std::vector<FieldSchema> & val) {
  this->cols = val;
}

void StorageDescriptor::__set_location(const std::string& val) {
  this->location = val;
}

void StorageDescriptor::__set_inputFormat(const std::string& val) {
  this->inputFormat = val;
}

void StorageDescriptor::__set_outputFormat(const std::string& val) {
  this->outputFormat = val;
}

void StorageDescriptor::__set_compressed(const bool val) {
  this->compressed = val;
}

void StorageDescriptor::__set_numBuckets(const int32_t val) {
  this->numBuckets = val;
}

void StorageDescriptor::__set_serdeInfo(const SerDeInfo& val) {
  this->serdeInfo = val;
}

void StorageDescriptor::__set_bucketCols(const std::vector<std::string> & val) {
  this->bucketCols = val;
}

void StorageDescriptor::__set_sortCols(const std::vector<Order> & val) {
  this->sortCols = val;
}

void StorageDescriptor::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void StorageDescriptor::__set_skewedInfo(const SkewedInfo& val) {
  this->skewedInfo = val;
__isset.skewedInfo = true;
}

void StorageDescriptor::__set_storedAsSubDirectories(const bool val) {
  this->storedAsSubDirectories = val;
__isset.storedAsSubDirectories = true;
}
std::ostream& operator<<(std::ostream& out, const StorageDescriptor& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StorageDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cols.clear();
            uint32_t _size267;
            ::apache::thrift::protocol::TType _etype270;
            xfer += iprot->readListBegin(_etype270, _size267);
            this->cols.resize(_size267);
            uint32_t _i271;
            for (_i271 = 0; _i271 < _size267; ++_i271)
            {
              xfer += this->cols[_i271].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->inputFormat);
          this->__isset.inputFormat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->outputFormat);
          this->__isset.outputFormat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compressed);
          this->__isset.compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numBuckets);
          this->__isset.numBuckets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->serdeInfo.read(iprot);
          this->__isset.serdeInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bucketCols.clear();
            uint32_t _size272;
            ::apache::thrift::protocol::TType _etype275;
            xfer += iprot->readListBegin(_etype275, _size272);
            this->bucketCols.resize(_size272);
            uint32_t _i276;
            for (_i276 = 0; _i276 < _size272; ++_i276)
            {
              xfer += iprot->readString(this->bucketCols[_i276]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.bucketCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sortCols.clear();
            uint32_t _size277;
            ::apache::thrift::protocol::TType _etype280;
            xfer += iprot->readListBegin(_etype280, _size277);
            this->sortCols.resize(_size277);
            uint32_t _i281;
            for (_i281 = 0; _i281 < _size277; ++_i281)
            {
              xfer += this->sortCols[_i281].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sortCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size282;
            ::apache::thrift::protocol::TType _ktype283;
            ::apache::thrift::protocol::TType _vtype284;
            xfer += iprot->readMapBegin(_ktype283, _vtype284, _size282);
            uint32_t _i286;
            for (_i286 = 0; _i286 < _size282; ++_i286)
            {
              std::string _key287;
              xfer += iprot->readString(_key287);
              std::string& _val288 = this->parameters[_key287];
              xfer += iprot->readString(_val288);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->skewedInfo.read(iprot);
          this->__isset.skewedInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->storedAsSubDirectories);
          this->__isset.storedAsSubDirectories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StorageDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StorageDescriptor");

  xfer += oprot->writeFieldBegin("cols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cols.size()));
    std::vector<FieldSchema> ::const_iterator _iter289;
    for (_iter289 = this->cols.begin(); _iter289 != this->cols.end(); ++_iter289)
    {
      xfer += (*_iter289).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->location);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inputFormat", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->inputFormat);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputFormat", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->outputFormat);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compressed", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->compressed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numBuckets", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->numBuckets);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serdeInfo", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->serdeInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bucketCols", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->bucketCols.size()));
    std::vector<std::string> ::const_iterator _iter290;
    for (_iter290 = this->bucketCols.begin(); _iter290 != this->bucketCols.end(); ++_iter290)
    {
      xfer += oprot->writeString((*_iter290));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sortCols", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->sortCols.size()));
    std::vector<Order> ::const_iterator _iter291;
    for (_iter291 = this->sortCols.begin(); _iter291 != this->sortCols.end(); ++_iter291)
    {
      xfer += (*_iter291).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter292;
    for (_iter292 = this->parameters.begin(); _iter292 != this->parameters.end(); ++_iter292)
    {
      xfer += oprot->writeString(_iter292->first);
      xfer += oprot->writeString(_iter292->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.skewedInfo) {
    xfer += oprot->writeFieldBegin("skewedInfo", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->skewedInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storedAsSubDirectories) {
    xfer += oprot->writeFieldBegin("storedAsSubDirectories", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->storedAsSubDirectories);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StorageDescriptor &a, StorageDescriptor &b) {
  using ::std::swap;
  swap(a.cols, b.cols);
  swap(a.location, b.location);
  swap(a.inputFormat, b.inputFormat);
  swap(a.outputFormat, b.outputFormat);
  swap(a.compressed, b.compressed);
  swap(a.numBuckets, b.numBuckets);
  swap(a.serdeInfo, b.serdeInfo);
  swap(a.bucketCols, b.bucketCols);
  swap(a.sortCols, b.sortCols);
  swap(a.parameters, b.parameters);
  swap(a.skewedInfo, b.skewedInfo);
  swap(a.storedAsSubDirectories, b.storedAsSubDirectories);
  swap(a.__isset, b.__isset);
}

StorageDescriptor::StorageDescriptor(const StorageDescriptor& other293) {
  cols = other293.cols;
  location = other293.location;
  inputFormat = other293.inputFormat;
  outputFormat = other293.outputFormat;
  compressed = other293.compressed;
  numBuckets = other293.numBuckets;
  serdeInfo = other293.serdeInfo;
  bucketCols = other293.bucketCols;
  sortCols = other293.sortCols;
  parameters = other293.parameters;
  skewedInfo = other293.skewedInfo;
  storedAsSubDirectories = other293.storedAsSubDirectories;
  __isset = other293.__isset;
}
StorageDescriptor& StorageDescriptor::operator=(const StorageDescriptor& other294) {
  cols = other294.cols;
  location = other294.location;
  inputFormat = other294.inputFormat;
  outputFormat = other294.outputFormat;
  compressed = other294.compressed;
  numBuckets = other294.numBuckets;
  serdeInfo = other294.serdeInfo;
  bucketCols = other294.bucketCols;
  sortCols = other294.sortCols;
  parameters = other294.parameters;
  skewedInfo = other294.skewedInfo;
  storedAsSubDirectories = other294.storedAsSubDirectories;
  __isset = other294.__isset;
  return *this;
}
void StorageDescriptor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StorageDescriptor(";
  out << "cols=" << to_string(cols);
  out << ", " << "location=" << to_string(location);
  out << ", " << "inputFormat=" << to_string(inputFormat);
  out << ", " << "outputFormat=" << to_string(outputFormat);
  out << ", " << "compressed=" << to_string(compressed);
  out << ", " << "numBuckets=" << to_string(numBuckets);
  out << ", " << "serdeInfo=" << to_string(serdeInfo);
  out << ", " << "bucketCols=" << to_string(bucketCols);
  out << ", " << "sortCols=" << to_string(sortCols);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "skewedInfo="; (__isset.skewedInfo ? (out << to_string(skewedInfo)) : (out << "<null>"));
  out << ", " << "storedAsSubDirectories="; (__isset.storedAsSubDirectories ? (out << to_string(storedAsSubDirectories)) : (out << "<null>"));
  out << ")";
}


CreationMetadata::~CreationMetadata() noexcept {
}


void CreationMetadata::__set_catName(const std::string& val) {
  this->catName = val;
}

void CreationMetadata::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void CreationMetadata::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void CreationMetadata::__set_tablesUsed(const std::set<std::string> & val) {
  this->tablesUsed = val;
}

void CreationMetadata::__set_validTxnList(const std::string& val) {
  this->validTxnList = val;
__isset.validTxnList = true;
}

void CreationMetadata::__set_materializationTime(const int64_t val) {
  this->materializationTime = val;
__isset.materializationTime = true;
}

void CreationMetadata::__set_sourceTables(const std::vector<SourceTable> & val) {
  this->sourceTables = val;
__isset.sourceTables = true;
}
std::ostream& operator<<(std::ostream& out, const CreationMetadata& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreationMetadata::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catName = false;
  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_tablesUsed = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->tablesUsed.clear();
            uint32_t _size295;
            ::apache::thrift::protocol::TType _etype298;
            xfer += iprot->readSetBegin(_etype298, _size295);
            uint32_t _i299;
            for (_i299 = 0; _i299 < _size295; ++_i299)
            {
              std::string _elem300;
              xfer += iprot->readString(_elem300);
              this->tablesUsed.insert(_elem300);
            }
            xfer += iprot->readSetEnd();
          }
          isset_tablesUsed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validTxnList);
          this->__isset.validTxnList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->materializationTime);
          this->__isset.materializationTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sourceTables.clear();
            uint32_t _size301;
            ::apache::thrift::protocol::TType _etype304;
            xfer += iprot->readListBegin(_etype304, _size301);
            this->sourceTables.resize(_size301);
            uint32_t _i305;
            for (_i305 = 0; _i305 < _size301; ++_i305)
            {
              xfer += this->sourceTables[_i305].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sourceTables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablesUsed)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CreationMetadata::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreationMetadata");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablesUsed", ::apache::thrift::protocol::T_SET, 4);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tablesUsed.size()));
    std::set<std::string> ::const_iterator _iter306;
    for (_iter306 = this->tablesUsed.begin(); _iter306 != this->tablesUsed.end(); ++_iter306)
    {
      xfer += oprot->writeString((*_iter306));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.validTxnList) {
    xfer += oprot->writeFieldBegin("validTxnList", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->validTxnList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.materializationTime) {
    xfer += oprot->writeFieldBegin("materializationTime", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->materializationTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sourceTables) {
    xfer += oprot->writeFieldBegin("sourceTables", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->sourceTables.size()));
      std::vector<SourceTable> ::const_iterator _iter307;
      for (_iter307 = this->sourceTables.begin(); _iter307 != this->sourceTables.end(); ++_iter307)
      {
        xfer += (*_iter307).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreationMetadata &a, CreationMetadata &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.tablesUsed, b.tablesUsed);
  swap(a.validTxnList, b.validTxnList);
  swap(a.materializationTime, b.materializationTime);
  swap(a.sourceTables, b.sourceTables);
  swap(a.__isset, b.__isset);
}

CreationMetadata::CreationMetadata(const CreationMetadata& other308) {
  catName = other308.catName;
  dbName = other308.dbName;
  tblName = other308.tblName;
  tablesUsed = other308.tablesUsed;
  validTxnList = other308.validTxnList;
  materializationTime = other308.materializationTime;
  sourceTables = other308.sourceTables;
  __isset = other308.__isset;
}
CreationMetadata& CreationMetadata::operator=(const CreationMetadata& other309) {
  catName = other309.catName;
  dbName = other309.dbName;
  tblName = other309.tblName;
  tablesUsed = other309.tablesUsed;
  validTxnList = other309.validTxnList;
  materializationTime = other309.materializationTime;
  sourceTables = other309.sourceTables;
  __isset = other309.__isset;
  return *this;
}
void CreationMetadata::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreationMetadata(";
  out << "catName=" << to_string(catName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "tablesUsed=" << to_string(tablesUsed);
  out << ", " << "validTxnList="; (__isset.validTxnList ? (out << to_string(validTxnList)) : (out << "<null>"));
  out << ", " << "materializationTime="; (__isset.materializationTime ? (out << to_string(materializationTime)) : (out << "<null>"));
  out << ", " << "sourceTables="; (__isset.sourceTables ? (out << to_string(sourceTables)) : (out << "<null>"));
  out << ")";
}


BooleanColumnStatsData::~BooleanColumnStatsData() noexcept {
}


void BooleanColumnStatsData::__set_numTrues(const int64_t val) {
  this->numTrues = val;
}

void BooleanColumnStatsData::__set_numFalses(const int64_t val) {
  this->numFalses = val;
}

void BooleanColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void BooleanColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}
std::ostream& operator<<(std::ostream& out, const BooleanColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BooleanColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numTrues = false;
  bool isset_numFalses = false;
  bool isset_numNulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numTrues);
          isset_numTrues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numFalses);
          isset_numFalses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numTrues)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numFalses)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t BooleanColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BooleanColumnStatsData");

  xfer += oprot->writeFieldBegin("numTrues", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->numTrues);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numFalses", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->numFalses);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BooleanColumnStatsData &a, BooleanColumnStatsData &b) {
  using ::std::swap;
  swap(a.numTrues, b.numTrues);
  swap(a.numFalses, b.numFalses);
  swap(a.numNulls, b.numNulls);
  swap(a.bitVectors, b.bitVectors);
  swap(a.__isset, b.__isset);
}

BooleanColumnStatsData::BooleanColumnStatsData(const BooleanColumnStatsData& other310) {
  numTrues = other310.numTrues;
  numFalses = other310.numFalses;
  numNulls = other310.numNulls;
  bitVectors = other310.bitVectors;
  __isset = other310.__isset;
}
BooleanColumnStatsData& BooleanColumnStatsData::operator=(const BooleanColumnStatsData& other311) {
  numTrues = other311.numTrues;
  numFalses = other311.numFalses;
  numNulls = other311.numNulls;
  bitVectors = other311.bitVectors;
  __isset = other311.__isset;
  return *this;
}
void BooleanColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BooleanColumnStatsData(";
  out << "numTrues=" << to_string(numTrues);
  out << ", " << "numFalses=" << to_string(numFalses);
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ")";
}


DoubleColumnStatsData::~DoubleColumnStatsData() noexcept {
}


void DoubleColumnStatsData::__set_lowValue(const double val) {
  this->lowValue = val;
__isset.lowValue = true;
}

void DoubleColumnStatsData::__set_highValue(const double val) {
  this->highValue = val;
__isset.highValue = true;
}

void DoubleColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void DoubleColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

void DoubleColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}

void DoubleColumnStatsData::__set_histogram(const std::string& val) {
  this->histogram = val;
__isset.histogram = true;
}
std::ostream& operator<<(std::ostream& out, const DoubleColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DoubleColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->lowValue);
          this->__isset.lowValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->highValue);
          this->__isset.highValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->histogram);
          this->__isset.histogram = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DoubleColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DoubleColumnStatsData");

  if (this->__isset.lowValue) {
    xfer += oprot->writeFieldBegin("lowValue", ::apache::thrift::protocol::T_DOUBLE, 1);
    xfer += oprot->writeDouble(this->lowValue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.highValue) {
    xfer += oprot->writeFieldBegin("highValue", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->highValue);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histogram) {
    xfer += oprot->writeFieldBegin("histogram", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeBinary(this->histogram);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DoubleColumnStatsData &a, DoubleColumnStatsData &b) {
  using ::std::swap;
  swap(a.lowValue, b.lowValue);
  swap(a.highValue, b.highValue);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
  swap(a.bitVectors, b.bitVectors);
  swap(a.histogram, b.histogram);
  swap(a.__isset, b.__isset);
}

DoubleColumnStatsData::DoubleColumnStatsData(const DoubleColumnStatsData& other312) {
  lowValue = other312.lowValue;
  highValue = other312.highValue;
  numNulls = other312.numNulls;
  numDVs = other312.numDVs;
  bitVectors = other312.bitVectors;
  histogram = other312.histogram;
  __isset = other312.__isset;
}
DoubleColumnStatsData& DoubleColumnStatsData::operator=(const DoubleColumnStatsData& other313) {
  lowValue = other313.lowValue;
  highValue = other313.highValue;
  numNulls = other313.numNulls;
  numDVs = other313.numDVs;
  bitVectors = other313.bitVectors;
  histogram = other313.histogram;
  __isset = other313.__isset;
  return *this;
}
void DoubleColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DoubleColumnStatsData(";
  out << "lowValue="; (__isset.lowValue ? (out << to_string(lowValue)) : (out << "<null>"));
  out << ", " << "highValue="; (__isset.highValue ? (out << to_string(highValue)) : (out << "<null>"));
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ", " << "histogram="; (__isset.histogram ? (out << to_string(histogram)) : (out << "<null>"));
  out << ")";
}


LongColumnStatsData::~LongColumnStatsData() noexcept {
}


void LongColumnStatsData::__set_lowValue(const int64_t val) {
  this->lowValue = val;
__isset.lowValue = true;
}

void LongColumnStatsData::__set_highValue(const int64_t val) {
  this->highValue = val;
__isset.highValue = true;
}

void LongColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void LongColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

void LongColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}

void LongColumnStatsData::__set_histogram(const std::string& val) {
  this->histogram = val;
__isset.histogram = true;
}
std::ostream& operator<<(std::ostream& out, const LongColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LongColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lowValue);
          this->__isset.lowValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->highValue);
          this->__isset.highValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->histogram);
          this->__isset.histogram = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LongColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LongColumnStatsData");

  if (this->__isset.lowValue) {
    xfer += oprot->writeFieldBegin("lowValue", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->lowValue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.highValue) {
    xfer += oprot->writeFieldBegin("highValue", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->highValue);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histogram) {
    xfer += oprot->writeFieldBegin("histogram", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeBinary(this->histogram);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LongColumnStatsData &a, LongColumnStatsData &b) {
  using ::std::swap;
  swap(a.lowValue, b.lowValue);
  swap(a.highValue, b.highValue);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
  swap(a.bitVectors, b.bitVectors);
  swap(a.histogram, b.histogram);
  swap(a.__isset, b.__isset);
}

LongColumnStatsData::LongColumnStatsData(const LongColumnStatsData& other314) {
  lowValue = other314.lowValue;
  highValue = other314.highValue;
  numNulls = other314.numNulls;
  numDVs = other314.numDVs;
  bitVectors = other314.bitVectors;
  histogram = other314.histogram;
  __isset = other314.__isset;
}
LongColumnStatsData& LongColumnStatsData::operator=(const LongColumnStatsData& other315) {
  lowValue = other315.lowValue;
  highValue = other315.highValue;
  numNulls = other315.numNulls;
  numDVs = other315.numDVs;
  bitVectors = other315.bitVectors;
  histogram = other315.histogram;
  __isset = other315.__isset;
  return *this;
}
void LongColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LongColumnStatsData(";
  out << "lowValue="; (__isset.lowValue ? (out << to_string(lowValue)) : (out << "<null>"));
  out << ", " << "highValue="; (__isset.highValue ? (out << to_string(highValue)) : (out << "<null>"));
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ", " << "histogram="; (__isset.histogram ? (out << to_string(histogram)) : (out << "<null>"));
  out << ")";
}


StringColumnStatsData::~StringColumnStatsData() noexcept {
}


void StringColumnStatsData::__set_maxColLen(const int64_t val) {
  this->maxColLen = val;
}

void StringColumnStatsData::__set_avgColLen(const double val) {
  this->avgColLen = val;
}

void StringColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void StringColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

void StringColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}
std::ostream& operator<<(std::ostream& out, const StringColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StringColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_maxColLen = false;
  bool isset_avgColLen = false;
  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxColLen);
          isset_maxColLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->avgColLen);
          isset_avgColLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_maxColLen)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_avgColLen)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t StringColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StringColumnStatsData");

  xfer += oprot->writeFieldBegin("maxColLen", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->maxColLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("avgColLen", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->avgColLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StringColumnStatsData &a, StringColumnStatsData &b) {
  using ::std::swap;
  swap(a.maxColLen, b.maxColLen);
  swap(a.avgColLen, b.avgColLen);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
  swap(a.bitVectors, b.bitVectors);
  swap(a.__isset, b.__isset);
}

StringColumnStatsData::StringColumnStatsData(const StringColumnStatsData& other316) {
  maxColLen = other316.maxColLen;
  avgColLen = other316.avgColLen;
  numNulls = other316.numNulls;
  numDVs = other316.numDVs;
  bitVectors = other316.bitVectors;
  __isset = other316.__isset;
}
StringColumnStatsData& StringColumnStatsData::operator=(const StringColumnStatsData& other317) {
  maxColLen = other317.maxColLen;
  avgColLen = other317.avgColLen;
  numNulls = other317.numNulls;
  numDVs = other317.numDVs;
  bitVectors = other317.bitVectors;
  __isset = other317.__isset;
  return *this;
}
void StringColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StringColumnStatsData(";
  out << "maxColLen=" << to_string(maxColLen);
  out << ", " << "avgColLen=" << to_string(avgColLen);
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ")";
}


BinaryColumnStatsData::~BinaryColumnStatsData() noexcept {
}


void BinaryColumnStatsData::__set_maxColLen(const int64_t val) {
  this->maxColLen = val;
}

void BinaryColumnStatsData::__set_avgColLen(const double val) {
  this->avgColLen = val;
}

void BinaryColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void BinaryColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}
std::ostream& operator<<(std::ostream& out, const BinaryColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BinaryColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_maxColLen = false;
  bool isset_avgColLen = false;
  bool isset_numNulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxColLen);
          isset_maxColLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->avgColLen);
          isset_avgColLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_maxColLen)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_avgColLen)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t BinaryColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BinaryColumnStatsData");

  xfer += oprot->writeFieldBegin("maxColLen", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->maxColLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("avgColLen", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->avgColLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BinaryColumnStatsData &a, BinaryColumnStatsData &b) {
  using ::std::swap;
  swap(a.maxColLen, b.maxColLen);
  swap(a.avgColLen, b.avgColLen);
  swap(a.numNulls, b.numNulls);
  swap(a.bitVectors, b.bitVectors);
  swap(a.__isset, b.__isset);
}

BinaryColumnStatsData::BinaryColumnStatsData(const BinaryColumnStatsData& other318) {
  maxColLen = other318.maxColLen;
  avgColLen = other318.avgColLen;
  numNulls = other318.numNulls;
  bitVectors = other318.bitVectors;
  __isset = other318.__isset;
}
BinaryColumnStatsData& BinaryColumnStatsData::operator=(const BinaryColumnStatsData& other319) {
  maxColLen = other319.maxColLen;
  avgColLen = other319.avgColLen;
  numNulls = other319.numNulls;
  bitVectors = other319.bitVectors;
  __isset = other319.__isset;
  return *this;
}
void BinaryColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BinaryColumnStatsData(";
  out << "maxColLen=" << to_string(maxColLen);
  out << ", " << "avgColLen=" << to_string(avgColLen);
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ")";
}


Decimal::~Decimal() noexcept {
}


void Decimal::__set_scale(const int16_t val) {
  this->scale = val;
}

void Decimal::__set_unscaled(const std::string& val) {
  this->unscaled = val;
}
std::ostream& operator<<(std::ostream& out, const Decimal& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Decimal::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_scale = false;
  bool isset_unscaled = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->scale);
          isset_scale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->unscaled);
          isset_unscaled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_scale)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_unscaled)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Decimal::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Decimal");

  xfer += oprot->writeFieldBegin("unscaled", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->unscaled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scale", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->scale);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Decimal &a, Decimal &b) {
  using ::std::swap;
  swap(a.scale, b.scale);
  swap(a.unscaled, b.unscaled);
}

Decimal::Decimal(const Decimal& other320) {
  scale = other320.scale;
  unscaled = other320.unscaled;
}
Decimal& Decimal::operator=(const Decimal& other321) {
  scale = other321.scale;
  unscaled = other321.unscaled;
  return *this;
}
void Decimal::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Decimal(";
  out << "scale=" << to_string(scale);
  out << ", " << "unscaled=" << to_string(unscaled);
  out << ")";
}


DecimalColumnStatsData::~DecimalColumnStatsData() noexcept {
}


void DecimalColumnStatsData::__set_lowValue(const Decimal& val) {
  this->lowValue = val;
__isset.lowValue = true;
}

void DecimalColumnStatsData::__set_highValue(const Decimal& val) {
  this->highValue = val;
__isset.highValue = true;
}

void DecimalColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void DecimalColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

void DecimalColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}

void DecimalColumnStatsData::__set_histogram(const std::string& val) {
  this->histogram = val;
__isset.histogram = true;
}
std::ostream& operator<<(std::ostream& out, const DecimalColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DecimalColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lowValue.read(iprot);
          this->__isset.lowValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->highValue.read(iprot);
          this->__isset.highValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->histogram);
          this->__isset.histogram = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DecimalColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DecimalColumnStatsData");

  if (this->__isset.lowValue) {
    xfer += oprot->writeFieldBegin("lowValue", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->lowValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.highValue) {
    xfer += oprot->writeFieldBegin("highValue", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->highValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histogram) {
    xfer += oprot->writeFieldBegin("histogram", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeBinary(this->histogram);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DecimalColumnStatsData &a, DecimalColumnStatsData &b) {
  using ::std::swap;
  swap(a.lowValue, b.lowValue);
  swap(a.highValue, b.highValue);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
  swap(a.bitVectors, b.bitVectors);
  swap(a.histogram, b.histogram);
  swap(a.__isset, b.__isset);
}

DecimalColumnStatsData::DecimalColumnStatsData(const DecimalColumnStatsData& other322) {
  lowValue = other322.lowValue;
  highValue = other322.highValue;
  numNulls = other322.numNulls;
  numDVs = other322.numDVs;
  bitVectors = other322.bitVectors;
  histogram = other322.histogram;
  __isset = other322.__isset;
}
DecimalColumnStatsData& DecimalColumnStatsData::operator=(const DecimalColumnStatsData& other323) {
  lowValue = other323.lowValue;
  highValue = other323.highValue;
  numNulls = other323.numNulls;
  numDVs = other323.numDVs;
  bitVectors = other323.bitVectors;
  histogram = other323.histogram;
  __isset = other323.__isset;
  return *this;
}
void DecimalColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DecimalColumnStatsData(";
  out << "lowValue="; (__isset.lowValue ? (out << to_string(lowValue)) : (out << "<null>"));
  out << ", " << "highValue="; (__isset.highValue ? (out << to_string(highValue)) : (out << "<null>"));
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ", " << "histogram="; (__isset.histogram ? (out << to_string(histogram)) : (out << "<null>"));
  out << ")";
}


Date::~Date() noexcept {
}


void Date::__set_daysSinceEpoch(const int64_t val) {
  this->daysSinceEpoch = val;
}
std::ostream& operator<<(std::ostream& out, const Date& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Date::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_daysSinceEpoch = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->daysSinceEpoch);
          isset_daysSinceEpoch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_daysSinceEpoch)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Date::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Date");

  xfer += oprot->writeFieldBegin("daysSinceEpoch", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->daysSinceEpoch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Date &a, Date &b) {
  using ::std::swap;
  swap(a.daysSinceEpoch, b.daysSinceEpoch);
}

Date::Date(const Date& other324) noexcept {
  daysSinceEpoch = other324.daysSinceEpoch;
}
Date& Date::operator=(const Date& other325) noexcept {
  daysSinceEpoch = other325.daysSinceEpoch;
  return *this;
}
void Date::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Date(";
  out << "daysSinceEpoch=" << to_string(daysSinceEpoch);
  out << ")";
}


DateColumnStatsData::~DateColumnStatsData() noexcept {
}


void DateColumnStatsData::__set_lowValue(const Date& val) {
  this->lowValue = val;
__isset.lowValue = true;
}

void DateColumnStatsData::__set_highValue(const Date& val) {
  this->highValue = val;
__isset.highValue = true;
}

void DateColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void DateColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

void DateColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}

void DateColumnStatsData::__set_histogram(const std::string& val) {
  this->histogram = val;
__isset.histogram = true;
}
std::ostream& operator<<(std::ostream& out, const DateColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DateColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lowValue.read(iprot);
          this->__isset.lowValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->highValue.read(iprot);
          this->__isset.highValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->histogram);
          this->__isset.histogram = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DateColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DateColumnStatsData");

  if (this->__isset.lowValue) {
    xfer += oprot->writeFieldBegin("lowValue", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->lowValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.highValue) {
    xfer += oprot->writeFieldBegin("highValue", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->highValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histogram) {
    xfer += oprot->writeFieldBegin("histogram", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeBinary(this->histogram);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DateColumnStatsData &a, DateColumnStatsData &b) {
  using ::std::swap;
  swap(a.lowValue, b.lowValue);
  swap(a.highValue, b.highValue);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
  swap(a.bitVectors, b.bitVectors);
  swap(a.histogram, b.histogram);
  swap(a.__isset, b.__isset);
}

DateColumnStatsData::DateColumnStatsData(const DateColumnStatsData& other326) {
  lowValue = other326.lowValue;
  highValue = other326.highValue;
  numNulls = other326.numNulls;
  numDVs = other326.numDVs;
  bitVectors = other326.bitVectors;
  histogram = other326.histogram;
  __isset = other326.__isset;
}
DateColumnStatsData& DateColumnStatsData::operator=(const DateColumnStatsData& other327) {
  lowValue = other327.lowValue;
  highValue = other327.highValue;
  numNulls = other327.numNulls;
  numDVs = other327.numDVs;
  bitVectors = other327.bitVectors;
  histogram = other327.histogram;
  __isset = other327.__isset;
  return *this;
}
void DateColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DateColumnStatsData(";
  out << "lowValue="; (__isset.lowValue ? (out << to_string(lowValue)) : (out << "<null>"));
  out << ", " << "highValue="; (__isset.highValue ? (out << to_string(highValue)) : (out << "<null>"));
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ", " << "histogram="; (__isset.histogram ? (out << to_string(histogram)) : (out << "<null>"));
  out << ")";
}


Timestamp::~Timestamp() noexcept {
}


void Timestamp::__set_secondsSinceEpoch(const int64_t val) {
  this->secondsSinceEpoch = val;
}
std::ostream& operator<<(std::ostream& out, const Timestamp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Timestamp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_secondsSinceEpoch = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->secondsSinceEpoch);
          isset_secondsSinceEpoch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_secondsSinceEpoch)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Timestamp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Timestamp");

  xfer += oprot->writeFieldBegin("secondsSinceEpoch", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->secondsSinceEpoch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Timestamp &a, Timestamp &b) {
  using ::std::swap;
  swap(a.secondsSinceEpoch, b.secondsSinceEpoch);
}

Timestamp::Timestamp(const Timestamp& other328) noexcept {
  secondsSinceEpoch = other328.secondsSinceEpoch;
}
Timestamp& Timestamp::operator=(const Timestamp& other329) noexcept {
  secondsSinceEpoch = other329.secondsSinceEpoch;
  return *this;
}
void Timestamp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Timestamp(";
  out << "secondsSinceEpoch=" << to_string(secondsSinceEpoch);
  out << ")";
}


TimestampColumnStatsData::~TimestampColumnStatsData() noexcept {
}


void TimestampColumnStatsData::__set_lowValue(const Timestamp& val) {
  this->lowValue = val;
__isset.lowValue = true;
}

void TimestampColumnStatsData::__set_highValue(const Timestamp& val) {
  this->highValue = val;
__isset.highValue = true;
}

void TimestampColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void TimestampColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

void TimestampColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}

void TimestampColumnStatsData::__set_histogram(const std::string& val) {
  this->histogram = val;
__isset.histogram = true;
}
std::ostream& operator<<(std::ostream& out, const TimestampColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimestampColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lowValue.read(iprot);
          this->__isset.lowValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->highValue.read(iprot);
          this->__isset.highValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->histogram);
          this->__isset.histogram = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TimestampColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimestampColumnStatsData");

  if (this->__isset.lowValue) {
    xfer += oprot->writeFieldBegin("lowValue", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->lowValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.highValue) {
    xfer += oprot->writeFieldBegin("highValue", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->highValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histogram) {
    xfer += oprot->writeFieldBegin("histogram", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeBinary(this->histogram);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimestampColumnStatsData &a, TimestampColumnStatsData &b) {
  using ::std::swap;
  swap(a.lowValue, b.lowValue);
  swap(a.highValue, b.highValue);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
  swap(a.bitVectors, b.bitVectors);
  swap(a.histogram, b.histogram);
  swap(a.__isset, b.__isset);
}

TimestampColumnStatsData::TimestampColumnStatsData(const TimestampColumnStatsData& other330) {
  lowValue = other330.lowValue;
  highValue = other330.highValue;
  numNulls = other330.numNulls;
  numDVs = other330.numDVs;
  bitVectors = other330.bitVectors;
  histogram = other330.histogram;
  __isset = other330.__isset;
}
TimestampColumnStatsData& TimestampColumnStatsData::operator=(const TimestampColumnStatsData& other331) {
  lowValue = other331.lowValue;
  highValue = other331.highValue;
  numNulls = other331.numNulls;
  numDVs = other331.numDVs;
  bitVectors = other331.bitVectors;
  histogram = other331.histogram;
  __isset = other331.__isset;
  return *this;
}
void TimestampColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimestampColumnStatsData(";
  out << "lowValue="; (__isset.lowValue ? (out << to_string(lowValue)) : (out << "<null>"));
  out << ", " << "highValue="; (__isset.highValue ? (out << to_string(highValue)) : (out << "<null>"));
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ", " << "histogram="; (__isset.histogram ? (out << to_string(histogram)) : (out << "<null>"));
  out << ")";
}


ColumnStatisticsData::~ColumnStatisticsData() noexcept {
}


void ColumnStatisticsData::__set_booleanStats(const BooleanColumnStatsData& val) {
  this->booleanStats = val;
__isset.booleanStats = true;
}

void ColumnStatisticsData::__set_longStats(const LongColumnStatsData& val) {
  this->longStats = val;
__isset.longStats = true;
}

void ColumnStatisticsData::__set_doubleStats(const DoubleColumnStatsData& val) {
  this->doubleStats = val;
__isset.doubleStats = true;
}

void ColumnStatisticsData::__set_stringStats(const StringColumnStatsData& val) {
  this->stringStats = val;
__isset.stringStats = true;
}

void ColumnStatisticsData::__set_binaryStats(const BinaryColumnStatsData& val) {
  this->binaryStats = val;
__isset.binaryStats = true;
}

void ColumnStatisticsData::__set_decimalStats(const DecimalColumnStatsData& val) {
  this->decimalStats = val;
__isset.decimalStats = true;
}

void ColumnStatisticsData::__set_dateStats(const DateColumnStatsData& val) {
  this->dateStats = val;
__isset.dateStats = true;
}

void ColumnStatisticsData::__set_timestampStats(const TimestampColumnStatsData& val) {
  this->timestampStats = val;
__isset.timestampStats = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnStatisticsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnStatisticsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->booleanStats.read(iprot);
          this->__isset.booleanStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->longStats.read(iprot);
          this->__isset.longStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->doubleStats.read(iprot);
          this->__isset.doubleStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stringStats.read(iprot);
          this->__isset.stringStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->binaryStats.read(iprot);
          this->__isset.binaryStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->decimalStats.read(iprot);
          this->__isset.decimalStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dateStats.read(iprot);
          this->__isset.dateStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->timestampStats.read(iprot);
          this->__isset.timestampStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnStatisticsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnStatisticsData");

  if (this->__isset.booleanStats) {
    xfer += oprot->writeFieldBegin("booleanStats", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->booleanStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.longStats) {
    xfer += oprot->writeFieldBegin("longStats", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->longStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.doubleStats) {
    xfer += oprot->writeFieldBegin("doubleStats", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->doubleStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stringStats) {
    xfer += oprot->writeFieldBegin("stringStats", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->stringStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.binaryStats) {
    xfer += oprot->writeFieldBegin("binaryStats", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->binaryStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.decimalStats) {
    xfer += oprot->writeFieldBegin("decimalStats", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->decimalStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dateStats) {
    xfer += oprot->writeFieldBegin("dateStats", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->dateStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestampStats) {
    xfer += oprot->writeFieldBegin("timestampStats", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->timestampStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnStatisticsData &a, ColumnStatisticsData &b) {
  using ::std::swap;
  swap(a.booleanStats, b.booleanStats);
  swap(a.longStats, b.longStats);
  swap(a.doubleStats, b.doubleStats);
  swap(a.stringStats, b.stringStats);
  swap(a.binaryStats, b.binaryStats);
  swap(a.decimalStats, b.decimalStats);
  swap(a.dateStats, b.dateStats);
  swap(a.timestampStats, b.timestampStats);
  swap(a.__isset, b.__isset);
}

ColumnStatisticsData::ColumnStatisticsData(const ColumnStatisticsData& other332) {
  booleanStats = other332.booleanStats;
  longStats = other332.longStats;
  doubleStats = other332.doubleStats;
  stringStats = other332.stringStats;
  binaryStats = other332.binaryStats;
  decimalStats = other332.decimalStats;
  dateStats = other332.dateStats;
  timestampStats = other332.timestampStats;
  __isset = other332.__isset;
}
ColumnStatisticsData& ColumnStatisticsData::operator=(const ColumnStatisticsData& other333) {
  booleanStats = other333.booleanStats;
  longStats = other333.longStats;
  doubleStats = other333.doubleStats;
  stringStats = other333.stringStats;
  binaryStats = other333.binaryStats;
  decimalStats = other333.decimalStats;
  dateStats = other333.dateStats;
  timestampStats = other333.timestampStats;
  __isset = other333.__isset;
  return *this;
}
void ColumnStatisticsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnStatisticsData(";
  out << "booleanStats="; (__isset.booleanStats ? (out << to_string(booleanStats)) : (out << "<null>"));
  out << ", " << "longStats="; (__isset.longStats ? (out << to_string(longStats)) : (out << "<null>"));
  out << ", " << "doubleStats="; (__isset.doubleStats ? (out << to_string(doubleStats)) : (out << "<null>"));
  out << ", " << "stringStats="; (__isset.stringStats ? (out << to_string(stringStats)) : (out << "<null>"));
  out << ", " << "binaryStats="; (__isset.binaryStats ? (out << to_string(binaryStats)) : (out << "<null>"));
  out << ", " << "decimalStats="; (__isset.decimalStats ? (out << to_string(decimalStats)) : (out << "<null>"));
  out << ", " << "dateStats="; (__isset.dateStats ? (out << to_string(dateStats)) : (out << "<null>"));
  out << ", " << "timestampStats="; (__isset.timestampStats ? (out << to_string(timestampStats)) : (out << "<null>"));
  out << ")";
}


ColumnStatisticsObj::~ColumnStatisticsObj() noexcept {
}


void ColumnStatisticsObj::__set_colName(const std::string& val) {
  this->colName = val;
}

void ColumnStatisticsObj::__set_colType(const std::string& val) {
  this->colType = val;
}

void ColumnStatisticsObj::__set_statsData(const ColumnStatisticsData& val) {
  this->statsData = val;
}
std::ostream& operator<<(std::ostream& out, const ColumnStatisticsObj& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnStatisticsObj::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_colName = false;
  bool isset_colType = false;
  bool isset_statsData = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->colName);
          isset_colName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->colType);
          isset_colType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->statsData.read(iprot);
          isset_statsData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_colName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_colType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statsData)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnStatisticsObj::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnStatisticsObj");

  xfer += oprot->writeFieldBegin("colName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->colName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colType", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->colType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statsData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->statsData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnStatisticsObj &a, ColumnStatisticsObj &b) {
  using ::std::swap;
  swap(a.colName, b.colName);
  swap(a.colType, b.colType);
  swap(a.statsData, b.statsData);
}

ColumnStatisticsObj::ColumnStatisticsObj(const ColumnStatisticsObj& other334) {
  colName = other334.colName;
  colType = other334.colType;
  statsData = other334.statsData;
}
ColumnStatisticsObj& ColumnStatisticsObj::operator=(const ColumnStatisticsObj& other335) {
  colName = other335.colName;
  colType = other335.colType;
  statsData = other335.statsData;
  return *this;
}
void ColumnStatisticsObj::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnStatisticsObj(";
  out << "colName=" << to_string(colName);
  out << ", " << "colType=" << to_string(colType);
  out << ", " << "statsData=" << to_string(statsData);
  out << ")";
}


ColumnStatisticsDesc::~ColumnStatisticsDesc() noexcept {
}


void ColumnStatisticsDesc::__set_isTblLevel(const bool val) {
  this->isTblLevel = val;
}

void ColumnStatisticsDesc::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void ColumnStatisticsDesc::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void ColumnStatisticsDesc::__set_partName(const std::string& val) {
  this->partName = val;
__isset.partName = true;
}

void ColumnStatisticsDesc::__set_lastAnalyzed(const int64_t val) {
  this->lastAnalyzed = val;
__isset.lastAnalyzed = true;
}

void ColumnStatisticsDesc::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnStatisticsDesc& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnStatisticsDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_isTblLevel = false;
  bool isset_dbName = false;
  bool isset_tableName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isTblLevel);
          isset_isTblLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partName);
          this->__isset.partName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastAnalyzed);
          this->__isset.lastAnalyzed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_isTblLevel)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnStatisticsDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnStatisticsDesc");

  xfer += oprot->writeFieldBegin("isTblLevel", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->isTblLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partName) {
    xfer += oprot->writeFieldBegin("partName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->partName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastAnalyzed) {
    xfer += oprot->writeFieldBegin("lastAnalyzed", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->lastAnalyzed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnStatisticsDesc &a, ColumnStatisticsDesc &b) {
  using ::std::swap;
  swap(a.isTblLevel, b.isTblLevel);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.partName, b.partName);
  swap(a.lastAnalyzed, b.lastAnalyzed);
  swap(a.catName, b.catName);
  swap(a.__isset, b.__isset);
}

ColumnStatisticsDesc::ColumnStatisticsDesc(const ColumnStatisticsDesc& other336) {
  isTblLevel = other336.isTblLevel;
  dbName = other336.dbName;
  tableName = other336.tableName;
  partName = other336.partName;
  lastAnalyzed = other336.lastAnalyzed;
  catName = other336.catName;
  __isset = other336.__isset;
}
ColumnStatisticsDesc& ColumnStatisticsDesc::operator=(const ColumnStatisticsDesc& other337) {
  isTblLevel = other337.isTblLevel;
  dbName = other337.dbName;
  tableName = other337.tableName;
  partName = other337.partName;
  lastAnalyzed = other337.lastAnalyzed;
  catName = other337.catName;
  __isset = other337.__isset;
  return *this;
}
void ColumnStatisticsDesc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnStatisticsDesc(";
  out << "isTblLevel=" << to_string(isTblLevel);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "partName="; (__isset.partName ? (out << to_string(partName)) : (out << "<null>"));
  out << ", " << "lastAnalyzed="; (__isset.lastAnalyzed ? (out << to_string(lastAnalyzed)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ")";
}


ColumnStatistics::~ColumnStatistics() noexcept {
}


void ColumnStatistics::__set_statsDesc(const ColumnStatisticsDesc& val) {
  this->statsDesc = val;
}

void ColumnStatistics::__set_statsObj(const std::vector<ColumnStatisticsObj> & val) {
  this->statsObj = val;
}

void ColumnStatistics::__set_isStatsCompliant(const bool val) {
  this->isStatsCompliant = val;
__isset.isStatsCompliant = true;
}

void ColumnStatistics::__set_engine(const std::string& val) {
  this->engine = val;
__isset.engine = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnStatistics& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnStatistics::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_statsDesc = false;
  bool isset_statsObj = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->statsDesc.read(iprot);
          isset_statsDesc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->statsObj.clear();
            uint32_t _size338;
            ::apache::thrift::protocol::TType _etype341;
            xfer += iprot->readListBegin(_etype341, _size338);
            this->statsObj.resize(_size338);
            uint32_t _i342;
            for (_i342 = 0; _i342 < _size338; ++_i342)
            {
              xfer += this->statsObj[_i342].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_statsObj = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isStatsCompliant);
          this->__isset.isStatsCompliant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->engine);
          this->__isset.engine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_statsDesc)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statsObj)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnStatistics::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnStatistics");

  xfer += oprot->writeFieldBegin("statsDesc", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->statsDesc.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statsObj", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->statsObj.size()));
    std::vector<ColumnStatisticsObj> ::const_iterator _iter343;
    for (_iter343 = this->statsObj.begin(); _iter343 != this->statsObj.end(); ++_iter343)
    {
      xfer += (*_iter343).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.isStatsCompliant) {
    xfer += oprot->writeFieldBegin("isStatsCompliant", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->isStatsCompliant);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.engine) {
    xfer += oprot->writeFieldBegin("engine", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->engine);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnStatistics &a, ColumnStatistics &b) {
  using ::std::swap;
  swap(a.statsDesc, b.statsDesc);
  swap(a.statsObj, b.statsObj);
  swap(a.isStatsCompliant, b.isStatsCompliant);
  swap(a.engine, b.engine);
  swap(a.__isset, b.__isset);
}

ColumnStatistics::ColumnStatistics(const ColumnStatistics& other344) {
  statsDesc = other344.statsDesc;
  statsObj = other344.statsObj;
  isStatsCompliant = other344.isStatsCompliant;
  engine = other344.engine;
  __isset = other344.__isset;
}
ColumnStatistics& ColumnStatistics::operator=(const ColumnStatistics& other345) {
  statsDesc = other345.statsDesc;
  statsObj = other345.statsObj;
  isStatsCompliant = other345.isStatsCompliant;
  engine = other345.engine;
  __isset = other345.__isset;
  return *this;
}
void ColumnStatistics::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnStatistics(";
  out << "statsDesc=" << to_string(statsDesc);
  out << ", " << "statsObj=" << to_string(statsObj);
  out << ", " << "isStatsCompliant="; (__isset.isStatsCompliant ? (out << to_string(isStatsCompliant)) : (out << "<null>"));
  out << ", " << "engine="; (__isset.engine ? (out << to_string(engine)) : (out << "<null>"));
  out << ")";
}


FileMetadata::~FileMetadata() noexcept {
}


void FileMetadata::__set_type(const int8_t val) {
  this->type = val;
}

void FileMetadata::__set_version(const int8_t val) {
  this->version = val;
}

void FileMetadata::__set_data(const std::vector<std::string> & val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const FileMetadata& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FileMetadata::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size346;
            ::apache::thrift::protocol::TType _etype349;
            xfer += iprot->readListBegin(_etype349, _size346);
            this->data.resize(_size346);
            uint32_t _i350;
            for (_i350 = 0; _i350 < _size346; ++_i350)
            {
              xfer += iprot->readBinary(this->data[_i350]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FileMetadata::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FileMetadata");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->data.size()));
    std::vector<std::string> ::const_iterator _iter351;
    for (_iter351 = this->data.begin(); _iter351 != this->data.end(); ++_iter351)
    {
      xfer += oprot->writeBinary((*_iter351));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FileMetadata &a, FileMetadata &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.version, b.version);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

FileMetadata::FileMetadata(const FileMetadata& other352) {
  type = other352.type;
  version = other352.version;
  data = other352.data;
  __isset = other352.__isset;
}
FileMetadata& FileMetadata::operator=(const FileMetadata& other353) {
  type = other353.type;
  version = other353.version;
  data = other353.data;
  __isset = other353.__isset;
  return *this;
}
void FileMetadata::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FileMetadata(";
  out << "type=" << to_string(type);
  out << ", " << "version=" << to_string(version);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


ObjectDictionary::~ObjectDictionary() noexcept {
}


void ObjectDictionary::__set_values(const std::map<std::string, std::vector<std::string> > & val) {
  this->values = val;
}
std::ostream& operator<<(std::ostream& out, const ObjectDictionary& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ObjectDictionary::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->values.clear();
            uint32_t _size354;
            ::apache::thrift::protocol::TType _ktype355;
            ::apache::thrift::protocol::TType _vtype356;
            xfer += iprot->readMapBegin(_ktype355, _vtype356, _size354);
            uint32_t _i358;
            for (_i358 = 0; _i358 < _size354; ++_i358)
            {
              std::string _key359;
              xfer += iprot->readString(_key359);
              std::vector<std::string> & _val360 = this->values[_key359];
              {
                _val360.clear();
                uint32_t _size361;
                ::apache::thrift::protocol::TType _etype364;
                xfer += iprot->readListBegin(_etype364, _size361);
                _val360.resize(_size361);
                uint32_t _i365;
                for (_i365 = 0; _i365 < _size361; ++_i365)
                {
                  xfer += iprot->readBinary(_val360[_i365]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ObjectDictionary::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ObjectDictionary");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->values.size()));
    std::map<std::string, std::vector<std::string> > ::const_iterator _iter366;
    for (_iter366 = this->values.begin(); _iter366 != this->values.end(); ++_iter366)
    {
      xfer += oprot->writeString(_iter366->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter366->second.size()));
        std::vector<std::string> ::const_iterator _iter367;
        for (_iter367 = _iter366->second.begin(); _iter367 != _iter366->second.end(); ++_iter367)
        {
          xfer += oprot->writeBinary((*_iter367));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ObjectDictionary &a, ObjectDictionary &b) {
  using ::std::swap;
  swap(a.values, b.values);
}

ObjectDictionary::ObjectDictionary(const ObjectDictionary& other368) {
  values = other368.values;
}
ObjectDictionary& ObjectDictionary::operator=(const ObjectDictionary& other369) {
  values = other369.values;
  return *this;
}
void ObjectDictionary::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ObjectDictionary(";
  out << "values=" << to_string(values);
  out << ")";
}


Table::~Table() noexcept {
}


void Table::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void Table::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void Table::__set_owner(const std::string& val) {
  this->owner = val;
}

void Table::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void Table::__set_lastAccessTime(const int32_t val) {
  this->lastAccessTime = val;
}

void Table::__set_retention(const int32_t val) {
  this->retention = val;
}

void Table::__set_sd(const StorageDescriptor& val) {
  this->sd = val;
}

void Table::__set_partitionKeys(const std::vector<FieldSchema> & val) {
  this->partitionKeys = val;
}

void Table::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void Table::__set_viewOriginalText(const std::string& val) {
  this->viewOriginalText = val;
}

void Table::__set_viewExpandedText(const std::string& val) {
  this->viewExpandedText = val;
}

void Table::__set_tableType(const std::string& val) {
  this->tableType = val;
}

void Table::__set_privileges(const PrincipalPrivilegeSet& val) {
  this->privileges = val;
__isset.privileges = true;
}

void Table::__set_temporary(const bool val) {
  this->temporary = val;
__isset.temporary = true;
}

void Table::__set_rewriteEnabled(const bool val) {
  this->rewriteEnabled = val;
__isset.rewriteEnabled = true;
}

void Table::__set_creationMetadata(const CreationMetadata& val) {
  this->creationMetadata = val;
__isset.creationMetadata = true;
}

void Table::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void Table::__set_ownerType(const PrincipalType::type val) {
  this->ownerType = val;
__isset.ownerType = true;
}

void Table::__set_writeId(const int64_t val) {
  this->writeId = val;
__isset.writeId = true;
}

void Table::__set_isStatsCompliant(const bool val) {
  this->isStatsCompliant = val;
__isset.isStatsCompliant = true;
}

void Table::__set_colStats(const ColumnStatistics& val) {
  this->colStats = val;
__isset.colStats = true;
}

void Table::__set_accessType(const int8_t val) {
  this->accessType = val;
__isset.accessType = true;
}

void Table::__set_requiredReadCapabilities(const std::vector<std::string> & val) {
  this->requiredReadCapabilities = val;
__isset.requiredReadCapabilities = true;
}

void Table::__set_requiredWriteCapabilities(const std::vector<std::string> & val) {
  this->requiredWriteCapabilities = val;
__isset.requiredWriteCapabilities = true;
}

void Table::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}

void Table::__set_fileMetadata(const FileMetadata& val) {
  this->fileMetadata = val;
__isset.fileMetadata = true;
}

void Table::__set_dictionary(const ObjectDictionary& val) {
  this->dictionary = val;
__isset.dictionary = true;
}

void Table::__set_txnId(const int64_t val) {
  this->txnId = val;
__isset.txnId = true;
}
std::ostream& operator<<(std::ostream& out, const Table& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Table::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner);
          this->__isset.owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastAccessTime);
          this->__isset.lastAccessTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->retention);
          this->__isset.retention = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sd.read(iprot);
          this->__isset.sd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionKeys.clear();
            uint32_t _size370;
            ::apache::thrift::protocol::TType _etype373;
            xfer += iprot->readListBegin(_etype373, _size370);
            this->partitionKeys.resize(_size370);
            uint32_t _i374;
            for (_i374 = 0; _i374 < _size370; ++_i374)
            {
              xfer += this->partitionKeys[_i374].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionKeys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size375;
            ::apache::thrift::protocol::TType _ktype376;
            ::apache::thrift::protocol::TType _vtype377;
            xfer += iprot->readMapBegin(_ktype376, _vtype377, _size375);
            uint32_t _i379;
            for (_i379 = 0; _i379 < _size375; ++_i379)
            {
              std::string _key380;
              xfer += iprot->readString(_key380);
              std::string& _val381 = this->parameters[_key380];
              xfer += iprot->readString(_val381);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewOriginalText);
          this->__isset.viewOriginalText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewExpandedText);
          this->__isset.viewExpandedText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableType);
          this->__isset.tableType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->temporary);
          this->__isset.temporary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rewriteEnabled);
          this->__isset.rewriteEnabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->creationMetadata.read(iprot);
          this->__isset.creationMetadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast382;
          xfer += iprot->readI32(ecast382);
          this->ownerType = static_cast<PrincipalType::type>(ecast382);
          this->__isset.ownerType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          this->__isset.writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isStatsCompliant);
          this->__isset.isStatsCompliant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->colStats.read(iprot);
          this->__isset.colStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->accessType);
          this->__isset.accessType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->requiredReadCapabilities.clear();
            uint32_t _size383;
            ::apache::thrift::protocol::TType _etype386;
            xfer += iprot->readListBegin(_etype386, _size383);
            this->requiredReadCapabilities.resize(_size383);
            uint32_t _i387;
            for (_i387 = 0; _i387 < _size383; ++_i387)
            {
              xfer += iprot->readString(this->requiredReadCapabilities[_i387]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.requiredReadCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->requiredWriteCapabilities.clear();
            uint32_t _size388;
            ::apache::thrift::protocol::TType _etype391;
            xfer += iprot->readListBegin(_etype391, _size388);
            this->requiredWriteCapabilities.resize(_size388);
            uint32_t _i392;
            for (_i392 = 0; _i392 < _size388; ++_i392)
            {
              xfer += iprot->readString(this->requiredWriteCapabilities[_i392]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.requiredWriteCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fileMetadata.read(iprot);
          this->__isset.fileMetadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dictionary.read(iprot);
          this->__isset.dictionary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnId);
          this->__isset.txnId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Table::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Table");

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastAccessTime", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->lastAccessTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("retention", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->retention);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sd", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->sd.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitionKeys", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitionKeys.size()));
    std::vector<FieldSchema> ::const_iterator _iter393;
    for (_iter393 = this->partitionKeys.begin(); _iter393 != this->partitionKeys.end(); ++_iter393)
    {
      xfer += (*_iter393).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 9);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter394;
    for (_iter394 = this->parameters.begin(); _iter394 != this->parameters.end(); ++_iter394)
    {
      xfer += oprot->writeString(_iter394->first);
      xfer += oprot->writeString(_iter394->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("viewOriginalText", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->viewOriginalText);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("viewExpandedText", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->viewExpandedText);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableType", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->tableType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.privileges) {
    xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->privileges.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.temporary) {
    xfer += oprot->writeFieldBegin("temporary", ::apache::thrift::protocol::T_BOOL, 14);
    xfer += oprot->writeBool(this->temporary);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rewriteEnabled) {
    xfer += oprot->writeFieldBegin("rewriteEnabled", ::apache::thrift::protocol::T_BOOL, 15);
    xfer += oprot->writeBool(this->rewriteEnabled);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.creationMetadata) {
    xfer += oprot->writeFieldBegin("creationMetadata", ::apache::thrift::protocol::T_STRUCT, 16);
    xfer += this->creationMetadata.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ownerType) {
    xfer += oprot->writeFieldBegin("ownerType", ::apache::thrift::protocol::T_I32, 18);
    xfer += oprot->writeI32(static_cast<int32_t>(this->ownerType));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writeId) {
    xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 19);
    xfer += oprot->writeI64(this->writeId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isStatsCompliant) {
    xfer += oprot->writeFieldBegin("isStatsCompliant", ::apache::thrift::protocol::T_BOOL, 20);
    xfer += oprot->writeBool(this->isStatsCompliant);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.colStats) {
    xfer += oprot->writeFieldBegin("colStats", ::apache::thrift::protocol::T_STRUCT, 21);
    xfer += this->colStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.accessType) {
    xfer += oprot->writeFieldBegin("accessType", ::apache::thrift::protocol::T_BYTE, 22);
    xfer += oprot->writeByte(this->accessType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.requiredReadCapabilities) {
    xfer += oprot->writeFieldBegin("requiredReadCapabilities", ::apache::thrift::protocol::T_LIST, 23);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->requiredReadCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter395;
      for (_iter395 = this->requiredReadCapabilities.begin(); _iter395 != this->requiredReadCapabilities.end(); ++_iter395)
      {
        xfer += oprot->writeString((*_iter395));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.requiredWriteCapabilities) {
    xfer += oprot->writeFieldBegin("requiredWriteCapabilities", ::apache::thrift::protocol::T_LIST, 24);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->requiredWriteCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter396;
      for (_iter396 = this->requiredWriteCapabilities.begin(); _iter396 != this->requiredWriteCapabilities.end(); ++_iter396)
      {
        xfer += oprot->writeString((*_iter396));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 25);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fileMetadata) {
    xfer += oprot->writeFieldBegin("fileMetadata", ::apache::thrift::protocol::T_STRUCT, 26);
    xfer += this->fileMetadata.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dictionary) {
    xfer += oprot->writeFieldBegin("dictionary", ::apache::thrift::protocol::T_STRUCT, 27);
    xfer += this->dictionary.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.txnId) {
    xfer += oprot->writeFieldBegin("txnId", ::apache::thrift::protocol::T_I64, 28);
    xfer += oprot->writeI64(this->txnId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Table &a, Table &b) {
  using ::std::swap;
  swap(a.tableName, b.tableName);
  swap(a.dbName, b.dbName);
  swap(a.owner, b.owner);
  swap(a.createTime, b.createTime);
  swap(a.lastAccessTime, b.lastAccessTime);
  swap(a.retention, b.retention);
  swap(a.sd, b.sd);
  swap(a.partitionKeys, b.partitionKeys);
  swap(a.parameters, b.parameters);
  swap(a.viewOriginalText, b.viewOriginalText);
  swap(a.viewExpandedText, b.viewExpandedText);
  swap(a.tableType, b.tableType);
  swap(a.privileges, b.privileges);
  swap(a.temporary, b.temporary);
  swap(a.rewriteEnabled, b.rewriteEnabled);
  swap(a.creationMetadata, b.creationMetadata);
  swap(a.catName, b.catName);
  swap(a.ownerType, b.ownerType);
  swap(a.writeId, b.writeId);
  swap(a.isStatsCompliant, b.isStatsCompliant);
  swap(a.colStats, b.colStats);
  swap(a.accessType, b.accessType);
  swap(a.requiredReadCapabilities, b.requiredReadCapabilities);
  swap(a.requiredWriteCapabilities, b.requiredWriteCapabilities);
  swap(a.id, b.id);
  swap(a.fileMetadata, b.fileMetadata);
  swap(a.dictionary, b.dictionary);
  swap(a.txnId, b.txnId);
  swap(a.__isset, b.__isset);
}

Table::Table(const Table& other397) {
  tableName = other397.tableName;
  dbName = other397.dbName;
  owner = other397.owner;
  createTime = other397.createTime;
  lastAccessTime = other397.lastAccessTime;
  retention = other397.retention;
  sd = other397.sd;
  partitionKeys = other397.partitionKeys;
  parameters = other397.parameters;
  viewOriginalText = other397.viewOriginalText;
  viewExpandedText = other397.viewExpandedText;
  tableType = other397.tableType;
  privileges = other397.privileges;
  temporary = other397.temporary;
  rewriteEnabled = other397.rewriteEnabled;
  creationMetadata = other397.creationMetadata;
  catName = other397.catName;
  ownerType = other397.ownerType;
  writeId = other397.writeId;
  isStatsCompliant = other397.isStatsCompliant;
  colStats = other397.colStats;
  accessType = other397.accessType;
  requiredReadCapabilities = other397.requiredReadCapabilities;
  requiredWriteCapabilities = other397.requiredWriteCapabilities;
  id = other397.id;
  fileMetadata = other397.fileMetadata;
  dictionary = other397.dictionary;
  txnId = other397.txnId;
  __isset = other397.__isset;
}
Table& Table::operator=(const Table& other398) {
  tableName = other398.tableName;
  dbName = other398.dbName;
  owner = other398.owner;
  createTime = other398.createTime;
  lastAccessTime = other398.lastAccessTime;
  retention = other398.retention;
  sd = other398.sd;
  partitionKeys = other398.partitionKeys;
  parameters = other398.parameters;
  viewOriginalText = other398.viewOriginalText;
  viewExpandedText = other398.viewExpandedText;
  tableType = other398.tableType;
  privileges = other398.privileges;
  temporary = other398.temporary;
  rewriteEnabled = other398.rewriteEnabled;
  creationMetadata = other398.creationMetadata;
  catName = other398.catName;
  ownerType = other398.ownerType;
  writeId = other398.writeId;
  isStatsCompliant = other398.isStatsCompliant;
  colStats = other398.colStats;
  accessType = other398.accessType;
  requiredReadCapabilities = other398.requiredReadCapabilities;
  requiredWriteCapabilities = other398.requiredWriteCapabilities;
  id = other398.id;
  fileMetadata = other398.fileMetadata;
  dictionary = other398.dictionary;
  txnId = other398.txnId;
  __isset = other398.__isset;
  return *this;
}
void Table::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Table(";
  out << "tableName=" << to_string(tableName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "owner=" << to_string(owner);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "lastAccessTime=" << to_string(lastAccessTime);
  out << ", " << "retention=" << to_string(retention);
  out << ", " << "sd=" << to_string(sd);
  out << ", " << "partitionKeys=" << to_string(partitionKeys);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "viewOriginalText=" << to_string(viewOriginalText);
  out << ", " << "viewExpandedText=" << to_string(viewExpandedText);
  out << ", " << "tableType=" << to_string(tableType);
  out << ", " << "privileges="; (__isset.privileges ? (out << to_string(privileges)) : (out << "<null>"));
  out << ", " << "temporary="; (__isset.temporary ? (out << to_string(temporary)) : (out << "<null>"));
  out << ", " << "rewriteEnabled="; (__isset.rewriteEnabled ? (out << to_string(rewriteEnabled)) : (out << "<null>"));
  out << ", " << "creationMetadata="; (__isset.creationMetadata ? (out << to_string(creationMetadata)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "ownerType="; (__isset.ownerType ? (out << to_string(ownerType)) : (out << "<null>"));
  out << ", " << "writeId="; (__isset.writeId ? (out << to_string(writeId)) : (out << "<null>"));
  out << ", " << "isStatsCompliant="; (__isset.isStatsCompliant ? (out << to_string(isStatsCompliant)) : (out << "<null>"));
  out << ", " << "colStats="; (__isset.colStats ? (out << to_string(colStats)) : (out << "<null>"));
  out << ", " << "accessType="; (__isset.accessType ? (out << to_string(accessType)) : (out << "<null>"));
  out << ", " << "requiredReadCapabilities="; (__isset.requiredReadCapabilities ? (out << to_string(requiredReadCapabilities)) : (out << "<null>"));
  out << ", " << "requiredWriteCapabilities="; (__isset.requiredWriteCapabilities ? (out << to_string(requiredWriteCapabilities)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "fileMetadata="; (__isset.fileMetadata ? (out << to_string(fileMetadata)) : (out << "<null>"));
  out << ", " << "dictionary="; (__isset.dictionary ? (out << to_string(dictionary)) : (out << "<null>"));
  out << ", " << "txnId="; (__isset.txnId ? (out << to_string(txnId)) : (out << "<null>"));
  out << ")";
}


SourceTable::~SourceTable() noexcept {
}


void SourceTable::__set_table(const Table& val) {
  this->table = val;
}

void SourceTable::__set_insertedCount(const int64_t val) {
  this->insertedCount = val;
}

void SourceTable::__set_updatedCount(const int64_t val) {
  this->updatedCount = val;
}

void SourceTable::__set_deletedCount(const int64_t val) {
  this->deletedCount = val;
}
std::ostream& operator<<(std::ostream& out, const SourceTable& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SourceTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table = false;
  bool isset_insertedCount = false;
  bool isset_updatedCount = false;
  bool isset_deletedCount = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table.read(iprot);
          isset_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->insertedCount);
          isset_insertedCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->updatedCount);
          isset_updatedCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->deletedCount);
          isset_deletedCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_insertedCount)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_updatedCount)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_deletedCount)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SourceTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SourceTable");

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("insertedCount", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->insertedCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updatedCount", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->updatedCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deletedCount", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->deletedCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SourceTable &a, SourceTable &b) {
  using ::std::swap;
  swap(a.table, b.table);
  swap(a.insertedCount, b.insertedCount);
  swap(a.updatedCount, b.updatedCount);
  swap(a.deletedCount, b.deletedCount);
}

SourceTable::SourceTable(const SourceTable& other399) {
  table = other399.table;
  insertedCount = other399.insertedCount;
  updatedCount = other399.updatedCount;
  deletedCount = other399.deletedCount;
}
SourceTable& SourceTable::operator=(const SourceTable& other400) {
  table = other400.table;
  insertedCount = other400.insertedCount;
  updatedCount = other400.updatedCount;
  deletedCount = other400.deletedCount;
  return *this;
}
void SourceTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SourceTable(";
  out << "table=" << to_string(table);
  out << ", " << "insertedCount=" << to_string(insertedCount);
  out << ", " << "updatedCount=" << to_string(updatedCount);
  out << ", " << "deletedCount=" << to_string(deletedCount);
  out << ")";
}


Partition::~Partition() noexcept {
}


void Partition::__set_values(const std::vector<std::string> & val) {
  this->values = val;
}

void Partition::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void Partition::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void Partition::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void Partition::__set_lastAccessTime(const int32_t val) {
  this->lastAccessTime = val;
}

void Partition::__set_sd(const StorageDescriptor& val) {
  this->sd = val;
}

void Partition::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void Partition::__set_privileges(const PrincipalPrivilegeSet& val) {
  this->privileges = val;
__isset.privileges = true;
}

void Partition::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void Partition::__set_writeId(const int64_t val) {
  this->writeId = val;
__isset.writeId = true;
}

void Partition::__set_isStatsCompliant(const bool val) {
  this->isStatsCompliant = val;
__isset.isStatsCompliant = true;
}

void Partition::__set_colStats(const ColumnStatistics& val) {
  this->colStats = val;
__isset.colStats = true;
}

void Partition::__set_fileMetadata(const FileMetadata& val) {
  this->fileMetadata = val;
__isset.fileMetadata = true;
}
std::ostream& operator<<(std::ostream& out, const Partition& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Partition::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size401;
            ::apache::thrift::protocol::TType _etype404;
            xfer += iprot->readListBegin(_etype404, _size401);
            this->values.resize(_size401);
            uint32_t _i405;
            for (_i405 = 0; _i405 < _size401; ++_i405)
            {
              xfer += iprot->readString(this->values[_i405]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastAccessTime);
          this->__isset.lastAccessTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sd.read(iprot);
          this->__isset.sd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size406;
            ::apache::thrift::protocol::TType _ktype407;
            ::apache::thrift::protocol::TType _vtype408;
            xfer += iprot->readMapBegin(_ktype407, _vtype408, _size406);
            uint32_t _i410;
            for (_i410 = 0; _i410 < _size406; ++_i410)
            {
              std::string _key411;
              xfer += iprot->readString(_key411);
              std::string& _val412 = this->parameters[_key411];
              xfer += iprot->readString(_val412);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          this->__isset.writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isStatsCompliant);
          this->__isset.isStatsCompliant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->colStats.read(iprot);
          this->__isset.colStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fileMetadata.read(iprot);
          this->__isset.fileMetadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Partition::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Partition");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter413;
    for (_iter413 = this->values.begin(); _iter413 != this->values.end(); ++_iter413)
    {
      xfer += oprot->writeString((*_iter413));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastAccessTime", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->lastAccessTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sd", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->sd.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 7);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter414;
    for (_iter414 = this->parameters.begin(); _iter414 != this->parameters.end(); ++_iter414)
    {
      xfer += oprot->writeString(_iter414->first);
      xfer += oprot->writeString(_iter414->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.privileges) {
    xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->privileges.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writeId) {
    xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->writeId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isStatsCompliant) {
    xfer += oprot->writeFieldBegin("isStatsCompliant", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->isStatsCompliant);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.colStats) {
    xfer += oprot->writeFieldBegin("colStats", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->colStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fileMetadata) {
    xfer += oprot->writeFieldBegin("fileMetadata", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->fileMetadata.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Partition &a, Partition &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.createTime, b.createTime);
  swap(a.lastAccessTime, b.lastAccessTime);
  swap(a.sd, b.sd);
  swap(a.parameters, b.parameters);
  swap(a.privileges, b.privileges);
  swap(a.catName, b.catName);
  swap(a.writeId, b.writeId);
  swap(a.isStatsCompliant, b.isStatsCompliant);
  swap(a.colStats, b.colStats);
  swap(a.fileMetadata, b.fileMetadata);
  swap(a.__isset, b.__isset);
}

Partition::Partition(const Partition& other415) {
  values = other415.values;
  dbName = other415.dbName;
  tableName = other415.tableName;
  createTime = other415.createTime;
  lastAccessTime = other415.lastAccessTime;
  sd = other415.sd;
  parameters = other415.parameters;
  privileges = other415.privileges;
  catName = other415.catName;
  writeId = other415.writeId;
  isStatsCompliant = other415.isStatsCompliant;
  colStats = other415.colStats;
  fileMetadata = other415.fileMetadata;
  __isset = other415.__isset;
}
Partition& Partition::operator=(const Partition& other416) {
  values = other416.values;
  dbName = other416.dbName;
  tableName = other416.tableName;
  createTime = other416.createTime;
  lastAccessTime = other416.lastAccessTime;
  sd = other416.sd;
  parameters = other416.parameters;
  privileges = other416.privileges;
  catName = other416.catName;
  writeId = other416.writeId;
  isStatsCompliant = other416.isStatsCompliant;
  colStats = other416.colStats;
  fileMetadata = other416.fileMetadata;
  __isset = other416.__isset;
  return *this;
}
void Partition::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Partition(";
  out << "values=" << to_string(values);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "lastAccessTime=" << to_string(lastAccessTime);
  out << ", " << "sd=" << to_string(sd);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "privileges="; (__isset.privileges ? (out << to_string(privileges)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "writeId="; (__isset.writeId ? (out << to_string(writeId)) : (out << "<null>"));
  out << ", " << "isStatsCompliant="; (__isset.isStatsCompliant ? (out << to_string(isStatsCompliant)) : (out << "<null>"));
  out << ", " << "colStats="; (__isset.colStats ? (out << to_string(colStats)) : (out << "<null>"));
  out << ", " << "fileMetadata="; (__isset.fileMetadata ? (out << to_string(fileMetadata)) : (out << "<null>"));
  out << ")";
}


PartitionWithoutSD::~PartitionWithoutSD() noexcept {
}


void PartitionWithoutSD::__set_values(const std::vector<std::string> & val) {
  this->values = val;
}

void PartitionWithoutSD::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void PartitionWithoutSD::__set_lastAccessTime(const int32_t val) {
  this->lastAccessTime = val;
}

void PartitionWithoutSD::__set_relativePath(const std::string& val) {
  this->relativePath = val;
}

void PartitionWithoutSD::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void PartitionWithoutSD::__set_privileges(const PrincipalPrivilegeSet& val) {
  this->privileges = val;
__isset.privileges = true;
}
std::ostream& operator<<(std::ostream& out, const PartitionWithoutSD& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionWithoutSD::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size417;
            ::apache::thrift::protocol::TType _etype420;
            xfer += iprot->readListBegin(_etype420, _size417);
            this->values.resize(_size417);
            uint32_t _i421;
            for (_i421 = 0; _i421 < _size417; ++_i421)
            {
              xfer += iprot->readString(this->values[_i421]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastAccessTime);
          this->__isset.lastAccessTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->relativePath);
          this->__isset.relativePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size422;
            ::apache::thrift::protocol::TType _ktype423;
            ::apache::thrift::protocol::TType _vtype424;
            xfer += iprot->readMapBegin(_ktype423, _vtype424, _size422);
            uint32_t _i426;
            for (_i426 = 0; _i426 < _size422; ++_i426)
            {
              std::string _key427;
              xfer += iprot->readString(_key427);
              std::string& _val428 = this->parameters[_key427];
              xfer += iprot->readString(_val428);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PartitionWithoutSD::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionWithoutSD");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter429;
    for (_iter429 = this->values.begin(); _iter429 != this->values.end(); ++_iter429)
    {
      xfer += oprot->writeString((*_iter429));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastAccessTime", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->lastAccessTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("relativePath", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->relativePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter430;
    for (_iter430 = this->parameters.begin(); _iter430 != this->parameters.end(); ++_iter430)
    {
      xfer += oprot->writeString(_iter430->first);
      xfer += oprot->writeString(_iter430->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.privileges) {
    xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->privileges.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionWithoutSD &a, PartitionWithoutSD &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.createTime, b.createTime);
  swap(a.lastAccessTime, b.lastAccessTime);
  swap(a.relativePath, b.relativePath);
  swap(a.parameters, b.parameters);
  swap(a.privileges, b.privileges);
  swap(a.__isset, b.__isset);
}

PartitionWithoutSD::PartitionWithoutSD(const PartitionWithoutSD& other431) {
  values = other431.values;
  createTime = other431.createTime;
  lastAccessTime = other431.lastAccessTime;
  relativePath = other431.relativePath;
  parameters = other431.parameters;
  privileges = other431.privileges;
  __isset = other431.__isset;
}
PartitionWithoutSD& PartitionWithoutSD::operator=(const PartitionWithoutSD& other432) {
  values = other432.values;
  createTime = other432.createTime;
  lastAccessTime = other432.lastAccessTime;
  relativePath = other432.relativePath;
  parameters = other432.parameters;
  privileges = other432.privileges;
  __isset = other432.__isset;
  return *this;
}
void PartitionWithoutSD::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionWithoutSD(";
  out << "values=" << to_string(values);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "lastAccessTime=" << to_string(lastAccessTime);
  out << ", " << "relativePath=" << to_string(relativePath);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "privileges="; (__isset.privileges ? (out << to_string(privileges)) : (out << "<null>"));
  out << ")";
}


PartitionSpecWithSharedSD::~PartitionSpecWithSharedSD() noexcept {
}


void PartitionSpecWithSharedSD::__set_partitions(const std::vector<PartitionWithoutSD> & val) {
  this->partitions = val;
}

void PartitionSpecWithSharedSD::__set_sd(const StorageDescriptor& val) {
  this->sd = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionSpecWithSharedSD& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionSpecWithSharedSD::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size433;
            ::apache::thrift::protocol::TType _etype436;
            xfer += iprot->readListBegin(_etype436, _size433);
            this->partitions.resize(_size433);
            uint32_t _i437;
            for (_i437 = 0; _i437 < _size433; ++_i437)
            {
              xfer += this->partitions[_i437].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sd.read(iprot);
          this->__isset.sd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PartitionSpecWithSharedSD::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionSpecWithSharedSD");

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<PartitionWithoutSD> ::const_iterator _iter438;
    for (_iter438 = this->partitions.begin(); _iter438 != this->partitions.end(); ++_iter438)
    {
      xfer += (*_iter438).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sd", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->sd.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionSpecWithSharedSD &a, PartitionSpecWithSharedSD &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.sd, b.sd);
  swap(a.__isset, b.__isset);
}

PartitionSpecWithSharedSD::PartitionSpecWithSharedSD(const PartitionSpecWithSharedSD& other439) {
  partitions = other439.partitions;
  sd = other439.sd;
  __isset = other439.__isset;
}
PartitionSpecWithSharedSD& PartitionSpecWithSharedSD::operator=(const PartitionSpecWithSharedSD& other440) {
  partitions = other440.partitions;
  sd = other440.sd;
  __isset = other440.__isset;
  return *this;
}
void PartitionSpecWithSharedSD::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionSpecWithSharedSD(";
  out << "partitions=" << to_string(partitions);
  out << ", " << "sd=" << to_string(sd);
  out << ")";
}


PartitionListComposingSpec::~PartitionListComposingSpec() noexcept {
}


void PartitionListComposingSpec::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionListComposingSpec& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionListComposingSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size441;
            ::apache::thrift::protocol::TType _etype444;
            xfer += iprot->readListBegin(_etype444, _size441);
            this->partitions.resize(_size441);
            uint32_t _i445;
            for (_i445 = 0; _i445 < _size441; ++_i445)
            {
              xfer += this->partitions[_i445].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PartitionListComposingSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionListComposingSpec");

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<Partition> ::const_iterator _iter446;
    for (_iter446 = this->partitions.begin(); _iter446 != this->partitions.end(); ++_iter446)
    {
      xfer += (*_iter446).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionListComposingSpec &a, PartitionListComposingSpec &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.__isset, b.__isset);
}

PartitionListComposingSpec::PartitionListComposingSpec(const PartitionListComposingSpec& other447) {
  partitions = other447.partitions;
  __isset = other447.__isset;
}
PartitionListComposingSpec& PartitionListComposingSpec::operator=(const PartitionListComposingSpec& other448) {
  partitions = other448.partitions;
  __isset = other448.__isset;
  return *this;
}
void PartitionListComposingSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionListComposingSpec(";
  out << "partitions=" << to_string(partitions);
  out << ")";
}


PartitionSpec::~PartitionSpec() noexcept {
}


void PartitionSpec::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void PartitionSpec::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void PartitionSpec::__set_rootPath(const std::string& val) {
  this->rootPath = val;
}

void PartitionSpec::__set_sharedSDPartitionSpec(const PartitionSpecWithSharedSD& val) {
  this->sharedSDPartitionSpec = val;
__isset.sharedSDPartitionSpec = true;
}

void PartitionSpec::__set_partitionList(const PartitionListComposingSpec& val) {
  this->partitionList = val;
__isset.partitionList = true;
}

void PartitionSpec::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void PartitionSpec::__set_writeId(const int64_t val) {
  this->writeId = val;
__isset.writeId = true;
}

void PartitionSpec::__set_isStatsCompliant(const bool val) {
  this->isStatsCompliant = val;
__isset.isStatsCompliant = true;
}
std::ostream& operator<<(std::ostream& out, const PartitionSpec& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rootPath);
          this->__isset.rootPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sharedSDPartitionSpec.read(iprot);
          this->__isset.sharedSDPartitionSpec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->partitionList.read(iprot);
          this->__isset.partitionList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          this->__isset.writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isStatsCompliant);
          this->__isset.isStatsCompliant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PartitionSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionSpec");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rootPath", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->rootPath);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sharedSDPartitionSpec) {
    xfer += oprot->writeFieldBegin("sharedSDPartitionSpec", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->sharedSDPartitionSpec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionList) {
    xfer += oprot->writeFieldBegin("partitionList", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->partitionList.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writeId) {
    xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->writeId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isStatsCompliant) {
    xfer += oprot->writeFieldBegin("isStatsCompliant", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->isStatsCompliant);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionSpec &a, PartitionSpec &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.rootPath, b.rootPath);
  swap(a.sharedSDPartitionSpec, b.sharedSDPartitionSpec);
  swap(a.partitionList, b.partitionList);
  swap(a.catName, b.catName);
  swap(a.writeId, b.writeId);
  swap(a.isStatsCompliant, b.isStatsCompliant);
  swap(a.__isset, b.__isset);
}

PartitionSpec::PartitionSpec(const PartitionSpec& other449) {
  dbName = other449.dbName;
  tableName = other449.tableName;
  rootPath = other449.rootPath;
  sharedSDPartitionSpec = other449.sharedSDPartitionSpec;
  partitionList = other449.partitionList;
  catName = other449.catName;
  writeId = other449.writeId;
  isStatsCompliant = other449.isStatsCompliant;
  __isset = other449.__isset;
}
PartitionSpec& PartitionSpec::operator=(const PartitionSpec& other450) {
  dbName = other450.dbName;
  tableName = other450.tableName;
  rootPath = other450.rootPath;
  sharedSDPartitionSpec = other450.sharedSDPartitionSpec;
  partitionList = other450.partitionList;
  catName = other450.catName;
  writeId = other450.writeId;
  isStatsCompliant = other450.isStatsCompliant;
  __isset = other450.__isset;
  return *this;
}
void PartitionSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionSpec(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "rootPath=" << to_string(rootPath);
  out << ", " << "sharedSDPartitionSpec="; (__isset.sharedSDPartitionSpec ? (out << to_string(sharedSDPartitionSpec)) : (out << "<null>"));
  out << ", " << "partitionList="; (__isset.partitionList ? (out << to_string(partitionList)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "writeId="; (__isset.writeId ? (out << to_string(writeId)) : (out << "<null>"));
  out << ", " << "isStatsCompliant="; (__isset.isStatsCompliant ? (out << to_string(isStatsCompliant)) : (out << "<null>"));
  out << ")";
}


AggrStats::~AggrStats() noexcept {
}


void AggrStats::__set_colStats(const std::vector<ColumnStatisticsObj> & val) {
  this->colStats = val;
}

void AggrStats::__set_partsFound(const int64_t val) {
  this->partsFound = val;
}

void AggrStats::__set_isStatsCompliant(const bool val) {
  this->isStatsCompliant = val;
__isset.isStatsCompliant = true;
}
std::ostream& operator<<(std::ostream& out, const AggrStats& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AggrStats::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_colStats = false;
  bool isset_partsFound = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colStats.clear();
            uint32_t _size451;
            ::apache::thrift::protocol::TType _etype454;
            xfer += iprot->readListBegin(_etype454, _size451);
            this->colStats.resize(_size451);
            uint32_t _i455;
            for (_i455 = 0; _i455 < _size451; ++_i455)
            {
              xfer += this->colStats[_i455].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_colStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->partsFound);
          isset_partsFound = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isStatsCompliant);
          this->__isset.isStatsCompliant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_colStats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partsFound)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AggrStats::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AggrStats");

  xfer += oprot->writeFieldBegin("colStats", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->colStats.size()));
    std::vector<ColumnStatisticsObj> ::const_iterator _iter456;
    for (_iter456 = this->colStats.begin(); _iter456 != this->colStats.end(); ++_iter456)
    {
      xfer += (*_iter456).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partsFound", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->partsFound);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.isStatsCompliant) {
    xfer += oprot->writeFieldBegin("isStatsCompliant", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->isStatsCompliant);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AggrStats &a, AggrStats &b) {
  using ::std::swap;
  swap(a.colStats, b.colStats);
  swap(a.partsFound, b.partsFound);
  swap(a.isStatsCompliant, b.isStatsCompliant);
  swap(a.__isset, b.__isset);
}

AggrStats::AggrStats(const AggrStats& other457) {
  colStats = other457.colStats;
  partsFound = other457.partsFound;
  isStatsCompliant = other457.isStatsCompliant;
  __isset = other457.__isset;
}
AggrStats& AggrStats::operator=(const AggrStats& other458) {
  colStats = other458.colStats;
  partsFound = other458.partsFound;
  isStatsCompliant = other458.isStatsCompliant;
  __isset = other458.__isset;
  return *this;
}
void AggrStats::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AggrStats(";
  out << "colStats=" << to_string(colStats);
  out << ", " << "partsFound=" << to_string(partsFound);
  out << ", " << "isStatsCompliant="; (__isset.isStatsCompliant ? (out << to_string(isStatsCompliant)) : (out << "<null>"));
  out << ")";
}


SetPartitionsStatsRequest::~SetPartitionsStatsRequest() noexcept {
}


void SetPartitionsStatsRequest::__set_colStats(const std::vector<ColumnStatistics> & val) {
  this->colStats = val;
}

void SetPartitionsStatsRequest::__set_needMerge(const bool val) {
  this->needMerge = val;
__isset.needMerge = true;
}

void SetPartitionsStatsRequest::__set_writeId(const int64_t val) {
  this->writeId = val;
__isset.writeId = true;
}

void SetPartitionsStatsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void SetPartitionsStatsRequest::__set_engine(const std::string& val) {
  this->engine = val;
}
std::ostream& operator<<(std::ostream& out, const SetPartitionsStatsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SetPartitionsStatsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_colStats = false;
  bool isset_engine = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colStats.clear();
            uint32_t _size459;
            ::apache::thrift::protocol::TType _etype462;
            xfer += iprot->readListBegin(_etype462, _size459);
            this->colStats.resize(_size459);
            uint32_t _i463;
            for (_i463 = 0; _i463 < _size459; ++_i463)
            {
              xfer += this->colStats[_i463].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_colStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->needMerge);
          this->__isset.needMerge = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          this->__isset.writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->engine);
          isset_engine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_colStats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_engine)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SetPartitionsStatsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SetPartitionsStatsRequest");

  xfer += oprot->writeFieldBegin("colStats", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->colStats.size()));
    std::vector<ColumnStatistics> ::const_iterator _iter464;
    for (_iter464 = this->colStats.begin(); _iter464 != this->colStats.end(); ++_iter464)
    {
      xfer += (*_iter464).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.needMerge) {
    xfer += oprot->writeFieldBegin("needMerge", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->needMerge);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writeId) {
    xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->writeId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("engine", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->engine);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SetPartitionsStatsRequest &a, SetPartitionsStatsRequest &b) {
  using ::std::swap;
  swap(a.colStats, b.colStats);
  swap(a.needMerge, b.needMerge);
  swap(a.writeId, b.writeId);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.engine, b.engine);
  swap(a.__isset, b.__isset);
}

SetPartitionsStatsRequest::SetPartitionsStatsRequest(const SetPartitionsStatsRequest& other465) {
  colStats = other465.colStats;
  needMerge = other465.needMerge;
  writeId = other465.writeId;
  validWriteIdList = other465.validWriteIdList;
  engine = other465.engine;
  __isset = other465.__isset;
}
SetPartitionsStatsRequest& SetPartitionsStatsRequest::operator=(const SetPartitionsStatsRequest& other466) {
  colStats = other466.colStats;
  needMerge = other466.needMerge;
  writeId = other466.writeId;
  validWriteIdList = other466.validWriteIdList;
  engine = other466.engine;
  __isset = other466.__isset;
  return *this;
}
void SetPartitionsStatsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SetPartitionsStatsRequest(";
  out << "colStats=" << to_string(colStats);
  out << ", " << "needMerge="; (__isset.needMerge ? (out << to_string(needMerge)) : (out << "<null>"));
  out << ", " << "writeId="; (__isset.writeId ? (out << to_string(writeId)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "engine=" << to_string(engine);
  out << ")";
}


SetPartitionsStatsResponse::~SetPartitionsStatsResponse() noexcept {
}


void SetPartitionsStatsResponse::__set_result(const bool val) {
  this->result = val;
}
std::ostream& operator<<(std::ostream& out, const SetPartitionsStatsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SetPartitionsStatsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_result = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->result);
          isset_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_result)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SetPartitionsStatsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SetPartitionsStatsResponse");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SetPartitionsStatsResponse &a, SetPartitionsStatsResponse &b) {
  using ::std::swap;
  swap(a.result, b.result);
}

SetPartitionsStatsResponse::SetPartitionsStatsResponse(const SetPartitionsStatsResponse& other467) noexcept {
  result = other467.result;
}
SetPartitionsStatsResponse& SetPartitionsStatsResponse::operator=(const SetPartitionsStatsResponse& other468) noexcept {
  result = other468.result;
  return *this;
}
void SetPartitionsStatsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SetPartitionsStatsResponse(";
  out << "result=" << to_string(result);
  out << ")";
}


Schema::~Schema() noexcept {
}


void Schema::__set_fieldSchemas(const std::vector<FieldSchema> & val) {
  this->fieldSchemas = val;
}

void Schema::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
}
std::ostream& operator<<(std::ostream& out, const Schema& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Schema::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fieldSchemas.clear();
            uint32_t _size469;
            ::apache::thrift::protocol::TType _etype472;
            xfer += iprot->readListBegin(_etype472, _size469);
            this->fieldSchemas.resize(_size469);
            uint32_t _i473;
            for (_i473 = 0; _i473 < _size469; ++_i473)
            {
              xfer += this->fieldSchemas[_i473].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldSchemas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size474;
            ::apache::thrift::protocol::TType _ktype475;
            ::apache::thrift::protocol::TType _vtype476;
            xfer += iprot->readMapBegin(_ktype475, _vtype476, _size474);
            uint32_t _i478;
            for (_i478 = 0; _i478 < _size474; ++_i478)
            {
              std::string _key479;
              xfer += iprot->readString(_key479);
              std::string& _val480 = this->properties[_key479];
              xfer += iprot->readString(_val480);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Schema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Schema");

  xfer += oprot->writeFieldBegin("fieldSchemas", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fieldSchemas.size()));
    std::vector<FieldSchema> ::const_iterator _iter481;
    for (_iter481 = this->fieldSchemas.begin(); _iter481 != this->fieldSchemas.end(); ++_iter481)
    {
      xfer += (*_iter481).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter482;
    for (_iter482 = this->properties.begin(); _iter482 != this->properties.end(); ++_iter482)
    {
      xfer += oprot->writeString(_iter482->first);
      xfer += oprot->writeString(_iter482->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Schema &a, Schema &b) {
  using ::std::swap;
  swap(a.fieldSchemas, b.fieldSchemas);
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

Schema::Schema(const Schema& other483) {
  fieldSchemas = other483.fieldSchemas;
  properties = other483.properties;
  __isset = other483.__isset;
}
Schema& Schema::operator=(const Schema& other484) {
  fieldSchemas = other484.fieldSchemas;
  properties = other484.properties;
  __isset = other484.__isset;
  return *this;
}
void Schema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Schema(";
  out << "fieldSchemas=" << to_string(fieldSchemas);
  out << ", " << "properties=" << to_string(properties);
  out << ")";
}


PrimaryKeysRequest::~PrimaryKeysRequest() noexcept {
}


void PrimaryKeysRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void PrimaryKeysRequest::__set_tbl_name(const std::string& val) {
  this->tbl_name = val;
}

void PrimaryKeysRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void PrimaryKeysRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void PrimaryKeysRequest::__set_tableId(const int64_t val) {
  this->tableId = val;
__isset.tableId = true;
}
std::ostream& operator<<(std::ostream& out, const PrimaryKeysRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PrimaryKeysRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db_name = false;
  bool isset_tbl_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbl_name);
          isset_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tbl_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PrimaryKeysRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PrimaryKeysRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tbl_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tbl_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableId) {
    xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->tableId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PrimaryKeysRequest &a, PrimaryKeysRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.tbl_name, b.tbl_name);
  swap(a.catName, b.catName);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.tableId, b.tableId);
  swap(a.__isset, b.__isset);
}

PrimaryKeysRequest::PrimaryKeysRequest(const PrimaryKeysRequest& other485) {
  db_name = other485.db_name;
  tbl_name = other485.tbl_name;
  catName = other485.catName;
  validWriteIdList = other485.validWriteIdList;
  tableId = other485.tableId;
  __isset = other485.__isset;
}
PrimaryKeysRequest& PrimaryKeysRequest::operator=(const PrimaryKeysRequest& other486) {
  db_name = other486.db_name;
  tbl_name = other486.tbl_name;
  catName = other486.catName;
  validWriteIdList = other486.validWriteIdList;
  tableId = other486.tableId;
  __isset = other486.__isset;
  return *this;
}
void PrimaryKeysRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PrimaryKeysRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "tbl_name=" << to_string(tbl_name);
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "tableId="; (__isset.tableId ? (out << to_string(tableId)) : (out << "<null>"));
  out << ")";
}


PrimaryKeysResponse::~PrimaryKeysResponse() noexcept {
}


void PrimaryKeysResponse::__set_primaryKeys(const std::vector<SQLPrimaryKey> & val) {
  this->primaryKeys = val;
}
std::ostream& operator<<(std::ostream& out, const PrimaryKeysResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PrimaryKeysResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_primaryKeys = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->primaryKeys.clear();
            uint32_t _size487;
            ::apache::thrift::protocol::TType _etype490;
            xfer += iprot->readListBegin(_etype490, _size487);
            this->primaryKeys.resize(_size487);
            uint32_t _i491;
            for (_i491 = 0; _i491 < _size487; ++_i491)
            {
              xfer += this->primaryKeys[_i491].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_primaryKeys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_primaryKeys)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PrimaryKeysResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PrimaryKeysResponse");

  xfer += oprot->writeFieldBegin("primaryKeys", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->primaryKeys.size()));
    std::vector<SQLPrimaryKey> ::const_iterator _iter492;
    for (_iter492 = this->primaryKeys.begin(); _iter492 != this->primaryKeys.end(); ++_iter492)
    {
      xfer += (*_iter492).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PrimaryKeysResponse &a, PrimaryKeysResponse &b) {
  using ::std::swap;
  swap(a.primaryKeys, b.primaryKeys);
}

PrimaryKeysResponse::PrimaryKeysResponse(const PrimaryKeysResponse& other493) {
  primaryKeys = other493.primaryKeys;
}
PrimaryKeysResponse& PrimaryKeysResponse::operator=(const PrimaryKeysResponse& other494) {
  primaryKeys = other494.primaryKeys;
  return *this;
}
void PrimaryKeysResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PrimaryKeysResponse(";
  out << "primaryKeys=" << to_string(primaryKeys);
  out << ")";
}


ForeignKeysRequest::~ForeignKeysRequest() noexcept {
}


void ForeignKeysRequest::__set_parent_db_name(const std::string& val) {
  this->parent_db_name = val;
}

void ForeignKeysRequest::__set_parent_tbl_name(const std::string& val) {
  this->parent_tbl_name = val;
}

void ForeignKeysRequest::__set_foreign_db_name(const std::string& val) {
  this->foreign_db_name = val;
}

void ForeignKeysRequest::__set_foreign_tbl_name(const std::string& val) {
  this->foreign_tbl_name = val;
}

void ForeignKeysRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void ForeignKeysRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void ForeignKeysRequest::__set_tableId(const int64_t val) {
  this->tableId = val;
__isset.tableId = true;
}
std::ostream& operator<<(std::ostream& out, const ForeignKeysRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ForeignKeysRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parent_db_name);
          this->__isset.parent_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parent_tbl_name);
          this->__isset.parent_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->foreign_db_name);
          this->__isset.foreign_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->foreign_tbl_name);
          this->__isset.foreign_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ForeignKeysRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ForeignKeysRequest");

  xfer += oprot->writeFieldBegin("parent_db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->parent_db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parent_tbl_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->parent_tbl_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("foreign_db_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->foreign_db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("foreign_tbl_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->foreign_tbl_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableId) {
    xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->tableId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ForeignKeysRequest &a, ForeignKeysRequest &b) {
  using ::std::swap;
  swap(a.parent_db_name, b.parent_db_name);
  swap(a.parent_tbl_name, b.parent_tbl_name);
  swap(a.foreign_db_name, b.foreign_db_name);
  swap(a.foreign_tbl_name, b.foreign_tbl_name);
  swap(a.catName, b.catName);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.tableId, b.tableId);
  swap(a.__isset, b.__isset);
}

ForeignKeysRequest::ForeignKeysRequest(const ForeignKeysRequest& other495) {
  parent_db_name = other495.parent_db_name;
  parent_tbl_name = other495.parent_tbl_name;
  foreign_db_name = other495.foreign_db_name;
  foreign_tbl_name = other495.foreign_tbl_name;
  catName = other495.catName;
  validWriteIdList = other495.validWriteIdList;
  tableId = other495.tableId;
  __isset = other495.__isset;
}
ForeignKeysRequest& ForeignKeysRequest::operator=(const ForeignKeysRequest& other496) {
  parent_db_name = other496.parent_db_name;
  parent_tbl_name = other496.parent_tbl_name;
  foreign_db_name = other496.foreign_db_name;
  foreign_tbl_name = other496.foreign_tbl_name;
  catName = other496.catName;
  validWriteIdList = other496.validWriteIdList;
  tableId = other496.tableId;
  __isset = other496.__isset;
  return *this;
}
void ForeignKeysRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ForeignKeysRequest(";
  out << "parent_db_name=" << to_string(parent_db_name);
  out << ", " << "parent_tbl_name=" << to_string(parent_tbl_name);
  out << ", " << "foreign_db_name=" << to_string(foreign_db_name);
  out << ", " << "foreign_tbl_name=" << to_string(foreign_tbl_name);
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "tableId="; (__isset.tableId ? (out << to_string(tableId)) : (out << "<null>"));
  out << ")";
}


ForeignKeysResponse::~ForeignKeysResponse() noexcept {
}


void ForeignKeysResponse::__set_foreignKeys(const std::vector<SQLForeignKey> & val) {
  this->foreignKeys = val;
}
std::ostream& operator<<(std::ostream& out, const ForeignKeysResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ForeignKeysResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_foreignKeys = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->foreignKeys.clear();
            uint32_t _size497;
            ::apache::thrift::protocol::TType _etype500;
            xfer += iprot->readListBegin(_etype500, _size497);
            this->foreignKeys.resize(_size497);
            uint32_t _i501;
            for (_i501 = 0; _i501 < _size497; ++_i501)
            {
              xfer += this->foreignKeys[_i501].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_foreignKeys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_foreignKeys)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ForeignKeysResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ForeignKeysResponse");

  xfer += oprot->writeFieldBegin("foreignKeys", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->foreignKeys.size()));
    std::vector<SQLForeignKey> ::const_iterator _iter502;
    for (_iter502 = this->foreignKeys.begin(); _iter502 != this->foreignKeys.end(); ++_iter502)
    {
      xfer += (*_iter502).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ForeignKeysResponse &a, ForeignKeysResponse &b) {
  using ::std::swap;
  swap(a.foreignKeys, b.foreignKeys);
}

ForeignKeysResponse::ForeignKeysResponse(const ForeignKeysResponse& other503) {
  foreignKeys = other503.foreignKeys;
}
ForeignKeysResponse& ForeignKeysResponse::operator=(const ForeignKeysResponse& other504) {
  foreignKeys = other504.foreignKeys;
  return *this;
}
void ForeignKeysResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ForeignKeysResponse(";
  out << "foreignKeys=" << to_string(foreignKeys);
  out << ")";
}


UniqueConstraintsRequest::~UniqueConstraintsRequest() noexcept {
}


void UniqueConstraintsRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void UniqueConstraintsRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void UniqueConstraintsRequest::__set_tbl_name(const std::string& val) {
  this->tbl_name = val;
}

void UniqueConstraintsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void UniqueConstraintsRequest::__set_tableId(const int64_t val) {
  this->tableId = val;
__isset.tableId = true;
}
std::ostream& operator<<(std::ostream& out, const UniqueConstraintsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UniqueConstraintsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catName = false;
  bool isset_db_name = false;
  bool isset_tbl_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbl_name);
          isset_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tbl_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UniqueConstraintsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UniqueConstraintsRequest");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tbl_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tbl_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableId) {
    xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->tableId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UniqueConstraintsRequest &a, UniqueConstraintsRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.db_name, b.db_name);
  swap(a.tbl_name, b.tbl_name);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.tableId, b.tableId);
  swap(a.__isset, b.__isset);
}

UniqueConstraintsRequest::UniqueConstraintsRequest(const UniqueConstraintsRequest& other505) {
  catName = other505.catName;
  db_name = other505.db_name;
  tbl_name = other505.tbl_name;
  validWriteIdList = other505.validWriteIdList;
  tableId = other505.tableId;
  __isset = other505.__isset;
}
UniqueConstraintsRequest& UniqueConstraintsRequest::operator=(const UniqueConstraintsRequest& other506) {
  catName = other506.catName;
  db_name = other506.db_name;
  tbl_name = other506.tbl_name;
  validWriteIdList = other506.validWriteIdList;
  tableId = other506.tableId;
  __isset = other506.__isset;
  return *this;
}
void UniqueConstraintsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UniqueConstraintsRequest(";
  out << "catName=" << to_string(catName);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "tbl_name=" << to_string(tbl_name);
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "tableId="; (__isset.tableId ? (out << to_string(tableId)) : (out << "<null>"));
  out << ")";
}


UniqueConstraintsResponse::~UniqueConstraintsResponse() noexcept {
}


void UniqueConstraintsResponse::__set_uniqueConstraints(const std::vector<SQLUniqueConstraint> & val) {
  this->uniqueConstraints = val;
}
std::ostream& operator<<(std::ostream& out, const UniqueConstraintsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UniqueConstraintsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_uniqueConstraints = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->uniqueConstraints.clear();
            uint32_t _size507;
            ::apache::thrift::protocol::TType _etype510;
            xfer += iprot->readListBegin(_etype510, _size507);
            this->uniqueConstraints.resize(_size507);
            uint32_t _i511;
            for (_i511 = 0; _i511 < _size507; ++_i511)
            {
              xfer += this->uniqueConstraints[_i511].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_uniqueConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_uniqueConstraints)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UniqueConstraintsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UniqueConstraintsResponse");

  xfer += oprot->writeFieldBegin("uniqueConstraints", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->uniqueConstraints.size()));
    std::vector<SQLUniqueConstraint> ::const_iterator _iter512;
    for (_iter512 = this->uniqueConstraints.begin(); _iter512 != this->uniqueConstraints.end(); ++_iter512)
    {
      xfer += (*_iter512).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UniqueConstraintsResponse &a, UniqueConstraintsResponse &b) {
  using ::std::swap;
  swap(a.uniqueConstraints, b.uniqueConstraints);
}

UniqueConstraintsResponse::UniqueConstraintsResponse(const UniqueConstraintsResponse& other513) {
  uniqueConstraints = other513.uniqueConstraints;
}
UniqueConstraintsResponse& UniqueConstraintsResponse::operator=(const UniqueConstraintsResponse& other514) {
  uniqueConstraints = other514.uniqueConstraints;
  return *this;
}
void UniqueConstraintsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UniqueConstraintsResponse(";
  out << "uniqueConstraints=" << to_string(uniqueConstraints);
  out << ")";
}


NotNullConstraintsRequest::~NotNullConstraintsRequest() noexcept {
}


void NotNullConstraintsRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void NotNullConstraintsRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void NotNullConstraintsRequest::__set_tbl_name(const std::string& val) {
  this->tbl_name = val;
}

void NotNullConstraintsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void NotNullConstraintsRequest::__set_tableId(const int64_t val) {
  this->tableId = val;
__isset.tableId = true;
}
std::ostream& operator<<(std::ostream& out, const NotNullConstraintsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotNullConstraintsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catName = false;
  bool isset_db_name = false;
  bool isset_tbl_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbl_name);
          isset_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tbl_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotNullConstraintsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotNullConstraintsRequest");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tbl_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tbl_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableId) {
    xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->tableId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotNullConstraintsRequest &a, NotNullConstraintsRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.db_name, b.db_name);
  swap(a.tbl_name, b.tbl_name);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.tableId, b.tableId);
  swap(a.__isset, b.__isset);
}

NotNullConstraintsRequest::NotNullConstraintsRequest(const NotNullConstraintsRequest& other515) {
  catName = other515.catName;
  db_name = other515.db_name;
  tbl_name = other515.tbl_name;
  validWriteIdList = other515.validWriteIdList;
  tableId = other515.tableId;
  __isset = other515.__isset;
}
NotNullConstraintsRequest& NotNullConstraintsRequest::operator=(const NotNullConstraintsRequest& other516) {
  catName = other516.catName;
  db_name = other516.db_name;
  tbl_name = other516.tbl_name;
  validWriteIdList = other516.validWriteIdList;
  tableId = other516.tableId;
  __isset = other516.__isset;
  return *this;
}
void NotNullConstraintsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotNullConstraintsRequest(";
  out << "catName=" << to_string(catName);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "tbl_name=" << to_string(tbl_name);
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "tableId="; (__isset.tableId ? (out << to_string(tableId)) : (out << "<null>"));
  out << ")";
}


NotNullConstraintsResponse::~NotNullConstraintsResponse() noexcept {
}


void NotNullConstraintsResponse::__set_notNullConstraints(const std::vector<SQLNotNullConstraint> & val) {
  this->notNullConstraints = val;
}
std::ostream& operator<<(std::ostream& out, const NotNullConstraintsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotNullConstraintsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_notNullConstraints = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->notNullConstraints.clear();
            uint32_t _size517;
            ::apache::thrift::protocol::TType _etype520;
            xfer += iprot->readListBegin(_etype520, _size517);
            this->notNullConstraints.resize(_size517);
            uint32_t _i521;
            for (_i521 = 0; _i521 < _size517; ++_i521)
            {
              xfer += this->notNullConstraints[_i521].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_notNullConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_notNullConstraints)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotNullConstraintsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotNullConstraintsResponse");

  xfer += oprot->writeFieldBegin("notNullConstraints", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->notNullConstraints.size()));
    std::vector<SQLNotNullConstraint> ::const_iterator _iter522;
    for (_iter522 = this->notNullConstraints.begin(); _iter522 != this->notNullConstraints.end(); ++_iter522)
    {
      xfer += (*_iter522).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotNullConstraintsResponse &a, NotNullConstraintsResponse &b) {
  using ::std::swap;
  swap(a.notNullConstraints, b.notNullConstraints);
}

NotNullConstraintsResponse::NotNullConstraintsResponse(const NotNullConstraintsResponse& other523) {
  notNullConstraints = other523.notNullConstraints;
}
NotNullConstraintsResponse& NotNullConstraintsResponse::operator=(const NotNullConstraintsResponse& other524) {
  notNullConstraints = other524.notNullConstraints;
  return *this;
}
void NotNullConstraintsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotNullConstraintsResponse(";
  out << "notNullConstraints=" << to_string(notNullConstraints);
  out << ")";
}


DefaultConstraintsRequest::~DefaultConstraintsRequest() noexcept {
}


void DefaultConstraintsRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void DefaultConstraintsRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void DefaultConstraintsRequest::__set_tbl_name(const std::string& val) {
  this->tbl_name = val;
}

void DefaultConstraintsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void DefaultConstraintsRequest::__set_tableId(const int64_t val) {
  this->tableId = val;
__isset.tableId = true;
}
std::ostream& operator<<(std::ostream& out, const DefaultConstraintsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DefaultConstraintsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catName = false;
  bool isset_db_name = false;
  bool isset_tbl_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbl_name);
          isset_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tbl_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DefaultConstraintsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DefaultConstraintsRequest");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tbl_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tbl_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableId) {
    xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->tableId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DefaultConstraintsRequest &a, DefaultConstraintsRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.db_name, b.db_name);
  swap(a.tbl_name, b.tbl_name);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.tableId, b.tableId);
  swap(a.__isset, b.__isset);
}

DefaultConstraintsRequest::DefaultConstraintsRequest(const DefaultConstraintsRequest& other525) {
  catName = other525.catName;
  db_name = other525.db_name;
  tbl_name = other525.tbl_name;
  validWriteIdList = other525.validWriteIdList;
  tableId = other525.tableId;
  __isset = other525.__isset;
}
DefaultConstraintsRequest& DefaultConstraintsRequest::operator=(const DefaultConstraintsRequest& other526) {
  catName = other526.catName;
  db_name = other526.db_name;
  tbl_name = other526.tbl_name;
  validWriteIdList = other526.validWriteIdList;
  tableId = other526.tableId;
  __isset = other526.__isset;
  return *this;
}
void DefaultConstraintsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DefaultConstraintsRequest(";
  out << "catName=" << to_string(catName);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "tbl_name=" << to_string(tbl_name);
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "tableId="; (__isset.tableId ? (out << to_string(tableId)) : (out << "<null>"));
  out << ")";
}


DefaultConstraintsResponse::~DefaultConstraintsResponse() noexcept {
}


void DefaultConstraintsResponse::__set_defaultConstraints(const std::vector<SQLDefaultConstraint> & val) {
  this->defaultConstraints = val;
}
std::ostream& operator<<(std::ostream& out, const DefaultConstraintsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DefaultConstraintsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_defaultConstraints = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->defaultConstraints.clear();
            uint32_t _size527;
            ::apache::thrift::protocol::TType _etype530;
            xfer += iprot->readListBegin(_etype530, _size527);
            this->defaultConstraints.resize(_size527);
            uint32_t _i531;
            for (_i531 = 0; _i531 < _size527; ++_i531)
            {
              xfer += this->defaultConstraints[_i531].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_defaultConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_defaultConstraints)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DefaultConstraintsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DefaultConstraintsResponse");

  xfer += oprot->writeFieldBegin("defaultConstraints", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->defaultConstraints.size()));
    std::vector<SQLDefaultConstraint> ::const_iterator _iter532;
    for (_iter532 = this->defaultConstraints.begin(); _iter532 != this->defaultConstraints.end(); ++_iter532)
    {
      xfer += (*_iter532).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DefaultConstraintsResponse &a, DefaultConstraintsResponse &b) {
  using ::std::swap;
  swap(a.defaultConstraints, b.defaultConstraints);
}

DefaultConstraintsResponse::DefaultConstraintsResponse(const DefaultConstraintsResponse& other533) {
  defaultConstraints = other533.defaultConstraints;
}
DefaultConstraintsResponse& DefaultConstraintsResponse::operator=(const DefaultConstraintsResponse& other534) {
  defaultConstraints = other534.defaultConstraints;
  return *this;
}
void DefaultConstraintsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DefaultConstraintsResponse(";
  out << "defaultConstraints=" << to_string(defaultConstraints);
  out << ")";
}


CheckConstraintsRequest::~CheckConstraintsRequest() noexcept {
}


void CheckConstraintsRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void CheckConstraintsRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void CheckConstraintsRequest::__set_tbl_name(const std::string& val) {
  this->tbl_name = val;
}

void CheckConstraintsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void CheckConstraintsRequest::__set_tableId(const int64_t val) {
  this->tableId = val;
__isset.tableId = true;
}
std::ostream& operator<<(std::ostream& out, const CheckConstraintsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CheckConstraintsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catName = false;
  bool isset_db_name = false;
  bool isset_tbl_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbl_name);
          isset_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tbl_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CheckConstraintsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CheckConstraintsRequest");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tbl_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tbl_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableId) {
    xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->tableId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CheckConstraintsRequest &a, CheckConstraintsRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.db_name, b.db_name);
  swap(a.tbl_name, b.tbl_name);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.tableId, b.tableId);
  swap(a.__isset, b.__isset);
}

CheckConstraintsRequest::CheckConstraintsRequest(const CheckConstraintsRequest& other535) {
  catName = other535.catName;
  db_name = other535.db_name;
  tbl_name = other535.tbl_name;
  validWriteIdList = other535.validWriteIdList;
  tableId = other535.tableId;
  __isset = other535.__isset;
}
CheckConstraintsRequest& CheckConstraintsRequest::operator=(const CheckConstraintsRequest& other536) {
  catName = other536.catName;
  db_name = other536.db_name;
  tbl_name = other536.tbl_name;
  validWriteIdList = other536.validWriteIdList;
  tableId = other536.tableId;
  __isset = other536.__isset;
  return *this;
}
void CheckConstraintsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CheckConstraintsRequest(";
  out << "catName=" << to_string(catName);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "tbl_name=" << to_string(tbl_name);
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "tableId="; (__isset.tableId ? (out << to_string(tableId)) : (out << "<null>"));
  out << ")";
}


CheckConstraintsResponse::~CheckConstraintsResponse() noexcept {
}


void CheckConstraintsResponse::__set_checkConstraints(const std::vector<SQLCheckConstraint> & val) {
  this->checkConstraints = val;
}
std::ostream& operator<<(std::ostream& out, const CheckConstraintsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CheckConstraintsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_checkConstraints = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->checkConstraints.clear();
            uint32_t _size537;
            ::apache::thrift::protocol::TType _etype540;
            xfer += iprot->readListBegin(_etype540, _size537);
            this->checkConstraints.resize(_size537);
            uint32_t _i541;
            for (_i541 = 0; _i541 < _size537; ++_i541)
            {
              xfer += this->checkConstraints[_i541].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_checkConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_checkConstraints)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CheckConstraintsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CheckConstraintsResponse");

  xfer += oprot->writeFieldBegin("checkConstraints", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->checkConstraints.size()));
    std::vector<SQLCheckConstraint> ::const_iterator _iter542;
    for (_iter542 = this->checkConstraints.begin(); _iter542 != this->checkConstraints.end(); ++_iter542)
    {
      xfer += (*_iter542).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CheckConstraintsResponse &a, CheckConstraintsResponse &b) {
  using ::std::swap;
  swap(a.checkConstraints, b.checkConstraints);
}

CheckConstraintsResponse::CheckConstraintsResponse(const CheckConstraintsResponse& other543) {
  checkConstraints = other543.checkConstraints;
}
CheckConstraintsResponse& CheckConstraintsResponse::operator=(const CheckConstraintsResponse& other544) {
  checkConstraints = other544.checkConstraints;
  return *this;
}
void CheckConstraintsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CheckConstraintsResponse(";
  out << "checkConstraints=" << to_string(checkConstraints);
  out << ")";
}


AllTableConstraintsRequest::~AllTableConstraintsRequest() noexcept {
}


void AllTableConstraintsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void AllTableConstraintsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void AllTableConstraintsRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void AllTableConstraintsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void AllTableConstraintsRequest::__set_tableId(const int64_t val) {
  this->tableId = val;
__isset.tableId = true;
}
std::ostream& operator<<(std::ostream& out, const AllTableConstraintsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AllTableConstraintsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_catName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AllTableConstraintsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AllTableConstraintsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableId) {
    xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->tableId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AllTableConstraintsRequest &a, AllTableConstraintsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.catName, b.catName);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.tableId, b.tableId);
  swap(a.__isset, b.__isset);
}

AllTableConstraintsRequest::AllTableConstraintsRequest(const AllTableConstraintsRequest& other545) {
  dbName = other545.dbName;
  tblName = other545.tblName;
  catName = other545.catName;
  validWriteIdList = other545.validWriteIdList;
  tableId = other545.tableId;
  __isset = other545.__isset;
}
AllTableConstraintsRequest& AllTableConstraintsRequest::operator=(const AllTableConstraintsRequest& other546) {
  dbName = other546.dbName;
  tblName = other546.tblName;
  catName = other546.catName;
  validWriteIdList = other546.validWriteIdList;
  tableId = other546.tableId;
  __isset = other546.__isset;
  return *this;
}
void AllTableConstraintsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AllTableConstraintsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "catName=" << to_string(catName);
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "tableId="; (__isset.tableId ? (out << to_string(tableId)) : (out << "<null>"));
  out << ")";
}


AllTableConstraintsResponse::~AllTableConstraintsResponse() noexcept {
}


void AllTableConstraintsResponse::__set_allTableConstraints(const SQLAllTableConstraints& val) {
  this->allTableConstraints = val;
}
std::ostream& operator<<(std::ostream& out, const AllTableConstraintsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AllTableConstraintsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_allTableConstraints = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->allTableConstraints.read(iprot);
          isset_allTableConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_allTableConstraints)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AllTableConstraintsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AllTableConstraintsResponse");

  xfer += oprot->writeFieldBegin("allTableConstraints", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->allTableConstraints.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AllTableConstraintsResponse &a, AllTableConstraintsResponse &b) {
  using ::std::swap;
  swap(a.allTableConstraints, b.allTableConstraints);
}

AllTableConstraintsResponse::AllTableConstraintsResponse(const AllTableConstraintsResponse& other547) {
  allTableConstraints = other547.allTableConstraints;
}
AllTableConstraintsResponse& AllTableConstraintsResponse::operator=(const AllTableConstraintsResponse& other548) {
  allTableConstraints = other548.allTableConstraints;
  return *this;
}
void AllTableConstraintsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AllTableConstraintsResponse(";
  out << "allTableConstraints=" << to_string(allTableConstraints);
  out << ")";
}


DropConstraintRequest::~DropConstraintRequest() noexcept {
}


void DropConstraintRequest::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void DropConstraintRequest::__set_tablename(const std::string& val) {
  this->tablename = val;
}

void DropConstraintRequest::__set_constraintname(const std::string& val) {
  this->constraintname = val;
}

void DropConstraintRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}
std::ostream& operator<<(std::ostream& out, const DropConstraintRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropConstraintRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbname = false;
  bool isset_tablename = false;
  bool isset_constraintname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          isset_tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->constraintname);
          isset_constraintname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_constraintname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DropConstraintRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropConstraintRequest");

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("constraintname", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->constraintname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropConstraintRequest &a, DropConstraintRequest &b) {
  using ::std::swap;
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.constraintname, b.constraintname);
  swap(a.catName, b.catName);
  swap(a.__isset, b.__isset);
}

DropConstraintRequest::DropConstraintRequest(const DropConstraintRequest& other549) {
  dbname = other549.dbname;
  tablename = other549.tablename;
  constraintname = other549.constraintname;
  catName = other549.catName;
  __isset = other549.__isset;
}
DropConstraintRequest& DropConstraintRequest::operator=(const DropConstraintRequest& other550) {
  dbname = other550.dbname;
  tablename = other550.tablename;
  constraintname = other550.constraintname;
  catName = other550.catName;
  __isset = other550.__isset;
  return *this;
}
void DropConstraintRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropConstraintRequest(";
  out << "dbname=" << to_string(dbname);
  out << ", " << "tablename=" << to_string(tablename);
  out << ", " << "constraintname=" << to_string(constraintname);
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ")";
}


AddPrimaryKeyRequest::~AddPrimaryKeyRequest() noexcept {
}


void AddPrimaryKeyRequest::__set_primaryKeyCols(const std::vector<SQLPrimaryKey> & val) {
  this->primaryKeyCols = val;
}
std::ostream& operator<<(std::ostream& out, const AddPrimaryKeyRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddPrimaryKeyRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_primaryKeyCols = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->primaryKeyCols.clear();
            uint32_t _size551;
            ::apache::thrift::protocol::TType _etype554;
            xfer += iprot->readListBegin(_etype554, _size551);
            this->primaryKeyCols.resize(_size551);
            uint32_t _i555;
            for (_i555 = 0; _i555 < _size551; ++_i555)
            {
              xfer += this->primaryKeyCols[_i555].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_primaryKeyCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_primaryKeyCols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddPrimaryKeyRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddPrimaryKeyRequest");

  xfer += oprot->writeFieldBegin("primaryKeyCols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->primaryKeyCols.size()));
    std::vector<SQLPrimaryKey> ::const_iterator _iter556;
    for (_iter556 = this->primaryKeyCols.begin(); _iter556 != this->primaryKeyCols.end(); ++_iter556)
    {
      xfer += (*_iter556).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddPrimaryKeyRequest &a, AddPrimaryKeyRequest &b) {
  using ::std::swap;
  swap(a.primaryKeyCols, b.primaryKeyCols);
}

AddPrimaryKeyRequest::AddPrimaryKeyRequest(const AddPrimaryKeyRequest& other557) {
  primaryKeyCols = other557.primaryKeyCols;
}
AddPrimaryKeyRequest& AddPrimaryKeyRequest::operator=(const AddPrimaryKeyRequest& other558) {
  primaryKeyCols = other558.primaryKeyCols;
  return *this;
}
void AddPrimaryKeyRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddPrimaryKeyRequest(";
  out << "primaryKeyCols=" << to_string(primaryKeyCols);
  out << ")";
}


AddForeignKeyRequest::~AddForeignKeyRequest() noexcept {
}


void AddForeignKeyRequest::__set_foreignKeyCols(const std::vector<SQLForeignKey> & val) {
  this->foreignKeyCols = val;
}
std::ostream& operator<<(std::ostream& out, const AddForeignKeyRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddForeignKeyRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_foreignKeyCols = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->foreignKeyCols.clear();
            uint32_t _size559;
            ::apache::thrift::protocol::TType _etype562;
            xfer += iprot->readListBegin(_etype562, _size559);
            this->foreignKeyCols.resize(_size559);
            uint32_t _i563;
            for (_i563 = 0; _i563 < _size559; ++_i563)
            {
              xfer += this->foreignKeyCols[_i563].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_foreignKeyCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_foreignKeyCols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddForeignKeyRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddForeignKeyRequest");

  xfer += oprot->writeFieldBegin("foreignKeyCols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->foreignKeyCols.size()));
    std::vector<SQLForeignKey> ::const_iterator _iter564;
    for (_iter564 = this->foreignKeyCols.begin(); _iter564 != this->foreignKeyCols.end(); ++_iter564)
    {
      xfer += (*_iter564).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddForeignKeyRequest &a, AddForeignKeyRequest &b) {
  using ::std::swap;
  swap(a.foreignKeyCols, b.foreignKeyCols);
}

AddForeignKeyRequest::AddForeignKeyRequest(const AddForeignKeyRequest& other565) {
  foreignKeyCols = other565.foreignKeyCols;
}
AddForeignKeyRequest& AddForeignKeyRequest::operator=(const AddForeignKeyRequest& other566) {
  foreignKeyCols = other566.foreignKeyCols;
  return *this;
}
void AddForeignKeyRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddForeignKeyRequest(";
  out << "foreignKeyCols=" << to_string(foreignKeyCols);
  out << ")";
}


AddUniqueConstraintRequest::~AddUniqueConstraintRequest() noexcept {
}


void AddUniqueConstraintRequest::__set_uniqueConstraintCols(const std::vector<SQLUniqueConstraint> & val) {
  this->uniqueConstraintCols = val;
}
std::ostream& operator<<(std::ostream& out, const AddUniqueConstraintRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddUniqueConstraintRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_uniqueConstraintCols = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->uniqueConstraintCols.clear();
            uint32_t _size567;
            ::apache::thrift::protocol::TType _etype570;
            xfer += iprot->readListBegin(_etype570, _size567);
            this->uniqueConstraintCols.resize(_size567);
            uint32_t _i571;
            for (_i571 = 0; _i571 < _size567; ++_i571)
            {
              xfer += this->uniqueConstraintCols[_i571].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_uniqueConstraintCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_uniqueConstraintCols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddUniqueConstraintRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddUniqueConstraintRequest");

  xfer += oprot->writeFieldBegin("uniqueConstraintCols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->uniqueConstraintCols.size()));
    std::vector<SQLUniqueConstraint> ::const_iterator _iter572;
    for (_iter572 = this->uniqueConstraintCols.begin(); _iter572 != this->uniqueConstraintCols.end(); ++_iter572)
    {
      xfer += (*_iter572).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddUniqueConstraintRequest &a, AddUniqueConstraintRequest &b) {
  using ::std::swap;
  swap(a.uniqueConstraintCols, b.uniqueConstraintCols);
}

AddUniqueConstraintRequest::AddUniqueConstraintRequest(const AddUniqueConstraintRequest& other573) {
  uniqueConstraintCols = other573.uniqueConstraintCols;
}
AddUniqueConstraintRequest& AddUniqueConstraintRequest::operator=(const AddUniqueConstraintRequest& other574) {
  uniqueConstraintCols = other574.uniqueConstraintCols;
  return *this;
}
void AddUniqueConstraintRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddUniqueConstraintRequest(";
  out << "uniqueConstraintCols=" << to_string(uniqueConstraintCols);
  out << ")";
}


AddNotNullConstraintRequest::~AddNotNullConstraintRequest() noexcept {
}


void AddNotNullConstraintRequest::__set_notNullConstraintCols(const std::vector<SQLNotNullConstraint> & val) {
  this->notNullConstraintCols = val;
}
std::ostream& operator<<(std::ostream& out, const AddNotNullConstraintRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddNotNullConstraintRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_notNullConstraintCols = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->notNullConstraintCols.clear();
            uint32_t _size575;
            ::apache::thrift::protocol::TType _etype578;
            xfer += iprot->readListBegin(_etype578, _size575);
            this->notNullConstraintCols.resize(_size575);
            uint32_t _i579;
            for (_i579 = 0; _i579 < _size575; ++_i579)
            {
              xfer += this->notNullConstraintCols[_i579].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_notNullConstraintCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_notNullConstraintCols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddNotNullConstraintRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddNotNullConstraintRequest");

  xfer += oprot->writeFieldBegin("notNullConstraintCols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->notNullConstraintCols.size()));
    std::vector<SQLNotNullConstraint> ::const_iterator _iter580;
    for (_iter580 = this->notNullConstraintCols.begin(); _iter580 != this->notNullConstraintCols.end(); ++_iter580)
    {
      xfer += (*_iter580).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddNotNullConstraintRequest &a, AddNotNullConstraintRequest &b) {
  using ::std::swap;
  swap(a.notNullConstraintCols, b.notNullConstraintCols);
}

AddNotNullConstraintRequest::AddNotNullConstraintRequest(const AddNotNullConstraintRequest& other581) {
  notNullConstraintCols = other581.notNullConstraintCols;
}
AddNotNullConstraintRequest& AddNotNullConstraintRequest::operator=(const AddNotNullConstraintRequest& other582) {
  notNullConstraintCols = other582.notNullConstraintCols;
  return *this;
}
void AddNotNullConstraintRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddNotNullConstraintRequest(";
  out << "notNullConstraintCols=" << to_string(notNullConstraintCols);
  out << ")";
}


AddDefaultConstraintRequest::~AddDefaultConstraintRequest() noexcept {
}


void AddDefaultConstraintRequest::__set_defaultConstraintCols(const std::vector<SQLDefaultConstraint> & val) {
  this->defaultConstraintCols = val;
}
std::ostream& operator<<(std::ostream& out, const AddDefaultConstraintRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddDefaultConstraintRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_defaultConstraintCols = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->defaultConstraintCols.clear();
            uint32_t _size583;
            ::apache::thrift::protocol::TType _etype586;
            xfer += iprot->readListBegin(_etype586, _size583);
            this->defaultConstraintCols.resize(_size583);
            uint32_t _i587;
            for (_i587 = 0; _i587 < _size583; ++_i587)
            {
              xfer += this->defaultConstraintCols[_i587].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_defaultConstraintCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_defaultConstraintCols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddDefaultConstraintRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddDefaultConstraintRequest");

  xfer += oprot->writeFieldBegin("defaultConstraintCols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->defaultConstraintCols.size()));
    std::vector<SQLDefaultConstraint> ::const_iterator _iter588;
    for (_iter588 = this->defaultConstraintCols.begin(); _iter588 != this->defaultConstraintCols.end(); ++_iter588)
    {
      xfer += (*_iter588).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddDefaultConstraintRequest &a, AddDefaultConstraintRequest &b) {
  using ::std::swap;
  swap(a.defaultConstraintCols, b.defaultConstraintCols);
}

AddDefaultConstraintRequest::AddDefaultConstraintRequest(const AddDefaultConstraintRequest& other589) {
  defaultConstraintCols = other589.defaultConstraintCols;
}
AddDefaultConstraintRequest& AddDefaultConstraintRequest::operator=(const AddDefaultConstraintRequest& other590) {
  defaultConstraintCols = other590.defaultConstraintCols;
  return *this;
}
void AddDefaultConstraintRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddDefaultConstraintRequest(";
  out << "defaultConstraintCols=" << to_string(defaultConstraintCols);
  out << ")";
}


AddCheckConstraintRequest::~AddCheckConstraintRequest() noexcept {
}


void AddCheckConstraintRequest::__set_checkConstraintCols(const std::vector<SQLCheckConstraint> & val) {
  this->checkConstraintCols = val;
}
std::ostream& operator<<(std::ostream& out, const AddCheckConstraintRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddCheckConstraintRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_checkConstraintCols = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->checkConstraintCols.clear();
            uint32_t _size591;
            ::apache::thrift::protocol::TType _etype594;
            xfer += iprot->readListBegin(_etype594, _size591);
            this->checkConstraintCols.resize(_size591);
            uint32_t _i595;
            for (_i595 = 0; _i595 < _size591; ++_i595)
            {
              xfer += this->checkConstraintCols[_i595].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_checkConstraintCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_checkConstraintCols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddCheckConstraintRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddCheckConstraintRequest");

  xfer += oprot->writeFieldBegin("checkConstraintCols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->checkConstraintCols.size()));
    std::vector<SQLCheckConstraint> ::const_iterator _iter596;
    for (_iter596 = this->checkConstraintCols.begin(); _iter596 != this->checkConstraintCols.end(); ++_iter596)
    {
      xfer += (*_iter596).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddCheckConstraintRequest &a, AddCheckConstraintRequest &b) {
  using ::std::swap;
  swap(a.checkConstraintCols, b.checkConstraintCols);
}

AddCheckConstraintRequest::AddCheckConstraintRequest(const AddCheckConstraintRequest& other597) {
  checkConstraintCols = other597.checkConstraintCols;
}
AddCheckConstraintRequest& AddCheckConstraintRequest::operator=(const AddCheckConstraintRequest& other598) {
  checkConstraintCols = other598.checkConstraintCols;
  return *this;
}
void AddCheckConstraintRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddCheckConstraintRequest(";
  out << "checkConstraintCols=" << to_string(checkConstraintCols);
  out << ")";
}


PartitionsByExprResult::~PartitionsByExprResult() noexcept {
}


void PartitionsByExprResult::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
}

void PartitionsByExprResult::__set_hasUnknownPartitions(const bool val) {
  this->hasUnknownPartitions = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionsByExprResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionsByExprResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partitions = false;
  bool isset_hasUnknownPartitions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size599;
            ::apache::thrift::protocol::TType _etype602;
            xfer += iprot->readListBegin(_etype602, _size599);
            this->partitions.resize(_size599);
            uint32_t _i603;
            for (_i603 = 0; _i603 < _size599; ++_i603)
            {
              xfer += this->partitions[_i603].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasUnknownPartitions);
          isset_hasUnknownPartitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hasUnknownPartitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsByExprResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsByExprResult");

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<Partition> ::const_iterator _iter604;
    for (_iter604 = this->partitions.begin(); _iter604 != this->partitions.end(); ++_iter604)
    {
      xfer += (*_iter604).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hasUnknownPartitions", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->hasUnknownPartitions);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsByExprResult &a, PartitionsByExprResult &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.hasUnknownPartitions, b.hasUnknownPartitions);
}

PartitionsByExprResult::PartitionsByExprResult(const PartitionsByExprResult& other605) {
  partitions = other605.partitions;
  hasUnknownPartitions = other605.hasUnknownPartitions;
}
PartitionsByExprResult& PartitionsByExprResult::operator=(const PartitionsByExprResult& other606) {
  partitions = other606.partitions;
  hasUnknownPartitions = other606.hasUnknownPartitions;
  return *this;
}
void PartitionsByExprResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsByExprResult(";
  out << "partitions=" << to_string(partitions);
  out << ", " << "hasUnknownPartitions=" << to_string(hasUnknownPartitions);
  out << ")";
}


PartitionsSpecByExprResult::~PartitionsSpecByExprResult() noexcept {
}


void PartitionsSpecByExprResult::__set_partitionsSpec(const std::vector<PartitionSpec> & val) {
  this->partitionsSpec = val;
}

void PartitionsSpecByExprResult::__set_hasUnknownPartitions(const bool val) {
  this->hasUnknownPartitions = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionsSpecByExprResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionsSpecByExprResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partitionsSpec = false;
  bool isset_hasUnknownPartitions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionsSpec.clear();
            uint32_t _size607;
            ::apache::thrift::protocol::TType _etype610;
            xfer += iprot->readListBegin(_etype610, _size607);
            this->partitionsSpec.resize(_size607);
            uint32_t _i611;
            for (_i611 = 0; _i611 < _size607; ++_i611)
            {
              xfer += this->partitionsSpec[_i611].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitionsSpec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasUnknownPartitions);
          isset_hasUnknownPartitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partitionsSpec)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hasUnknownPartitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsSpecByExprResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsSpecByExprResult");

  xfer += oprot->writeFieldBegin("partitionsSpec", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitionsSpec.size()));
    std::vector<PartitionSpec> ::const_iterator _iter612;
    for (_iter612 = this->partitionsSpec.begin(); _iter612 != this->partitionsSpec.end(); ++_iter612)
    {
      xfer += (*_iter612).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hasUnknownPartitions", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->hasUnknownPartitions);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsSpecByExprResult &a, PartitionsSpecByExprResult &b) {
  using ::std::swap;
  swap(a.partitionsSpec, b.partitionsSpec);
  swap(a.hasUnknownPartitions, b.hasUnknownPartitions);
}

PartitionsSpecByExprResult::PartitionsSpecByExprResult(const PartitionsSpecByExprResult& other613) {
  partitionsSpec = other613.partitionsSpec;
  hasUnknownPartitions = other613.hasUnknownPartitions;
}
PartitionsSpecByExprResult& PartitionsSpecByExprResult::operator=(const PartitionsSpecByExprResult& other614) {
  partitionsSpec = other614.partitionsSpec;
  hasUnknownPartitions = other614.hasUnknownPartitions;
  return *this;
}
void PartitionsSpecByExprResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsSpecByExprResult(";
  out << "partitionsSpec=" << to_string(partitionsSpec);
  out << ", " << "hasUnknownPartitions=" << to_string(hasUnknownPartitions);
  out << ")";
}


PartitionsByExprRequest::~PartitionsByExprRequest() noexcept {
}


void PartitionsByExprRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void PartitionsByExprRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void PartitionsByExprRequest::__set_expr(const std::string& val) {
  this->expr = val;
}

void PartitionsByExprRequest::__set_defaultPartitionName(const std::string& val) {
  this->defaultPartitionName = val;
__isset.defaultPartitionName = true;
}

void PartitionsByExprRequest::__set_maxParts(const int16_t val) {
  this->maxParts = val;
__isset.maxParts = true;
}

void PartitionsByExprRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void PartitionsByExprRequest::__set_order(const std::string& val) {
  this->order = val;
__isset.order = true;
}

void PartitionsByExprRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void PartitionsByExprRequest::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}
std::ostream& operator<<(std::ostream& out, const PartitionsByExprRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionsByExprRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_expr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->expr);
          isset_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->defaultPartitionName);
          this->__isset.defaultPartitionName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->maxParts);
          this->__isset.maxParts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->order);
          this->__isset.order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_expr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsByExprRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsByExprRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expr", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->expr);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.defaultPartitionName) {
    xfer += oprot->writeFieldBegin("defaultPartitionName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->defaultPartitionName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxParts) {
    xfer += oprot->writeFieldBegin("maxParts", ::apache::thrift::protocol::T_I16, 5);
    xfer += oprot->writeI16(this->maxParts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.order) {
    xfer += oprot->writeFieldBegin("order", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->order);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsByExprRequest &a, PartitionsByExprRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.expr, b.expr);
  swap(a.defaultPartitionName, b.defaultPartitionName);
  swap(a.maxParts, b.maxParts);
  swap(a.catName, b.catName);
  swap(a.order, b.order);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

PartitionsByExprRequest::PartitionsByExprRequest(const PartitionsByExprRequest& other615) {
  dbName = other615.dbName;
  tblName = other615.tblName;
  expr = other615.expr;
  defaultPartitionName = other615.defaultPartitionName;
  maxParts = other615.maxParts;
  catName = other615.catName;
  order = other615.order;
  validWriteIdList = other615.validWriteIdList;
  id = other615.id;
  __isset = other615.__isset;
}
PartitionsByExprRequest& PartitionsByExprRequest::operator=(const PartitionsByExprRequest& other616) {
  dbName = other616.dbName;
  tblName = other616.tblName;
  expr = other616.expr;
  defaultPartitionName = other616.defaultPartitionName;
  maxParts = other616.maxParts;
  catName = other616.catName;
  order = other616.order;
  validWriteIdList = other616.validWriteIdList;
  id = other616.id;
  __isset = other616.__isset;
  return *this;
}
void PartitionsByExprRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsByExprRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "expr=" << to_string(expr);
  out << ", " << "defaultPartitionName="; (__isset.defaultPartitionName ? (out << to_string(defaultPartitionName)) : (out << "<null>"));
  out << ", " << "maxParts="; (__isset.maxParts ? (out << to_string(maxParts)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "order="; (__isset.order ? (out << to_string(order)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


TableStatsResult::~TableStatsResult() noexcept {
}


void TableStatsResult::__set_tableStats(const std::vector<ColumnStatisticsObj> & val) {
  this->tableStats = val;
}

void TableStatsResult::__set_isStatsCompliant(const bool val) {
  this->isStatsCompliant = val;
__isset.isStatsCompliant = true;
}
std::ostream& operator<<(std::ostream& out, const TableStatsResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TableStatsResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tableStats = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tableStats.clear();
            uint32_t _size617;
            ::apache::thrift::protocol::TType _etype620;
            xfer += iprot->readListBegin(_etype620, _size617);
            this->tableStats.resize(_size617);
            uint32_t _i621;
            for (_i621 = 0; _i621 < _size617; ++_i621)
            {
              xfer += this->tableStats[_i621].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_tableStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isStatsCompliant);
          this->__isset.isStatsCompliant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tableStats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TableStatsResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TableStatsResult");

  xfer += oprot->writeFieldBegin("tableStats", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tableStats.size()));
    std::vector<ColumnStatisticsObj> ::const_iterator _iter622;
    for (_iter622 = this->tableStats.begin(); _iter622 != this->tableStats.end(); ++_iter622)
    {
      xfer += (*_iter622).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.isStatsCompliant) {
    xfer += oprot->writeFieldBegin("isStatsCompliant", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->isStatsCompliant);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableStatsResult &a, TableStatsResult &b) {
  using ::std::swap;
  swap(a.tableStats, b.tableStats);
  swap(a.isStatsCompliant, b.isStatsCompliant);
  swap(a.__isset, b.__isset);
}

TableStatsResult::TableStatsResult(const TableStatsResult& other623) {
  tableStats = other623.tableStats;
  isStatsCompliant = other623.isStatsCompliant;
  __isset = other623.__isset;
}
TableStatsResult& TableStatsResult::operator=(const TableStatsResult& other624) {
  tableStats = other624.tableStats;
  isStatsCompliant = other624.isStatsCompliant;
  __isset = other624.__isset;
  return *this;
}
void TableStatsResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TableStatsResult(";
  out << "tableStats=" << to_string(tableStats);
  out << ", " << "isStatsCompliant="; (__isset.isStatsCompliant ? (out << to_string(isStatsCompliant)) : (out << "<null>"));
  out << ")";
}


PartitionsStatsResult::~PartitionsStatsResult() noexcept {
}


void PartitionsStatsResult::__set_partStats(const std::map<std::string, std::vector<ColumnStatisticsObj> > & val) {
  this->partStats = val;
}

void PartitionsStatsResult::__set_isStatsCompliant(const bool val) {
  this->isStatsCompliant = val;
__isset.isStatsCompliant = true;
}
std::ostream& operator<<(std::ostream& out, const PartitionsStatsResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionsStatsResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partStats = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->partStats.clear();
            uint32_t _size625;
            ::apache::thrift::protocol::TType _ktype626;
            ::apache::thrift::protocol::TType _vtype627;
            xfer += iprot->readMapBegin(_ktype626, _vtype627, _size625);
            uint32_t _i629;
            for (_i629 = 0; _i629 < _size625; ++_i629)
            {
              std::string _key630;
              xfer += iprot->readString(_key630);
              std::vector<ColumnStatisticsObj> & _val631 = this->partStats[_key630];
              {
                _val631.clear();
                uint32_t _size632;
                ::apache::thrift::protocol::TType _etype635;
                xfer += iprot->readListBegin(_etype635, _size632);
                _val631.resize(_size632);
                uint32_t _i636;
                for (_i636 = 0; _i636 < _size632; ++_i636)
                {
                  xfer += _val631[_i636].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_partStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isStatsCompliant);
          this->__isset.isStatsCompliant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partStats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsStatsResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsStatsResult");

  xfer += oprot->writeFieldBegin("partStats", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->partStats.size()));
    std::map<std::string, std::vector<ColumnStatisticsObj> > ::const_iterator _iter637;
    for (_iter637 = this->partStats.begin(); _iter637 != this->partStats.end(); ++_iter637)
    {
      xfer += oprot->writeString(_iter637->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter637->second.size()));
        std::vector<ColumnStatisticsObj> ::const_iterator _iter638;
        for (_iter638 = _iter637->second.begin(); _iter638 != _iter637->second.end(); ++_iter638)
        {
          xfer += (*_iter638).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.isStatsCompliant) {
    xfer += oprot->writeFieldBegin("isStatsCompliant", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->isStatsCompliant);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsStatsResult &a, PartitionsStatsResult &b) {
  using ::std::swap;
  swap(a.partStats, b.partStats);
  swap(a.isStatsCompliant, b.isStatsCompliant);
  swap(a.__isset, b.__isset);
}

PartitionsStatsResult::PartitionsStatsResult(const PartitionsStatsResult& other639) {
  partStats = other639.partStats;
  isStatsCompliant = other639.isStatsCompliant;
  __isset = other639.__isset;
}
PartitionsStatsResult& PartitionsStatsResult::operator=(const PartitionsStatsResult& other640) {
  partStats = other640.partStats;
  isStatsCompliant = other640.isStatsCompliant;
  __isset = other640.__isset;
  return *this;
}
void PartitionsStatsResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsStatsResult(";
  out << "partStats=" << to_string(partStats);
  out << ", " << "isStatsCompliant="; (__isset.isStatsCompliant ? (out << to_string(isStatsCompliant)) : (out << "<null>"));
  out << ")";
}


TableStatsRequest::~TableStatsRequest() noexcept {
}


void TableStatsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void TableStatsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void TableStatsRequest::__set_colNames(const std::vector<std::string> & val) {
  this->colNames = val;
}

void TableStatsRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void TableStatsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void TableStatsRequest::__set_engine(const std::string& val) {
  this->engine = val;
}

void TableStatsRequest::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}
std::ostream& operator<<(std::ostream& out, const TableStatsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TableStatsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_colNames = false;
  bool isset_engine = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colNames.clear();
            uint32_t _size641;
            ::apache::thrift::protocol::TType _etype644;
            xfer += iprot->readListBegin(_etype644, _size641);
            this->colNames.resize(_size641);
            uint32_t _i645;
            for (_i645 = 0; _i645 < _size641; ++_i645)
            {
              xfer += iprot->readString(this->colNames[_i645]);
            }
            xfer += iprot->readListEnd();
          }
          isset_colNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->engine);
          isset_engine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_colNames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_engine)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TableStatsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TableStatsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colNames", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->colNames.size()));
    std::vector<std::string> ::const_iterator _iter646;
    for (_iter646 = this->colNames.begin(); _iter646 != this->colNames.end(); ++_iter646)
    {
      xfer += oprot->writeString((*_iter646));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("engine", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->engine);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableStatsRequest &a, TableStatsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.colNames, b.colNames);
  swap(a.catName, b.catName);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.engine, b.engine);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

TableStatsRequest::TableStatsRequest(const TableStatsRequest& other647) {
  dbName = other647.dbName;
  tblName = other647.tblName;
  colNames = other647.colNames;
  catName = other647.catName;
  validWriteIdList = other647.validWriteIdList;
  engine = other647.engine;
  id = other647.id;
  __isset = other647.__isset;
}
TableStatsRequest& TableStatsRequest::operator=(const TableStatsRequest& other648) {
  dbName = other648.dbName;
  tblName = other648.tblName;
  colNames = other648.colNames;
  catName = other648.catName;
  validWriteIdList = other648.validWriteIdList;
  engine = other648.engine;
  id = other648.id;
  __isset = other648.__isset;
  return *this;
}
void TableStatsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TableStatsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "colNames=" << to_string(colNames);
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "engine=" << to_string(engine);
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


PartitionsStatsRequest::~PartitionsStatsRequest() noexcept {
}


void PartitionsStatsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void PartitionsStatsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void PartitionsStatsRequest::__set_colNames(const std::vector<std::string> & val) {
  this->colNames = val;
}

void PartitionsStatsRequest::__set_partNames(const std::vector<std::string> & val) {
  this->partNames = val;
}

void PartitionsStatsRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void PartitionsStatsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void PartitionsStatsRequest::__set_engine(const std::string& val) {
  this->engine = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionsStatsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionsStatsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_colNames = false;
  bool isset_partNames = false;
  bool isset_engine = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colNames.clear();
            uint32_t _size649;
            ::apache::thrift::protocol::TType _etype652;
            xfer += iprot->readListBegin(_etype652, _size649);
            this->colNames.resize(_size649);
            uint32_t _i653;
            for (_i653 = 0; _i653 < _size649; ++_i653)
            {
              xfer += iprot->readString(this->colNames[_i653]);
            }
            xfer += iprot->readListEnd();
          }
          isset_colNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partNames.clear();
            uint32_t _size654;
            ::apache::thrift::protocol::TType _etype657;
            xfer += iprot->readListBegin(_etype657, _size654);
            this->partNames.resize(_size654);
            uint32_t _i658;
            for (_i658 = 0; _i658 < _size654; ++_i658)
            {
              xfer += iprot->readString(this->partNames[_i658]);
            }
            xfer += iprot->readListEnd();
          }
          isset_partNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->engine);
          isset_engine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_colNames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partNames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_engine)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsStatsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsStatsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colNames", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->colNames.size()));
    std::vector<std::string> ::const_iterator _iter659;
    for (_iter659 = this->colNames.begin(); _iter659 != this->colNames.end(); ++_iter659)
    {
      xfer += oprot->writeString((*_iter659));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partNames", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partNames.size()));
    std::vector<std::string> ::const_iterator _iter660;
    for (_iter660 = this->partNames.begin(); _iter660 != this->partNames.end(); ++_iter660)
    {
      xfer += oprot->writeString((*_iter660));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("engine", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->engine);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsStatsRequest &a, PartitionsStatsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.colNames, b.colNames);
  swap(a.partNames, b.partNames);
  swap(a.catName, b.catName);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.engine, b.engine);
  swap(a.__isset, b.__isset);
}

PartitionsStatsRequest::PartitionsStatsRequest(const PartitionsStatsRequest& other661) {
  dbName = other661.dbName;
  tblName = other661.tblName;
  colNames = other661.colNames;
  partNames = other661.partNames;
  catName = other661.catName;
  validWriteIdList = other661.validWriteIdList;
  engine = other661.engine;
  __isset = other661.__isset;
}
PartitionsStatsRequest& PartitionsStatsRequest::operator=(const PartitionsStatsRequest& other662) {
  dbName = other662.dbName;
  tblName = other662.tblName;
  colNames = other662.colNames;
  partNames = other662.partNames;
  catName = other662.catName;
  validWriteIdList = other662.validWriteIdList;
  engine = other662.engine;
  __isset = other662.__isset;
  return *this;
}
void PartitionsStatsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsStatsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "colNames=" << to_string(colNames);
  out << ", " << "partNames=" << to_string(partNames);
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "engine=" << to_string(engine);
  out << ")";
}


AddPartitionsResult::~AddPartitionsResult() noexcept {
}


void AddPartitionsResult::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
__isset.partitions = true;
}

void AddPartitionsResult::__set_isStatsCompliant(const bool val) {
  this->isStatsCompliant = val;
__isset.isStatsCompliant = true;
}
std::ostream& operator<<(std::ostream& out, const AddPartitionsResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddPartitionsResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size663;
            ::apache::thrift::protocol::TType _etype666;
            xfer += iprot->readListBegin(_etype666, _size663);
            this->partitions.resize(_size663);
            uint32_t _i667;
            for (_i667 = 0; _i667 < _size663; ++_i667)
            {
              xfer += this->partitions[_i667].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isStatsCompliant);
          this->__isset.isStatsCompliant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AddPartitionsResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddPartitionsResult");

  if (this->__isset.partitions) {
    xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
      std::vector<Partition> ::const_iterator _iter668;
      for (_iter668 = this->partitions.begin(); _iter668 != this->partitions.end(); ++_iter668)
      {
        xfer += (*_iter668).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isStatsCompliant) {
    xfer += oprot->writeFieldBegin("isStatsCompliant", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->isStatsCompliant);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddPartitionsResult &a, AddPartitionsResult &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.isStatsCompliant, b.isStatsCompliant);
  swap(a.__isset, b.__isset);
}

AddPartitionsResult::AddPartitionsResult(const AddPartitionsResult& other669) {
  partitions = other669.partitions;
  isStatsCompliant = other669.isStatsCompliant;
  __isset = other669.__isset;
}
AddPartitionsResult& AddPartitionsResult::operator=(const AddPartitionsResult& other670) {
  partitions = other670.partitions;
  isStatsCompliant = other670.isStatsCompliant;
  __isset = other670.__isset;
  return *this;
}
void AddPartitionsResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddPartitionsResult(";
  out << "partitions="; (__isset.partitions ? (out << to_string(partitions)) : (out << "<null>"));
  out << ", " << "isStatsCompliant="; (__isset.isStatsCompliant ? (out << to_string(isStatsCompliant)) : (out << "<null>"));
  out << ")";
}


AddPartitionsRequest::~AddPartitionsRequest() noexcept {
}


void AddPartitionsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void AddPartitionsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void AddPartitionsRequest::__set_parts(const std::vector<Partition> & val) {
  this->parts = val;
}

void AddPartitionsRequest::__set_ifNotExists(const bool val) {
  this->ifNotExists = val;
}

void AddPartitionsRequest::__set_needResult(const bool val) {
  this->needResult = val;
__isset.needResult = true;
}

void AddPartitionsRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void AddPartitionsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}
std::ostream& operator<<(std::ostream& out, const AddPartitionsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddPartitionsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_parts = false;
  bool isset_ifNotExists = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->parts.clear();
            uint32_t _size671;
            ::apache::thrift::protocol::TType _etype674;
            xfer += iprot->readListBegin(_etype674, _size671);
            this->parts.resize(_size671);
            uint32_t _i675;
            for (_i675 = 0; _i675 < _size671; ++_i675)
            {
              xfer += this->parts[_i675].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_parts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ifNotExists);
          isset_ifNotExists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->needResult);
          this->__isset.needResult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_parts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ifNotExists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddPartitionsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddPartitionsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parts", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->parts.size()));
    std::vector<Partition> ::const_iterator _iter676;
    for (_iter676 = this->parts.begin(); _iter676 != this->parts.end(); ++_iter676)
    {
      xfer += (*_iter676).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ifNotExists", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->ifNotExists);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.needResult) {
    xfer += oprot->writeFieldBegin("needResult", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->needResult);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddPartitionsRequest &a, AddPartitionsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.parts, b.parts);
  swap(a.ifNotExists, b.ifNotExists);
  swap(a.needResult, b.needResult);
  swap(a.catName, b.catName);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.__isset, b.__isset);
}

AddPartitionsRequest::AddPartitionsRequest(const AddPartitionsRequest& other677) {
  dbName = other677.dbName;
  tblName = other677.tblName;
  parts = other677.parts;
  ifNotExists = other677.ifNotExists;
  needResult = other677.needResult;
  catName = other677.catName;
  validWriteIdList = other677.validWriteIdList;
  __isset = other677.__isset;
}
AddPartitionsRequest& AddPartitionsRequest::operator=(const AddPartitionsRequest& other678) {
  dbName = other678.dbName;
  tblName = other678.tblName;
  parts = other678.parts;
  ifNotExists = other678.ifNotExists;
  needResult = other678.needResult;
  catName = other678.catName;
  validWriteIdList = other678.validWriteIdList;
  __isset = other678.__isset;
  return *this;
}
void AddPartitionsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddPartitionsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "parts=" << to_string(parts);
  out << ", " << "ifNotExists=" << to_string(ifNotExists);
  out << ", " << "needResult="; (__isset.needResult ? (out << to_string(needResult)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ")";
}


DropPartitionsResult::~DropPartitionsResult() noexcept {
}


void DropPartitionsResult::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
__isset.partitions = true;
}
std::ostream& operator<<(std::ostream& out, const DropPartitionsResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropPartitionsResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size679;
            ::apache::thrift::protocol::TType _etype682;
            xfer += iprot->readListBegin(_etype682, _size679);
            this->partitions.resize(_size679);
            uint32_t _i683;
            for (_i683 = 0; _i683 < _size679; ++_i683)
            {
              xfer += this->partitions[_i683].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DropPartitionsResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropPartitionsResult");

  if (this->__isset.partitions) {
    xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
      std::vector<Partition> ::const_iterator _iter684;
      for (_iter684 = this->partitions.begin(); _iter684 != this->partitions.end(); ++_iter684)
      {
        xfer += (*_iter684).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropPartitionsResult &a, DropPartitionsResult &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.__isset, b.__isset);
}

DropPartitionsResult::DropPartitionsResult(const DropPartitionsResult& other685) {
  partitions = other685.partitions;
  __isset = other685.__isset;
}
DropPartitionsResult& DropPartitionsResult::operator=(const DropPartitionsResult& other686) {
  partitions = other686.partitions;
  __isset = other686.__isset;
  return *this;
}
void DropPartitionsResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropPartitionsResult(";
  out << "partitions="; (__isset.partitions ? (out << to_string(partitions)) : (out << "<null>"));
  out << ")";
}


DropPartitionsExpr::~DropPartitionsExpr() noexcept {
}


void DropPartitionsExpr::__set_expr(const std::string& val) {
  this->expr = val;
}

void DropPartitionsExpr::__set_partArchiveLevel(const int32_t val) {
  this->partArchiveLevel = val;
__isset.partArchiveLevel = true;
}
std::ostream& operator<<(std::ostream& out, const DropPartitionsExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropPartitionsExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_expr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->expr);
          isset_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partArchiveLevel);
          this->__isset.partArchiveLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_expr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DropPartitionsExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropPartitionsExpr");

  xfer += oprot->writeFieldBegin("expr", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->expr);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partArchiveLevel) {
    xfer += oprot->writeFieldBegin("partArchiveLevel", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->partArchiveLevel);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropPartitionsExpr &a, DropPartitionsExpr &b) {
  using ::std::swap;
  swap(a.expr, b.expr);
  swap(a.partArchiveLevel, b.partArchiveLevel);
  swap(a.__isset, b.__isset);
}

DropPartitionsExpr::DropPartitionsExpr(const DropPartitionsExpr& other687) {
  expr = other687.expr;
  partArchiveLevel = other687.partArchiveLevel;
  __isset = other687.__isset;
}
DropPartitionsExpr& DropPartitionsExpr::operator=(const DropPartitionsExpr& other688) {
  expr = other688.expr;
  partArchiveLevel = other688.partArchiveLevel;
  __isset = other688.__isset;
  return *this;
}
void DropPartitionsExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropPartitionsExpr(";
  out << "expr=" << to_string(expr);
  out << ", " << "partArchiveLevel="; (__isset.partArchiveLevel ? (out << to_string(partArchiveLevel)) : (out << "<null>"));
  out << ")";
}


RequestPartsSpec::~RequestPartsSpec() noexcept {
}


void RequestPartsSpec::__set_names(const std::vector<std::string> & val) {
  this->names = val;
__isset.names = true;
}

void RequestPartsSpec::__set_exprs(const std::vector<DropPartitionsExpr> & val) {
  this->exprs = val;
__isset.exprs = true;
}
std::ostream& operator<<(std::ostream& out, const RequestPartsSpec& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RequestPartsSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size689;
            ::apache::thrift::protocol::TType _etype692;
            xfer += iprot->readListBegin(_etype692, _size689);
            this->names.resize(_size689);
            uint32_t _i693;
            for (_i693 = 0; _i693 < _size689; ++_i693)
            {
              xfer += iprot->readString(this->names[_i693]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->exprs.clear();
            uint32_t _size694;
            ::apache::thrift::protocol::TType _etype697;
            xfer += iprot->readListBegin(_etype697, _size694);
            this->exprs.resize(_size694);
            uint32_t _i698;
            for (_i698 = 0; _i698 < _size694; ++_i698)
            {
              xfer += this->exprs[_i698].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RequestPartsSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RequestPartsSpec");

  if (this->__isset.names) {
    xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->names.size()));
      std::vector<std::string> ::const_iterator _iter699;
      for (_iter699 = this->names.begin(); _iter699 != this->names.end(); ++_iter699)
      {
        xfer += oprot->writeString((*_iter699));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exprs) {
    xfer += oprot->writeFieldBegin("exprs", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->exprs.size()));
      std::vector<DropPartitionsExpr> ::const_iterator _iter700;
      for (_iter700 = this->exprs.begin(); _iter700 != this->exprs.end(); ++_iter700)
      {
        xfer += (*_iter700).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RequestPartsSpec &a, RequestPartsSpec &b) {
  using ::std::swap;
  swap(a.names, b.names);
  swap(a.exprs, b.exprs);
  swap(a.__isset, b.__isset);
}

RequestPartsSpec::RequestPartsSpec(const RequestPartsSpec& other701) {
  names = other701.names;
  exprs = other701.exprs;
  __isset = other701.__isset;
}
RequestPartsSpec& RequestPartsSpec::operator=(const RequestPartsSpec& other702) {
  names = other702.names;
  exprs = other702.exprs;
  __isset = other702.__isset;
  return *this;
}
void RequestPartsSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RequestPartsSpec(";
  out << "names="; (__isset.names ? (out << to_string(names)) : (out << "<null>"));
  out << ", " << "exprs="; (__isset.exprs ? (out << to_string(exprs)) : (out << "<null>"));
  out << ")";
}


DropPartitionsRequest::~DropPartitionsRequest() noexcept {
}


void DropPartitionsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void DropPartitionsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void DropPartitionsRequest::__set_parts(const RequestPartsSpec& val) {
  this->parts = val;
}

void DropPartitionsRequest::__set_deleteData(const bool val) {
  this->deleteData = val;
__isset.deleteData = true;
}

void DropPartitionsRequest::__set_ifExists(const bool val) {
  this->ifExists = val;
__isset.ifExists = true;
}

void DropPartitionsRequest::__set_ignoreProtection(const bool val) {
  this->ignoreProtection = val;
__isset.ignoreProtection = true;
}

void DropPartitionsRequest::__set_environmentContext(const EnvironmentContext& val) {
  this->environmentContext = val;
__isset.environmentContext = true;
}

void DropPartitionsRequest::__set_needResult(const bool val) {
  this->needResult = val;
__isset.needResult = true;
}

void DropPartitionsRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}
std::ostream& operator<<(std::ostream& out, const DropPartitionsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropPartitionsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_parts = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->parts.read(iprot);
          isset_parts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->deleteData);
          this->__isset.deleteData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ifExists);
          this->__isset.ifExists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ignoreProtection);
          this->__isset.ignoreProtection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->environmentContext.read(iprot);
          this->__isset.environmentContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->needResult);
          this->__isset.needResult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_parts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DropPartitionsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropPartitionsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parts", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->parts.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.deleteData) {
    xfer += oprot->writeFieldBegin("deleteData", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->deleteData);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ifExists) {
    xfer += oprot->writeFieldBegin("ifExists", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->ifExists);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ignoreProtection) {
    xfer += oprot->writeFieldBegin("ignoreProtection", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->ignoreProtection);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.environmentContext) {
    xfer += oprot->writeFieldBegin("environmentContext", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->environmentContext.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.needResult) {
    xfer += oprot->writeFieldBegin("needResult", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->needResult);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropPartitionsRequest &a, DropPartitionsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.parts, b.parts);
  swap(a.deleteData, b.deleteData);
  swap(a.ifExists, b.ifExists);
  swap(a.ignoreProtection, b.ignoreProtection);
  swap(a.environmentContext, b.environmentContext);
  swap(a.needResult, b.needResult);
  swap(a.catName, b.catName);
  swap(a.__isset, b.__isset);
}

DropPartitionsRequest::DropPartitionsRequest(const DropPartitionsRequest& other703) {
  dbName = other703.dbName;
  tblName = other703.tblName;
  parts = other703.parts;
  deleteData = other703.deleteData;
  ifExists = other703.ifExists;
  ignoreProtection = other703.ignoreProtection;
  environmentContext = other703.environmentContext;
  needResult = other703.needResult;
  catName = other703.catName;
  __isset = other703.__isset;
}
DropPartitionsRequest& DropPartitionsRequest::operator=(const DropPartitionsRequest& other704) {
  dbName = other704.dbName;
  tblName = other704.tblName;
  parts = other704.parts;
  deleteData = other704.deleteData;
  ifExists = other704.ifExists;
  ignoreProtection = other704.ignoreProtection;
  environmentContext = other704.environmentContext;
  needResult = other704.needResult;
  catName = other704.catName;
  __isset = other704.__isset;
  return *this;
}
void DropPartitionsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropPartitionsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "parts=" << to_string(parts);
  out << ", " << "deleteData="; (__isset.deleteData ? (out << to_string(deleteData)) : (out << "<null>"));
  out << ", " << "ifExists="; (__isset.ifExists ? (out << to_string(ifExists)) : (out << "<null>"));
  out << ", " << "ignoreProtection="; (__isset.ignoreProtection ? (out << to_string(ignoreProtection)) : (out << "<null>"));
  out << ", " << "environmentContext="; (__isset.environmentContext ? (out << to_string(environmentContext)) : (out << "<null>"));
  out << ", " << "needResult="; (__isset.needResult ? (out << to_string(needResult)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ")";
}


PartitionValuesRequest::~PartitionValuesRequest() noexcept {
}


void PartitionValuesRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void PartitionValuesRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void PartitionValuesRequest::__set_partitionKeys(const std::vector<FieldSchema> & val) {
  this->partitionKeys = val;
}

void PartitionValuesRequest::__set_applyDistinct(const bool val) {
  this->applyDistinct = val;
__isset.applyDistinct = true;
}

void PartitionValuesRequest::__set_filter(const std::string& val) {
  this->filter = val;
__isset.filter = true;
}

void PartitionValuesRequest::__set_partitionOrder(const std::vector<FieldSchema> & val) {
  this->partitionOrder = val;
__isset.partitionOrder = true;
}

void PartitionValuesRequest::__set_ascending(const bool val) {
  this->ascending = val;
__isset.ascending = true;
}

void PartitionValuesRequest::__set_maxParts(const int64_t val) {
  this->maxParts = val;
__isset.maxParts = true;
}

void PartitionValuesRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void PartitionValuesRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}
std::ostream& operator<<(std::ostream& out, const PartitionValuesRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionValuesRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_partitionKeys = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionKeys.clear();
            uint32_t _size705;
            ::apache::thrift::protocol::TType _etype708;
            xfer += iprot->readListBegin(_etype708, _size705);
            this->partitionKeys.resize(_size705);
            uint32_t _i709;
            for (_i709 = 0; _i709 < _size705; ++_i709)
            {
              xfer += this->partitionKeys[_i709].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitionKeys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->applyDistinct);
          this->__isset.applyDistinct = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->filter);
          this->__isset.filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionOrder.clear();
            uint32_t _size710;
            ::apache::thrift::protocol::TType _etype713;
            xfer += iprot->readListBegin(_etype713, _size710);
            this->partitionOrder.resize(_size710);
            uint32_t _i714;
            for (_i714 = 0; _i714 < _size710; ++_i714)
            {
              xfer += this->partitionOrder[_i714].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionOrder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ascending);
          this->__isset.ascending = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxParts);
          this->__isset.maxParts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partitionKeys)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionValuesRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionValuesRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitionKeys", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitionKeys.size()));
    std::vector<FieldSchema> ::const_iterator _iter715;
    for (_iter715 = this->partitionKeys.begin(); _iter715 != this->partitionKeys.end(); ++_iter715)
    {
      xfer += (*_iter715).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.applyDistinct) {
    xfer += oprot->writeFieldBegin("applyDistinct", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->applyDistinct);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filter) {
    xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->filter);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionOrder) {
    xfer += oprot->writeFieldBegin("partitionOrder", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitionOrder.size()));
      std::vector<FieldSchema> ::const_iterator _iter716;
      for (_iter716 = this->partitionOrder.begin(); _iter716 != this->partitionOrder.end(); ++_iter716)
      {
        xfer += (*_iter716).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ascending) {
    xfer += oprot->writeFieldBegin("ascending", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->ascending);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxParts) {
    xfer += oprot->writeFieldBegin("maxParts", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->maxParts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionValuesRequest &a, PartitionValuesRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.partitionKeys, b.partitionKeys);
  swap(a.applyDistinct, b.applyDistinct);
  swap(a.filter, b.filter);
  swap(a.partitionOrder, b.partitionOrder);
  swap(a.ascending, b.ascending);
  swap(a.maxParts, b.maxParts);
  swap(a.catName, b.catName);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.__isset, b.__isset);
}

PartitionValuesRequest::PartitionValuesRequest(const PartitionValuesRequest& other717) {
  dbName = other717.dbName;
  tblName = other717.tblName;
  partitionKeys = other717.partitionKeys;
  applyDistinct = other717.applyDistinct;
  filter = other717.filter;
  partitionOrder = other717.partitionOrder;
  ascending = other717.ascending;
  maxParts = other717.maxParts;
  catName = other717.catName;
  validWriteIdList = other717.validWriteIdList;
  __isset = other717.__isset;
}
PartitionValuesRequest& PartitionValuesRequest::operator=(const PartitionValuesRequest& other718) {
  dbName = other718.dbName;
  tblName = other718.tblName;
  partitionKeys = other718.partitionKeys;
  applyDistinct = other718.applyDistinct;
  filter = other718.filter;
  partitionOrder = other718.partitionOrder;
  ascending = other718.ascending;
  maxParts = other718.maxParts;
  catName = other718.catName;
  validWriteIdList = other718.validWriteIdList;
  __isset = other718.__isset;
  return *this;
}
void PartitionValuesRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionValuesRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "partitionKeys=" << to_string(partitionKeys);
  out << ", " << "applyDistinct="; (__isset.applyDistinct ? (out << to_string(applyDistinct)) : (out << "<null>"));
  out << ", " << "filter="; (__isset.filter ? (out << to_string(filter)) : (out << "<null>"));
  out << ", " << "partitionOrder="; (__isset.partitionOrder ? (out << to_string(partitionOrder)) : (out << "<null>"));
  out << ", " << "ascending="; (__isset.ascending ? (out << to_string(ascending)) : (out << "<null>"));
  out << ", " << "maxParts="; (__isset.maxParts ? (out << to_string(maxParts)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ")";
}


PartitionValuesRow::~PartitionValuesRow() noexcept {
}


void PartitionValuesRow::__set_row(const std::vector<std::string> & val) {
  this->row = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionValuesRow& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionValuesRow::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row.clear();
            uint32_t _size719;
            ::apache::thrift::protocol::TType _etype722;
            xfer += iprot->readListBegin(_etype722, _size719);
            this->row.resize(_size719);
            uint32_t _i723;
            for (_i723 = 0; _i723 < _size719; ++_i723)
            {
              xfer += iprot->readString(this->row[_i723]);
            }
            xfer += iprot->readListEnd();
          }
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionValuesRow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionValuesRow");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->row.size()));
    std::vector<std::string> ::const_iterator _iter724;
    for (_iter724 = this->row.begin(); _iter724 != this->row.end(); ++_iter724)
    {
      xfer += oprot->writeString((*_iter724));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionValuesRow &a, PartitionValuesRow &b) {
  using ::std::swap;
  swap(a.row, b.row);
}

PartitionValuesRow::PartitionValuesRow(const PartitionValuesRow& other725) {
  row = other725.row;
}
PartitionValuesRow& PartitionValuesRow::operator=(const PartitionValuesRow& other726) {
  row = other726.row;
  return *this;
}
void PartitionValuesRow::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionValuesRow(";
  out << "row=" << to_string(row);
  out << ")";
}


PartitionValuesResponse::~PartitionValuesResponse() noexcept {
}


void PartitionValuesResponse::__set_partitionValues(const std::vector<PartitionValuesRow> & val) {
  this->partitionValues = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionValuesResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionValuesResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partitionValues = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionValues.clear();
            uint32_t _size727;
            ::apache::thrift::protocol::TType _etype730;
            xfer += iprot->readListBegin(_etype730, _size727);
            this->partitionValues.resize(_size727);
            uint32_t _i731;
            for (_i731 = 0; _i731 < _size727; ++_i731)
            {
              xfer += this->partitionValues[_i731].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitionValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partitionValues)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionValuesResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionValuesResponse");

  xfer += oprot->writeFieldBegin("partitionValues", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitionValues.size()));
    std::vector<PartitionValuesRow> ::const_iterator _iter732;
    for (_iter732 = this->partitionValues.begin(); _iter732 != this->partitionValues.end(); ++_iter732)
    {
      xfer += (*_iter732).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionValuesResponse &a, PartitionValuesResponse &b) {
  using ::std::swap;
  swap(a.partitionValues, b.partitionValues);
}

PartitionValuesResponse::PartitionValuesResponse(const PartitionValuesResponse& other733) {
  partitionValues = other733.partitionValues;
}
PartitionValuesResponse& PartitionValuesResponse::operator=(const PartitionValuesResponse& other734) {
  partitionValues = other734.partitionValues;
  return *this;
}
void PartitionValuesResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionValuesResponse(";
  out << "partitionValues=" << to_string(partitionValues);
  out << ")";
}


GetPartitionsByNamesRequest::~GetPartitionsByNamesRequest() noexcept {
}


void GetPartitionsByNamesRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void GetPartitionsByNamesRequest::__set_tbl_name(const std::string& val) {
  this->tbl_name = val;
}

void GetPartitionsByNamesRequest::__set_names(const std::vector<std::string> & val) {
  this->names = val;
__isset.names = true;
}

void GetPartitionsByNamesRequest::__set_get_col_stats(const bool val) {
  this->get_col_stats = val;
__isset.get_col_stats = true;
}

void GetPartitionsByNamesRequest::__set_processorCapabilities(const std::vector<std::string> & val) {
  this->processorCapabilities = val;
__isset.processorCapabilities = true;
}

void GetPartitionsByNamesRequest::__set_processorIdentifier(const std::string& val) {
  this->processorIdentifier = val;
__isset.processorIdentifier = true;
}

void GetPartitionsByNamesRequest::__set_engine(const std::string& val) {
  this->engine = val;
__isset.engine = true;
}

void GetPartitionsByNamesRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void GetPartitionsByNamesRequest::__set_getFileMetadata(const bool val) {
  this->getFileMetadata = val;
__isset.getFileMetadata = true;
}

void GetPartitionsByNamesRequest::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionsByNamesRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionsByNamesRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db_name = false;
  bool isset_tbl_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbl_name);
          isset_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size735;
            ::apache::thrift::protocol::TType _etype738;
            xfer += iprot->readListBegin(_etype738, _size735);
            this->names.resize(_size735);
            uint32_t _i739;
            for (_i739 = 0; _i739 < _size735; ++_i739)
            {
              xfer += iprot->readString(this->names[_i739]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->get_col_stats);
          this->__isset.get_col_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->processorCapabilities.clear();
            uint32_t _size740;
            ::apache::thrift::protocol::TType _etype743;
            xfer += iprot->readListBegin(_etype743, _size740);
            this->processorCapabilities.resize(_size740);
            uint32_t _i744;
            for (_i744 = 0; _i744 < _size740; ++_i744)
            {
              xfer += iprot->readString(this->processorCapabilities[_i744]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.processorCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->processorIdentifier);
          this->__isset.processorIdentifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->engine);
          this->__isset.engine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->getFileMetadata);
          this->__isset.getFileMetadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tbl_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPartitionsByNamesRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionsByNamesRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tbl_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tbl_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.names) {
    xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->names.size()));
      std::vector<std::string> ::const_iterator _iter745;
      for (_iter745 = this->names.begin(); _iter745 != this->names.end(); ++_iter745)
      {
        xfer += oprot->writeString((*_iter745));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_col_stats) {
    xfer += oprot->writeFieldBegin("get_col_stats", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->get_col_stats);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorCapabilities) {
    xfer += oprot->writeFieldBegin("processorCapabilities", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->processorCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter746;
      for (_iter746 = this->processorCapabilities.begin(); _iter746 != this->processorCapabilities.end(); ++_iter746)
      {
        xfer += oprot->writeString((*_iter746));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorIdentifier) {
    xfer += oprot->writeFieldBegin("processorIdentifier", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->processorIdentifier);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.engine) {
    xfer += oprot->writeFieldBegin("engine", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->engine);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.getFileMetadata) {
    xfer += oprot->writeFieldBegin("getFileMetadata", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->getFileMetadata);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionsByNamesRequest &a, GetPartitionsByNamesRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.tbl_name, b.tbl_name);
  swap(a.names, b.names);
  swap(a.get_col_stats, b.get_col_stats);
  swap(a.processorCapabilities, b.processorCapabilities);
  swap(a.processorIdentifier, b.processorIdentifier);
  swap(a.engine, b.engine);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.getFileMetadata, b.getFileMetadata);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

GetPartitionsByNamesRequest::GetPartitionsByNamesRequest(const GetPartitionsByNamesRequest& other747) {
  db_name = other747.db_name;
  tbl_name = other747.tbl_name;
  names = other747.names;
  get_col_stats = other747.get_col_stats;
  processorCapabilities = other747.processorCapabilities;
  processorIdentifier = other747.processorIdentifier;
  engine = other747.engine;
  validWriteIdList = other747.validWriteIdList;
  getFileMetadata = other747.getFileMetadata;
  id = other747.id;
  __isset = other747.__isset;
}
GetPartitionsByNamesRequest& GetPartitionsByNamesRequest::operator=(const GetPartitionsByNamesRequest& other748) {
  db_name = other748.db_name;
  tbl_name = other748.tbl_name;
  names = other748.names;
  get_col_stats = other748.get_col_stats;
  processorCapabilities = other748.processorCapabilities;
  processorIdentifier = other748.processorIdentifier;
  engine = other748.engine;
  validWriteIdList = other748.validWriteIdList;
  getFileMetadata = other748.getFileMetadata;
  id = other748.id;
  __isset = other748.__isset;
  return *this;
}
void GetPartitionsByNamesRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionsByNamesRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "tbl_name=" << to_string(tbl_name);
  out << ", " << "names="; (__isset.names ? (out << to_string(names)) : (out << "<null>"));
  out << ", " << "get_col_stats="; (__isset.get_col_stats ? (out << to_string(get_col_stats)) : (out << "<null>"));
  out << ", " << "processorCapabilities="; (__isset.processorCapabilities ? (out << to_string(processorCapabilities)) : (out << "<null>"));
  out << ", " << "processorIdentifier="; (__isset.processorIdentifier ? (out << to_string(processorIdentifier)) : (out << "<null>"));
  out << ", " << "engine="; (__isset.engine ? (out << to_string(engine)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "getFileMetadata="; (__isset.getFileMetadata ? (out << to_string(getFileMetadata)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


GetPartitionsByNamesResult::~GetPartitionsByNamesResult() noexcept {
}


void GetPartitionsByNamesResult::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
}

void GetPartitionsByNamesResult::__set_dictionary(const ObjectDictionary& val) {
  this->dictionary = val;
__isset.dictionary = true;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionsByNamesResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionsByNamesResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partitions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size749;
            ::apache::thrift::protocol::TType _etype752;
            xfer += iprot->readListBegin(_etype752, _size749);
            this->partitions.resize(_size749);
            uint32_t _i753;
            for (_i753 = 0; _i753 < _size749; ++_i753)
            {
              xfer += this->partitions[_i753].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dictionary.read(iprot);
          this->__isset.dictionary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPartitionsByNamesResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionsByNamesResult");

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<Partition> ::const_iterator _iter754;
    for (_iter754 = this->partitions.begin(); _iter754 != this->partitions.end(); ++_iter754)
    {
      xfer += (*_iter754).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dictionary) {
    xfer += oprot->writeFieldBegin("dictionary", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->dictionary.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionsByNamesResult &a, GetPartitionsByNamesResult &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.dictionary, b.dictionary);
  swap(a.__isset, b.__isset);
}

GetPartitionsByNamesResult::GetPartitionsByNamesResult(const GetPartitionsByNamesResult& other755) {
  partitions = other755.partitions;
  dictionary = other755.dictionary;
  __isset = other755.__isset;
}
GetPartitionsByNamesResult& GetPartitionsByNamesResult::operator=(const GetPartitionsByNamesResult& other756) {
  partitions = other756.partitions;
  dictionary = other756.dictionary;
  __isset = other756.__isset;
  return *this;
}
void GetPartitionsByNamesResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionsByNamesResult(";
  out << "partitions=" << to_string(partitions);
  out << ", " << "dictionary="; (__isset.dictionary ? (out << to_string(dictionary)) : (out << "<null>"));
  out << ")";
}


DataConnector::~DataConnector() noexcept {
}


void DataConnector::__set_name(const std::string& val) {
  this->name = val;
}

void DataConnector::__set_type(const std::string& val) {
  this->type = val;
}

void DataConnector::__set_url(const std::string& val) {
  this->url = val;
}

void DataConnector::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void DataConnector::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
__isset.parameters = true;
}

void DataConnector::__set_ownerName(const std::string& val) {
  this->ownerName = val;
__isset.ownerName = true;
}

void DataConnector::__set_ownerType(const PrincipalType::type val) {
  this->ownerType = val;
__isset.ownerType = true;
}

void DataConnector::__set_createTime(const int32_t val) {
  this->createTime = val;
__isset.createTime = true;
}
std::ostream& operator<<(std::ostream& out, const DataConnector& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DataConnector::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size757;
            ::apache::thrift::protocol::TType _ktype758;
            ::apache::thrift::protocol::TType _vtype759;
            xfer += iprot->readMapBegin(_ktype758, _vtype759, _size757);
            uint32_t _i761;
            for (_i761 = 0; _i761 < _size757; ++_i761)
            {
              std::string _key762;
              xfer += iprot->readString(_key762);
              std::string& _val763 = this->parameters[_key762];
              xfer += iprot->readString(_val763);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast764;
          xfer += iprot->readI32(ecast764);
          this->ownerType = static_cast<PrincipalType::type>(ecast764);
          this->__isset.ownerType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DataConnector::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DataConnector");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parameters) {
    xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
      std::map<std::string, std::string> ::const_iterator _iter765;
      for (_iter765 = this->parameters.begin(); _iter765 != this->parameters.end(); ++_iter765)
      {
        xfer += oprot->writeString(_iter765->first);
        xfer += oprot->writeString(_iter765->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ownerName) {
    xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->ownerName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ownerType) {
    xfer += oprot->writeFieldBegin("ownerType", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(static_cast<int32_t>(this->ownerType));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTime) {
    xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->createTime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DataConnector &a, DataConnector &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.url, b.url);
  swap(a.description, b.description);
  swap(a.parameters, b.parameters);
  swap(a.ownerName, b.ownerName);
  swap(a.ownerType, b.ownerType);
  swap(a.createTime, b.createTime);
  swap(a.__isset, b.__isset);
}

DataConnector::DataConnector(const DataConnector& other766) {
  name = other766.name;
  type = other766.type;
  url = other766.url;
  description = other766.description;
  parameters = other766.parameters;
  ownerName = other766.ownerName;
  ownerType = other766.ownerType;
  createTime = other766.createTime;
  __isset = other766.__isset;
}
DataConnector& DataConnector::operator=(const DataConnector& other767) {
  name = other767.name;
  type = other767.type;
  url = other767.url;
  description = other767.description;
  parameters = other767.parameters;
  ownerName = other767.ownerName;
  ownerType = other767.ownerType;
  createTime = other767.createTime;
  __isset = other767.__isset;
  return *this;
}
void DataConnector::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DataConnector(";
  out << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "url=" << to_string(url);
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "parameters="; (__isset.parameters ? (out << to_string(parameters)) : (out << "<null>"));
  out << ", " << "ownerName="; (__isset.ownerName ? (out << to_string(ownerName)) : (out << "<null>"));
  out << ", " << "ownerType="; (__isset.ownerType ? (out << to_string(ownerType)) : (out << "<null>"));
  out << ", " << "createTime="; (__isset.createTime ? (out << to_string(createTime)) : (out << "<null>"));
  out << ")";
}


ResourceUri::~ResourceUri() noexcept {
}


void ResourceUri::__set_resourceType(const ResourceType::type val) {
  this->resourceType = val;
}

void ResourceUri::__set_uri(const std::string& val) {
  this->uri = val;
}
std::ostream& operator<<(std::ostream& out, const ResourceUri& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResourceUri::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast768;
          xfer += iprot->readI32(ecast768);
          this->resourceType = static_cast<ResourceType::type>(ecast768);
          this->__isset.resourceType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uri);
          this->__isset.uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ResourceUri::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResourceUri");

  xfer += oprot->writeFieldBegin("resourceType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->resourceType));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uri", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->uri);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResourceUri &a, ResourceUri &b) {
  using ::std::swap;
  swap(a.resourceType, b.resourceType);
  swap(a.uri, b.uri);
  swap(a.__isset, b.__isset);
}

ResourceUri::ResourceUri(const ResourceUri& other769) {
  resourceType = other769.resourceType;
  uri = other769.uri;
  __isset = other769.__isset;
}
ResourceUri& ResourceUri::operator=(const ResourceUri& other770) {
  resourceType = other770.resourceType;
  uri = other770.uri;
  __isset = other770.__isset;
  return *this;
}
void ResourceUri::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResourceUri(";
  out << "resourceType=" << to_string(resourceType);
  out << ", " << "uri=" << to_string(uri);
  out << ")";
}


Function::~Function() noexcept {
}


void Function::__set_functionName(const std::string& val) {
  this->functionName = val;
}

void Function::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void Function::__set_className(const std::string& val) {
  this->className = val;
}

void Function::__set_ownerName(const std::string& val) {
  this->ownerName = val;
}

void Function::__set_ownerType(const PrincipalType::type val) {
  this->ownerType = val;
}

void Function::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void Function::__set_functionType(const FunctionType::type val) {
  this->functionType = val;
}

void Function::__set_resourceUris(const std::vector<ResourceUri> & val) {
  this->resourceUris = val;
}

void Function::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}
std::ostream& operator<<(std::ostream& out, const Function& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Function::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->functionName);
          this->__isset.functionName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->className);
          this->__isset.className = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast771;
          xfer += iprot->readI32(ecast771);
          this->ownerType = static_cast<PrincipalType::type>(ecast771);
          this->__isset.ownerType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast772;
          xfer += iprot->readI32(ecast772);
          this->functionType = static_cast<FunctionType::type>(ecast772);
          this->__isset.functionType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->resourceUris.clear();
            uint32_t _size773;
            ::apache::thrift::protocol::TType _etype776;
            xfer += iprot->readListBegin(_etype776, _size773);
            this->resourceUris.resize(_size773);
            uint32_t _i777;
            for (_i777 = 0; _i777 < _size773; ++_i777)
            {
              xfer += this->resourceUris[_i777].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.resourceUris = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Function::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Function");

  xfer += oprot->writeFieldBegin("functionName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->functionName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("className", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->className);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->ownerName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ownerType", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(static_cast<int32_t>(this->ownerType));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("functionType", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(static_cast<int32_t>(this->functionType));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resourceUris", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->resourceUris.size()));
    std::vector<ResourceUri> ::const_iterator _iter778;
    for (_iter778 = this->resourceUris.begin(); _iter778 != this->resourceUris.end(); ++_iter778)
    {
      xfer += (*_iter778).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Function &a, Function &b) {
  using ::std::swap;
  swap(a.functionName, b.functionName);
  swap(a.dbName, b.dbName);
  swap(a.className, b.className);
  swap(a.ownerName, b.ownerName);
  swap(a.ownerType, b.ownerType);
  swap(a.createTime, b.createTime);
  swap(a.functionType, b.functionType);
  swap(a.resourceUris, b.resourceUris);
  swap(a.catName, b.catName);
  swap(a.__isset, b.__isset);
}

Function::Function(const Function& other779) {
  functionName = other779.functionName;
  dbName = other779.dbName;
  className = other779.className;
  ownerName = other779.ownerName;
  ownerType = other779.ownerType;
  createTime = other779.createTime;
  functionType = other779.functionType;
  resourceUris = other779.resourceUris;
  catName = other779.catName;
  __isset = other779.__isset;
}
Function& Function::operator=(const Function& other780) {
  functionName = other780.functionName;
  dbName = other780.dbName;
  className = other780.className;
  ownerName = other780.ownerName;
  ownerType = other780.ownerType;
  createTime = other780.createTime;
  functionType = other780.functionType;
  resourceUris = other780.resourceUris;
  catName = other780.catName;
  __isset = other780.__isset;
  return *this;
}
void Function::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Function(";
  out << "functionName=" << to_string(functionName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "className=" << to_string(className);
  out << ", " << "ownerName=" << to_string(ownerName);
  out << ", " << "ownerType=" << to_string(ownerType);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "functionType=" << to_string(functionType);
  out << ", " << "resourceUris=" << to_string(resourceUris);
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ")";
}


TxnInfo::~TxnInfo() noexcept {
}


void TxnInfo::__set_id(const int64_t val) {
  this->id = val;
}

void TxnInfo::__set_state(const TxnState::type val) {
  this->state = val;
}

void TxnInfo::__set_user(const std::string& val) {
  this->user = val;
}

void TxnInfo::__set_hostname(const std::string& val) {
  this->hostname = val;
}

void TxnInfo::__set_agentInfo(const std::string& val) {
  this->agentInfo = val;
__isset.agentInfo = true;
}

void TxnInfo::__set_heartbeatCount(const int32_t val) {
  this->heartbeatCount = val;
__isset.heartbeatCount = true;
}

void TxnInfo::__set_metaInfo(const std::string& val) {
  this->metaInfo = val;
__isset.metaInfo = true;
}

void TxnInfo::__set_startedTime(const int64_t val) {
  this->startedTime = val;
__isset.startedTime = true;
}

void TxnInfo::__set_lastHeartbeatTime(const int64_t val) {
  this->lastHeartbeatTime = val;
__isset.lastHeartbeatTime = true;
}
std::ostream& operator<<(std::ostream& out, const TxnInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TxnInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_state = false;
  bool isset_user = false;
  bool isset_hostname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast781;
          xfer += iprot->readI32(ecast781);
          this->state = static_cast<TxnState::type>(ecast781);
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          isset_hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agentInfo);
          this->__isset.agentInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->heartbeatCount);
          this->__isset.heartbeatCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metaInfo);
          this->__isset.metaInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startedTime);
          this->__isset.startedTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastHeartbeatTime);
          this->__isset.lastHeartbeatTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hostname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TxnInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TxnInfo");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->state));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.agentInfo) {
    xfer += oprot->writeFieldBegin("agentInfo", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->agentInfo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.heartbeatCount) {
    xfer += oprot->writeFieldBegin("heartbeatCount", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->heartbeatCount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.metaInfo) {
    xfer += oprot->writeFieldBegin("metaInfo", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->metaInfo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.startedTime) {
    xfer += oprot->writeFieldBegin("startedTime", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->startedTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastHeartbeatTime) {
    xfer += oprot->writeFieldBegin("lastHeartbeatTime", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->lastHeartbeatTime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TxnInfo &a, TxnInfo &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.state, b.state);
  swap(a.user, b.user);
  swap(a.hostname, b.hostname);
  swap(a.agentInfo, b.agentInfo);
  swap(a.heartbeatCount, b.heartbeatCount);
  swap(a.metaInfo, b.metaInfo);
  swap(a.startedTime, b.startedTime);
  swap(a.lastHeartbeatTime, b.lastHeartbeatTime);
  swap(a.__isset, b.__isset);
}

TxnInfo::TxnInfo(const TxnInfo& other782) {
  id = other782.id;
  state = other782.state;
  user = other782.user;
  hostname = other782.hostname;
  agentInfo = other782.agentInfo;
  heartbeatCount = other782.heartbeatCount;
  metaInfo = other782.metaInfo;
  startedTime = other782.startedTime;
  lastHeartbeatTime = other782.lastHeartbeatTime;
  __isset = other782.__isset;
}
TxnInfo& TxnInfo::operator=(const TxnInfo& other783) {
  id = other783.id;
  state = other783.state;
  user = other783.user;
  hostname = other783.hostname;
  agentInfo = other783.agentInfo;
  heartbeatCount = other783.heartbeatCount;
  metaInfo = other783.metaInfo;
  startedTime = other783.startedTime;
  lastHeartbeatTime = other783.lastHeartbeatTime;
  __isset = other783.__isset;
  return *this;
}
void TxnInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TxnInfo(";
  out << "id=" << to_string(id);
  out << ", " << "state=" << to_string(state);
  out << ", " << "user=" << to_string(user);
  out << ", " << "hostname=" << to_string(hostname);
  out << ", " << "agentInfo="; (__isset.agentInfo ? (out << to_string(agentInfo)) : (out << "<null>"));
  out << ", " << "heartbeatCount="; (__isset.heartbeatCount ? (out << to_string(heartbeatCount)) : (out << "<null>"));
  out << ", " << "metaInfo="; (__isset.metaInfo ? (out << to_string(metaInfo)) : (out << "<null>"));
  out << ", " << "startedTime="; (__isset.startedTime ? (out << to_string(startedTime)) : (out << "<null>"));
  out << ", " << "lastHeartbeatTime="; (__isset.lastHeartbeatTime ? (out << to_string(lastHeartbeatTime)) : (out << "<null>"));
  out << ")";
}


GetOpenTxnsInfoResponse::~GetOpenTxnsInfoResponse() noexcept {
}


void GetOpenTxnsInfoResponse::__set_txn_high_water_mark(const int64_t val) {
  this->txn_high_water_mark = val;
}

void GetOpenTxnsInfoResponse::__set_open_txns(const std::vector<TxnInfo> & val) {
  this->open_txns = val;
}
std::ostream& operator<<(std::ostream& out, const GetOpenTxnsInfoResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetOpenTxnsInfoResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txn_high_water_mark = false;
  bool isset_open_txns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txn_high_water_mark);
          isset_txn_high_water_mark = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->open_txns.clear();
            uint32_t _size784;
            ::apache::thrift::protocol::TType _etype787;
            xfer += iprot->readListBegin(_etype787, _size784);
            this->open_txns.resize(_size784);
            uint32_t _i788;
            for (_i788 = 0; _i788 < _size784; ++_i788)
            {
              xfer += this->open_txns[_i788].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_open_txns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txn_high_water_mark)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_open_txns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetOpenTxnsInfoResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetOpenTxnsInfoResponse");

  xfer += oprot->writeFieldBegin("txn_high_water_mark", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txn_high_water_mark);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("open_txns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->open_txns.size()));
    std::vector<TxnInfo> ::const_iterator _iter789;
    for (_iter789 = this->open_txns.begin(); _iter789 != this->open_txns.end(); ++_iter789)
    {
      xfer += (*_iter789).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetOpenTxnsInfoResponse &a, GetOpenTxnsInfoResponse &b) {
  using ::std::swap;
  swap(a.txn_high_water_mark, b.txn_high_water_mark);
  swap(a.open_txns, b.open_txns);
}

GetOpenTxnsInfoResponse::GetOpenTxnsInfoResponse(const GetOpenTxnsInfoResponse& other790) {
  txn_high_water_mark = other790.txn_high_water_mark;
  open_txns = other790.open_txns;
}
GetOpenTxnsInfoResponse& GetOpenTxnsInfoResponse::operator=(const GetOpenTxnsInfoResponse& other791) {
  txn_high_water_mark = other791.txn_high_water_mark;
  open_txns = other791.open_txns;
  return *this;
}
void GetOpenTxnsInfoResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetOpenTxnsInfoResponse(";
  out << "txn_high_water_mark=" << to_string(txn_high_water_mark);
  out << ", " << "open_txns=" << to_string(open_txns);
  out << ")";
}


GetOpenTxnsResponse::~GetOpenTxnsResponse() noexcept {
}


void GetOpenTxnsResponse::__set_txn_high_water_mark(const int64_t val) {
  this->txn_high_water_mark = val;
}

void GetOpenTxnsResponse::__set_open_txns(const std::vector<int64_t> & val) {
  this->open_txns = val;
}

void GetOpenTxnsResponse::__set_min_open_txn(const int64_t val) {
  this->min_open_txn = val;
__isset.min_open_txn = true;
}

void GetOpenTxnsResponse::__set_abortedBits(const std::string& val) {
  this->abortedBits = val;
}
std::ostream& operator<<(std::ostream& out, const GetOpenTxnsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetOpenTxnsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txn_high_water_mark = false;
  bool isset_open_txns = false;
  bool isset_abortedBits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txn_high_water_mark);
          isset_txn_high_water_mark = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->open_txns.clear();
            uint32_t _size792;
            ::apache::thrift::protocol::TType _etype795;
            xfer += iprot->readListBegin(_etype795, _size792);
            this->open_txns.resize(_size792);
            uint32_t _i796;
            for (_i796 = 0; _i796 < _size792; ++_i796)
            {
              xfer += iprot->readI64(this->open_txns[_i796]);
            }
            xfer += iprot->readListEnd();
          }
          isset_open_txns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->min_open_txn);
          this->__isset.min_open_txn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->abortedBits);
          isset_abortedBits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txn_high_water_mark)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_open_txns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_abortedBits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetOpenTxnsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetOpenTxnsResponse");

  xfer += oprot->writeFieldBegin("txn_high_water_mark", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txn_high_water_mark);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("open_txns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->open_txns.size()));
    std::vector<int64_t> ::const_iterator _iter797;
    for (_iter797 = this->open_txns.begin(); _iter797 != this->open_txns.end(); ++_iter797)
    {
      xfer += oprot->writeI64((*_iter797));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.min_open_txn) {
    xfer += oprot->writeFieldBegin("min_open_txn", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->min_open_txn);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("abortedBits", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->abortedBits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetOpenTxnsResponse &a, GetOpenTxnsResponse &b) {
  using ::std::swap;
  swap(a.txn_high_water_mark, b.txn_high_water_mark);
  swap(a.open_txns, b.open_txns);
  swap(a.min_open_txn, b.min_open_txn);
  swap(a.abortedBits, b.abortedBits);
  swap(a.__isset, b.__isset);
}

GetOpenTxnsResponse::GetOpenTxnsResponse(const GetOpenTxnsResponse& other798) {
  txn_high_water_mark = other798.txn_high_water_mark;
  open_txns = other798.open_txns;
  min_open_txn = other798.min_open_txn;
  abortedBits = other798.abortedBits;
  __isset = other798.__isset;
}
GetOpenTxnsResponse& GetOpenTxnsResponse::operator=(const GetOpenTxnsResponse& other799) {
  txn_high_water_mark = other799.txn_high_water_mark;
  open_txns = other799.open_txns;
  min_open_txn = other799.min_open_txn;
  abortedBits = other799.abortedBits;
  __isset = other799.__isset;
  return *this;
}
void GetOpenTxnsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetOpenTxnsResponse(";
  out << "txn_high_water_mark=" << to_string(txn_high_water_mark);
  out << ", " << "open_txns=" << to_string(open_txns);
  out << ", " << "min_open_txn="; (__isset.min_open_txn ? (out << to_string(min_open_txn)) : (out << "<null>"));
  out << ", " << "abortedBits=" << to_string(abortedBits);
  out << ")";
}


OpenTxnRequest::~OpenTxnRequest() noexcept {
}


void OpenTxnRequest::__set_num_txns(const int32_t val) {
  this->num_txns = val;
}

void OpenTxnRequest::__set_user(const std::string& val) {
  this->user = val;
}

void OpenTxnRequest::__set_hostname(const std::string& val) {
  this->hostname = val;
}

void OpenTxnRequest::__set_agentInfo(const std::string& val) {
  this->agentInfo = val;
__isset.agentInfo = true;
}

void OpenTxnRequest::__set_replPolicy(const std::string& val) {
  this->replPolicy = val;
__isset.replPolicy = true;
}

void OpenTxnRequest::__set_replSrcTxnIds(const std::vector<int64_t> & val) {
  this->replSrcTxnIds = val;
__isset.replSrcTxnIds = true;
}

void OpenTxnRequest::__set_txn_type(const TxnType::type val) {
  this->txn_type = val;
__isset.txn_type = true;
}
std::ostream& operator<<(std::ostream& out, const OpenTxnRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t OpenTxnRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_num_txns = false;
  bool isset_user = false;
  bool isset_hostname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_txns);
          isset_num_txns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          isset_hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agentInfo);
          this->__isset.agentInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replPolicy);
          this->__isset.replPolicy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->replSrcTxnIds.clear();
            uint32_t _size800;
            ::apache::thrift::protocol::TType _etype803;
            xfer += iprot->readListBegin(_etype803, _size800);
            this->replSrcTxnIds.resize(_size800);
            uint32_t _i804;
            for (_i804 = 0; _i804 < _size800; ++_i804)
            {
              xfer += iprot->readI64(this->replSrcTxnIds[_i804]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.replSrcTxnIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast805;
          xfer += iprot->readI32(ecast805);
          this->txn_type = static_cast<TxnType::type>(ecast805);
          this->__isset.txn_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_num_txns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hostname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t OpenTxnRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OpenTxnRequest");

  xfer += oprot->writeFieldBegin("num_txns", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->num_txns);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.agentInfo) {
    xfer += oprot->writeFieldBegin("agentInfo", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->agentInfo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replPolicy) {
    xfer += oprot->writeFieldBegin("replPolicy", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->replPolicy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replSrcTxnIds) {
    xfer += oprot->writeFieldBegin("replSrcTxnIds", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->replSrcTxnIds.size()));
      std::vector<int64_t> ::const_iterator _iter806;
      for (_iter806 = this->replSrcTxnIds.begin(); _iter806 != this->replSrcTxnIds.end(); ++_iter806)
      {
        xfer += oprot->writeI64((*_iter806));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.txn_type) {
    xfer += oprot->writeFieldBegin("txn_type", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(static_cast<int32_t>(this->txn_type));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OpenTxnRequest &a, OpenTxnRequest &b) {
  using ::std::swap;
  swap(a.num_txns, b.num_txns);
  swap(a.user, b.user);
  swap(a.hostname, b.hostname);
  swap(a.agentInfo, b.agentInfo);
  swap(a.replPolicy, b.replPolicy);
  swap(a.replSrcTxnIds, b.replSrcTxnIds);
  swap(a.txn_type, b.txn_type);
  swap(a.__isset, b.__isset);
}

OpenTxnRequest::OpenTxnRequest(const OpenTxnRequest& other807) {
  num_txns = other807.num_txns;
  user = other807.user;
  hostname = other807.hostname;
  agentInfo = other807.agentInfo;
  replPolicy = other807.replPolicy;
  replSrcTxnIds = other807.replSrcTxnIds;
  txn_type = other807.txn_type;
  __isset = other807.__isset;
}
OpenTxnRequest& OpenTxnRequest::operator=(const OpenTxnRequest& other808) {
  num_txns = other808.num_txns;
  user = other808.user;
  hostname = other808.hostname;
  agentInfo = other808.agentInfo;
  replPolicy = other808.replPolicy;
  replSrcTxnIds = other808.replSrcTxnIds;
  txn_type = other808.txn_type;
  __isset = other808.__isset;
  return *this;
}
void OpenTxnRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OpenTxnRequest(";
  out << "num_txns=" << to_string(num_txns);
  out << ", " << "user=" << to_string(user);
  out << ", " << "hostname=" << to_string(hostname);
  out << ", " << "agentInfo="; (__isset.agentInfo ? (out << to_string(agentInfo)) : (out << "<null>"));
  out << ", " << "replPolicy="; (__isset.replPolicy ? (out << to_string(replPolicy)) : (out << "<null>"));
  out << ", " << "replSrcTxnIds="; (__isset.replSrcTxnIds ? (out << to_string(replSrcTxnIds)) : (out << "<null>"));
  out << ", " << "txn_type="; (__isset.txn_type ? (out << to_string(txn_type)) : (out << "<null>"));
  out << ")";
}


OpenTxnsResponse::~OpenTxnsResponse() noexcept {
}


void OpenTxnsResponse::__set_txn_ids(const std::vector<int64_t> & val) {
  this->txn_ids = val;
}
std::ostream& operator<<(std::ostream& out, const OpenTxnsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t OpenTxnsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txn_ids = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->txn_ids.clear();
            uint32_t _size809;
            ::apache::thrift::protocol::TType _etype812;
            xfer += iprot->readListBegin(_etype812, _size809);
            this->txn_ids.resize(_size809);
            uint32_t _i813;
            for (_i813 = 0; _i813 < _size809; ++_i813)
            {
              xfer += iprot->readI64(this->txn_ids[_i813]);
            }
            xfer += iprot->readListEnd();
          }
          isset_txn_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txn_ids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t OpenTxnsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OpenTxnsResponse");

  xfer += oprot->writeFieldBegin("txn_ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->txn_ids.size()));
    std::vector<int64_t> ::const_iterator _iter814;
    for (_iter814 = this->txn_ids.begin(); _iter814 != this->txn_ids.end(); ++_iter814)
    {
      xfer += oprot->writeI64((*_iter814));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OpenTxnsResponse &a, OpenTxnsResponse &b) {
  using ::std::swap;
  swap(a.txn_ids, b.txn_ids);
}

OpenTxnsResponse::OpenTxnsResponse(const OpenTxnsResponse& other815) {
  txn_ids = other815.txn_ids;
}
OpenTxnsResponse& OpenTxnsResponse::operator=(const OpenTxnsResponse& other816) {
  txn_ids = other816.txn_ids;
  return *this;
}
void OpenTxnsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OpenTxnsResponse(";
  out << "txn_ids=" << to_string(txn_ids);
  out << ")";
}


AbortTxnRequest::~AbortTxnRequest() noexcept {
}


void AbortTxnRequest::__set_txnid(const int64_t val) {
  this->txnid = val;
}

void AbortTxnRequest::__set_replPolicy(const std::string& val) {
  this->replPolicy = val;
__isset.replPolicy = true;
}

void AbortTxnRequest::__set_txn_type(const TxnType::type val) {
  this->txn_type = val;
__isset.txn_type = true;
}

void AbortTxnRequest::__set_errorCode(const int64_t val) {
  this->errorCode = val;
__isset.errorCode = true;
}
std::ostream& operator<<(std::ostream& out, const AbortTxnRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AbortTxnRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txnid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          isset_txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replPolicy);
          this->__isset.replPolicy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast817;
          xfer += iprot->readI32(ecast817);
          this->txn_type = static_cast<TxnType::type>(ecast817);
          this->__isset.txn_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->errorCode);
          this->__isset.errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txnid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AbortTxnRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AbortTxnRequest");

  xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txnid);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.replPolicy) {
    xfer += oprot->writeFieldBegin("replPolicy", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->replPolicy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.txn_type) {
    xfer += oprot->writeFieldBegin("txn_type", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(static_cast<int32_t>(this->txn_type));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.errorCode) {
    xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->errorCode);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AbortTxnRequest &a, AbortTxnRequest &b) {
  using ::std::swap;
  swap(a.txnid, b.txnid);
  swap(a.replPolicy, b.replPolicy);
  swap(a.txn_type, b.txn_type);
  swap(a.errorCode, b.errorCode);
  swap(a.__isset, b.__isset);
}

AbortTxnRequest::AbortTxnRequest(const AbortTxnRequest& other818) {
  txnid = other818.txnid;
  replPolicy = other818.replPolicy;
  txn_type = other818.txn_type;
  errorCode = other818.errorCode;
  __isset = other818.__isset;
}
AbortTxnRequest& AbortTxnRequest::operator=(const AbortTxnRequest& other819) {
  txnid = other819.txnid;
  replPolicy = other819.replPolicy;
  txn_type = other819.txn_type;
  errorCode = other819.errorCode;
  __isset = other819.__isset;
  return *this;
}
void AbortTxnRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AbortTxnRequest(";
  out << "txnid=" << to_string(txnid);
  out << ", " << "replPolicy="; (__isset.replPolicy ? (out << to_string(replPolicy)) : (out << "<null>"));
  out << ", " << "txn_type="; (__isset.txn_type ? (out << to_string(txn_type)) : (out << "<null>"));
  out << ", " << "errorCode="; (__isset.errorCode ? (out << to_string(errorCode)) : (out << "<null>"));
  out << ")";
}


AbortTxnsRequest::~AbortTxnsRequest() noexcept {
}


void AbortTxnsRequest::__set_txn_ids(const std::vector<int64_t> & val) {
  this->txn_ids = val;
}

void AbortTxnsRequest::__set_errorCode(const int64_t val) {
  this->errorCode = val;
__isset.errorCode = true;
}
std::ostream& operator<<(std::ostream& out, const AbortTxnsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AbortTxnsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txn_ids = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->txn_ids.clear();
            uint32_t _size820;
            ::apache::thrift::protocol::TType _etype823;
            xfer += iprot->readListBegin(_etype823, _size820);
            this->txn_ids.resize(_size820);
            uint32_t _i824;
            for (_i824 = 0; _i824 < _size820; ++_i824)
            {
              xfer += iprot->readI64(this->txn_ids[_i824]);
            }
            xfer += iprot->readListEnd();
          }
          isset_txn_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->errorCode);
          this->__isset.errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txn_ids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AbortTxnsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AbortTxnsRequest");

  xfer += oprot->writeFieldBegin("txn_ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->txn_ids.size()));
    std::vector<int64_t> ::const_iterator _iter825;
    for (_iter825 = this->txn_ids.begin(); _iter825 != this->txn_ids.end(); ++_iter825)
    {
      xfer += oprot->writeI64((*_iter825));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.errorCode) {
    xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->errorCode);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AbortTxnsRequest &a, AbortTxnsRequest &b) {
  using ::std::swap;
  swap(a.txn_ids, b.txn_ids);
  swap(a.errorCode, b.errorCode);
  swap(a.__isset, b.__isset);
}

AbortTxnsRequest::AbortTxnsRequest(const AbortTxnsRequest& other826) {
  txn_ids = other826.txn_ids;
  errorCode = other826.errorCode;
  __isset = other826.__isset;
}
AbortTxnsRequest& AbortTxnsRequest::operator=(const AbortTxnsRequest& other827) {
  txn_ids = other827.txn_ids;
  errorCode = other827.errorCode;
  __isset = other827.__isset;
  return *this;
}
void AbortTxnsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AbortTxnsRequest(";
  out << "txn_ids=" << to_string(txn_ids);
  out << ", " << "errorCode="; (__isset.errorCode ? (out << to_string(errorCode)) : (out << "<null>"));
  out << ")";
}


CommitTxnKeyValue::~CommitTxnKeyValue() noexcept {
}


void CommitTxnKeyValue::__set_tableId(const int64_t val) {
  this->tableId = val;
}

void CommitTxnKeyValue::__set_key(const std::string& val) {
  this->key = val;
}

void CommitTxnKeyValue::__set_value(const std::string& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const CommitTxnKeyValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CommitTxnKeyValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tableId = false;
  bool isset_key = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tableId);
          isset_tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          isset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tableId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CommitTxnKeyValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CommitTxnKeyValue");

  xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tableId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CommitTxnKeyValue &a, CommitTxnKeyValue &b) {
  using ::std::swap;
  swap(a.tableId, b.tableId);
  swap(a.key, b.key);
  swap(a.value, b.value);
}

CommitTxnKeyValue::CommitTxnKeyValue(const CommitTxnKeyValue& other828) {
  tableId = other828.tableId;
  key = other828.key;
  value = other828.value;
}
CommitTxnKeyValue& CommitTxnKeyValue::operator=(const CommitTxnKeyValue& other829) {
  tableId = other829.tableId;
  key = other829.key;
  value = other829.value;
  return *this;
}
void CommitTxnKeyValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CommitTxnKeyValue(";
  out << "tableId=" << to_string(tableId);
  out << ", " << "key=" << to_string(key);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


WriteEventInfo::~WriteEventInfo() noexcept {
}


void WriteEventInfo::__set_writeId(const int64_t val) {
  this->writeId = val;
}

void WriteEventInfo::__set_database(const std::string& val) {
  this->database = val;
}

void WriteEventInfo::__set_table(const std::string& val) {
  this->table = val;
}

void WriteEventInfo::__set_files(const std::string& val) {
  this->files = val;
}

void WriteEventInfo::__set_partition(const std::string& val) {
  this->partition = val;
__isset.partition = true;
}

void WriteEventInfo::__set_tableObj(const std::string& val) {
  this->tableObj = val;
__isset.tableObj = true;
}

void WriteEventInfo::__set_partitionObj(const std::string& val) {
  this->partitionObj = val;
__isset.partitionObj = true;
}
std::ostream& operator<<(std::ostream& out, const WriteEventInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WriteEventInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_writeId = false;
  bool isset_database = false;
  bool isset_table = false;
  bool isset_files = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          isset_writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->database);
          isset_database = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table);
          isset_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->files);
          isset_files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partition);
          this->__isset.partition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableObj);
          this->__isset.tableObj = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partitionObj);
          this->__isset.partitionObj = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_writeId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_database)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_files)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WriteEventInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WriteEventInfo");

  xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->writeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("database", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->database);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("files", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->files);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition) {
    xfer += oprot->writeFieldBegin("partition", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->partition);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableObj) {
    xfer += oprot->writeFieldBegin("tableObj", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->tableObj);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionObj) {
    xfer += oprot->writeFieldBegin("partitionObj", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->partitionObj);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WriteEventInfo &a, WriteEventInfo &b) {
  using ::std::swap;
  swap(a.writeId, b.writeId);
  swap(a.database, b.database);
  swap(a.table, b.table);
  swap(a.files, b.files);
  swap(a.partition, b.partition);
  swap(a.tableObj, b.tableObj);
  swap(a.partitionObj, b.partitionObj);
  swap(a.__isset, b.__isset);
}

WriteEventInfo::WriteEventInfo(const WriteEventInfo& other830) {
  writeId = other830.writeId;
  database = other830.database;
  table = other830.table;
  files = other830.files;
  partition = other830.partition;
  tableObj = other830.tableObj;
  partitionObj = other830.partitionObj;
  __isset = other830.__isset;
}
WriteEventInfo& WriteEventInfo::operator=(const WriteEventInfo& other831) {
  writeId = other831.writeId;
  database = other831.database;
  table = other831.table;
  files = other831.files;
  partition = other831.partition;
  tableObj = other831.tableObj;
  partitionObj = other831.partitionObj;
  __isset = other831.__isset;
  return *this;
}
void WriteEventInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WriteEventInfo(";
  out << "writeId=" << to_string(writeId);
  out << ", " << "database=" << to_string(database);
  out << ", " << "table=" << to_string(table);
  out << ", " << "files=" << to_string(files);
  out << ", " << "partition="; (__isset.partition ? (out << to_string(partition)) : (out << "<null>"));
  out << ", " << "tableObj="; (__isset.tableObj ? (out << to_string(tableObj)) : (out << "<null>"));
  out << ", " << "partitionObj="; (__isset.partitionObj ? (out << to_string(partitionObj)) : (out << "<null>"));
  out << ")";
}


ReplLastIdInfo::~ReplLastIdInfo() noexcept {
}


void ReplLastIdInfo::__set_database(const std::string& val) {
  this->database = val;
}

void ReplLastIdInfo::__set_lastReplId(const int64_t val) {
  this->lastReplId = val;
}

void ReplLastIdInfo::__set_table(const std::string& val) {
  this->table = val;
__isset.table = true;
}

void ReplLastIdInfo::__set_catalog(const std::string& val) {
  this->catalog = val;
__isset.catalog = true;
}

void ReplLastIdInfo::__set_partitionList(const std::vector<std::string> & val) {
  this->partitionList = val;
__isset.partitionList = true;
}
std::ostream& operator<<(std::ostream& out, const ReplLastIdInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ReplLastIdInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_database = false;
  bool isset_lastReplId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->database);
          isset_database = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastReplId);
          isset_lastReplId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table);
          this->__isset.table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalog);
          this->__isset.catalog = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionList.clear();
            uint32_t _size832;
            ::apache::thrift::protocol::TType _etype835;
            xfer += iprot->readListBegin(_etype835, _size832);
            this->partitionList.resize(_size832);
            uint32_t _i836;
            for (_i836 = 0; _i836 < _size832; ++_i836)
            {
              xfer += iprot->readString(this->partitionList[_i836]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_database)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_lastReplId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ReplLastIdInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ReplLastIdInfo");

  xfer += oprot->writeFieldBegin("database", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->database);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastReplId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->lastReplId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.table) {
    xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->table);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalog) {
    xfer += oprot->writeFieldBegin("catalog", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->catalog);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionList) {
    xfer += oprot->writeFieldBegin("partitionList", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partitionList.size()));
      std::vector<std::string> ::const_iterator _iter837;
      for (_iter837 = this->partitionList.begin(); _iter837 != this->partitionList.end(); ++_iter837)
      {
        xfer += oprot->writeString((*_iter837));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReplLastIdInfo &a, ReplLastIdInfo &b) {
  using ::std::swap;
  swap(a.database, b.database);
  swap(a.lastReplId, b.lastReplId);
  swap(a.table, b.table);
  swap(a.catalog, b.catalog);
  swap(a.partitionList, b.partitionList);
  swap(a.__isset, b.__isset);
}

ReplLastIdInfo::ReplLastIdInfo(const ReplLastIdInfo& other838) {
  database = other838.database;
  lastReplId = other838.lastReplId;
  table = other838.table;
  catalog = other838.catalog;
  partitionList = other838.partitionList;
  __isset = other838.__isset;
}
ReplLastIdInfo& ReplLastIdInfo::operator=(const ReplLastIdInfo& other839) {
  database = other839.database;
  lastReplId = other839.lastReplId;
  table = other839.table;
  catalog = other839.catalog;
  partitionList = other839.partitionList;
  __isset = other839.__isset;
  return *this;
}
void ReplLastIdInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ReplLastIdInfo(";
  out << "database=" << to_string(database);
  out << ", " << "lastReplId=" << to_string(lastReplId);
  out << ", " << "table="; (__isset.table ? (out << to_string(table)) : (out << "<null>"));
  out << ", " << "catalog="; (__isset.catalog ? (out << to_string(catalog)) : (out << "<null>"));
  out << ", " << "partitionList="; (__isset.partitionList ? (out << to_string(partitionList)) : (out << "<null>"));
  out << ")";
}


UpdateTransactionalStatsRequest::~UpdateTransactionalStatsRequest() noexcept {
}


void UpdateTransactionalStatsRequest::__set_tableId(const int64_t val) {
  this->tableId = val;
}

void UpdateTransactionalStatsRequest::__set_insertCount(const int64_t val) {
  this->insertCount = val;
}

void UpdateTransactionalStatsRequest::__set_updatedCount(const int64_t val) {
  this->updatedCount = val;
}

void UpdateTransactionalStatsRequest::__set_deletedCount(const int64_t val) {
  this->deletedCount = val;
}
std::ostream& operator<<(std::ostream& out, const UpdateTransactionalStatsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UpdateTransactionalStatsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tableId = false;
  bool isset_insertCount = false;
  bool isset_updatedCount = false;
  bool isset_deletedCount = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tableId);
          isset_tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->insertCount);
          isset_insertCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->updatedCount);
          isset_updatedCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->deletedCount);
          isset_deletedCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tableId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_insertCount)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_updatedCount)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_deletedCount)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UpdateTransactionalStatsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UpdateTransactionalStatsRequest");

  xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tableId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("insertCount", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->insertCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updatedCount", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->updatedCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deletedCount", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->deletedCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateTransactionalStatsRequest &a, UpdateTransactionalStatsRequest &b) {
  using ::std::swap;
  swap(a.tableId, b.tableId);
  swap(a.insertCount, b.insertCount);
  swap(a.updatedCount, b.updatedCount);
  swap(a.deletedCount, b.deletedCount);
}

UpdateTransactionalStatsRequest::UpdateTransactionalStatsRequest(const UpdateTransactionalStatsRequest& other840) noexcept {
  tableId = other840.tableId;
  insertCount = other840.insertCount;
  updatedCount = other840.updatedCount;
  deletedCount = other840.deletedCount;
}
UpdateTransactionalStatsRequest& UpdateTransactionalStatsRequest::operator=(const UpdateTransactionalStatsRequest& other841) noexcept {
  tableId = other841.tableId;
  insertCount = other841.insertCount;
  updatedCount = other841.updatedCount;
  deletedCount = other841.deletedCount;
  return *this;
}
void UpdateTransactionalStatsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UpdateTransactionalStatsRequest(";
  out << "tableId=" << to_string(tableId);
  out << ", " << "insertCount=" << to_string(insertCount);
  out << ", " << "updatedCount=" << to_string(updatedCount);
  out << ", " << "deletedCount=" << to_string(deletedCount);
  out << ")";
}


CommitTxnRequest::~CommitTxnRequest() noexcept {
}


void CommitTxnRequest::__set_txnid(const int64_t val) {
  this->txnid = val;
}

void CommitTxnRequest::__set_replPolicy(const std::string& val) {
  this->replPolicy = val;
__isset.replPolicy = true;
}

void CommitTxnRequest::__set_writeEventInfos(const std::vector<WriteEventInfo> & val) {
  this->writeEventInfos = val;
__isset.writeEventInfos = true;
}

void CommitTxnRequest::__set_replLastIdInfo(const ReplLastIdInfo& val) {
  this->replLastIdInfo = val;
__isset.replLastIdInfo = true;
}

void CommitTxnRequest::__set_keyValue(const CommitTxnKeyValue& val) {
  this->keyValue = val;
__isset.keyValue = true;
}

void CommitTxnRequest::__set_exclWriteEnabled(const bool val) {
  this->exclWriteEnabled = val;
__isset.exclWriteEnabled = true;
}

void CommitTxnRequest::__set_txn_type(const TxnType::type val) {
  this->txn_type = val;
__isset.txn_type = true;
}
std::ostream& operator<<(std::ostream& out, const CommitTxnRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CommitTxnRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txnid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          isset_txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replPolicy);
          this->__isset.replPolicy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->writeEventInfos.clear();
            uint32_t _size842;
            ::apache::thrift::protocol::TType _etype845;
            xfer += iprot->readListBegin(_etype845, _size842);
            this->writeEventInfos.resize(_size842);
            uint32_t _i846;
            for (_i846 = 0; _i846 < _size842; ++_i846)
            {
              xfer += this->writeEventInfos[_i846].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.writeEventInfos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->replLastIdInfo.read(iprot);
          this->__isset.replLastIdInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->keyValue.read(iprot);
          this->__isset.keyValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->exclWriteEnabled);
          this->__isset.exclWriteEnabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast847;
          xfer += iprot->readI32(ecast847);
          this->txn_type = static_cast<TxnType::type>(ecast847);
          this->__isset.txn_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txnid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CommitTxnRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CommitTxnRequest");

  xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txnid);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.replPolicy) {
    xfer += oprot->writeFieldBegin("replPolicy", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->replPolicy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writeEventInfos) {
    xfer += oprot->writeFieldBegin("writeEventInfos", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->writeEventInfos.size()));
      std::vector<WriteEventInfo> ::const_iterator _iter848;
      for (_iter848 = this->writeEventInfos.begin(); _iter848 != this->writeEventInfos.end(); ++_iter848)
      {
        xfer += (*_iter848).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replLastIdInfo) {
    xfer += oprot->writeFieldBegin("replLastIdInfo", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->replLastIdInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.keyValue) {
    xfer += oprot->writeFieldBegin("keyValue", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->keyValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exclWriteEnabled) {
    xfer += oprot->writeFieldBegin("exclWriteEnabled", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->exclWriteEnabled);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.txn_type) {
    xfer += oprot->writeFieldBegin("txn_type", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(static_cast<int32_t>(this->txn_type));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CommitTxnRequest &a, CommitTxnRequest &b) {
  using ::std::swap;
  swap(a.txnid, b.txnid);
  swap(a.replPolicy, b.replPolicy);
  swap(a.writeEventInfos, b.writeEventInfos);
  swap(a.replLastIdInfo, b.replLastIdInfo);
  swap(a.keyValue, b.keyValue);
  swap(a.exclWriteEnabled, b.exclWriteEnabled);
  swap(a.txn_type, b.txn_type);
  swap(a.__isset, b.__isset);
}

CommitTxnRequest::CommitTxnRequest(const CommitTxnRequest& other849) {
  txnid = other849.txnid;
  replPolicy = other849.replPolicy;
  writeEventInfos = other849.writeEventInfos;
  replLastIdInfo = other849.replLastIdInfo;
  keyValue = other849.keyValue;
  exclWriteEnabled = other849.exclWriteEnabled;
  txn_type = other849.txn_type;
  __isset = other849.__isset;
}
CommitTxnRequest& CommitTxnRequest::operator=(const CommitTxnRequest& other850) {
  txnid = other850.txnid;
  replPolicy = other850.replPolicy;
  writeEventInfos = other850.writeEventInfos;
  replLastIdInfo = other850.replLastIdInfo;
  keyValue = other850.keyValue;
  exclWriteEnabled = other850.exclWriteEnabled;
  txn_type = other850.txn_type;
  __isset = other850.__isset;
  return *this;
}
void CommitTxnRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CommitTxnRequest(";
  out << "txnid=" << to_string(txnid);
  out << ", " << "replPolicy="; (__isset.replPolicy ? (out << to_string(replPolicy)) : (out << "<null>"));
  out << ", " << "writeEventInfos="; (__isset.writeEventInfos ? (out << to_string(writeEventInfos)) : (out << "<null>"));
  out << ", " << "replLastIdInfo="; (__isset.replLastIdInfo ? (out << to_string(replLastIdInfo)) : (out << "<null>"));
  out << ", " << "keyValue="; (__isset.keyValue ? (out << to_string(keyValue)) : (out << "<null>"));
  out << ", " << "exclWriteEnabled="; (__isset.exclWriteEnabled ? (out << to_string(exclWriteEnabled)) : (out << "<null>"));
  out << ", " << "txn_type="; (__isset.txn_type ? (out << to_string(txn_type)) : (out << "<null>"));
  out << ")";
}


ReplTblWriteIdStateRequest::~ReplTblWriteIdStateRequest() noexcept {
}


void ReplTblWriteIdStateRequest::__set_validWriteIdlist(const std::string& val) {
  this->validWriteIdlist = val;
}

void ReplTblWriteIdStateRequest::__set_user(const std::string& val) {
  this->user = val;
}

void ReplTblWriteIdStateRequest::__set_hostName(const std::string& val) {
  this->hostName = val;
}

void ReplTblWriteIdStateRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void ReplTblWriteIdStateRequest::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void ReplTblWriteIdStateRequest::__set_partNames(const std::vector<std::string> & val) {
  this->partNames = val;
__isset.partNames = true;
}
std::ostream& operator<<(std::ostream& out, const ReplTblWriteIdStateRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ReplTblWriteIdStateRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_validWriteIdlist = false;
  bool isset_user = false;
  bool isset_hostName = false;
  bool isset_dbName = false;
  bool isset_tableName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdlist);
          isset_validWriteIdlist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostName);
          isset_hostName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partNames.clear();
            uint32_t _size851;
            ::apache::thrift::protocol::TType _etype854;
            xfer += iprot->readListBegin(_etype854, _size851);
            this->partNames.resize(_size851);
            uint32_t _i855;
            for (_i855 = 0; _i855 < _size851; ++_i855)
            {
              xfer += iprot->readString(this->partNames[_i855]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_validWriteIdlist)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hostName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ReplTblWriteIdStateRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ReplTblWriteIdStateRequest");

  xfer += oprot->writeFieldBegin("validWriteIdlist", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->validWriteIdlist);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->hostName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partNames) {
    xfer += oprot->writeFieldBegin("partNames", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partNames.size()));
      std::vector<std::string> ::const_iterator _iter856;
      for (_iter856 = this->partNames.begin(); _iter856 != this->partNames.end(); ++_iter856)
      {
        xfer += oprot->writeString((*_iter856));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReplTblWriteIdStateRequest &a, ReplTblWriteIdStateRequest &b) {
  using ::std::swap;
  swap(a.validWriteIdlist, b.validWriteIdlist);
  swap(a.user, b.user);
  swap(a.hostName, b.hostName);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.partNames, b.partNames);
  swap(a.__isset, b.__isset);
}

ReplTblWriteIdStateRequest::ReplTblWriteIdStateRequest(const ReplTblWriteIdStateRequest& other857) {
  validWriteIdlist = other857.validWriteIdlist;
  user = other857.user;
  hostName = other857.hostName;
  dbName = other857.dbName;
  tableName = other857.tableName;
  partNames = other857.partNames;
  __isset = other857.__isset;
}
ReplTblWriteIdStateRequest& ReplTblWriteIdStateRequest::operator=(const ReplTblWriteIdStateRequest& other858) {
  validWriteIdlist = other858.validWriteIdlist;
  user = other858.user;
  hostName = other858.hostName;
  dbName = other858.dbName;
  tableName = other858.tableName;
  partNames = other858.partNames;
  __isset = other858.__isset;
  return *this;
}
void ReplTblWriteIdStateRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ReplTblWriteIdStateRequest(";
  out << "validWriteIdlist=" << to_string(validWriteIdlist);
  out << ", " << "user=" << to_string(user);
  out << ", " << "hostName=" << to_string(hostName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "partNames="; (__isset.partNames ? (out << to_string(partNames)) : (out << "<null>"));
  out << ")";
}


GetValidWriteIdsRequest::~GetValidWriteIdsRequest() noexcept {
}


void GetValidWriteIdsRequest::__set_fullTableNames(const std::vector<std::string> & val) {
  this->fullTableNames = val;
}

void GetValidWriteIdsRequest::__set_validTxnList(const std::string& val) {
  this->validTxnList = val;
__isset.validTxnList = true;
}

void GetValidWriteIdsRequest::__set_writeId(const int64_t val) {
  this->writeId = val;
__isset.writeId = true;
}
std::ostream& operator<<(std::ostream& out, const GetValidWriteIdsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetValidWriteIdsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fullTableNames = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fullTableNames.clear();
            uint32_t _size859;
            ::apache::thrift::protocol::TType _etype862;
            xfer += iprot->readListBegin(_etype862, _size859);
            this->fullTableNames.resize(_size859);
            uint32_t _i863;
            for (_i863 = 0; _i863 < _size859; ++_i863)
            {
              xfer += iprot->readString(this->fullTableNames[_i863]);
            }
            xfer += iprot->readListEnd();
          }
          isset_fullTableNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validTxnList);
          this->__isset.validTxnList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          this->__isset.writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fullTableNames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetValidWriteIdsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetValidWriteIdsRequest");

  xfer += oprot->writeFieldBegin("fullTableNames", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fullTableNames.size()));
    std::vector<std::string> ::const_iterator _iter864;
    for (_iter864 = this->fullTableNames.begin(); _iter864 != this->fullTableNames.end(); ++_iter864)
    {
      xfer += oprot->writeString((*_iter864));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.validTxnList) {
    xfer += oprot->writeFieldBegin("validTxnList", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->validTxnList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writeId) {
    xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->writeId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetValidWriteIdsRequest &a, GetValidWriteIdsRequest &b) {
  using ::std::swap;
  swap(a.fullTableNames, b.fullTableNames);
  swap(a.validTxnList, b.validTxnList);
  swap(a.writeId, b.writeId);
  swap(a.__isset, b.__isset);
}

GetValidWriteIdsRequest::GetValidWriteIdsRequest(const GetValidWriteIdsRequest& other865) {
  fullTableNames = other865.fullTableNames;
  validTxnList = other865.validTxnList;
  writeId = other865.writeId;
  __isset = other865.__isset;
}
GetValidWriteIdsRequest& GetValidWriteIdsRequest::operator=(const GetValidWriteIdsRequest& other866) {
  fullTableNames = other866.fullTableNames;
  validTxnList = other866.validTxnList;
  writeId = other866.writeId;
  __isset = other866.__isset;
  return *this;
}
void GetValidWriteIdsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetValidWriteIdsRequest(";
  out << "fullTableNames=" << to_string(fullTableNames);
  out << ", " << "validTxnList="; (__isset.validTxnList ? (out << to_string(validTxnList)) : (out << "<null>"));
  out << ", " << "writeId="; (__isset.writeId ? (out << to_string(writeId)) : (out << "<null>"));
  out << ")";
}


TableValidWriteIds::~TableValidWriteIds() noexcept {
}


void TableValidWriteIds::__set_fullTableName(const std::string& val) {
  this->fullTableName = val;
}

void TableValidWriteIds::__set_writeIdHighWaterMark(const int64_t val) {
  this->writeIdHighWaterMark = val;
}

void TableValidWriteIds::__set_invalidWriteIds(const std::vector<int64_t> & val) {
  this->invalidWriteIds = val;
}

void TableValidWriteIds::__set_minOpenWriteId(const int64_t val) {
  this->minOpenWriteId = val;
__isset.minOpenWriteId = true;
}

void TableValidWriteIds::__set_abortedBits(const std::string& val) {
  this->abortedBits = val;
}
std::ostream& operator<<(std::ostream& out, const TableValidWriteIds& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TableValidWriteIds::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fullTableName = false;
  bool isset_writeIdHighWaterMark = false;
  bool isset_invalidWriteIds = false;
  bool isset_abortedBits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fullTableName);
          isset_fullTableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeIdHighWaterMark);
          isset_writeIdHighWaterMark = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->invalidWriteIds.clear();
            uint32_t _size867;
            ::apache::thrift::protocol::TType _etype870;
            xfer += iprot->readListBegin(_etype870, _size867);
            this->invalidWriteIds.resize(_size867);
            uint32_t _i871;
            for (_i871 = 0; _i871 < _size867; ++_i871)
            {
              xfer += iprot->readI64(this->invalidWriteIds[_i871]);
            }
            xfer += iprot->readListEnd();
          }
          isset_invalidWriteIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->minOpenWriteId);
          this->__isset.minOpenWriteId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->abortedBits);
          isset_abortedBits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fullTableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_writeIdHighWaterMark)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_invalidWriteIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_abortedBits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TableValidWriteIds::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TableValidWriteIds");

  xfer += oprot->writeFieldBegin("fullTableName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->fullTableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("writeIdHighWaterMark", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->writeIdHighWaterMark);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("invalidWriteIds", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->invalidWriteIds.size()));
    std::vector<int64_t> ::const_iterator _iter872;
    for (_iter872 = this->invalidWriteIds.begin(); _iter872 != this->invalidWriteIds.end(); ++_iter872)
    {
      xfer += oprot->writeI64((*_iter872));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.minOpenWriteId) {
    xfer += oprot->writeFieldBegin("minOpenWriteId", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->minOpenWriteId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("abortedBits", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->abortedBits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableValidWriteIds &a, TableValidWriteIds &b) {
  using ::std::swap;
  swap(a.fullTableName, b.fullTableName);
  swap(a.writeIdHighWaterMark, b.writeIdHighWaterMark);
  swap(a.invalidWriteIds, b.invalidWriteIds);
  swap(a.minOpenWriteId, b.minOpenWriteId);
  swap(a.abortedBits, b.abortedBits);
  swap(a.__isset, b.__isset);
}

TableValidWriteIds::TableValidWriteIds(const TableValidWriteIds& other873) {
  fullTableName = other873.fullTableName;
  writeIdHighWaterMark = other873.writeIdHighWaterMark;
  invalidWriteIds = other873.invalidWriteIds;
  minOpenWriteId = other873.minOpenWriteId;
  abortedBits = other873.abortedBits;
  __isset = other873.__isset;
}
TableValidWriteIds& TableValidWriteIds::operator=(const TableValidWriteIds& other874) {
  fullTableName = other874.fullTableName;
  writeIdHighWaterMark = other874.writeIdHighWaterMark;
  invalidWriteIds = other874.invalidWriteIds;
  minOpenWriteId = other874.minOpenWriteId;
  abortedBits = other874.abortedBits;
  __isset = other874.__isset;
  return *this;
}
void TableValidWriteIds::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TableValidWriteIds(";
  out << "fullTableName=" << to_string(fullTableName);
  out << ", " << "writeIdHighWaterMark=" << to_string(writeIdHighWaterMark);
  out << ", " << "invalidWriteIds=" << to_string(invalidWriteIds);
  out << ", " << "minOpenWriteId="; (__isset.minOpenWriteId ? (out << to_string(minOpenWriteId)) : (out << "<null>"));
  out << ", " << "abortedBits=" << to_string(abortedBits);
  out << ")";
}


GetValidWriteIdsResponse::~GetValidWriteIdsResponse() noexcept {
}


void GetValidWriteIdsResponse::__set_tblValidWriteIds(const std::vector<TableValidWriteIds> & val) {
  this->tblValidWriteIds = val;
}
std::ostream& operator<<(std::ostream& out, const GetValidWriteIdsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetValidWriteIdsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tblValidWriteIds = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tblValidWriteIds.clear();
            uint32_t _size875;
            ::apache::thrift::protocol::TType _etype878;
            xfer += iprot->readListBegin(_etype878, _size875);
            this->tblValidWriteIds.resize(_size875);
            uint32_t _i879;
            for (_i879 = 0; _i879 < _size875; ++_i879)
            {
              xfer += this->tblValidWriteIds[_i879].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_tblValidWriteIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tblValidWriteIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetValidWriteIdsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetValidWriteIdsResponse");

  xfer += oprot->writeFieldBegin("tblValidWriteIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tblValidWriteIds.size()));
    std::vector<TableValidWriteIds> ::const_iterator _iter880;
    for (_iter880 = this->tblValidWriteIds.begin(); _iter880 != this->tblValidWriteIds.end(); ++_iter880)
    {
      xfer += (*_iter880).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetValidWriteIdsResponse &a, GetValidWriteIdsResponse &b) {
  using ::std::swap;
  swap(a.tblValidWriteIds, b.tblValidWriteIds);
}

GetValidWriteIdsResponse::GetValidWriteIdsResponse(const GetValidWriteIdsResponse& other881) {
  tblValidWriteIds = other881.tblValidWriteIds;
}
GetValidWriteIdsResponse& GetValidWriteIdsResponse::operator=(const GetValidWriteIdsResponse& other882) {
  tblValidWriteIds = other882.tblValidWriteIds;
  return *this;
}
void GetValidWriteIdsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetValidWriteIdsResponse(";
  out << "tblValidWriteIds=" << to_string(tblValidWriteIds);
  out << ")";
}


TxnToWriteId::~TxnToWriteId() noexcept {
}


void TxnToWriteId::__set_txnId(const int64_t val) {
  this->txnId = val;
}

void TxnToWriteId::__set_writeId(const int64_t val) {
  this->writeId = val;
}
std::ostream& operator<<(std::ostream& out, const TxnToWriteId& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TxnToWriteId::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txnId = false;
  bool isset_writeId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnId);
          isset_txnId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          isset_writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txnId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_writeId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TxnToWriteId::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TxnToWriteId");

  xfer += oprot->writeFieldBegin("txnId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txnId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->writeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TxnToWriteId &a, TxnToWriteId &b) {
  using ::std::swap;
  swap(a.txnId, b.txnId);
  swap(a.writeId, b.writeId);
}

TxnToWriteId::TxnToWriteId(const TxnToWriteId& other883) noexcept {
  txnId = other883.txnId;
  writeId = other883.writeId;
}
TxnToWriteId& TxnToWriteId::operator=(const TxnToWriteId& other884) noexcept {
  txnId = other884.txnId;
  writeId = other884.writeId;
  return *this;
}
void TxnToWriteId::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TxnToWriteId(";
  out << "txnId=" << to_string(txnId);
  out << ", " << "writeId=" << to_string(writeId);
  out << ")";
}


AllocateTableWriteIdsRequest::~AllocateTableWriteIdsRequest() noexcept {
}


void AllocateTableWriteIdsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void AllocateTableWriteIdsRequest::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void AllocateTableWriteIdsRequest::__set_txnIds(const std::vector<int64_t> & val) {
  this->txnIds = val;
__isset.txnIds = true;
}

void AllocateTableWriteIdsRequest::__set_replPolicy(const std::string& val) {
  this->replPolicy = val;
__isset.replPolicy = true;
}

void AllocateTableWriteIdsRequest::__set_srcTxnToWriteIdList(const std::vector<TxnToWriteId> & val) {
  this->srcTxnToWriteIdList = val;
__isset.srcTxnToWriteIdList = true;
}

void AllocateTableWriteIdsRequest::__set_reallocate(const bool val) {
  this->reallocate = val;
__isset.reallocate = true;
}
std::ostream& operator<<(std::ostream& out, const AllocateTableWriteIdsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AllocateTableWriteIdsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tableName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->txnIds.clear();
            uint32_t _size885;
            ::apache::thrift::protocol::TType _etype888;
            xfer += iprot->readListBegin(_etype888, _size885);
            this->txnIds.resize(_size885);
            uint32_t _i889;
            for (_i889 = 0; _i889 < _size885; ++_i889)
            {
              xfer += iprot->readI64(this->txnIds[_i889]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.txnIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replPolicy);
          this->__isset.replPolicy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->srcTxnToWriteIdList.clear();
            uint32_t _size890;
            ::apache::thrift::protocol::TType _etype893;
            xfer += iprot->readListBegin(_etype893, _size890);
            this->srcTxnToWriteIdList.resize(_size890);
            uint32_t _i894;
            for (_i894 = 0; _i894 < _size890; ++_i894)
            {
              xfer += this->srcTxnToWriteIdList[_i894].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.srcTxnToWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->reallocate);
          this->__isset.reallocate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AllocateTableWriteIdsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AllocateTableWriteIdsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.txnIds) {
    xfer += oprot->writeFieldBegin("txnIds", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->txnIds.size()));
      std::vector<int64_t> ::const_iterator _iter895;
      for (_iter895 = this->txnIds.begin(); _iter895 != this->txnIds.end(); ++_iter895)
      {
        xfer += oprot->writeI64((*_iter895));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replPolicy) {
    xfer += oprot->writeFieldBegin("replPolicy", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->replPolicy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.srcTxnToWriteIdList) {
    xfer += oprot->writeFieldBegin("srcTxnToWriteIdList", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->srcTxnToWriteIdList.size()));
      std::vector<TxnToWriteId> ::const_iterator _iter896;
      for (_iter896 = this->srcTxnToWriteIdList.begin(); _iter896 != this->srcTxnToWriteIdList.end(); ++_iter896)
      {
        xfer += (*_iter896).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.reallocate) {
    xfer += oprot->writeFieldBegin("reallocate", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->reallocate);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AllocateTableWriteIdsRequest &a, AllocateTableWriteIdsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.txnIds, b.txnIds);
  swap(a.replPolicy, b.replPolicy);
  swap(a.srcTxnToWriteIdList, b.srcTxnToWriteIdList);
  swap(a.reallocate, b.reallocate);
  swap(a.__isset, b.__isset);
}

AllocateTableWriteIdsRequest::AllocateTableWriteIdsRequest(const AllocateTableWriteIdsRequest& other897) {
  dbName = other897.dbName;
  tableName = other897.tableName;
  txnIds = other897.txnIds;
  replPolicy = other897.replPolicy;
  srcTxnToWriteIdList = other897.srcTxnToWriteIdList;
  reallocate = other897.reallocate;
  __isset = other897.__isset;
}
AllocateTableWriteIdsRequest& AllocateTableWriteIdsRequest::operator=(const AllocateTableWriteIdsRequest& other898) {
  dbName = other898.dbName;
  tableName = other898.tableName;
  txnIds = other898.txnIds;
  replPolicy = other898.replPolicy;
  srcTxnToWriteIdList = other898.srcTxnToWriteIdList;
  reallocate = other898.reallocate;
  __isset = other898.__isset;
  return *this;
}
void AllocateTableWriteIdsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AllocateTableWriteIdsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "txnIds="; (__isset.txnIds ? (out << to_string(txnIds)) : (out << "<null>"));
  out << ", " << "replPolicy="; (__isset.replPolicy ? (out << to_string(replPolicy)) : (out << "<null>"));
  out << ", " << "srcTxnToWriteIdList="; (__isset.srcTxnToWriteIdList ? (out << to_string(srcTxnToWriteIdList)) : (out << "<null>"));
  out << ", " << "reallocate="; (__isset.reallocate ? (out << to_string(reallocate)) : (out << "<null>"));
  out << ")";
}


AllocateTableWriteIdsResponse::~AllocateTableWriteIdsResponse() noexcept {
}


void AllocateTableWriteIdsResponse::__set_txnToWriteIds(const std::vector<TxnToWriteId> & val) {
  this->txnToWriteIds = val;
}
std::ostream& operator<<(std::ostream& out, const AllocateTableWriteIdsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AllocateTableWriteIdsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txnToWriteIds = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->txnToWriteIds.clear();
            uint32_t _size899;
            ::apache::thrift::protocol::TType _etype902;
            xfer += iprot->readListBegin(_etype902, _size899);
            this->txnToWriteIds.resize(_size899);
            uint32_t _i903;
            for (_i903 = 0; _i903 < _size899; ++_i903)
            {
              xfer += this->txnToWriteIds[_i903].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_txnToWriteIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txnToWriteIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AllocateTableWriteIdsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AllocateTableWriteIdsResponse");

  xfer += oprot->writeFieldBegin("txnToWriteIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->txnToWriteIds.size()));
    std::vector<TxnToWriteId> ::const_iterator _iter904;
    for (_iter904 = this->txnToWriteIds.begin(); _iter904 != this->txnToWriteIds.end(); ++_iter904)
    {
      xfer += (*_iter904).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AllocateTableWriteIdsResponse &a, AllocateTableWriteIdsResponse &b) {
  using ::std::swap;
  swap(a.txnToWriteIds, b.txnToWriteIds);
}

AllocateTableWriteIdsResponse::AllocateTableWriteIdsResponse(const AllocateTableWriteIdsResponse& other905) {
  txnToWriteIds = other905.txnToWriteIds;
}
AllocateTableWriteIdsResponse& AllocateTableWriteIdsResponse::operator=(const AllocateTableWriteIdsResponse& other906) {
  txnToWriteIds = other906.txnToWriteIds;
  return *this;
}
void AllocateTableWriteIdsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AllocateTableWriteIdsResponse(";
  out << "txnToWriteIds=" << to_string(txnToWriteIds);
  out << ")";
}


MaxAllocatedTableWriteIdRequest::~MaxAllocatedTableWriteIdRequest() noexcept {
}


void MaxAllocatedTableWriteIdRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void MaxAllocatedTableWriteIdRequest::__set_tableName(const std::string& val) {
  this->tableName = val;
}
std::ostream& operator<<(std::ostream& out, const MaxAllocatedTableWriteIdRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MaxAllocatedTableWriteIdRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tableName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MaxAllocatedTableWriteIdRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MaxAllocatedTableWriteIdRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MaxAllocatedTableWriteIdRequest &a, MaxAllocatedTableWriteIdRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
}

MaxAllocatedTableWriteIdRequest::MaxAllocatedTableWriteIdRequest(const MaxAllocatedTableWriteIdRequest& other907) {
  dbName = other907.dbName;
  tableName = other907.tableName;
}
MaxAllocatedTableWriteIdRequest& MaxAllocatedTableWriteIdRequest::operator=(const MaxAllocatedTableWriteIdRequest& other908) {
  dbName = other908.dbName;
  tableName = other908.tableName;
  return *this;
}
void MaxAllocatedTableWriteIdRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MaxAllocatedTableWriteIdRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ")";
}


MaxAllocatedTableWriteIdResponse::~MaxAllocatedTableWriteIdResponse() noexcept {
}


void MaxAllocatedTableWriteIdResponse::__set_maxWriteId(const int64_t val) {
  this->maxWriteId = val;
}
std::ostream& operator<<(std::ostream& out, const MaxAllocatedTableWriteIdResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MaxAllocatedTableWriteIdResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_maxWriteId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxWriteId);
          isset_maxWriteId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_maxWriteId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MaxAllocatedTableWriteIdResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MaxAllocatedTableWriteIdResponse");

  xfer += oprot->writeFieldBegin("maxWriteId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->maxWriteId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MaxAllocatedTableWriteIdResponse &a, MaxAllocatedTableWriteIdResponse &b) {
  using ::std::swap;
  swap(a.maxWriteId, b.maxWriteId);
}

MaxAllocatedTableWriteIdResponse::MaxAllocatedTableWriteIdResponse(const MaxAllocatedTableWriteIdResponse& other909) noexcept {
  maxWriteId = other909.maxWriteId;
}
MaxAllocatedTableWriteIdResponse& MaxAllocatedTableWriteIdResponse::operator=(const MaxAllocatedTableWriteIdResponse& other910) noexcept {
  maxWriteId = other910.maxWriteId;
  return *this;
}
void MaxAllocatedTableWriteIdResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MaxAllocatedTableWriteIdResponse(";
  out << "maxWriteId=" << to_string(maxWriteId);
  out << ")";
}


SeedTableWriteIdsRequest::~SeedTableWriteIdsRequest() noexcept {
}


void SeedTableWriteIdsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void SeedTableWriteIdsRequest::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void SeedTableWriteIdsRequest::__set_seedWriteId(const int64_t val) {
  this->seedWriteId = val;
}
std::ostream& operator<<(std::ostream& out, const SeedTableWriteIdsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SeedTableWriteIdsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tableName = false;
  bool isset_seedWriteId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->seedWriteId);
          isset_seedWriteId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_seedWriteId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SeedTableWriteIdsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SeedTableWriteIdsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("seedWriteId", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->seedWriteId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SeedTableWriteIdsRequest &a, SeedTableWriteIdsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.seedWriteId, b.seedWriteId);
}

SeedTableWriteIdsRequest::SeedTableWriteIdsRequest(const SeedTableWriteIdsRequest& other911) {
  dbName = other911.dbName;
  tableName = other911.tableName;
  seedWriteId = other911.seedWriteId;
}
SeedTableWriteIdsRequest& SeedTableWriteIdsRequest::operator=(const SeedTableWriteIdsRequest& other912) {
  dbName = other912.dbName;
  tableName = other912.tableName;
  seedWriteId = other912.seedWriteId;
  return *this;
}
void SeedTableWriteIdsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SeedTableWriteIdsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "seedWriteId=" << to_string(seedWriteId);
  out << ")";
}


SeedTxnIdRequest::~SeedTxnIdRequest() noexcept {
}


void SeedTxnIdRequest::__set_seedTxnId(const int64_t val) {
  this->seedTxnId = val;
}
std::ostream& operator<<(std::ostream& out, const SeedTxnIdRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SeedTxnIdRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_seedTxnId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->seedTxnId);
          isset_seedTxnId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_seedTxnId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SeedTxnIdRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SeedTxnIdRequest");

  xfer += oprot->writeFieldBegin("seedTxnId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->seedTxnId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SeedTxnIdRequest &a, SeedTxnIdRequest &b) {
  using ::std::swap;
  swap(a.seedTxnId, b.seedTxnId);
}

SeedTxnIdRequest::SeedTxnIdRequest(const SeedTxnIdRequest& other913) noexcept {
  seedTxnId = other913.seedTxnId;
}
SeedTxnIdRequest& SeedTxnIdRequest::operator=(const SeedTxnIdRequest& other914) noexcept {
  seedTxnId = other914.seedTxnId;
  return *this;
}
void SeedTxnIdRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SeedTxnIdRequest(";
  out << "seedTxnId=" << to_string(seedTxnId);
  out << ")";
}


LockComponent::~LockComponent() noexcept {
}


void LockComponent::__set_type(const LockType::type val) {
  this->type = val;
}

void LockComponent::__set_level(const LockLevel::type val) {
  this->level = val;
}

void LockComponent::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void LockComponent::__set_tablename(const std::string& val) {
  this->tablename = val;
__isset.tablename = true;
}

void LockComponent::__set_partitionname(const std::string& val) {
  this->partitionname = val;
__isset.partitionname = true;
}

void LockComponent::__set_operationType(const DataOperationType::type val) {
  this->operationType = val;
__isset.operationType = true;
}

void LockComponent::__set_isTransactional(const bool val) {
  this->isTransactional = val;
__isset.isTransactional = true;
}

void LockComponent::__set_isDynamicPartitionWrite(const bool val) {
  this->isDynamicPartitionWrite = val;
__isset.isDynamicPartitionWrite = true;
}
std::ostream& operator<<(std::ostream& out, const LockComponent& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LockComponent::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;
  bool isset_level = false;
  bool isset_dbname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast915;
          xfer += iprot->readI32(ecast915);
          this->type = static_cast<LockType::type>(ecast915);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast916;
          xfer += iprot->readI32(ecast916);
          this->level = static_cast<LockLevel::type>(ecast916);
          isset_level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          this->__isset.tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partitionname);
          this->__isset.partitionname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast917;
          xfer += iprot->readI32(ecast917);
          this->operationType = static_cast<DataOperationType::type>(ecast917);
          this->__isset.operationType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isTransactional);
          this->__isset.isTransactional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isDynamicPartitionWrite);
          this->__isset.isDynamicPartitionWrite = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_level)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LockComponent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LockComponent");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->level));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tablename) {
    xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->tablename);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionname) {
    xfer += oprot->writeFieldBegin("partitionname", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->partitionname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.operationType) {
    xfer += oprot->writeFieldBegin("operationType", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(static_cast<int32_t>(this->operationType));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isTransactional) {
    xfer += oprot->writeFieldBegin("isTransactional", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->isTransactional);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isDynamicPartitionWrite) {
    xfer += oprot->writeFieldBegin("isDynamicPartitionWrite", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->isDynamicPartitionWrite);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LockComponent &a, LockComponent &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.level, b.level);
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionname, b.partitionname);
  swap(a.operationType, b.operationType);
  swap(a.isTransactional, b.isTransactional);
  swap(a.isDynamicPartitionWrite, b.isDynamicPartitionWrite);
  swap(a.__isset, b.__isset);
}

LockComponent::LockComponent(const LockComponent& other918) {
  type = other918.type;
  level = other918.level;
  dbname = other918.dbname;
  tablename = other918.tablename;
  partitionname = other918.partitionname;
  operationType = other918.operationType;
  isTransactional = other918.isTransactional;
  isDynamicPartitionWrite = other918.isDynamicPartitionWrite;
  __isset = other918.__isset;
}
LockComponent& LockComponent::operator=(const LockComponent& other919) {
  type = other919.type;
  level = other919.level;
  dbname = other919.dbname;
  tablename = other919.tablename;
  partitionname = other919.partitionname;
  operationType = other919.operationType;
  isTransactional = other919.isTransactional;
  isDynamicPartitionWrite = other919.isDynamicPartitionWrite;
  __isset = other919.__isset;
  return *this;
}
void LockComponent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LockComponent(";
  out << "type=" << to_string(type);
  out << ", " << "level=" << to_string(level);
  out << ", " << "dbname=" << to_string(dbname);
  out << ", " << "tablename="; (__isset.tablename ? (out << to_string(tablename)) : (out << "<null>"));
  out << ", " << "partitionname="; (__isset.partitionname ? (out << to_string(partitionname)) : (out << "<null>"));
  out << ", " << "operationType="; (__isset.operationType ? (out << to_string(operationType)) : (out << "<null>"));
  out << ", " << "isTransactional="; (__isset.isTransactional ? (out << to_string(isTransactional)) : (out << "<null>"));
  out << ", " << "isDynamicPartitionWrite="; (__isset.isDynamicPartitionWrite ? (out << to_string(isDynamicPartitionWrite)) : (out << "<null>"));
  out << ")";
}


LockRequest::~LockRequest() noexcept {
}


void LockRequest::__set_component(const std::vector<LockComponent> & val) {
  this->component = val;
}

void LockRequest::__set_txnid(const int64_t val) {
  this->txnid = val;
__isset.txnid = true;
}

void LockRequest::__set_user(const std::string& val) {
  this->user = val;
}

void LockRequest::__set_hostname(const std::string& val) {
  this->hostname = val;
}

void LockRequest::__set_agentInfo(const std::string& val) {
  this->agentInfo = val;
__isset.agentInfo = true;
}

void LockRequest::__set_zeroWaitReadEnabled(const bool val) {
  this->zeroWaitReadEnabled = val;
__isset.zeroWaitReadEnabled = true;
}

void LockRequest::__set_exclusiveCTAS(const bool val) {
  this->exclusiveCTAS = val;
__isset.exclusiveCTAS = true;
}

void LockRequest::__set_locklessReadsEnabled(const bool val) {
  this->locklessReadsEnabled = val;
__isset.locklessReadsEnabled = true;
}
std::ostream& operator<<(std::ostream& out, const LockRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LockRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_component = false;
  bool isset_user = false;
  bool isset_hostname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->component.clear();
            uint32_t _size920;
            ::apache::thrift::protocol::TType _etype923;
            xfer += iprot->readListBegin(_etype923, _size920);
            this->component.resize(_size920);
            uint32_t _i924;
            for (_i924 = 0; _i924 < _size920; ++_i924)
            {
              xfer += this->component[_i924].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_component = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          this->__isset.txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          isset_hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agentInfo);
          this->__isset.agentInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->zeroWaitReadEnabled);
          this->__isset.zeroWaitReadEnabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->exclusiveCTAS);
          this->__isset.exclusiveCTAS = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->locklessReadsEnabled);
          this->__isset.locklessReadsEnabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_component)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hostname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LockRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LockRequest");

  xfer += oprot->writeFieldBegin("component", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->component.size()));
    std::vector<LockComponent> ::const_iterator _iter925;
    for (_iter925 = this->component.begin(); _iter925 != this->component.end(); ++_iter925)
    {
      xfer += (*_iter925).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.txnid) {
    xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->txnid);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.agentInfo) {
    xfer += oprot->writeFieldBegin("agentInfo", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->agentInfo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.zeroWaitReadEnabled) {
    xfer += oprot->writeFieldBegin("zeroWaitReadEnabled", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->zeroWaitReadEnabled);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exclusiveCTAS) {
    xfer += oprot->writeFieldBegin("exclusiveCTAS", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->exclusiveCTAS);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.locklessReadsEnabled) {
    xfer += oprot->writeFieldBegin("locklessReadsEnabled", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->locklessReadsEnabled);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LockRequest &a, LockRequest &b) {
  using ::std::swap;
  swap(a.component, b.component);
  swap(a.txnid, b.txnid);
  swap(a.user, b.user);
  swap(a.hostname, b.hostname);
  swap(a.agentInfo, b.agentInfo);
  swap(a.zeroWaitReadEnabled, b.zeroWaitReadEnabled);
  swap(a.exclusiveCTAS, b.exclusiveCTAS);
  swap(a.locklessReadsEnabled, b.locklessReadsEnabled);
  swap(a.__isset, b.__isset);
}

LockRequest::LockRequest(const LockRequest& other926) {
  component = other926.component;
  txnid = other926.txnid;
  user = other926.user;
  hostname = other926.hostname;
  agentInfo = other926.agentInfo;
  zeroWaitReadEnabled = other926.zeroWaitReadEnabled;
  exclusiveCTAS = other926.exclusiveCTAS;
  locklessReadsEnabled = other926.locklessReadsEnabled;
  __isset = other926.__isset;
}
LockRequest& LockRequest::operator=(const LockRequest& other927) {
  component = other927.component;
  txnid = other927.txnid;
  user = other927.user;
  hostname = other927.hostname;
  agentInfo = other927.agentInfo;
  zeroWaitReadEnabled = other927.zeroWaitReadEnabled;
  exclusiveCTAS = other927.exclusiveCTAS;
  locklessReadsEnabled = other927.locklessReadsEnabled;
  __isset = other927.__isset;
  return *this;
}
void LockRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LockRequest(";
  out << "component=" << to_string(component);
  out << ", " << "txnid="; (__isset.txnid ? (out << to_string(txnid)) : (out << "<null>"));
  out << ", " << "user=" << to_string(user);
  out << ", " << "hostname=" << to_string(hostname);
  out << ", " << "agentInfo="; (__isset.agentInfo ? (out << to_string(agentInfo)) : (out << "<null>"));
  out << ", " << "zeroWaitReadEnabled="; (__isset.zeroWaitReadEnabled ? (out << to_string(zeroWaitReadEnabled)) : (out << "<null>"));
  out << ", " << "exclusiveCTAS="; (__isset.exclusiveCTAS ? (out << to_string(exclusiveCTAS)) : (out << "<null>"));
  out << ", " << "locklessReadsEnabled="; (__isset.locklessReadsEnabled ? (out << to_string(locklessReadsEnabled)) : (out << "<null>"));
  out << ")";
}


LockResponse::~LockResponse() noexcept {
}


void LockResponse::__set_lockid(const int64_t val) {
  this->lockid = val;
}

void LockResponse::__set_state(const LockState::type val) {
  this->state = val;
}

void LockResponse::__set_errorMessage(const std::string& val) {
  this->errorMessage = val;
__isset.errorMessage = true;
}
std::ostream& operator<<(std::ostream& out, const LockResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LockResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lockid = false;
  bool isset_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockid);
          isset_lockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast928;
          xfer += iprot->readI32(ecast928);
          this->state = static_cast<LockState::type>(ecast928);
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errorMessage);
          this->__isset.errorMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lockid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LockResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LockResponse");

  xfer += oprot->writeFieldBegin("lockid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lockid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->state));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.errorMessage) {
    xfer += oprot->writeFieldBegin("errorMessage", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->errorMessage);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LockResponse &a, LockResponse &b) {
  using ::std::swap;
  swap(a.lockid, b.lockid);
  swap(a.state, b.state);
  swap(a.errorMessage, b.errorMessage);
  swap(a.__isset, b.__isset);
}

LockResponse::LockResponse(const LockResponse& other929) {
  lockid = other929.lockid;
  state = other929.state;
  errorMessage = other929.errorMessage;
  __isset = other929.__isset;
}
LockResponse& LockResponse::operator=(const LockResponse& other930) {
  lockid = other930.lockid;
  state = other930.state;
  errorMessage = other930.errorMessage;
  __isset = other930.__isset;
  return *this;
}
void LockResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LockResponse(";
  out << "lockid=" << to_string(lockid);
  out << ", " << "state=" << to_string(state);
  out << ", " << "errorMessage="; (__isset.errorMessage ? (out << to_string(errorMessage)) : (out << "<null>"));
  out << ")";
}


CheckLockRequest::~CheckLockRequest() noexcept {
}


void CheckLockRequest::__set_lockid(const int64_t val) {
  this->lockid = val;
}

void CheckLockRequest::__set_txnid(const int64_t val) {
  this->txnid = val;
__isset.txnid = true;
}

void CheckLockRequest::__set_elapsed_ms(const int64_t val) {
  this->elapsed_ms = val;
__isset.elapsed_ms = true;
}
std::ostream& operator<<(std::ostream& out, const CheckLockRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CheckLockRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lockid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockid);
          isset_lockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          this->__isset.txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->elapsed_ms);
          this->__isset.elapsed_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lockid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CheckLockRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CheckLockRequest");

  xfer += oprot->writeFieldBegin("lockid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lockid);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.txnid) {
    xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->txnid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.elapsed_ms) {
    xfer += oprot->writeFieldBegin("elapsed_ms", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->elapsed_ms);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CheckLockRequest &a, CheckLockRequest &b) {
  using ::std::swap;
  swap(a.lockid, b.lockid);
  swap(a.txnid, b.txnid);
  swap(a.elapsed_ms, b.elapsed_ms);
  swap(a.__isset, b.__isset);
}

CheckLockRequest::CheckLockRequest(const CheckLockRequest& other931) noexcept {
  lockid = other931.lockid;
  txnid = other931.txnid;
  elapsed_ms = other931.elapsed_ms;
  __isset = other931.__isset;
}
CheckLockRequest& CheckLockRequest::operator=(const CheckLockRequest& other932) noexcept {
  lockid = other932.lockid;
  txnid = other932.txnid;
  elapsed_ms = other932.elapsed_ms;
  __isset = other932.__isset;
  return *this;
}
void CheckLockRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CheckLockRequest(";
  out << "lockid=" << to_string(lockid);
  out << ", " << "txnid="; (__isset.txnid ? (out << to_string(txnid)) : (out << "<null>"));
  out << ", " << "elapsed_ms="; (__isset.elapsed_ms ? (out << to_string(elapsed_ms)) : (out << "<null>"));
  out << ")";
}


UnlockRequest::~UnlockRequest() noexcept {
}


void UnlockRequest::__set_lockid(const int64_t val) {
  this->lockid = val;
}
std::ostream& operator<<(std::ostream& out, const UnlockRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UnlockRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lockid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockid);
          isset_lockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lockid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UnlockRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnlockRequest");

  xfer += oprot->writeFieldBegin("lockid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lockid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnlockRequest &a, UnlockRequest &b) {
  using ::std::swap;
  swap(a.lockid, b.lockid);
}

UnlockRequest::UnlockRequest(const UnlockRequest& other933) noexcept {
  lockid = other933.lockid;
}
UnlockRequest& UnlockRequest::operator=(const UnlockRequest& other934) noexcept {
  lockid = other934.lockid;
  return *this;
}
void UnlockRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnlockRequest(";
  out << "lockid=" << to_string(lockid);
  out << ")";
}


ShowLocksRequest::~ShowLocksRequest() noexcept {
}


void ShowLocksRequest::__set_dbname(const std::string& val) {
  this->dbname = val;
__isset.dbname = true;
}

void ShowLocksRequest::__set_tablename(const std::string& val) {
  this->tablename = val;
__isset.tablename = true;
}

void ShowLocksRequest::__set_partname(const std::string& val) {
  this->partname = val;
__isset.partname = true;
}

void ShowLocksRequest::__set_isExtended(const bool val) {
  this->isExtended = val;
__isset.isExtended = true;
}

void ShowLocksRequest::__set_txnid(const int64_t val) {
  this->txnid = val;
__isset.txnid = true;
}
std::ostream& operator<<(std::ostream& out, const ShowLocksRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowLocksRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          this->__isset.dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          this->__isset.tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partname);
          this->__isset.partname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isExtended);
          this->__isset.isExtended = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          this->__isset.txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowLocksRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowLocksRequest");

  if (this->__isset.dbname) {
    xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->dbname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tablename) {
    xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->tablename);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partname) {
    xfer += oprot->writeFieldBegin("partname", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->partname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isExtended) {
    xfer += oprot->writeFieldBegin("isExtended", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->isExtended);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.txnid) {
    xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->txnid);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowLocksRequest &a, ShowLocksRequest &b) {
  using ::std::swap;
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partname, b.partname);
  swap(a.isExtended, b.isExtended);
  swap(a.txnid, b.txnid);
  swap(a.__isset, b.__isset);
}

ShowLocksRequest::ShowLocksRequest(const ShowLocksRequest& other935) {
  dbname = other935.dbname;
  tablename = other935.tablename;
  partname = other935.partname;
  isExtended = other935.isExtended;
  txnid = other935.txnid;
  __isset = other935.__isset;
}
ShowLocksRequest& ShowLocksRequest::operator=(const ShowLocksRequest& other936) {
  dbname = other936.dbname;
  tablename = other936.tablename;
  partname = other936.partname;
  isExtended = other936.isExtended;
  txnid = other936.txnid;
  __isset = other936.__isset;
  return *this;
}
void ShowLocksRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowLocksRequest(";
  out << "dbname="; (__isset.dbname ? (out << to_string(dbname)) : (out << "<null>"));
  out << ", " << "tablename="; (__isset.tablename ? (out << to_string(tablename)) : (out << "<null>"));
  out << ", " << "partname="; (__isset.partname ? (out << to_string(partname)) : (out << "<null>"));
  out << ", " << "isExtended="; (__isset.isExtended ? (out << to_string(isExtended)) : (out << "<null>"));
  out << ", " << "txnid="; (__isset.txnid ? (out << to_string(txnid)) : (out << "<null>"));
  out << ")";
}


ShowLocksResponseElement::~ShowLocksResponseElement() noexcept {
}


void ShowLocksResponseElement::__set_lockid(const int64_t val) {
  this->lockid = val;
}

void ShowLocksResponseElement::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void ShowLocksResponseElement::__set_tablename(const std::string& val) {
  this->tablename = val;
__isset.tablename = true;
}

void ShowLocksResponseElement::__set_partname(const std::string& val) {
  this->partname = val;
__isset.partname = true;
}

void ShowLocksResponseElement::__set_state(const LockState::type val) {
  this->state = val;
}

void ShowLocksResponseElement::__set_type(const LockType::type val) {
  this->type = val;
}

void ShowLocksResponseElement::__set_txnid(const int64_t val) {
  this->txnid = val;
__isset.txnid = true;
}

void ShowLocksResponseElement::__set_lastheartbeat(const int64_t val) {
  this->lastheartbeat = val;
}

void ShowLocksResponseElement::__set_acquiredat(const int64_t val) {
  this->acquiredat = val;
__isset.acquiredat = true;
}

void ShowLocksResponseElement::__set_user(const std::string& val) {
  this->user = val;
}

void ShowLocksResponseElement::__set_hostname(const std::string& val) {
  this->hostname = val;
}

void ShowLocksResponseElement::__set_heartbeatCount(const int32_t val) {
  this->heartbeatCount = val;
__isset.heartbeatCount = true;
}

void ShowLocksResponseElement::__set_agentInfo(const std::string& val) {
  this->agentInfo = val;
__isset.agentInfo = true;
}

void ShowLocksResponseElement::__set_blockedByExtId(const int64_t val) {
  this->blockedByExtId = val;
__isset.blockedByExtId = true;
}

void ShowLocksResponseElement::__set_blockedByIntId(const int64_t val) {
  this->blockedByIntId = val;
__isset.blockedByIntId = true;
}

void ShowLocksResponseElement::__set_lockIdInternal(const int64_t val) {
  this->lockIdInternal = val;
__isset.lockIdInternal = true;
}
std::ostream& operator<<(std::ostream& out, const ShowLocksResponseElement& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowLocksResponseElement::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lockid = false;
  bool isset_dbname = false;
  bool isset_state = false;
  bool isset_type = false;
  bool isset_lastheartbeat = false;
  bool isset_user = false;
  bool isset_hostname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockid);
          isset_lockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          this->__isset.tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partname);
          this->__isset.partname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast937;
          xfer += iprot->readI32(ecast937);
          this->state = static_cast<LockState::type>(ecast937);
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast938;
          xfer += iprot->readI32(ecast938);
          this->type = static_cast<LockType::type>(ecast938);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          this->__isset.txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastheartbeat);
          isset_lastheartbeat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acquiredat);
          this->__isset.acquiredat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          isset_hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->heartbeatCount);
          this->__isset.heartbeatCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agentInfo);
          this->__isset.agentInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->blockedByExtId);
          this->__isset.blockedByExtId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->blockedByIntId);
          this->__isset.blockedByIntId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockIdInternal);
          this->__isset.lockIdInternal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lockid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_lastheartbeat)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hostname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ShowLocksResponseElement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowLocksResponseElement");

  xfer += oprot->writeFieldBegin("lockid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lockid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tablename) {
    xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->tablename);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partname) {
    xfer += oprot->writeFieldBegin("partname", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->partname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(static_cast<int32_t>(this->state));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.txnid) {
    xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->txnid);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("lastheartbeat", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->lastheartbeat);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.acquiredat) {
    xfer += oprot->writeFieldBegin("acquiredat", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->acquiredat);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.heartbeatCount) {
    xfer += oprot->writeFieldBegin("heartbeatCount", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->heartbeatCount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.agentInfo) {
    xfer += oprot->writeFieldBegin("agentInfo", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->agentInfo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blockedByExtId) {
    xfer += oprot->writeFieldBegin("blockedByExtId", ::apache::thrift::protocol::T_I64, 14);
    xfer += oprot->writeI64(this->blockedByExtId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blockedByIntId) {
    xfer += oprot->writeFieldBegin("blockedByIntId", ::apache::thrift::protocol::T_I64, 15);
    xfer += oprot->writeI64(this->blockedByIntId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lockIdInternal) {
    xfer += oprot->writeFieldBegin("lockIdInternal", ::apache::thrift::protocol::T_I64, 16);
    xfer += oprot->writeI64(this->lockIdInternal);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowLocksResponseElement &a, ShowLocksResponseElement &b) {
  using ::std::swap;
  swap(a.lockid, b.lockid);
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partname, b.partname);
  swap(a.state, b.state);
  swap(a.type, b.type);
  swap(a.txnid, b.txnid);
  swap(a.lastheartbeat, b.lastheartbeat);
  swap(a.acquiredat, b.acquiredat);
  swap(a.user, b.user);
  swap(a.hostname, b.hostname);
  swap(a.heartbeatCount, b.heartbeatCount);
  swap(a.agentInfo, b.agentInfo);
  swap(a.blockedByExtId, b.blockedByExtId);
  swap(a.blockedByIntId, b.blockedByIntId);
  swap(a.lockIdInternal, b.lockIdInternal);
  swap(a.__isset, b.__isset);
}

ShowLocksResponseElement::ShowLocksResponseElement(const ShowLocksResponseElement& other939) {
  lockid = other939.lockid;
  dbname = other939.dbname;
  tablename = other939.tablename;
  partname = other939.partname;
  state = other939.state;
  type = other939.type;
  txnid = other939.txnid;
  lastheartbeat = other939.lastheartbeat;
  acquiredat = other939.acquiredat;
  user = other939.user;
  hostname = other939.hostname;
  heartbeatCount = other939.heartbeatCount;
  agentInfo = other939.agentInfo;
  blockedByExtId = other939.blockedByExtId;
  blockedByIntId = other939.blockedByIntId;
  lockIdInternal = other939.lockIdInternal;
  __isset = other939.__isset;
}
ShowLocksResponseElement& ShowLocksResponseElement::operator=(const ShowLocksResponseElement& other940) {
  lockid = other940.lockid;
  dbname = other940.dbname;
  tablename = other940.tablename;
  partname = other940.partname;
  state = other940.state;
  type = other940.type;
  txnid = other940.txnid;
  lastheartbeat = other940.lastheartbeat;
  acquiredat = other940.acquiredat;
  user = other940.user;
  hostname = other940.hostname;
  heartbeatCount = other940.heartbeatCount;
  agentInfo = other940.agentInfo;
  blockedByExtId = other940.blockedByExtId;
  blockedByIntId = other940.blockedByIntId;
  lockIdInternal = other940.lockIdInternal;
  __isset = other940.__isset;
  return *this;
}
void ShowLocksResponseElement::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowLocksResponseElement(";
  out << "lockid=" << to_string(lockid);
  out << ", " << "dbname=" << to_string(dbname);
  out << ", " << "tablename="; (__isset.tablename ? (out << to_string(tablename)) : (out << "<null>"));
  out << ", " << "partname="; (__isset.partname ? (out << to_string(partname)) : (out << "<null>"));
  out << ", " << "state=" << to_string(state);
  out << ", " << "type=" << to_string(type);
  out << ", " << "txnid="; (__isset.txnid ? (out << to_string(txnid)) : (out << "<null>"));
  out << ", " << "lastheartbeat=" << to_string(lastheartbeat);
  out << ", " << "acquiredat="; (__isset.acquiredat ? (out << to_string(acquiredat)) : (out << "<null>"));
  out << ", " << "user=" << to_string(user);
  out << ", " << "hostname=" << to_string(hostname);
  out << ", " << "heartbeatCount="; (__isset.heartbeatCount ? (out << to_string(heartbeatCount)) : (out << "<null>"));
  out << ", " << "agentInfo="; (__isset.agentInfo ? (out << to_string(agentInfo)) : (out << "<null>"));
  out << ", " << "blockedByExtId="; (__isset.blockedByExtId ? (out << to_string(blockedByExtId)) : (out << "<null>"));
  out << ", " << "blockedByIntId="; (__isset.blockedByIntId ? (out << to_string(blockedByIntId)) : (out << "<null>"));
  out << ", " << "lockIdInternal="; (__isset.lockIdInternal ? (out << to_string(lockIdInternal)) : (out << "<null>"));
  out << ")";
}


ShowLocksResponse::~ShowLocksResponse() noexcept {
}


void ShowLocksResponse::__set_locks(const std::vector<ShowLocksResponseElement> & val) {
  this->locks = val;
}
std::ostream& operator<<(std::ostream& out, const ShowLocksResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowLocksResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->locks.clear();
            uint32_t _size941;
            ::apache::thrift::protocol::TType _etype944;
            xfer += iprot->readListBegin(_etype944, _size941);
            this->locks.resize(_size941);
            uint32_t _i945;
            for (_i945 = 0; _i945 < _size941; ++_i945)
            {
              xfer += this->locks[_i945].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.locks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowLocksResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowLocksResponse");

  xfer += oprot->writeFieldBegin("locks", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->locks.size()));
    std::vector<ShowLocksResponseElement> ::const_iterator _iter946;
    for (_iter946 = this->locks.begin(); _iter946 != this->locks.end(); ++_iter946)
    {
      xfer += (*_iter946).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowLocksResponse &a, ShowLocksResponse &b) {
  using ::std::swap;
  swap(a.locks, b.locks);
  swap(a.__isset, b.__isset);
}

ShowLocksResponse::ShowLocksResponse(const ShowLocksResponse& other947) {
  locks = other947.locks;
  __isset = other947.__isset;
}
ShowLocksResponse& ShowLocksResponse::operator=(const ShowLocksResponse& other948) {
  locks = other948.locks;
  __isset = other948.__isset;
  return *this;
}
void ShowLocksResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowLocksResponse(";
  out << "locks=" << to_string(locks);
  out << ")";
}


HeartbeatRequest::~HeartbeatRequest() noexcept {
}


void HeartbeatRequest::__set_lockid(const int64_t val) {
  this->lockid = val;
__isset.lockid = true;
}

void HeartbeatRequest::__set_txnid(const int64_t val) {
  this->txnid = val;
__isset.txnid = true;
}
std::ostream& operator<<(std::ostream& out, const HeartbeatRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HeartbeatRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockid);
          this->__isset.lockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          this->__isset.txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HeartbeatRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HeartbeatRequest");

  if (this->__isset.lockid) {
    xfer += oprot->writeFieldBegin("lockid", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->lockid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.txnid) {
    xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->txnid);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HeartbeatRequest &a, HeartbeatRequest &b) {
  using ::std::swap;
  swap(a.lockid, b.lockid);
  swap(a.txnid, b.txnid);
  swap(a.__isset, b.__isset);
}

HeartbeatRequest::HeartbeatRequest(const HeartbeatRequest& other949) noexcept {
  lockid = other949.lockid;
  txnid = other949.txnid;
  __isset = other949.__isset;
}
HeartbeatRequest& HeartbeatRequest::operator=(const HeartbeatRequest& other950) noexcept {
  lockid = other950.lockid;
  txnid = other950.txnid;
  __isset = other950.__isset;
  return *this;
}
void HeartbeatRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HeartbeatRequest(";
  out << "lockid="; (__isset.lockid ? (out << to_string(lockid)) : (out << "<null>"));
  out << ", " << "txnid="; (__isset.txnid ? (out << to_string(txnid)) : (out << "<null>"));
  out << ")";
}


HeartbeatTxnRangeRequest::~HeartbeatTxnRangeRequest() noexcept {
}


void HeartbeatTxnRangeRequest::__set_min(const int64_t val) {
  this->min = val;
}

void HeartbeatTxnRangeRequest::__set_max(const int64_t val) {
  this->max = val;
}
std::ostream& operator<<(std::ostream& out, const HeartbeatTxnRangeRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HeartbeatTxnRangeRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_min = false;
  bool isset_max = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->min);
          isset_min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max);
          isset_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_min)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_max)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HeartbeatTxnRangeRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HeartbeatTxnRangeRequest");

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HeartbeatTxnRangeRequest &a, HeartbeatTxnRangeRequest &b) {
  using ::std::swap;
  swap(a.min, b.min);
  swap(a.max, b.max);
}

HeartbeatTxnRangeRequest::HeartbeatTxnRangeRequest(const HeartbeatTxnRangeRequest& other951) noexcept {
  min = other951.min;
  max = other951.max;
}
HeartbeatTxnRangeRequest& HeartbeatTxnRangeRequest::operator=(const HeartbeatTxnRangeRequest& other952) noexcept {
  min = other952.min;
  max = other952.max;
  return *this;
}
void HeartbeatTxnRangeRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HeartbeatTxnRangeRequest(";
  out << "min=" << to_string(min);
  out << ", " << "max=" << to_string(max);
  out << ")";
}


HeartbeatTxnRangeResponse::~HeartbeatTxnRangeResponse() noexcept {
}


void HeartbeatTxnRangeResponse::__set_aborted(const std::set<int64_t> & val) {
  this->aborted = val;
}

void HeartbeatTxnRangeResponse::__set_nosuch(const std::set<int64_t> & val) {
  this->nosuch = val;
}
std::ostream& operator<<(std::ostream& out, const HeartbeatTxnRangeResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HeartbeatTxnRangeResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_aborted = false;
  bool isset_nosuch = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->aborted.clear();
            uint32_t _size953;
            ::apache::thrift::protocol::TType _etype956;
            xfer += iprot->readSetBegin(_etype956, _size953);
            uint32_t _i957;
            for (_i957 = 0; _i957 < _size953; ++_i957)
            {
              int64_t _elem958;
              xfer += iprot->readI64(_elem958);
              this->aborted.insert(_elem958);
            }
            xfer += iprot->readSetEnd();
          }
          isset_aborted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->nosuch.clear();
            uint32_t _size959;
            ::apache::thrift::protocol::TType _etype962;
            xfer += iprot->readSetBegin(_etype962, _size959);
            uint32_t _i963;
            for (_i963 = 0; _i963 < _size959; ++_i963)
            {
              int64_t _elem964;
              xfer += iprot->readI64(_elem964);
              this->nosuch.insert(_elem964);
            }
            xfer += iprot->readSetEnd();
          }
          isset_nosuch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_aborted)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nosuch)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HeartbeatTxnRangeResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HeartbeatTxnRangeResponse");

  xfer += oprot->writeFieldBegin("aborted", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->aborted.size()));
    std::set<int64_t> ::const_iterator _iter965;
    for (_iter965 = this->aborted.begin(); _iter965 != this->aborted.end(); ++_iter965)
    {
      xfer += oprot->writeI64((*_iter965));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nosuch", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->nosuch.size()));
    std::set<int64_t> ::const_iterator _iter966;
    for (_iter966 = this->nosuch.begin(); _iter966 != this->nosuch.end(); ++_iter966)
    {
      xfer += oprot->writeI64((*_iter966));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HeartbeatTxnRangeResponse &a, HeartbeatTxnRangeResponse &b) {
  using ::std::swap;
  swap(a.aborted, b.aborted);
  swap(a.nosuch, b.nosuch);
}

HeartbeatTxnRangeResponse::HeartbeatTxnRangeResponse(const HeartbeatTxnRangeResponse& other967) {
  aborted = other967.aborted;
  nosuch = other967.nosuch;
}
HeartbeatTxnRangeResponse& HeartbeatTxnRangeResponse::operator=(const HeartbeatTxnRangeResponse& other968) {
  aborted = other968.aborted;
  nosuch = other968.nosuch;
  return *this;
}
void HeartbeatTxnRangeResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HeartbeatTxnRangeResponse(";
  out << "aborted=" << to_string(aborted);
  out << ", " << "nosuch=" << to_string(nosuch);
  out << ")";
}


CompactionRequest::~CompactionRequest() noexcept {
}


void CompactionRequest::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void CompactionRequest::__set_tablename(const std::string& val) {
  this->tablename = val;
}

void CompactionRequest::__set_partitionname(const std::string& val) {
  this->partitionname = val;
__isset.partitionname = true;
}

void CompactionRequest::__set_type(const CompactionType::type val) {
  this->type = val;
}

void CompactionRequest::__set_runas(const std::string& val) {
  this->runas = val;
__isset.runas = true;
}

void CompactionRequest::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
__isset.properties = true;
}

void CompactionRequest::__set_initiatorId(const std::string& val) {
  this->initiatorId = val;
__isset.initiatorId = true;
}

void CompactionRequest::__set_initiatorVersion(const std::string& val) {
  this->initiatorVersion = val;
__isset.initiatorVersion = true;
}

void CompactionRequest::__set_poolName(const std::string& val) {
  this->poolName = val;
__isset.poolName = true;
}

void CompactionRequest::__set_numberOfBuckets(const int32_t val) {
  this->numberOfBuckets = val;
__isset.numberOfBuckets = true;
}

void CompactionRequest::__set_orderByClause(const std::string& val) {
  this->orderByClause = val;
__isset.orderByClause = true;
}
std::ostream& operator<<(std::ostream& out, const CompactionRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CompactionRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbname = false;
  bool isset_tablename = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          isset_tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partitionname);
          this->__isset.partitionname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast969;
          xfer += iprot->readI32(ecast969);
          this->type = static_cast<CompactionType::type>(ecast969);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->runas);
          this->__isset.runas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size970;
            ::apache::thrift::protocol::TType _ktype971;
            ::apache::thrift::protocol::TType _vtype972;
            xfer += iprot->readMapBegin(_ktype971, _vtype972, _size970);
            uint32_t _i974;
            for (_i974 = 0; _i974 < _size970; ++_i974)
            {
              std::string _key975;
              xfer += iprot->readString(_key975);
              std::string& _val976 = this->properties[_key975];
              xfer += iprot->readString(_val976);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->initiatorId);
          this->__isset.initiatorId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->initiatorVersion);
          this->__isset.initiatorVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->poolName);
          this->__isset.poolName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numberOfBuckets);
          this->__isset.numberOfBuckets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->orderByClause);
          this->__isset.orderByClause = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CompactionRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactionRequest");

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partitionname) {
    xfer += oprot->writeFieldBegin("partitionname", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->partitionname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.runas) {
    xfer += oprot->writeFieldBegin("runas", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->runas);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.properties) {
    xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter977;
      for (_iter977 = this->properties.begin(); _iter977 != this->properties.end(); ++_iter977)
      {
        xfer += oprot->writeString(_iter977->first);
        xfer += oprot->writeString(_iter977->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.initiatorId) {
    xfer += oprot->writeFieldBegin("initiatorId", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->initiatorId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.initiatorVersion) {
    xfer += oprot->writeFieldBegin("initiatorVersion", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->initiatorVersion);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.poolName) {
    xfer += oprot->writeFieldBegin("poolName", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->poolName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.numberOfBuckets) {
    xfer += oprot->writeFieldBegin("numberOfBuckets", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->numberOfBuckets);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.orderByClause) {
    xfer += oprot->writeFieldBegin("orderByClause", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->orderByClause);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactionRequest &a, CompactionRequest &b) {
  using ::std::swap;
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionname, b.partitionname);
  swap(a.type, b.type);
  swap(a.runas, b.runas);
  swap(a.properties, b.properties);
  swap(a.initiatorId, b.initiatorId);
  swap(a.initiatorVersion, b.initiatorVersion);
  swap(a.poolName, b.poolName);
  swap(a.numberOfBuckets, b.numberOfBuckets);
  swap(a.orderByClause, b.orderByClause);
  swap(a.__isset, b.__isset);
}

CompactionRequest::CompactionRequest(const CompactionRequest& other978) {
  dbname = other978.dbname;
  tablename = other978.tablename;
  partitionname = other978.partitionname;
  type = other978.type;
  runas = other978.runas;
  properties = other978.properties;
  initiatorId = other978.initiatorId;
  initiatorVersion = other978.initiatorVersion;
  poolName = other978.poolName;
  numberOfBuckets = other978.numberOfBuckets;
  orderByClause = other978.orderByClause;
  __isset = other978.__isset;
}
CompactionRequest& CompactionRequest::operator=(const CompactionRequest& other979) {
  dbname = other979.dbname;
  tablename = other979.tablename;
  partitionname = other979.partitionname;
  type = other979.type;
  runas = other979.runas;
  properties = other979.properties;
  initiatorId = other979.initiatorId;
  initiatorVersion = other979.initiatorVersion;
  poolName = other979.poolName;
  numberOfBuckets = other979.numberOfBuckets;
  orderByClause = other979.orderByClause;
  __isset = other979.__isset;
  return *this;
}
void CompactionRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactionRequest(";
  out << "dbname=" << to_string(dbname);
  out << ", " << "tablename=" << to_string(tablename);
  out << ", " << "partitionname="; (__isset.partitionname ? (out << to_string(partitionname)) : (out << "<null>"));
  out << ", " << "type=" << to_string(type);
  out << ", " << "runas="; (__isset.runas ? (out << to_string(runas)) : (out << "<null>"));
  out << ", " << "properties="; (__isset.properties ? (out << to_string(properties)) : (out << "<null>"));
  out << ", " << "initiatorId="; (__isset.initiatorId ? (out << to_string(initiatorId)) : (out << "<null>"));
  out << ", " << "initiatorVersion="; (__isset.initiatorVersion ? (out << to_string(initiatorVersion)) : (out << "<null>"));
  out << ", " << "poolName="; (__isset.poolName ? (out << to_string(poolName)) : (out << "<null>"));
  out << ", " << "numberOfBuckets="; (__isset.numberOfBuckets ? (out << to_string(numberOfBuckets)) : (out << "<null>"));
  out << ", " << "orderByClause="; (__isset.orderByClause ? (out << to_string(orderByClause)) : (out << "<null>"));
  out << ")";
}


CompactionInfoStruct::~CompactionInfoStruct() noexcept {
}


void CompactionInfoStruct::__set_id(const int64_t val) {
  this->id = val;
}

void CompactionInfoStruct::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void CompactionInfoStruct::__set_tablename(const std::string& val) {
  this->tablename = val;
}

void CompactionInfoStruct::__set_partitionname(const std::string& val) {
  this->partitionname = val;
__isset.partitionname = true;
}

void CompactionInfoStruct::__set_type(const CompactionType::type val) {
  this->type = val;
}

void CompactionInfoStruct::__set_runas(const std::string& val) {
  this->runas = val;
__isset.runas = true;
}

void CompactionInfoStruct::__set_properties(const std::string& val) {
  this->properties = val;
__isset.properties = true;
}

void CompactionInfoStruct::__set_toomanyaborts(const bool val) {
  this->toomanyaborts = val;
__isset.toomanyaborts = true;
}

void CompactionInfoStruct::__set_state(const std::string& val) {
  this->state = val;
__isset.state = true;
}

void CompactionInfoStruct::__set_workerId(const std::string& val) {
  this->workerId = val;
__isset.workerId = true;
}

void CompactionInfoStruct::__set_start(const int64_t val) {
  this->start = val;
__isset.start = true;
}

void CompactionInfoStruct::__set_highestWriteId(const int64_t val) {
  this->highestWriteId = val;
__isset.highestWriteId = true;
}

void CompactionInfoStruct::__set_errorMessage(const std::string& val) {
  this->errorMessage = val;
__isset.errorMessage = true;
}

void CompactionInfoStruct::__set_hasoldabort(const bool val) {
  this->hasoldabort = val;
__isset.hasoldabort = true;
}

void CompactionInfoStruct::__set_enqueueTime(const int64_t val) {
  this->enqueueTime = val;
__isset.enqueueTime = true;
}

void CompactionInfoStruct::__set_retryRetention(const int64_t val) {
  this->retryRetention = val;
__isset.retryRetention = true;
}

void CompactionInfoStruct::__set_poolname(const std::string& val) {
  this->poolname = val;
__isset.poolname = true;
}

void CompactionInfoStruct::__set_numberOfBuckets(const int32_t val) {
  this->numberOfBuckets = val;
__isset.numberOfBuckets = true;
}

void CompactionInfoStruct::__set_orderByClause(const std::string& val) {
  this->orderByClause = val;
__isset.orderByClause = true;
}
std::ostream& operator<<(std::ostream& out, const CompactionInfoStruct& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CompactionInfoStruct::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_dbname = false;
  bool isset_tablename = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          isset_tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partitionname);
          this->__isset.partitionname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast980;
          xfer += iprot->readI32(ecast980);
          this->type = static_cast<CompactionType::type>(ecast980);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->runas);
          this->__isset.runas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->properties);
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->toomanyaborts);
          this->__isset.toomanyaborts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->state);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->workerId);
          this->__isset.workerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->highestWriteId);
          this->__isset.highestWriteId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errorMessage);
          this->__isset.errorMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasoldabort);
          this->__isset.hasoldabort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->enqueueTime);
          this->__isset.enqueueTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->retryRetention);
          this->__isset.retryRetention = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->poolname);
          this->__isset.poolname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numberOfBuckets);
          this->__isset.numberOfBuckets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->orderByClause);
          this->__isset.orderByClause = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CompactionInfoStruct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactionInfoStruct");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partitionname) {
    xfer += oprot->writeFieldBegin("partitionname", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->partitionname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.runas) {
    xfer += oprot->writeFieldBegin("runas", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->runas);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.properties) {
    xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->properties);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.toomanyaborts) {
    xfer += oprot->writeFieldBegin("toomanyaborts", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->toomanyaborts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.workerId) {
    xfer += oprot->writeFieldBegin("workerId", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->workerId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.start) {
    xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->start);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.highestWriteId) {
    xfer += oprot->writeFieldBegin("highestWriteId", ::apache::thrift::protocol::T_I64, 12);
    xfer += oprot->writeI64(this->highestWriteId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.errorMessage) {
    xfer += oprot->writeFieldBegin("errorMessage", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->errorMessage);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hasoldabort) {
    xfer += oprot->writeFieldBegin("hasoldabort", ::apache::thrift::protocol::T_BOOL, 14);
    xfer += oprot->writeBool(this->hasoldabort);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.enqueueTime) {
    xfer += oprot->writeFieldBegin("enqueueTime", ::apache::thrift::protocol::T_I64, 15);
    xfer += oprot->writeI64(this->enqueueTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.retryRetention) {
    xfer += oprot->writeFieldBegin("retryRetention", ::apache::thrift::protocol::T_I64, 16);
    xfer += oprot->writeI64(this->retryRetention);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.poolname) {
    xfer += oprot->writeFieldBegin("poolname", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->poolname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.numberOfBuckets) {
    xfer += oprot->writeFieldBegin("numberOfBuckets", ::apache::thrift::protocol::T_I32, 18);
    xfer += oprot->writeI32(this->numberOfBuckets);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.orderByClause) {
    xfer += oprot->writeFieldBegin("orderByClause", ::apache::thrift::protocol::T_STRING, 19);
    xfer += oprot->writeString(this->orderByClause);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactionInfoStruct &a, CompactionInfoStruct &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionname, b.partitionname);
  swap(a.type, b.type);
  swap(a.runas, b.runas);
  swap(a.properties, b.properties);
  swap(a.toomanyaborts, b.toomanyaborts);
  swap(a.state, b.state);
  swap(a.workerId, b.workerId);
  swap(a.start, b.start);
  swap(a.highestWriteId, b.highestWriteId);
  swap(a.errorMessage, b.errorMessage);
  swap(a.hasoldabort, b.hasoldabort);
  swap(a.enqueueTime, b.enqueueTime);
  swap(a.retryRetention, b.retryRetention);
  swap(a.poolname, b.poolname);
  swap(a.numberOfBuckets, b.numberOfBuckets);
  swap(a.orderByClause, b.orderByClause);
  swap(a.__isset, b.__isset);
}

CompactionInfoStruct::CompactionInfoStruct(const CompactionInfoStruct& other981) {
  id = other981.id;
  dbname = other981.dbname;
  tablename = other981.tablename;
  partitionname = other981.partitionname;
  type = other981.type;
  runas = other981.runas;
  properties = other981.properties;
  toomanyaborts = other981.toomanyaborts;
  state = other981.state;
  workerId = other981.workerId;
  start = other981.start;
  highestWriteId = other981.highestWriteId;
  errorMessage = other981.errorMessage;
  hasoldabort = other981.hasoldabort;
  enqueueTime = other981.enqueueTime;
  retryRetention = other981.retryRetention;
  poolname = other981.poolname;
  numberOfBuckets = other981.numberOfBuckets;
  orderByClause = other981.orderByClause;
  __isset = other981.__isset;
}
CompactionInfoStruct& CompactionInfoStruct::operator=(const CompactionInfoStruct& other982) {
  id = other982.id;
  dbname = other982.dbname;
  tablename = other982.tablename;
  partitionname = other982.partitionname;
  type = other982.type;
  runas = other982.runas;
  properties = other982.properties;
  toomanyaborts = other982.toomanyaborts;
  state = other982.state;
  workerId = other982.workerId;
  start = other982.start;
  highestWriteId = other982.highestWriteId;
  errorMessage = other982.errorMessage;
  hasoldabort = other982.hasoldabort;
  enqueueTime = other982.enqueueTime;
  retryRetention = other982.retryRetention;
  poolname = other982.poolname;
  numberOfBuckets = other982.numberOfBuckets;
  orderByClause = other982.orderByClause;
  __isset = other982.__isset;
  return *this;
}
void CompactionInfoStruct::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactionInfoStruct(";
  out << "id=" << to_string(id);
  out << ", " << "dbname=" << to_string(dbname);
  out << ", " << "tablename=" << to_string(tablename);
  out << ", " << "partitionname="; (__isset.partitionname ? (out << to_string(partitionname)) : (out << "<null>"));
  out << ", " << "type=" << to_string(type);
  out << ", " << "runas="; (__isset.runas ? (out << to_string(runas)) : (out << "<null>"));
  out << ", " << "properties="; (__isset.properties ? (out << to_string(properties)) : (out << "<null>"));
  out << ", " << "toomanyaborts="; (__isset.toomanyaborts ? (out << to_string(toomanyaborts)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "workerId="; (__isset.workerId ? (out << to_string(workerId)) : (out << "<null>"));
  out << ", " << "start="; (__isset.start ? (out << to_string(start)) : (out << "<null>"));
  out << ", " << "highestWriteId="; (__isset.highestWriteId ? (out << to_string(highestWriteId)) : (out << "<null>"));
  out << ", " << "errorMessage="; (__isset.errorMessage ? (out << to_string(errorMessage)) : (out << "<null>"));
  out << ", " << "hasoldabort="; (__isset.hasoldabort ? (out << to_string(hasoldabort)) : (out << "<null>"));
  out << ", " << "enqueueTime="; (__isset.enqueueTime ? (out << to_string(enqueueTime)) : (out << "<null>"));
  out << ", " << "retryRetention="; (__isset.retryRetention ? (out << to_string(retryRetention)) : (out << "<null>"));
  out << ", " << "poolname="; (__isset.poolname ? (out << to_string(poolname)) : (out << "<null>"));
  out << ", " << "numberOfBuckets="; (__isset.numberOfBuckets ? (out << to_string(numberOfBuckets)) : (out << "<null>"));
  out << ", " << "orderByClause="; (__isset.orderByClause ? (out << to_string(orderByClause)) : (out << "<null>"));
  out << ")";
}


OptionalCompactionInfoStruct::~OptionalCompactionInfoStruct() noexcept {
}


void OptionalCompactionInfoStruct::__set_ci(const CompactionInfoStruct& val) {
  this->ci = val;
__isset.ci = true;
}
std::ostream& operator<<(std::ostream& out, const OptionalCompactionInfoStruct& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t OptionalCompactionInfoStruct::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ci.read(iprot);
          this->__isset.ci = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OptionalCompactionInfoStruct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OptionalCompactionInfoStruct");

  if (this->__isset.ci) {
    xfer += oprot->writeFieldBegin("ci", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ci.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OptionalCompactionInfoStruct &a, OptionalCompactionInfoStruct &b) {
  using ::std::swap;
  swap(a.ci, b.ci);
  swap(a.__isset, b.__isset);
}

OptionalCompactionInfoStruct::OptionalCompactionInfoStruct(const OptionalCompactionInfoStruct& other983) {
  ci = other983.ci;
  __isset = other983.__isset;
}
OptionalCompactionInfoStruct& OptionalCompactionInfoStruct::operator=(const OptionalCompactionInfoStruct& other984) {
  ci = other984.ci;
  __isset = other984.__isset;
  return *this;
}
void OptionalCompactionInfoStruct::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OptionalCompactionInfoStruct(";
  out << "ci="; (__isset.ci ? (out << to_string(ci)) : (out << "<null>"));
  out << ")";
}


CompactionMetricsDataStruct::~CompactionMetricsDataStruct() noexcept {
}


void CompactionMetricsDataStruct::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void CompactionMetricsDataStruct::__set_tblname(const std::string& val) {
  this->tblname = val;
}

void CompactionMetricsDataStruct::__set_partitionname(const std::string& val) {
  this->partitionname = val;
__isset.partitionname = true;
}

void CompactionMetricsDataStruct::__set_type(const CompactionMetricsMetricType::type val) {
  this->type = val;
}

void CompactionMetricsDataStruct::__set_metricvalue(const int32_t val) {
  this->metricvalue = val;
}

void CompactionMetricsDataStruct::__set_version(const int32_t val) {
  this->version = val;
}

void CompactionMetricsDataStruct::__set_threshold(const int32_t val) {
  this->threshold = val;
}
std::ostream& operator<<(std::ostream& out, const CompactionMetricsDataStruct& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CompactionMetricsDataStruct::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbname = false;
  bool isset_tblname = false;
  bool isset_type = false;
  bool isset_metricvalue = false;
  bool isset_version = false;
  bool isset_threshold = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblname);
          isset_tblname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partitionname);
          this->__isset.partitionname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast985;
          xfer += iprot->readI32(ecast985);
          this->type = static_cast<CompactionMetricsMetricType::type>(ecast985);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->metricvalue);
          isset_metricvalue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->threshold);
          isset_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metricvalue)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CompactionMetricsDataStruct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactionMetricsDataStruct");

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblname", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partitionname) {
    xfer += oprot->writeFieldBegin("partitionname", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->partitionname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metricvalue", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->metricvalue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("threshold", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactionMetricsDataStruct &a, CompactionMetricsDataStruct &b) {
  using ::std::swap;
  swap(a.dbname, b.dbname);
  swap(a.tblname, b.tblname);
  swap(a.partitionname, b.partitionname);
  swap(a.type, b.type);
  swap(a.metricvalue, b.metricvalue);
  swap(a.version, b.version);
  swap(a.threshold, b.threshold);
  swap(a.__isset, b.__isset);
}

CompactionMetricsDataStruct::CompactionMetricsDataStruct(const CompactionMetricsDataStruct& other986) {
  dbname = other986.dbname;
  tblname = other986.tblname;
  partitionname = other986.partitionname;
  type = other986.type;
  metricvalue = other986.metricvalue;
  version = other986.version;
  threshold = other986.threshold;
  __isset = other986.__isset;
}
CompactionMetricsDataStruct& CompactionMetricsDataStruct::operator=(const CompactionMetricsDataStruct& other987) {
  dbname = other987.dbname;
  tblname = other987.tblname;
  partitionname = other987.partitionname;
  type = other987.type;
  metricvalue = other987.metricvalue;
  version = other987.version;
  threshold = other987.threshold;
  __isset = other987.__isset;
  return *this;
}
void CompactionMetricsDataStruct::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactionMetricsDataStruct(";
  out << "dbname=" << to_string(dbname);
  out << ", " << "tblname=" << to_string(tblname);
  out << ", " << "partitionname="; (__isset.partitionname ? (out << to_string(partitionname)) : (out << "<null>"));
  out << ", " << "type=" << to_string(type);
  out << ", " << "metricvalue=" << to_string(metricvalue);
  out << ", " << "version=" << to_string(version);
  out << ", " << "threshold=" << to_string(threshold);
  out << ")";
}


CompactionMetricsDataResponse::~CompactionMetricsDataResponse() noexcept {
}


void CompactionMetricsDataResponse::__set_data(const CompactionMetricsDataStruct& val) {
  this->data = val;
__isset.data = true;
}
std::ostream& operator<<(std::ostream& out, const CompactionMetricsDataResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CompactionMetricsDataResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CompactionMetricsDataResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactionMetricsDataResponse");

  if (this->__isset.data) {
    xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->data.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactionMetricsDataResponse &a, CompactionMetricsDataResponse &b) {
  using ::std::swap;
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CompactionMetricsDataResponse::CompactionMetricsDataResponse(const CompactionMetricsDataResponse& other988) {
  data = other988.data;
  __isset = other988.__isset;
}
CompactionMetricsDataResponse& CompactionMetricsDataResponse::operator=(const CompactionMetricsDataResponse& other989) {
  data = other989.data;
  __isset = other989.__isset;
  return *this;
}
void CompactionMetricsDataResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactionMetricsDataResponse(";
  out << "data="; (__isset.data ? (out << to_string(data)) : (out << "<null>"));
  out << ")";
}


CompactionMetricsDataRequest::~CompactionMetricsDataRequest() noexcept {
}


void CompactionMetricsDataRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void CompactionMetricsDataRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void CompactionMetricsDataRequest::__set_partitionName(const std::string& val) {
  this->partitionName = val;
__isset.partitionName = true;
}

void CompactionMetricsDataRequest::__set_type(const CompactionMetricsMetricType::type val) {
  this->type = val;
}
std::ostream& operator<<(std::ostream& out, const CompactionMetricsDataRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CompactionMetricsDataRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partitionName);
          this->__isset.partitionName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast990;
          xfer += iprot->readI32(ecast990);
          this->type = static_cast<CompactionMetricsMetricType::type>(ecast990);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CompactionMetricsDataRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactionMetricsDataRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partitionName) {
    xfer += oprot->writeFieldBegin("partitionName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->partitionName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactionMetricsDataRequest &a, CompactionMetricsDataRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.partitionName, b.partitionName);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

CompactionMetricsDataRequest::CompactionMetricsDataRequest(const CompactionMetricsDataRequest& other991) {
  dbName = other991.dbName;
  tblName = other991.tblName;
  partitionName = other991.partitionName;
  type = other991.type;
  __isset = other991.__isset;
}
CompactionMetricsDataRequest& CompactionMetricsDataRequest::operator=(const CompactionMetricsDataRequest& other992) {
  dbName = other992.dbName;
  tblName = other992.tblName;
  partitionName = other992.partitionName;
  type = other992.type;
  __isset = other992.__isset;
  return *this;
}
void CompactionMetricsDataRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactionMetricsDataRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "partitionName="; (__isset.partitionName ? (out << to_string(partitionName)) : (out << "<null>"));
  out << ", " << "type=" << to_string(type);
  out << ")";
}


CompactionResponse::~CompactionResponse() noexcept {
}


void CompactionResponse::__set_id(const int64_t val) {
  this->id = val;
}

void CompactionResponse::__set_state(const std::string& val) {
  this->state = val;
}

void CompactionResponse::__set_accepted(const bool val) {
  this->accepted = val;
}

void CompactionResponse::__set_errormessage(const std::string& val) {
  this->errormessage = val;
__isset.errormessage = true;
}
std::ostream& operator<<(std::ostream& out, const CompactionResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CompactionResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_state = false;
  bool isset_accepted = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->state);
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->accepted);
          isset_accepted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errormessage);
          this->__isset.errormessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_accepted)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CompactionResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactionResponse");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("accepted", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->accepted);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.errormessage) {
    xfer += oprot->writeFieldBegin("errormessage", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->errormessage);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactionResponse &a, CompactionResponse &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.state, b.state);
  swap(a.accepted, b.accepted);
  swap(a.errormessage, b.errormessage);
  swap(a.__isset, b.__isset);
}

CompactionResponse::CompactionResponse(const CompactionResponse& other993) {
  id = other993.id;
  state = other993.state;
  accepted = other993.accepted;
  errormessage = other993.errormessage;
  __isset = other993.__isset;
}
CompactionResponse& CompactionResponse::operator=(const CompactionResponse& other994) {
  id = other994.id;
  state = other994.state;
  accepted = other994.accepted;
  errormessage = other994.errormessage;
  __isset = other994.__isset;
  return *this;
}
void CompactionResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactionResponse(";
  out << "id=" << to_string(id);
  out << ", " << "state=" << to_string(state);
  out << ", " << "accepted=" << to_string(accepted);
  out << ", " << "errormessage="; (__isset.errormessage ? (out << to_string(errormessage)) : (out << "<null>"));
  out << ")";
}


ShowCompactRequest::~ShowCompactRequest() noexcept {
}


void ShowCompactRequest::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}

void ShowCompactRequest::__set_poolName(const std::string& val) {
  this->poolName = val;
__isset.poolName = true;
}

void ShowCompactRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
__isset.dbName = true;
}

void ShowCompactRequest::__set_tbName(const std::string& val) {
  this->tbName = val;
__isset.tbName = true;
}

void ShowCompactRequest::__set_partName(const std::string& val) {
  this->partName = val;
__isset.partName = true;
}

void ShowCompactRequest::__set_type(const CompactionType::type val) {
  this->type = val;
__isset.type = true;
}

void ShowCompactRequest::__set_state(const std::string& val) {
  this->state = val;
__isset.state = true;
}

void ShowCompactRequest::__set_limit(const int64_t val) {
  this->limit = val;
__isset.limit = true;
}

void ShowCompactRequest::__set_order(const std::string& val) {
  this->order = val;
__isset.order = true;
}
std::ostream& operator<<(std::ostream& out, const ShowCompactRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowCompactRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->poolName);
          this->__isset.poolName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbName);
          this->__isset.tbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partName);
          this->__isset.partName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast995;
          xfer += iprot->readI32(ecast995);
          this->type = static_cast<CompactionType::type>(ecast995);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->state);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->order);
          this->__isset.order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowCompactRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowCompactRequest");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.poolName) {
    xfer += oprot->writeFieldBegin("poolName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->poolName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dbName) {
    xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->dbName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tbName) {
    xfer += oprot->writeFieldBegin("tbName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->tbName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partName) {
    xfer += oprot->writeFieldBegin("partName", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->partName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(static_cast<int32_t>(this->type));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.limit) {
    xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.order) {
    xfer += oprot->writeFieldBegin("order", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowCompactRequest &a, ShowCompactRequest &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.poolName, b.poolName);
  swap(a.dbName, b.dbName);
  swap(a.tbName, b.tbName);
  swap(a.partName, b.partName);
  swap(a.type, b.type);
  swap(a.state, b.state);
  swap(a.limit, b.limit);
  swap(a.order, b.order);
  swap(a.__isset, b.__isset);
}

ShowCompactRequest::ShowCompactRequest(const ShowCompactRequest& other996) {
  id = other996.id;
  poolName = other996.poolName;
  dbName = other996.dbName;
  tbName = other996.tbName;
  partName = other996.partName;
  type = other996.type;
  state = other996.state;
  limit = other996.limit;
  order = other996.order;
  __isset = other996.__isset;
}
ShowCompactRequest& ShowCompactRequest::operator=(const ShowCompactRequest& other997) {
  id = other997.id;
  poolName = other997.poolName;
  dbName = other997.dbName;
  tbName = other997.tbName;
  partName = other997.partName;
  type = other997.type;
  state = other997.state;
  limit = other997.limit;
  order = other997.order;
  __isset = other997.__isset;
  return *this;
}
void ShowCompactRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowCompactRequest(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "poolName="; (__isset.poolName ? (out << to_string(poolName)) : (out << "<null>"));
  out << ", " << "dbName="; (__isset.dbName ? (out << to_string(dbName)) : (out << "<null>"));
  out << ", " << "tbName="; (__isset.tbName ? (out << to_string(tbName)) : (out << "<null>"));
  out << ", " << "partName="; (__isset.partName ? (out << to_string(partName)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "limit="; (__isset.limit ? (out << to_string(limit)) : (out << "<null>"));
  out << ", " << "order="; (__isset.order ? (out << to_string(order)) : (out << "<null>"));
  out << ")";
}


ShowCompactResponseElement::~ShowCompactResponseElement() noexcept {
}


void ShowCompactResponseElement::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void ShowCompactResponseElement::__set_tablename(const std::string& val) {
  this->tablename = val;
}

void ShowCompactResponseElement::__set_partitionname(const std::string& val) {
  this->partitionname = val;
__isset.partitionname = true;
}

void ShowCompactResponseElement::__set_type(const CompactionType::type val) {
  this->type = val;
}

void ShowCompactResponseElement::__set_state(const std::string& val) {
  this->state = val;
}

void ShowCompactResponseElement::__set_workerid(const std::string& val) {
  this->workerid = val;
__isset.workerid = true;
}

void ShowCompactResponseElement::__set_start(const int64_t val) {
  this->start = val;
__isset.start = true;
}

void ShowCompactResponseElement::__set_runAs(const std::string& val) {
  this->runAs = val;
__isset.runAs = true;
}

void ShowCompactResponseElement::__set_hightestTxnId(const int64_t val) {
  this->hightestTxnId = val;
__isset.hightestTxnId = true;
}

void ShowCompactResponseElement::__set_metaInfo(const std::string& val) {
  this->metaInfo = val;
__isset.metaInfo = true;
}

void ShowCompactResponseElement::__set_endTime(const int64_t val) {
  this->endTime = val;
__isset.endTime = true;
}

void ShowCompactResponseElement::__set_hadoopJobId(const std::string& val) {
  this->hadoopJobId = val;
__isset.hadoopJobId = true;
}

void ShowCompactResponseElement::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}

void ShowCompactResponseElement::__set_errorMessage(const std::string& val) {
  this->errorMessage = val;
__isset.errorMessage = true;
}

void ShowCompactResponseElement::__set_enqueueTime(const int64_t val) {
  this->enqueueTime = val;
__isset.enqueueTime = true;
}

void ShowCompactResponseElement::__set_workerVersion(const std::string& val) {
  this->workerVersion = val;
__isset.workerVersion = true;
}

void ShowCompactResponseElement::__set_initiatorId(const std::string& val) {
  this->initiatorId = val;
__isset.initiatorId = true;
}

void ShowCompactResponseElement::__set_initiatorVersion(const std::string& val) {
  this->initiatorVersion = val;
__isset.initiatorVersion = true;
}

void ShowCompactResponseElement::__set_cleanerStart(const int64_t val) {
  this->cleanerStart = val;
__isset.cleanerStart = true;
}

void ShowCompactResponseElement::__set_poolName(const std::string& val) {
  this->poolName = val;
__isset.poolName = true;
}

void ShowCompactResponseElement::__set_nextTxnId(const int64_t val) {
  this->nextTxnId = val;
__isset.nextTxnId = true;
}

void ShowCompactResponseElement::__set_txnId(const int64_t val) {
  this->txnId = val;
__isset.txnId = true;
}

void ShowCompactResponseElement::__set_commitTime(const int64_t val) {
  this->commitTime = val;
__isset.commitTime = true;
}

void ShowCompactResponseElement::__set_hightestWriteId(const int64_t val) {
  this->hightestWriteId = val;
__isset.hightestWriteId = true;
}
std::ostream& operator<<(std::ostream& out, const ShowCompactResponseElement& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowCompactResponseElement::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbname = false;
  bool isset_tablename = false;
  bool isset_type = false;
  bool isset_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          isset_tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partitionname);
          this->__isset.partitionname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast998;
          xfer += iprot->readI32(ecast998);
          this->type = static_cast<CompactionType::type>(ecast998);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->state);
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->workerid);
          this->__isset.workerid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->runAs);
          this->__isset.runAs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->hightestTxnId);
          this->__isset.hightestTxnId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metaInfo);
          this->__isset.metaInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->endTime);
          this->__isset.endTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hadoopJobId);
          this->__isset.hadoopJobId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errorMessage);
          this->__isset.errorMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->enqueueTime);
          this->__isset.enqueueTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->workerVersion);
          this->__isset.workerVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->initiatorId);
          this->__isset.initiatorId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->initiatorVersion);
          this->__isset.initiatorVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cleanerStart);
          this->__isset.cleanerStart = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->poolName);
          this->__isset.poolName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nextTxnId);
          this->__isset.nextTxnId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnId);
          this->__isset.txnId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->commitTime);
          this->__isset.commitTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->hightestWriteId);
          this->__isset.hightestWriteId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ShowCompactResponseElement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowCompactResponseElement");

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partitionname) {
    xfer += oprot->writeFieldBegin("partitionname", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->partitionname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.workerid) {
    xfer += oprot->writeFieldBegin("workerid", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->workerid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.start) {
    xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->start);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.runAs) {
    xfer += oprot->writeFieldBegin("runAs", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->runAs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hightestTxnId) {
    xfer += oprot->writeFieldBegin("hightestTxnId", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->hightestTxnId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.metaInfo) {
    xfer += oprot->writeFieldBegin("metaInfo", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->metaInfo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.endTime) {
    xfer += oprot->writeFieldBegin("endTime", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->endTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hadoopJobId) {
    xfer += oprot->writeFieldBegin("hadoopJobId", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->hadoopJobId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 13);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.errorMessage) {
    xfer += oprot->writeFieldBegin("errorMessage", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->errorMessage);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.enqueueTime) {
    xfer += oprot->writeFieldBegin("enqueueTime", ::apache::thrift::protocol::T_I64, 15);
    xfer += oprot->writeI64(this->enqueueTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.workerVersion) {
    xfer += oprot->writeFieldBegin("workerVersion", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->workerVersion);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.initiatorId) {
    xfer += oprot->writeFieldBegin("initiatorId", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->initiatorId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.initiatorVersion) {
    xfer += oprot->writeFieldBegin("initiatorVersion", ::apache::thrift::protocol::T_STRING, 18);
    xfer += oprot->writeString(this->initiatorVersion);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cleanerStart) {
    xfer += oprot->writeFieldBegin("cleanerStart", ::apache::thrift::protocol::T_I64, 19);
    xfer += oprot->writeI64(this->cleanerStart);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.poolName) {
    xfer += oprot->writeFieldBegin("poolName", ::apache::thrift::protocol::T_STRING, 20);
    xfer += oprot->writeString(this->poolName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nextTxnId) {
    xfer += oprot->writeFieldBegin("nextTxnId", ::apache::thrift::protocol::T_I64, 21);
    xfer += oprot->writeI64(this->nextTxnId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.txnId) {
    xfer += oprot->writeFieldBegin("txnId", ::apache::thrift::protocol::T_I64, 22);
    xfer += oprot->writeI64(this->txnId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.commitTime) {
    xfer += oprot->writeFieldBegin("commitTime", ::apache::thrift::protocol::T_I64, 23);
    xfer += oprot->writeI64(this->commitTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hightestWriteId) {
    xfer += oprot->writeFieldBegin("hightestWriteId", ::apache::thrift::protocol::T_I64, 24);
    xfer += oprot->writeI64(this->hightestWriteId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowCompactResponseElement &a, ShowCompactResponseElement &b) {
  using ::std::swap;
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionname, b.partitionname);
  swap(a.type, b.type);
  swap(a.state, b.state);
  swap(a.workerid, b.workerid);
  swap(a.start, b.start);
  swap(a.runAs, b.runAs);
  swap(a.hightestTxnId, b.hightestTxnId);
  swap(a.metaInfo, b.metaInfo);
  swap(a.endTime, b.endTime);
  swap(a.hadoopJobId, b.hadoopJobId);
  swap(a.id, b.id);
  swap(a.errorMessage, b.errorMessage);
  swap(a.enqueueTime, b.enqueueTime);
  swap(a.workerVersion, b.workerVersion);
  swap(a.initiatorId, b.initiatorId);
  swap(a.initiatorVersion, b.initiatorVersion);
  swap(a.cleanerStart, b.cleanerStart);
  swap(a.poolName, b.poolName);
  swap(a.nextTxnId, b.nextTxnId);
  swap(a.txnId, b.txnId);
  swap(a.commitTime, b.commitTime);
  swap(a.hightestWriteId, b.hightestWriteId);
  swap(a.__isset, b.__isset);
}

ShowCompactResponseElement::ShowCompactResponseElement(const ShowCompactResponseElement& other999) {
  dbname = other999.dbname;
  tablename = other999.tablename;
  partitionname = other999.partitionname;
  type = other999.type;
  state = other999.state;
  workerid = other999.workerid;
  start = other999.start;
  runAs = other999.runAs;
  hightestTxnId = other999.hightestTxnId;
  metaInfo = other999.metaInfo;
  endTime = other999.endTime;
  hadoopJobId = other999.hadoopJobId;
  id = other999.id;
  errorMessage = other999.errorMessage;
  enqueueTime = other999.enqueueTime;
  workerVersion = other999.workerVersion;
  initiatorId = other999.initiatorId;
  initiatorVersion = other999.initiatorVersion;
  cleanerStart = other999.cleanerStart;
  poolName = other999.poolName;
  nextTxnId = other999.nextTxnId;
  txnId = other999.txnId;
  commitTime = other999.commitTime;
  hightestWriteId = other999.hightestWriteId;
  __isset = other999.__isset;
}
ShowCompactResponseElement& ShowCompactResponseElement::operator=(const ShowCompactResponseElement& other1000) {
  dbname = other1000.dbname;
  tablename = other1000.tablename;
  partitionname = other1000.partitionname;
  type = other1000.type;
  state = other1000.state;
  workerid = other1000.workerid;
  start = other1000.start;
  runAs = other1000.runAs;
  hightestTxnId = other1000.hightestTxnId;
  metaInfo = other1000.metaInfo;
  endTime = other1000.endTime;
  hadoopJobId = other1000.hadoopJobId;
  id = other1000.id;
  errorMessage = other1000.errorMessage;
  enqueueTime = other1000.enqueueTime;
  workerVersion = other1000.workerVersion;
  initiatorId = other1000.initiatorId;
  initiatorVersion = other1000.initiatorVersion;
  cleanerStart = other1000.cleanerStart;
  poolName = other1000.poolName;
  nextTxnId = other1000.nextTxnId;
  txnId = other1000.txnId;
  commitTime = other1000.commitTime;
  hightestWriteId = other1000.hightestWriteId;
  __isset = other1000.__isset;
  return *this;
}
void ShowCompactResponseElement::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowCompactResponseElement(";
  out << "dbname=" << to_string(dbname);
  out << ", " << "tablename=" << to_string(tablename);
  out << ", " << "partitionname="; (__isset.partitionname ? (out << to_string(partitionname)) : (out << "<null>"));
  out << ", " << "type=" << to_string(type);
  out << ", " << "state=" << to_string(state);
  out << ", " << "workerid="; (__isset.workerid ? (out << to_string(workerid)) : (out << "<null>"));
  out << ", " << "start="; (__isset.start ? (out << to_string(start)) : (out << "<null>"));
  out << ", " << "runAs="; (__isset.runAs ? (out << to_string(runAs)) : (out << "<null>"));
  out << ", " << "hightestTxnId="; (__isset.hightestTxnId ? (out << to_string(hightestTxnId)) : (out << "<null>"));
  out << ", " << "metaInfo="; (__isset.metaInfo ? (out << to_string(metaInfo)) : (out << "<null>"));
  out << ", " << "endTime="; (__isset.endTime ? (out << to_string(endTime)) : (out << "<null>"));
  out << ", " << "hadoopJobId="; (__isset.hadoopJobId ? (out << to_string(hadoopJobId)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "errorMessage="; (__isset.errorMessage ? (out << to_string(errorMessage)) : (out << "<null>"));
  out << ", " << "enqueueTime="; (__isset.enqueueTime ? (out << to_string(enqueueTime)) : (out << "<null>"));
  out << ", " << "workerVersion="; (__isset.workerVersion ? (out << to_string(workerVersion)) : (out << "<null>"));
  out << ", " << "initiatorId="; (__isset.initiatorId ? (out << to_string(initiatorId)) : (out << "<null>"));
  out << ", " << "initiatorVersion="; (__isset.initiatorVersion ? (out << to_string(initiatorVersion)) : (out << "<null>"));
  out << ", " << "cleanerStart="; (__isset.cleanerStart ? (out << to_string(cleanerStart)) : (out << "<null>"));
  out << ", " << "poolName="; (__isset.poolName ? (out << to_string(poolName)) : (out << "<null>"));
  out << ", " << "nextTxnId="; (__isset.nextTxnId ? (out << to_string(nextTxnId)) : (out << "<null>"));
  out << ", " << "txnId="; (__isset.txnId ? (out << to_string(txnId)) : (out << "<null>"));
  out << ", " << "commitTime="; (__isset.commitTime ? (out << to_string(commitTime)) : (out << "<null>"));
  out << ", " << "hightestWriteId="; (__isset.hightestWriteId ? (out << to_string(hightestWriteId)) : (out << "<null>"));
  out << ")";
}


ShowCompactResponse::~ShowCompactResponse() noexcept {
}


void ShowCompactResponse::__set_compacts(const std::vector<ShowCompactResponseElement> & val) {
  this->compacts = val;
}
std::ostream& operator<<(std::ostream& out, const ShowCompactResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowCompactResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_compacts = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->compacts.clear();
            uint32_t _size1001;
            ::apache::thrift::protocol::TType _etype1004;
            xfer += iprot->readListBegin(_etype1004, _size1001);
            this->compacts.resize(_size1001);
            uint32_t _i1005;
            for (_i1005 = 0; _i1005 < _size1001; ++_i1005)
            {
              xfer += this->compacts[_i1005].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_compacts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_compacts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ShowCompactResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowCompactResponse");

  xfer += oprot->writeFieldBegin("compacts", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->compacts.size()));
    std::vector<ShowCompactResponseElement> ::const_iterator _iter1006;
    for (_iter1006 = this->compacts.begin(); _iter1006 != this->compacts.end(); ++_iter1006)
    {
      xfer += (*_iter1006).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowCompactResponse &a, ShowCompactResponse &b) {
  using ::std::swap;
  swap(a.compacts, b.compacts);
}

ShowCompactResponse::ShowCompactResponse(const ShowCompactResponse& other1007) {
  compacts = other1007.compacts;
}
ShowCompactResponse& ShowCompactResponse::operator=(const ShowCompactResponse& other1008) {
  compacts = other1008.compacts;
  return *this;
}
void ShowCompactResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowCompactResponse(";
  out << "compacts=" << to_string(compacts);
  out << ")";
}


AbortCompactionRequest::~AbortCompactionRequest() noexcept {
}


void AbortCompactionRequest::__set_compactionIds(const std::vector<int64_t> & val) {
  this->compactionIds = val;
}

void AbortCompactionRequest::__set_type(const std::string& val) {
  this->type = val;
__isset.type = true;
}

void AbortCompactionRequest::__set_poolName(const std::string& val) {
  this->poolName = val;
__isset.poolName = true;
}
std::ostream& operator<<(std::ostream& out, const AbortCompactionRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AbortCompactionRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_compactionIds = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->compactionIds.clear();
            uint32_t _size1009;
            ::apache::thrift::protocol::TType _etype1012;
            xfer += iprot->readListBegin(_etype1012, _size1009);
            this->compactionIds.resize(_size1009);
            uint32_t _i1013;
            for (_i1013 = 0; _i1013 < _size1009; ++_i1013)
            {
              xfer += iprot->readI64(this->compactionIds[_i1013]);
            }
            xfer += iprot->readListEnd();
          }
          isset_compactionIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->poolName);
          this->__isset.poolName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_compactionIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AbortCompactionRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AbortCompactionRequest");

  xfer += oprot->writeFieldBegin("compactionIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->compactionIds.size()));
    std::vector<int64_t> ::const_iterator _iter1014;
    for (_iter1014 = this->compactionIds.begin(); _iter1014 != this->compactionIds.end(); ++_iter1014)
    {
      xfer += oprot->writeI64((*_iter1014));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.poolName) {
    xfer += oprot->writeFieldBegin("poolName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->poolName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AbortCompactionRequest &a, AbortCompactionRequest &b) {
  using ::std::swap;
  swap(a.compactionIds, b.compactionIds);
  swap(a.type, b.type);
  swap(a.poolName, b.poolName);
  swap(a.__isset, b.__isset);
}

AbortCompactionRequest::AbortCompactionRequest(const AbortCompactionRequest& other1015) {
  compactionIds = other1015.compactionIds;
  type = other1015.type;
  poolName = other1015.poolName;
  __isset = other1015.__isset;
}
AbortCompactionRequest& AbortCompactionRequest::operator=(const AbortCompactionRequest& other1016) {
  compactionIds = other1016.compactionIds;
  type = other1016.type;
  poolName = other1016.poolName;
  __isset = other1016.__isset;
  return *this;
}
void AbortCompactionRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AbortCompactionRequest(";
  out << "compactionIds=" << to_string(compactionIds);
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "poolName="; (__isset.poolName ? (out << to_string(poolName)) : (out << "<null>"));
  out << ")";
}


AbortCompactionResponseElement::~AbortCompactionResponseElement() noexcept {
}


void AbortCompactionResponseElement::__set_compactionId(const int64_t val) {
  this->compactionId = val;
}

void AbortCompactionResponseElement::__set_status(const std::string& val) {
  this->status = val;
__isset.status = true;
}

void AbortCompactionResponseElement::__set_message(const std::string& val) {
  this->message = val;
__isset.message = true;
}
std::ostream& operator<<(std::ostream& out, const AbortCompactionResponseElement& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AbortCompactionResponseElement::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_compactionId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->compactionId);
          isset_compactionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_compactionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AbortCompactionResponseElement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AbortCompactionResponseElement");

  xfer += oprot->writeFieldBegin("compactionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->compactionId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->status);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AbortCompactionResponseElement &a, AbortCompactionResponseElement &b) {
  using ::std::swap;
  swap(a.compactionId, b.compactionId);
  swap(a.status, b.status);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

AbortCompactionResponseElement::AbortCompactionResponseElement(const AbortCompactionResponseElement& other1017) {
  compactionId = other1017.compactionId;
  status = other1017.status;
  message = other1017.message;
  __isset = other1017.__isset;
}
AbortCompactionResponseElement& AbortCompactionResponseElement::operator=(const AbortCompactionResponseElement& other1018) {
  compactionId = other1018.compactionId;
  status = other1018.status;
  message = other1018.message;
  __isset = other1018.__isset;
  return *this;
}
void AbortCompactionResponseElement::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AbortCompactionResponseElement(";
  out << "compactionId=" << to_string(compactionId);
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ", " << "message="; (__isset.message ? (out << to_string(message)) : (out << "<null>"));
  out << ")";
}


AbortCompactResponse::~AbortCompactResponse() noexcept {
}


void AbortCompactResponse::__set_abortedcompacts(const std::map<int64_t, AbortCompactionResponseElement> & val) {
  this->abortedcompacts = val;
}
std::ostream& operator<<(std::ostream& out, const AbortCompactResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AbortCompactResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_abortedcompacts = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->abortedcompacts.clear();
            uint32_t _size1019;
            ::apache::thrift::protocol::TType _ktype1020;
            ::apache::thrift::protocol::TType _vtype1021;
            xfer += iprot->readMapBegin(_ktype1020, _vtype1021, _size1019);
            uint32_t _i1023;
            for (_i1023 = 0; _i1023 < _size1019; ++_i1023)
            {
              int64_t _key1024;
              xfer += iprot->readI64(_key1024);
              AbortCompactionResponseElement& _val1025 = this->abortedcompacts[_key1024];
              xfer += _val1025.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_abortedcompacts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_abortedcompacts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AbortCompactResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AbortCompactResponse");

  xfer += oprot->writeFieldBegin("abortedcompacts", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->abortedcompacts.size()));
    std::map<int64_t, AbortCompactionResponseElement> ::const_iterator _iter1026;
    for (_iter1026 = this->abortedcompacts.begin(); _iter1026 != this->abortedcompacts.end(); ++_iter1026)
    {
      xfer += oprot->writeI64(_iter1026->first);
      xfer += _iter1026->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AbortCompactResponse &a, AbortCompactResponse &b) {
  using ::std::swap;
  swap(a.abortedcompacts, b.abortedcompacts);
}

AbortCompactResponse::AbortCompactResponse(const AbortCompactResponse& other1027) {
  abortedcompacts = other1027.abortedcompacts;
}
AbortCompactResponse& AbortCompactResponse::operator=(const AbortCompactResponse& other1028) {
  abortedcompacts = other1028.abortedcompacts;
  return *this;
}
void AbortCompactResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AbortCompactResponse(";
  out << "abortedcompacts=" << to_string(abortedcompacts);
  out << ")";
}


GetLatestCommittedCompactionInfoRequest::~GetLatestCommittedCompactionInfoRequest() noexcept {
}


void GetLatestCommittedCompactionInfoRequest::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void GetLatestCommittedCompactionInfoRequest::__set_tablename(const std::string& val) {
  this->tablename = val;
}

void GetLatestCommittedCompactionInfoRequest::__set_partitionnames(const std::vector<std::string> & val) {
  this->partitionnames = val;
__isset.partitionnames = true;
}

void GetLatestCommittedCompactionInfoRequest::__set_lastCompactionId(const int64_t val) {
  this->lastCompactionId = val;
__isset.lastCompactionId = true;
}
std::ostream& operator<<(std::ostream& out, const GetLatestCommittedCompactionInfoRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetLatestCommittedCompactionInfoRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbname = false;
  bool isset_tablename = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          isset_tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionnames.clear();
            uint32_t _size1029;
            ::apache::thrift::protocol::TType _etype1032;
            xfer += iprot->readListBegin(_etype1032, _size1029);
            this->partitionnames.resize(_size1029);
            uint32_t _i1033;
            for (_i1033 = 0; _i1033 < _size1029; ++_i1033)
            {
              xfer += iprot->readString(this->partitionnames[_i1033]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionnames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastCompactionId);
          this->__isset.lastCompactionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetLatestCommittedCompactionInfoRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetLatestCommittedCompactionInfoRequest");

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partitionnames) {
    xfer += oprot->writeFieldBegin("partitionnames", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partitionnames.size()));
      std::vector<std::string> ::const_iterator _iter1034;
      for (_iter1034 = this->partitionnames.begin(); _iter1034 != this->partitionnames.end(); ++_iter1034)
      {
        xfer += oprot->writeString((*_iter1034));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastCompactionId) {
    xfer += oprot->writeFieldBegin("lastCompactionId", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->lastCompactionId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetLatestCommittedCompactionInfoRequest &a, GetLatestCommittedCompactionInfoRequest &b) {
  using ::std::swap;
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionnames, b.partitionnames);
  swap(a.lastCompactionId, b.lastCompactionId);
  swap(a.__isset, b.__isset);
}

GetLatestCommittedCompactionInfoRequest::GetLatestCommittedCompactionInfoRequest(const GetLatestCommittedCompactionInfoRequest& other1035) {
  dbname = other1035.dbname;
  tablename = other1035.tablename;
  partitionnames = other1035.partitionnames;
  lastCompactionId = other1035.lastCompactionId;
  __isset = other1035.__isset;
}
GetLatestCommittedCompactionInfoRequest& GetLatestCommittedCompactionInfoRequest::operator=(const GetLatestCommittedCompactionInfoRequest& other1036) {
  dbname = other1036.dbname;
  tablename = other1036.tablename;
  partitionnames = other1036.partitionnames;
  lastCompactionId = other1036.lastCompactionId;
  __isset = other1036.__isset;
  return *this;
}
void GetLatestCommittedCompactionInfoRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetLatestCommittedCompactionInfoRequest(";
  out << "dbname=" << to_string(dbname);
  out << ", " << "tablename=" << to_string(tablename);
  out << ", " << "partitionnames="; (__isset.partitionnames ? (out << to_string(partitionnames)) : (out << "<null>"));
  out << ", " << "lastCompactionId="; (__isset.lastCompactionId ? (out << to_string(lastCompactionId)) : (out << "<null>"));
  out << ")";
}


GetLatestCommittedCompactionInfoResponse::~GetLatestCommittedCompactionInfoResponse() noexcept {
}


void GetLatestCommittedCompactionInfoResponse::__set_compactions(const std::vector<CompactionInfoStruct> & val) {
  this->compactions = val;
}
std::ostream& operator<<(std::ostream& out, const GetLatestCommittedCompactionInfoResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetLatestCommittedCompactionInfoResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_compactions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->compactions.clear();
            uint32_t _size1037;
            ::apache::thrift::protocol::TType _etype1040;
            xfer += iprot->readListBegin(_etype1040, _size1037);
            this->compactions.resize(_size1037);
            uint32_t _i1041;
            for (_i1041 = 0; _i1041 < _size1037; ++_i1041)
            {
              xfer += this->compactions[_i1041].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_compactions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_compactions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetLatestCommittedCompactionInfoResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetLatestCommittedCompactionInfoResponse");

  xfer += oprot->writeFieldBegin("compactions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->compactions.size()));
    std::vector<CompactionInfoStruct> ::const_iterator _iter1042;
    for (_iter1042 = this->compactions.begin(); _iter1042 != this->compactions.end(); ++_iter1042)
    {
      xfer += (*_iter1042).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetLatestCommittedCompactionInfoResponse &a, GetLatestCommittedCompactionInfoResponse &b) {
  using ::std::swap;
  swap(a.compactions, b.compactions);
}

GetLatestCommittedCompactionInfoResponse::GetLatestCommittedCompactionInfoResponse(const GetLatestCommittedCompactionInfoResponse& other1043) {
  compactions = other1043.compactions;
}
GetLatestCommittedCompactionInfoResponse& GetLatestCommittedCompactionInfoResponse::operator=(const GetLatestCommittedCompactionInfoResponse& other1044) {
  compactions = other1044.compactions;
  return *this;
}
void GetLatestCommittedCompactionInfoResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetLatestCommittedCompactionInfoResponse(";
  out << "compactions=" << to_string(compactions);
  out << ")";
}


FindNextCompactRequest::~FindNextCompactRequest() noexcept {
}


void FindNextCompactRequest::__set_workerId(const std::string& val) {
  this->workerId = val;
__isset.workerId = true;
}

void FindNextCompactRequest::__set_workerVersion(const std::string& val) {
  this->workerVersion = val;
__isset.workerVersion = true;
}

void FindNextCompactRequest::__set_poolName(const std::string& val) {
  this->poolName = val;
__isset.poolName = true;
}
std::ostream& operator<<(std::ostream& out, const FindNextCompactRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FindNextCompactRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->workerId);
          this->__isset.workerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->workerVersion);
          this->__isset.workerVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->poolName);
          this->__isset.poolName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FindNextCompactRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FindNextCompactRequest");

  if (this->__isset.workerId) {
    xfer += oprot->writeFieldBegin("workerId", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->workerId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.workerVersion) {
    xfer += oprot->writeFieldBegin("workerVersion", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->workerVersion);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.poolName) {
    xfer += oprot->writeFieldBegin("poolName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->poolName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FindNextCompactRequest &a, FindNextCompactRequest &b) {
  using ::std::swap;
  swap(a.workerId, b.workerId);
  swap(a.workerVersion, b.workerVersion);
  swap(a.poolName, b.poolName);
  swap(a.__isset, b.__isset);
}

FindNextCompactRequest::FindNextCompactRequest(const FindNextCompactRequest& other1045) {
  workerId = other1045.workerId;
  workerVersion = other1045.workerVersion;
  poolName = other1045.poolName;
  __isset = other1045.__isset;
}
FindNextCompactRequest& FindNextCompactRequest::operator=(const FindNextCompactRequest& other1046) {
  workerId = other1046.workerId;
  workerVersion = other1046.workerVersion;
  poolName = other1046.poolName;
  __isset = other1046.__isset;
  return *this;
}
void FindNextCompactRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FindNextCompactRequest(";
  out << "workerId="; (__isset.workerId ? (out << to_string(workerId)) : (out << "<null>"));
  out << ", " << "workerVersion="; (__isset.workerVersion ? (out << to_string(workerVersion)) : (out << "<null>"));
  out << ", " << "poolName="; (__isset.poolName ? (out << to_string(poolName)) : (out << "<null>"));
  out << ")";
}


AddDynamicPartitions::~AddDynamicPartitions() noexcept {
}


void AddDynamicPartitions::__set_txnid(const int64_t val) {
  this->txnid = val;
}

void AddDynamicPartitions::__set_writeid(const int64_t val) {
  this->writeid = val;
}

void AddDynamicPartitions::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void AddDynamicPartitions::__set_tablename(const std::string& val) {
  this->tablename = val;
}

void AddDynamicPartitions::__set_partitionnames(const std::vector<std::string> & val) {
  this->partitionnames = val;
}

void AddDynamicPartitions::__set_operationType(const DataOperationType::type val) {
  this->operationType = val;
__isset.operationType = true;
}
std::ostream& operator<<(std::ostream& out, const AddDynamicPartitions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddDynamicPartitions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txnid = false;
  bool isset_writeid = false;
  bool isset_dbname = false;
  bool isset_tablename = false;
  bool isset_partitionnames = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          isset_txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeid);
          isset_writeid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          isset_tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionnames.clear();
            uint32_t _size1047;
            ::apache::thrift::protocol::TType _etype1050;
            xfer += iprot->readListBegin(_etype1050, _size1047);
            this->partitionnames.resize(_size1047);
            uint32_t _i1051;
            for (_i1051 = 0; _i1051 < _size1047; ++_i1051)
            {
              xfer += iprot->readString(this->partitionnames[_i1051]);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitionnames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1052;
          xfer += iprot->readI32(ecast1052);
          this->operationType = static_cast<DataOperationType::type>(ecast1052);
          this->__isset.operationType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txnid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_writeid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partitionnames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddDynamicPartitions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddDynamicPartitions");

  xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txnid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("writeid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->writeid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitionnames", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partitionnames.size()));
    std::vector<std::string> ::const_iterator _iter1053;
    for (_iter1053 = this->partitionnames.begin(); _iter1053 != this->partitionnames.end(); ++_iter1053)
    {
      xfer += oprot->writeString((*_iter1053));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationType) {
    xfer += oprot->writeFieldBegin("operationType", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(static_cast<int32_t>(this->operationType));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddDynamicPartitions &a, AddDynamicPartitions &b) {
  using ::std::swap;
  swap(a.txnid, b.txnid);
  swap(a.writeid, b.writeid);
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionnames, b.partitionnames);
  swap(a.operationType, b.operationType);
  swap(a.__isset, b.__isset);
}

AddDynamicPartitions::AddDynamicPartitions(const AddDynamicPartitions& other1054) {
  txnid = other1054.txnid;
  writeid = other1054.writeid;
  dbname = other1054.dbname;
  tablename = other1054.tablename;
  partitionnames = other1054.partitionnames;
  operationType = other1054.operationType;
  __isset = other1054.__isset;
}
AddDynamicPartitions& AddDynamicPartitions::operator=(const AddDynamicPartitions& other1055) {
  txnid = other1055.txnid;
  writeid = other1055.writeid;
  dbname = other1055.dbname;
  tablename = other1055.tablename;
  partitionnames = other1055.partitionnames;
  operationType = other1055.operationType;
  __isset = other1055.__isset;
  return *this;
}
void AddDynamicPartitions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddDynamicPartitions(";
  out << "txnid=" << to_string(txnid);
  out << ", " << "writeid=" << to_string(writeid);
  out << ", " << "dbname=" << to_string(dbname);
  out << ", " << "tablename=" << to_string(tablename);
  out << ", " << "partitionnames=" << to_string(partitionnames);
  out << ", " << "operationType="; (__isset.operationType ? (out << to_string(operationType)) : (out << "<null>"));
  out << ")";
}


BasicTxnInfo::~BasicTxnInfo() noexcept {
}


void BasicTxnInfo::__set_isnull(const bool val) {
  this->isnull = val;
}

void BasicTxnInfo::__set_time(const int64_t val) {
  this->time = val;
__isset.time = true;
}

void BasicTxnInfo::__set_txnid(const int64_t val) {
  this->txnid = val;
__isset.txnid = true;
}

void BasicTxnInfo::__set_dbname(const std::string& val) {
  this->dbname = val;
__isset.dbname = true;
}

void BasicTxnInfo::__set_tablename(const std::string& val) {
  this->tablename = val;
__isset.tablename = true;
}

void BasicTxnInfo::__set_partitionname(const std::string& val) {
  this->partitionname = val;
__isset.partitionname = true;
}
std::ostream& operator<<(std::ostream& out, const BasicTxnInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BasicTxnInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_isnull = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isnull);
          isset_isnull = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          this->__isset.txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          this->__isset.dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          this->__isset.tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partitionname);
          this->__isset.partitionname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_isnull)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t BasicTxnInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BasicTxnInfo");

  xfer += oprot->writeFieldBegin("isnull", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->isnull);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.time) {
    xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.txnid) {
    xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->txnid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dbname) {
    xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->dbname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tablename) {
    xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->tablename);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionname) {
    xfer += oprot->writeFieldBegin("partitionname", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->partitionname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BasicTxnInfo &a, BasicTxnInfo &b) {
  using ::std::swap;
  swap(a.isnull, b.isnull);
  swap(a.time, b.time);
  swap(a.txnid, b.txnid);
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionname, b.partitionname);
  swap(a.__isset, b.__isset);
}

BasicTxnInfo::BasicTxnInfo(const BasicTxnInfo& other1056) {
  isnull = other1056.isnull;
  time = other1056.time;
  txnid = other1056.txnid;
  dbname = other1056.dbname;
  tablename = other1056.tablename;
  partitionname = other1056.partitionname;
  __isset = other1056.__isset;
}
BasicTxnInfo& BasicTxnInfo::operator=(const BasicTxnInfo& other1057) {
  isnull = other1057.isnull;
  time = other1057.time;
  txnid = other1057.txnid;
  dbname = other1057.dbname;
  tablename = other1057.tablename;
  partitionname = other1057.partitionname;
  __isset = other1057.__isset;
  return *this;
}
void BasicTxnInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BasicTxnInfo(";
  out << "isnull=" << to_string(isnull);
  out << ", " << "time="; (__isset.time ? (out << to_string(time)) : (out << "<null>"));
  out << ", " << "txnid="; (__isset.txnid ? (out << to_string(txnid)) : (out << "<null>"));
  out << ", " << "dbname="; (__isset.dbname ? (out << to_string(dbname)) : (out << "<null>"));
  out << ", " << "tablename="; (__isset.tablename ? (out << to_string(tablename)) : (out << "<null>"));
  out << ", " << "partitionname="; (__isset.partitionname ? (out << to_string(partitionname)) : (out << "<null>"));
  out << ")";
}


NotificationEventRequest::~NotificationEventRequest() noexcept {
}


void NotificationEventRequest::__set_lastEvent(const int64_t val) {
  this->lastEvent = val;
}

void NotificationEventRequest::__set_maxEvents(const int32_t val) {
  this->maxEvents = val;
__isset.maxEvents = true;
}

void NotificationEventRequest::__set_eventTypeSkipList(const std::vector<std::string> & val) {
  this->eventTypeSkipList = val;
__isset.eventTypeSkipList = true;
}
std::ostream& operator<<(std::ostream& out, const NotificationEventRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotificationEventRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lastEvent = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastEvent);
          isset_lastEvent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxEvents);
          this->__isset.maxEvents = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->eventTypeSkipList.clear();
            uint32_t _size1058;
            ::apache::thrift::protocol::TType _etype1061;
            xfer += iprot->readListBegin(_etype1061, _size1058);
            this->eventTypeSkipList.resize(_size1058);
            uint32_t _i1062;
            for (_i1062 = 0; _i1062 < _size1058; ++_i1062)
            {
              xfer += iprot->readString(this->eventTypeSkipList[_i1062]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.eventTypeSkipList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lastEvent)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotificationEventRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotificationEventRequest");

  xfer += oprot->writeFieldBegin("lastEvent", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lastEvent);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.maxEvents) {
    xfer += oprot->writeFieldBegin("maxEvents", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->maxEvents);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.eventTypeSkipList) {
    xfer += oprot->writeFieldBegin("eventTypeSkipList", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->eventTypeSkipList.size()));
      std::vector<std::string> ::const_iterator _iter1063;
      for (_iter1063 = this->eventTypeSkipList.begin(); _iter1063 != this->eventTypeSkipList.end(); ++_iter1063)
      {
        xfer += oprot->writeString((*_iter1063));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotificationEventRequest &a, NotificationEventRequest &b) {
  using ::std::swap;
  swap(a.lastEvent, b.lastEvent);
  swap(a.maxEvents, b.maxEvents);
  swap(a.eventTypeSkipList, b.eventTypeSkipList);
  swap(a.__isset, b.__isset);
}

NotificationEventRequest::NotificationEventRequest(const NotificationEventRequest& other1064) {
  lastEvent = other1064.lastEvent;
  maxEvents = other1064.maxEvents;
  eventTypeSkipList = other1064.eventTypeSkipList;
  __isset = other1064.__isset;
}
NotificationEventRequest& NotificationEventRequest::operator=(const NotificationEventRequest& other1065) {
  lastEvent = other1065.lastEvent;
  maxEvents = other1065.maxEvents;
  eventTypeSkipList = other1065.eventTypeSkipList;
  __isset = other1065.__isset;
  return *this;
}
void NotificationEventRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotificationEventRequest(";
  out << "lastEvent=" << to_string(lastEvent);
  out << ", " << "maxEvents="; (__isset.maxEvents ? (out << to_string(maxEvents)) : (out << "<null>"));
  out << ", " << "eventTypeSkipList="; (__isset.eventTypeSkipList ? (out << to_string(eventTypeSkipList)) : (out << "<null>"));
  out << ")";
}


NotificationEvent::~NotificationEvent() noexcept {
}


void NotificationEvent::__set_eventId(const int64_t val) {
  this->eventId = val;
}

void NotificationEvent::__set_eventTime(const int32_t val) {
  this->eventTime = val;
}

void NotificationEvent::__set_eventType(const std::string& val) {
  this->eventType = val;
}

void NotificationEvent::__set_dbName(const std::string& val) {
  this->dbName = val;
__isset.dbName = true;
}

void NotificationEvent::__set_tableName(const std::string& val) {
  this->tableName = val;
__isset.tableName = true;
}

void NotificationEvent::__set_message(const std::string& val) {
  this->message = val;
}

void NotificationEvent::__set_messageFormat(const std::string& val) {
  this->messageFormat = val;
__isset.messageFormat = true;
}

void NotificationEvent::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}
std::ostream& operator<<(std::ostream& out, const NotificationEvent& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotificationEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_eventId = false;
  bool isset_eventTime = false;
  bool isset_eventType = false;
  bool isset_message = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->eventId);
          isset_eventId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->eventTime);
          isset_eventTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->eventType);
          isset_eventType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          isset_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->messageFormat);
          this->__isset.messageFormat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_eventId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_eventTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_eventType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_message)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotificationEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotificationEvent");

  xfer += oprot->writeFieldBegin("eventId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->eventId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eventTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->eventTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eventType", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->eventType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dbName) {
    xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->dbName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableName) {
    xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->tableName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.messageFormat) {
    xfer += oprot->writeFieldBegin("messageFormat", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->messageFormat);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotificationEvent &a, NotificationEvent &b) {
  using ::std::swap;
  swap(a.eventId, b.eventId);
  swap(a.eventTime, b.eventTime);
  swap(a.eventType, b.eventType);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.message, b.message);
  swap(a.messageFormat, b.messageFormat);
  swap(a.catName, b.catName);
  swap(a.__isset, b.__isset);
}

NotificationEvent::NotificationEvent(const NotificationEvent& other1066) {
  eventId = other1066.eventId;
  eventTime = other1066.eventTime;
  eventType = other1066.eventType;
  dbName = other1066.dbName;
  tableName = other1066.tableName;
  message = other1066.message;
  messageFormat = other1066.messageFormat;
  catName = other1066.catName;
  __isset = other1066.__isset;
}
NotificationEvent& NotificationEvent::operator=(const NotificationEvent& other1067) {
  eventId = other1067.eventId;
  eventTime = other1067.eventTime;
  eventType = other1067.eventType;
  dbName = other1067.dbName;
  tableName = other1067.tableName;
  message = other1067.message;
  messageFormat = other1067.messageFormat;
  catName = other1067.catName;
  __isset = other1067.__isset;
  return *this;
}
void NotificationEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotificationEvent(";
  out << "eventId=" << to_string(eventId);
  out << ", " << "eventTime=" << to_string(eventTime);
  out << ", " << "eventType=" << to_string(eventType);
  out << ", " << "dbName="; (__isset.dbName ? (out << to_string(dbName)) : (out << "<null>"));
  out << ", " << "tableName="; (__isset.tableName ? (out << to_string(tableName)) : (out << "<null>"));
  out << ", " << "message=" << to_string(message);
  out << ", " << "messageFormat="; (__isset.messageFormat ? (out << to_string(messageFormat)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ")";
}


NotificationEventResponse::~NotificationEventResponse() noexcept {
}


void NotificationEventResponse::__set_events(const std::vector<NotificationEvent> & val) {
  this->events = val;
}
std::ostream& operator<<(std::ostream& out, const NotificationEventResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotificationEventResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_events = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->events.clear();
            uint32_t _size1068;
            ::apache::thrift::protocol::TType _etype1071;
            xfer += iprot->readListBegin(_etype1071, _size1068);
            this->events.resize(_size1068);
            uint32_t _i1072;
            for (_i1072 = 0; _i1072 < _size1068; ++_i1072)
            {
              xfer += this->events[_i1072].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_events = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_events)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotificationEventResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotificationEventResponse");

  xfer += oprot->writeFieldBegin("events", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->events.size()));
    std::vector<NotificationEvent> ::const_iterator _iter1073;
    for (_iter1073 = this->events.begin(); _iter1073 != this->events.end(); ++_iter1073)
    {
      xfer += (*_iter1073).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotificationEventResponse &a, NotificationEventResponse &b) {
  using ::std::swap;
  swap(a.events, b.events);
}

NotificationEventResponse::NotificationEventResponse(const NotificationEventResponse& other1074) {
  events = other1074.events;
}
NotificationEventResponse& NotificationEventResponse::operator=(const NotificationEventResponse& other1075) {
  events = other1075.events;
  return *this;
}
void NotificationEventResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotificationEventResponse(";
  out << "events=" << to_string(events);
  out << ")";
}


CurrentNotificationEventId::~CurrentNotificationEventId() noexcept {
}


void CurrentNotificationEventId::__set_eventId(const int64_t val) {
  this->eventId = val;
}
std::ostream& operator<<(std::ostream& out, const CurrentNotificationEventId& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CurrentNotificationEventId::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_eventId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->eventId);
          isset_eventId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_eventId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CurrentNotificationEventId::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CurrentNotificationEventId");

  xfer += oprot->writeFieldBegin("eventId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->eventId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CurrentNotificationEventId &a, CurrentNotificationEventId &b) {
  using ::std::swap;
  swap(a.eventId, b.eventId);
}

CurrentNotificationEventId::CurrentNotificationEventId(const CurrentNotificationEventId& other1076) noexcept {
  eventId = other1076.eventId;
}
CurrentNotificationEventId& CurrentNotificationEventId::operator=(const CurrentNotificationEventId& other1077) noexcept {
  eventId = other1077.eventId;
  return *this;
}
void CurrentNotificationEventId::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CurrentNotificationEventId(";
  out << "eventId=" << to_string(eventId);
  out << ")";
}


NotificationEventsCountRequest::~NotificationEventsCountRequest() noexcept {
}


void NotificationEventsCountRequest::__set_fromEventId(const int64_t val) {
  this->fromEventId = val;
}

void NotificationEventsCountRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void NotificationEventsCountRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void NotificationEventsCountRequest::__set_toEventId(const int64_t val) {
  this->toEventId = val;
__isset.toEventId = true;
}

void NotificationEventsCountRequest::__set_limit(const int64_t val) {
  this->limit = val;
__isset.limit = true;
}
std::ostream& operator<<(std::ostream& out, const NotificationEventsCountRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotificationEventsCountRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fromEventId = false;
  bool isset_dbName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->fromEventId);
          isset_fromEventId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->toEventId);
          this->__isset.toEventId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fromEventId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotificationEventsCountRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotificationEventsCountRequest");

  xfer += oprot->writeFieldBegin("fromEventId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->fromEventId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.toEventId) {
    xfer += oprot->writeFieldBegin("toEventId", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->toEventId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.limit) {
    xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->limit);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotificationEventsCountRequest &a, NotificationEventsCountRequest &b) {
  using ::std::swap;
  swap(a.fromEventId, b.fromEventId);
  swap(a.dbName, b.dbName);
  swap(a.catName, b.catName);
  swap(a.toEventId, b.toEventId);
  swap(a.limit, b.limit);
  swap(a.__isset, b.__isset);
}

NotificationEventsCountRequest::NotificationEventsCountRequest(const NotificationEventsCountRequest& other1078) {
  fromEventId = other1078.fromEventId;
  dbName = other1078.dbName;
  catName = other1078.catName;
  toEventId = other1078.toEventId;
  limit = other1078.limit;
  __isset = other1078.__isset;
}
NotificationEventsCountRequest& NotificationEventsCountRequest::operator=(const NotificationEventsCountRequest& other1079) {
  fromEventId = other1079.fromEventId;
  dbName = other1079.dbName;
  catName = other1079.catName;
  toEventId = other1079.toEventId;
  limit = other1079.limit;
  __isset = other1079.__isset;
  return *this;
}
void NotificationEventsCountRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotificationEventsCountRequest(";
  out << "fromEventId=" << to_string(fromEventId);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "toEventId="; (__isset.toEventId ? (out << to_string(toEventId)) : (out << "<null>"));
  out << ", " << "limit="; (__isset.limit ? (out << to_string(limit)) : (out << "<null>"));
  out << ")";
}


NotificationEventsCountResponse::~NotificationEventsCountResponse() noexcept {
}


void NotificationEventsCountResponse::__set_eventsCount(const int64_t val) {
  this->eventsCount = val;
}
std::ostream& operator<<(std::ostream& out, const NotificationEventsCountResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotificationEventsCountResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_eventsCount = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->eventsCount);
          isset_eventsCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_eventsCount)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotificationEventsCountResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotificationEventsCountResponse");

  xfer += oprot->writeFieldBegin("eventsCount", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->eventsCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotificationEventsCountResponse &a, NotificationEventsCountResponse &b) {
  using ::std::swap;
  swap(a.eventsCount, b.eventsCount);
}

NotificationEventsCountResponse::NotificationEventsCountResponse(const NotificationEventsCountResponse& other1080) noexcept {
  eventsCount = other1080.eventsCount;
}
NotificationEventsCountResponse& NotificationEventsCountResponse::operator=(const NotificationEventsCountResponse& other1081) noexcept {
  eventsCount = other1081.eventsCount;
  return *this;
}
void NotificationEventsCountResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotificationEventsCountResponse(";
  out << "eventsCount=" << to_string(eventsCount);
  out << ")";
}


InsertEventRequestData::~InsertEventRequestData() noexcept {
}


void InsertEventRequestData::__set_replace(const bool val) {
  this->replace = val;
__isset.replace = true;
}

void InsertEventRequestData::__set_filesAdded(const std::vector<std::string> & val) {
  this->filesAdded = val;
}

void InsertEventRequestData::__set_filesAddedChecksum(const std::vector<std::string> & val) {
  this->filesAddedChecksum = val;
__isset.filesAddedChecksum = true;
}

void InsertEventRequestData::__set_subDirectoryList(const std::vector<std::string> & val) {
  this->subDirectoryList = val;
__isset.subDirectoryList = true;
}

void InsertEventRequestData::__set_partitionVal(const std::vector<std::string> & val) {
  this->partitionVal = val;
__isset.partitionVal = true;
}
std::ostream& operator<<(std::ostream& out, const InsertEventRequestData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InsertEventRequestData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_filesAdded = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->replace);
          this->__isset.replace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->filesAdded.clear();
            uint32_t _size1082;
            ::apache::thrift::protocol::TType _etype1085;
            xfer += iprot->readListBegin(_etype1085, _size1082);
            this->filesAdded.resize(_size1082);
            uint32_t _i1086;
            for (_i1086 = 0; _i1086 < _size1082; ++_i1086)
            {
              xfer += iprot->readString(this->filesAdded[_i1086]);
            }
            xfer += iprot->readListEnd();
          }
          isset_filesAdded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->filesAddedChecksum.clear();
            uint32_t _size1087;
            ::apache::thrift::protocol::TType _etype1090;
            xfer += iprot->readListBegin(_etype1090, _size1087);
            this->filesAddedChecksum.resize(_size1087);
            uint32_t _i1091;
            for (_i1091 = 0; _i1091 < _size1087; ++_i1091)
            {
              xfer += iprot->readString(this->filesAddedChecksum[_i1091]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.filesAddedChecksum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->subDirectoryList.clear();
            uint32_t _size1092;
            ::apache::thrift::protocol::TType _etype1095;
            xfer += iprot->readListBegin(_etype1095, _size1092);
            this->subDirectoryList.resize(_size1092);
            uint32_t _i1096;
            for (_i1096 = 0; _i1096 < _size1092; ++_i1096)
            {
              xfer += iprot->readString(this->subDirectoryList[_i1096]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.subDirectoryList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionVal.clear();
            uint32_t _size1097;
            ::apache::thrift::protocol::TType _etype1100;
            xfer += iprot->readListBegin(_etype1100, _size1097);
            this->partitionVal.resize(_size1097);
            uint32_t _i1101;
            for (_i1101 = 0; _i1101 < _size1097; ++_i1101)
            {
              xfer += iprot->readString(this->partitionVal[_i1101]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_filesAdded)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InsertEventRequestData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InsertEventRequestData");

  if (this->__isset.replace) {
    xfer += oprot->writeFieldBegin("replace", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->replace);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("filesAdded", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->filesAdded.size()));
    std::vector<std::string> ::const_iterator _iter1102;
    for (_iter1102 = this->filesAdded.begin(); _iter1102 != this->filesAdded.end(); ++_iter1102)
    {
      xfer += oprot->writeString((*_iter1102));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.filesAddedChecksum) {
    xfer += oprot->writeFieldBegin("filesAddedChecksum", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->filesAddedChecksum.size()));
      std::vector<std::string> ::const_iterator _iter1103;
      for (_iter1103 = this->filesAddedChecksum.begin(); _iter1103 != this->filesAddedChecksum.end(); ++_iter1103)
      {
        xfer += oprot->writeString((*_iter1103));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subDirectoryList) {
    xfer += oprot->writeFieldBegin("subDirectoryList", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->subDirectoryList.size()));
      std::vector<std::string> ::const_iterator _iter1104;
      for (_iter1104 = this->subDirectoryList.begin(); _iter1104 != this->subDirectoryList.end(); ++_iter1104)
      {
        xfer += oprot->writeString((*_iter1104));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionVal) {
    xfer += oprot->writeFieldBegin("partitionVal", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partitionVal.size()));
      std::vector<std::string> ::const_iterator _iter1105;
      for (_iter1105 = this->partitionVal.begin(); _iter1105 != this->partitionVal.end(); ++_iter1105)
      {
        xfer += oprot->writeString((*_iter1105));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InsertEventRequestData &a, InsertEventRequestData &b) {
  using ::std::swap;
  swap(a.replace, b.replace);
  swap(a.filesAdded, b.filesAdded);
  swap(a.filesAddedChecksum, b.filesAddedChecksum);
  swap(a.subDirectoryList, b.subDirectoryList);
  swap(a.partitionVal, b.partitionVal);
  swap(a.__isset, b.__isset);
}

InsertEventRequestData::InsertEventRequestData(const InsertEventRequestData& other1106) {
  replace = other1106.replace;
  filesAdded = other1106.filesAdded;
  filesAddedChecksum = other1106.filesAddedChecksum;
  subDirectoryList = other1106.subDirectoryList;
  partitionVal = other1106.partitionVal;
  __isset = other1106.__isset;
}
InsertEventRequestData& InsertEventRequestData::operator=(const InsertEventRequestData& other1107) {
  replace = other1107.replace;
  filesAdded = other1107.filesAdded;
  filesAddedChecksum = other1107.filesAddedChecksum;
  subDirectoryList = other1107.subDirectoryList;
  partitionVal = other1107.partitionVal;
  __isset = other1107.__isset;
  return *this;
}
void InsertEventRequestData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InsertEventRequestData(";
  out << "replace="; (__isset.replace ? (out << to_string(replace)) : (out << "<null>"));
  out << ", " << "filesAdded=" << to_string(filesAdded);
  out << ", " << "filesAddedChecksum="; (__isset.filesAddedChecksum ? (out << to_string(filesAddedChecksum)) : (out << "<null>"));
  out << ", " << "subDirectoryList="; (__isset.subDirectoryList ? (out << to_string(subDirectoryList)) : (out << "<null>"));
  out << ", " << "partitionVal="; (__isset.partitionVal ? (out << to_string(partitionVal)) : (out << "<null>"));
  out << ")";
}


FireEventRequestData::~FireEventRequestData() noexcept {
}


void FireEventRequestData::__set_insertData(const InsertEventRequestData& val) {
  this->insertData = val;
__isset.insertData = true;
}

void FireEventRequestData::__set_insertDatas(const std::vector<InsertEventRequestData> & val) {
  this->insertDatas = val;
__isset.insertDatas = true;
}

void FireEventRequestData::__set_refreshEvent(const bool val) {
  this->refreshEvent = val;
__isset.refreshEvent = true;
}
std::ostream& operator<<(std::ostream& out, const FireEventRequestData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FireEventRequestData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->insertData.read(iprot);
          this->__isset.insertData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->insertDatas.clear();
            uint32_t _size1108;
            ::apache::thrift::protocol::TType _etype1111;
            xfer += iprot->readListBegin(_etype1111, _size1108);
            this->insertDatas.resize(_size1108);
            uint32_t _i1112;
            for (_i1112 = 0; _i1112 < _size1108; ++_i1112)
            {
              xfer += this->insertDatas[_i1112].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.insertDatas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->refreshEvent);
          this->__isset.refreshEvent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FireEventRequestData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FireEventRequestData");

  if (this->__isset.insertData) {
    xfer += oprot->writeFieldBegin("insertData", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->insertData.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.insertDatas) {
    xfer += oprot->writeFieldBegin("insertDatas", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->insertDatas.size()));
      std::vector<InsertEventRequestData> ::const_iterator _iter1113;
      for (_iter1113 = this->insertDatas.begin(); _iter1113 != this->insertDatas.end(); ++_iter1113)
      {
        xfer += (*_iter1113).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.refreshEvent) {
    xfer += oprot->writeFieldBegin("refreshEvent", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->refreshEvent);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FireEventRequestData &a, FireEventRequestData &b) {
  using ::std::swap;
  swap(a.insertData, b.insertData);
  swap(a.insertDatas, b.insertDatas);
  swap(a.refreshEvent, b.refreshEvent);
  swap(a.__isset, b.__isset);
}

FireEventRequestData::FireEventRequestData(const FireEventRequestData& other1114) {
  insertData = other1114.insertData;
  insertDatas = other1114.insertDatas;
  refreshEvent = other1114.refreshEvent;
  __isset = other1114.__isset;
}
FireEventRequestData& FireEventRequestData::operator=(const FireEventRequestData& other1115) {
  insertData = other1115.insertData;
  insertDatas = other1115.insertDatas;
  refreshEvent = other1115.refreshEvent;
  __isset = other1115.__isset;
  return *this;
}
void FireEventRequestData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FireEventRequestData(";
  out << "insertData="; (__isset.insertData ? (out << to_string(insertData)) : (out << "<null>"));
  out << ", " << "insertDatas="; (__isset.insertDatas ? (out << to_string(insertDatas)) : (out << "<null>"));
  out << ", " << "refreshEvent="; (__isset.refreshEvent ? (out << to_string(refreshEvent)) : (out << "<null>"));
  out << ")";
}


FireEventRequest::~FireEventRequest() noexcept {
}


void FireEventRequest::__set_successful(const bool val) {
  this->successful = val;
}

void FireEventRequest::__set_data(const FireEventRequestData& val) {
  this->data = val;
}

void FireEventRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
__isset.dbName = true;
}

void FireEventRequest::__set_tableName(const std::string& val) {
  this->tableName = val;
__isset.tableName = true;
}

void FireEventRequest::__set_partitionVals(const std::vector<std::string> & val) {
  this->partitionVals = val;
__isset.partitionVals = true;
}

void FireEventRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void FireEventRequest::__set_tblParams(const std::map<std::string, std::string> & val) {
  this->tblParams = val;
__isset.tblParams = true;
}
std::ostream& operator<<(std::ostream& out, const FireEventRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FireEventRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_successful = false;
  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->successful);
          isset_successful = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionVals.clear();
            uint32_t _size1116;
            ::apache::thrift::protocol::TType _etype1119;
            xfer += iprot->readListBegin(_etype1119, _size1116);
            this->partitionVals.resize(_size1116);
            uint32_t _i1120;
            for (_i1120 = 0; _i1120 < _size1116; ++_i1120)
            {
              xfer += iprot->readString(this->partitionVals[_i1120]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionVals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->tblParams.clear();
            uint32_t _size1121;
            ::apache::thrift::protocol::TType _ktype1122;
            ::apache::thrift::protocol::TType _vtype1123;
            xfer += iprot->readMapBegin(_ktype1122, _vtype1123, _size1121);
            uint32_t _i1125;
            for (_i1125 = 0; _i1125 < _size1121; ++_i1125)
            {
              std::string _key1126;
              xfer += iprot->readString(_key1126);
              std::string& _val1127 = this->tblParams[_key1126];
              xfer += iprot->readString(_val1127);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.tblParams = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_successful)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t FireEventRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FireEventRequest");

  xfer += oprot->writeFieldBegin("successful", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->successful);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dbName) {
    xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->dbName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableName) {
    xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->tableName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionVals) {
    xfer += oprot->writeFieldBegin("partitionVals", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partitionVals.size()));
      std::vector<std::string> ::const_iterator _iter1128;
      for (_iter1128 = this->partitionVals.begin(); _iter1128 != this->partitionVals.end(); ++_iter1128)
      {
        xfer += oprot->writeString((*_iter1128));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tblParams) {
    xfer += oprot->writeFieldBegin("tblParams", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tblParams.size()));
      std::map<std::string, std::string> ::const_iterator _iter1129;
      for (_iter1129 = this->tblParams.begin(); _iter1129 != this->tblParams.end(); ++_iter1129)
      {
        xfer += oprot->writeString(_iter1129->first);
        xfer += oprot->writeString(_iter1129->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FireEventRequest &a, FireEventRequest &b) {
  using ::std::swap;
  swap(a.successful, b.successful);
  swap(a.data, b.data);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.partitionVals, b.partitionVals);
  swap(a.catName, b.catName);
  swap(a.tblParams, b.tblParams);
  swap(a.__isset, b.__isset);
}

FireEventRequest::FireEventRequest(const FireEventRequest& other1130) {
  successful = other1130.successful;
  data = other1130.data;
  dbName = other1130.dbName;
  tableName = other1130.tableName;
  partitionVals = other1130.partitionVals;
  catName = other1130.catName;
  tblParams = other1130.tblParams;
  __isset = other1130.__isset;
}
FireEventRequest& FireEventRequest::operator=(const FireEventRequest& other1131) {
  successful = other1131.successful;
  data = other1131.data;
  dbName = other1131.dbName;
  tableName = other1131.tableName;
  partitionVals = other1131.partitionVals;
  catName = other1131.catName;
  tblParams = other1131.tblParams;
  __isset = other1131.__isset;
  return *this;
}
void FireEventRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FireEventRequest(";
  out << "successful=" << to_string(successful);
  out << ", " << "data=" << to_string(data);
  out << ", " << "dbName="; (__isset.dbName ? (out << to_string(dbName)) : (out << "<null>"));
  out << ", " << "tableName="; (__isset.tableName ? (out << to_string(tableName)) : (out << "<null>"));
  out << ", " << "partitionVals="; (__isset.partitionVals ? (out << to_string(partitionVals)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "tblParams="; (__isset.tblParams ? (out << to_string(tblParams)) : (out << "<null>"));
  out << ")";
}


FireEventResponse::~FireEventResponse() noexcept {
}


void FireEventResponse::__set_eventIds(const std::vector<int64_t> & val) {
  this->eventIds = val;
}
std::ostream& operator<<(std::ostream& out, const FireEventResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FireEventResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->eventIds.clear();
            uint32_t _size1132;
            ::apache::thrift::protocol::TType _etype1135;
            xfer += iprot->readListBegin(_etype1135, _size1132);
            this->eventIds.resize(_size1132);
            uint32_t _i1136;
            for (_i1136 = 0; _i1136 < _size1132; ++_i1136)
            {
              xfer += iprot->readI64(this->eventIds[_i1136]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.eventIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FireEventResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FireEventResponse");

  xfer += oprot->writeFieldBegin("eventIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->eventIds.size()));
    std::vector<int64_t> ::const_iterator _iter1137;
    for (_iter1137 = this->eventIds.begin(); _iter1137 != this->eventIds.end(); ++_iter1137)
    {
      xfer += oprot->writeI64((*_iter1137));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FireEventResponse &a, FireEventResponse &b) {
  using ::std::swap;
  swap(a.eventIds, b.eventIds);
  swap(a.__isset, b.__isset);
}

FireEventResponse::FireEventResponse(const FireEventResponse& other1138) {
  eventIds = other1138.eventIds;
  __isset = other1138.__isset;
}
FireEventResponse& FireEventResponse::operator=(const FireEventResponse& other1139) {
  eventIds = other1139.eventIds;
  __isset = other1139.__isset;
  return *this;
}
void FireEventResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FireEventResponse(";
  out << "eventIds=" << to_string(eventIds);
  out << ")";
}


WriteNotificationLogRequest::~WriteNotificationLogRequest() noexcept {
}


void WriteNotificationLogRequest::__set_txnId(const int64_t val) {
  this->txnId = val;
}

void WriteNotificationLogRequest::__set_writeId(const int64_t val) {
  this->writeId = val;
}

void WriteNotificationLogRequest::__set_db(const std::string& val) {
  this->db = val;
}

void WriteNotificationLogRequest::__set_table(const std::string& val) {
  this->table = val;
}

void WriteNotificationLogRequest::__set_fileInfo(const InsertEventRequestData& val) {
  this->fileInfo = val;
}

void WriteNotificationLogRequest::__set_partitionVals(const std::vector<std::string> & val) {
  this->partitionVals = val;
__isset.partitionVals = true;
}
std::ostream& operator<<(std::ostream& out, const WriteNotificationLogRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WriteNotificationLogRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txnId = false;
  bool isset_writeId = false;
  bool isset_db = false;
  bool isset_table = false;
  bool isset_fileInfo = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnId);
          isset_txnId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          isset_writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          isset_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table);
          isset_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fileInfo.read(iprot);
          isset_fileInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionVals.clear();
            uint32_t _size1140;
            ::apache::thrift::protocol::TType _etype1143;
            xfer += iprot->readListBegin(_etype1143, _size1140);
            this->partitionVals.resize(_size1140);
            uint32_t _i1144;
            for (_i1144 = 0; _i1144 < _size1140; ++_i1144)
            {
              xfer += iprot->readString(this->partitionVals[_i1144]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionVals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txnId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_writeId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fileInfo)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WriteNotificationLogRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WriteNotificationLogRequest");

  xfer += oprot->writeFieldBegin("txnId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txnId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->writeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->table);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fileInfo", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->fileInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partitionVals) {
    xfer += oprot->writeFieldBegin("partitionVals", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partitionVals.size()));
      std::vector<std::string> ::const_iterator _iter1145;
      for (_iter1145 = this->partitionVals.begin(); _iter1145 != this->partitionVals.end(); ++_iter1145)
      {
        xfer += oprot->writeString((*_iter1145));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WriteNotificationLogRequest &a, WriteNotificationLogRequest &b) {
  using ::std::swap;
  swap(a.txnId, b.txnId);
  swap(a.writeId, b.writeId);
  swap(a.db, b.db);
  swap(a.table, b.table);
  swap(a.fileInfo, b.fileInfo);
  swap(a.partitionVals, b.partitionVals);
  swap(a.__isset, b.__isset);
}

WriteNotificationLogRequest::WriteNotificationLogRequest(const WriteNotificationLogRequest& other1146) {
  txnId = other1146.txnId;
  writeId = other1146.writeId;
  db = other1146.db;
  table = other1146.table;
  fileInfo = other1146.fileInfo;
  partitionVals = other1146.partitionVals;
  __isset = other1146.__isset;
}
WriteNotificationLogRequest& WriteNotificationLogRequest::operator=(const WriteNotificationLogRequest& other1147) {
  txnId = other1147.txnId;
  writeId = other1147.writeId;
  db = other1147.db;
  table = other1147.table;
  fileInfo = other1147.fileInfo;
  partitionVals = other1147.partitionVals;
  __isset = other1147.__isset;
  return *this;
}
void WriteNotificationLogRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WriteNotificationLogRequest(";
  out << "txnId=" << to_string(txnId);
  out << ", " << "writeId=" << to_string(writeId);
  out << ", " << "db=" << to_string(db);
  out << ", " << "table=" << to_string(table);
  out << ", " << "fileInfo=" << to_string(fileInfo);
  out << ", " << "partitionVals="; (__isset.partitionVals ? (out << to_string(partitionVals)) : (out << "<null>"));
  out << ")";
}


WriteNotificationLogResponse::~WriteNotificationLogResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WriteNotificationLogResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WriteNotificationLogResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WriteNotificationLogResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WriteNotificationLogResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WriteNotificationLogResponse &a, WriteNotificationLogResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WriteNotificationLogResponse::WriteNotificationLogResponse(const WriteNotificationLogResponse& other1148) noexcept {
  (void) other1148;
}
WriteNotificationLogResponse& WriteNotificationLogResponse::operator=(const WriteNotificationLogResponse& other1149) noexcept {
  (void) other1149;
  return *this;
}
void WriteNotificationLogResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WriteNotificationLogResponse(";
  out << ")";
}


WriteNotificationLogBatchRequest::~WriteNotificationLogBatchRequest() noexcept {
}


void WriteNotificationLogBatchRequest::__set_catalog(const std::string& val) {
  this->catalog = val;
}

void WriteNotificationLogBatchRequest::__set_db(const std::string& val) {
  this->db = val;
}

void WriteNotificationLogBatchRequest::__set_table(const std::string& val) {
  this->table = val;
}

void WriteNotificationLogBatchRequest::__set_requestList(const std::vector<WriteNotificationLogRequest> & val) {
  this->requestList = val;
}
std::ostream& operator<<(std::ostream& out, const WriteNotificationLogBatchRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WriteNotificationLogBatchRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catalog = false;
  bool isset_db = false;
  bool isset_table = false;
  bool isset_requestList = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalog);
          isset_catalog = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          isset_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table);
          isset_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->requestList.clear();
            uint32_t _size1150;
            ::apache::thrift::protocol::TType _etype1153;
            xfer += iprot->readListBegin(_etype1153, _size1150);
            this->requestList.resize(_size1150);
            uint32_t _i1154;
            for (_i1154 = 0; _i1154 < _size1150; ++_i1154)
            {
              xfer += this->requestList[_i1154].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_requestList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catalog)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_requestList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WriteNotificationLogBatchRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WriteNotificationLogBatchRequest");

  xfer += oprot->writeFieldBegin("catalog", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catalog);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("requestList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->requestList.size()));
    std::vector<WriteNotificationLogRequest> ::const_iterator _iter1155;
    for (_iter1155 = this->requestList.begin(); _iter1155 != this->requestList.end(); ++_iter1155)
    {
      xfer += (*_iter1155).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WriteNotificationLogBatchRequest &a, WriteNotificationLogBatchRequest &b) {
  using ::std::swap;
  swap(a.catalog, b.catalog);
  swap(a.db, b.db);
  swap(a.table, b.table);
  swap(a.requestList, b.requestList);
}

WriteNotificationLogBatchRequest::WriteNotificationLogBatchRequest(const WriteNotificationLogBatchRequest& other1156) {
  catalog = other1156.catalog;
  db = other1156.db;
  table = other1156.table;
  requestList = other1156.requestList;
}
WriteNotificationLogBatchRequest& WriteNotificationLogBatchRequest::operator=(const WriteNotificationLogBatchRequest& other1157) {
  catalog = other1157.catalog;
  db = other1157.db;
  table = other1157.table;
  requestList = other1157.requestList;
  return *this;
}
void WriteNotificationLogBatchRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WriteNotificationLogBatchRequest(";
  out << "catalog=" << to_string(catalog);
  out << ", " << "db=" << to_string(db);
  out << ", " << "table=" << to_string(table);
  out << ", " << "requestList=" << to_string(requestList);
  out << ")";
}


WriteNotificationLogBatchResponse::~WriteNotificationLogBatchResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WriteNotificationLogBatchResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WriteNotificationLogBatchResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WriteNotificationLogBatchResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WriteNotificationLogBatchResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WriteNotificationLogBatchResponse &a, WriteNotificationLogBatchResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WriteNotificationLogBatchResponse::WriteNotificationLogBatchResponse(const WriteNotificationLogBatchResponse& other1158) noexcept {
  (void) other1158;
}
WriteNotificationLogBatchResponse& WriteNotificationLogBatchResponse::operator=(const WriteNotificationLogBatchResponse& other1159) noexcept {
  (void) other1159;
  return *this;
}
void WriteNotificationLogBatchResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WriteNotificationLogBatchResponse(";
  out << ")";
}


MetadataPpdResult::~MetadataPpdResult() noexcept {
}


void MetadataPpdResult::__set_metadata(const std::string& val) {
  this->metadata = val;
__isset.metadata = true;
}

void MetadataPpdResult::__set_includeBitset(const std::string& val) {
  this->includeBitset = val;
__isset.includeBitset = true;
}
std::ostream& operator<<(std::ostream& out, const MetadataPpdResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MetadataPpdResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->metadata);
          this->__isset.metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->includeBitset);
          this->__isset.includeBitset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MetadataPpdResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MetadataPpdResult");

  if (this->__isset.metadata) {
    xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->metadata);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeBitset) {
    xfer += oprot->writeFieldBegin("includeBitset", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->includeBitset);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MetadataPpdResult &a, MetadataPpdResult &b) {
  using ::std::swap;
  swap(a.metadata, b.metadata);
  swap(a.includeBitset, b.includeBitset);
  swap(a.__isset, b.__isset);
}

MetadataPpdResult::MetadataPpdResult(const MetadataPpdResult& other1160) {
  metadata = other1160.metadata;
  includeBitset = other1160.includeBitset;
  __isset = other1160.__isset;
}
MetadataPpdResult& MetadataPpdResult::operator=(const MetadataPpdResult& other1161) {
  metadata = other1161.metadata;
  includeBitset = other1161.includeBitset;
  __isset = other1161.__isset;
  return *this;
}
void MetadataPpdResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MetadataPpdResult(";
  out << "metadata="; (__isset.metadata ? (out << to_string(metadata)) : (out << "<null>"));
  out << ", " << "includeBitset="; (__isset.includeBitset ? (out << to_string(includeBitset)) : (out << "<null>"));
  out << ")";
}


GetFileMetadataByExprResult::~GetFileMetadataByExprResult() noexcept {
}


void GetFileMetadataByExprResult::__set_metadata(const std::map<int64_t, MetadataPpdResult> & val) {
  this->metadata = val;
}

void GetFileMetadataByExprResult::__set_isSupported(const bool val) {
  this->isSupported = val;
}
std::ostream& operator<<(std::ostream& out, const GetFileMetadataByExprResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetFileMetadataByExprResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_metadata = false;
  bool isset_isSupported = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size1162;
            ::apache::thrift::protocol::TType _ktype1163;
            ::apache::thrift::protocol::TType _vtype1164;
            xfer += iprot->readMapBegin(_ktype1163, _vtype1164, _size1162);
            uint32_t _i1166;
            for (_i1166 = 0; _i1166 < _size1162; ++_i1166)
            {
              int64_t _key1167;
              xfer += iprot->readI64(_key1167);
              MetadataPpdResult& _val1168 = this->metadata[_key1167];
              xfer += _val1168.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isSupported);
          isset_isSupported = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isSupported)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetFileMetadataByExprResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetFileMetadataByExprResult");

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->metadata.size()));
    std::map<int64_t, MetadataPpdResult> ::const_iterator _iter1169;
    for (_iter1169 = this->metadata.begin(); _iter1169 != this->metadata.end(); ++_iter1169)
    {
      xfer += oprot->writeI64(_iter1169->first);
      xfer += _iter1169->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isSupported", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->isSupported);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetFileMetadataByExprResult &a, GetFileMetadataByExprResult &b) {
  using ::std::swap;
  swap(a.metadata, b.metadata);
  swap(a.isSupported, b.isSupported);
}

GetFileMetadataByExprResult::GetFileMetadataByExprResult(const GetFileMetadataByExprResult& other1170) {
  metadata = other1170.metadata;
  isSupported = other1170.isSupported;
}
GetFileMetadataByExprResult& GetFileMetadataByExprResult::operator=(const GetFileMetadataByExprResult& other1171) {
  metadata = other1171.metadata;
  isSupported = other1171.isSupported;
  return *this;
}
void GetFileMetadataByExprResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetFileMetadataByExprResult(";
  out << "metadata=" << to_string(metadata);
  out << ", " << "isSupported=" << to_string(isSupported);
  out << ")";
}


GetFileMetadataByExprRequest::~GetFileMetadataByExprRequest() noexcept {
}


void GetFileMetadataByExprRequest::__set_fileIds(const std::vector<int64_t> & val) {
  this->fileIds = val;
}

void GetFileMetadataByExprRequest::__set_expr(const std::string& val) {
  this->expr = val;
}

void GetFileMetadataByExprRequest::__set_doGetFooters(const bool val) {
  this->doGetFooters = val;
__isset.doGetFooters = true;
}

void GetFileMetadataByExprRequest::__set_type(const FileMetadataExprType::type val) {
  this->type = val;
__isset.type = true;
}
std::ostream& operator<<(std::ostream& out, const GetFileMetadataByExprRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetFileMetadataByExprRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fileIds = false;
  bool isset_expr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fileIds.clear();
            uint32_t _size1172;
            ::apache::thrift::protocol::TType _etype1175;
            xfer += iprot->readListBegin(_etype1175, _size1172);
            this->fileIds.resize(_size1172);
            uint32_t _i1176;
            for (_i1176 = 0; _i1176 < _size1172; ++_i1176)
            {
              xfer += iprot->readI64(this->fileIds[_i1176]);
            }
            xfer += iprot->readListEnd();
          }
          isset_fileIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->expr);
          isset_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->doGetFooters);
          this->__isset.doGetFooters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1177;
          xfer += iprot->readI32(ecast1177);
          this->type = static_cast<FileMetadataExprType::type>(ecast1177);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fileIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_expr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetFileMetadataByExprRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetFileMetadataByExprRequest");

  xfer += oprot->writeFieldBegin("fileIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->fileIds.size()));
    std::vector<int64_t> ::const_iterator _iter1178;
    for (_iter1178 = this->fileIds.begin(); _iter1178 != this->fileIds.end(); ++_iter1178)
    {
      xfer += oprot->writeI64((*_iter1178));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->expr);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.doGetFooters) {
    xfer += oprot->writeFieldBegin("doGetFooters", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->doGetFooters);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->type));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetFileMetadataByExprRequest &a, GetFileMetadataByExprRequest &b) {
  using ::std::swap;
  swap(a.fileIds, b.fileIds);
  swap(a.expr, b.expr);
  swap(a.doGetFooters, b.doGetFooters);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

GetFileMetadataByExprRequest::GetFileMetadataByExprRequest(const GetFileMetadataByExprRequest& other1179) {
  fileIds = other1179.fileIds;
  expr = other1179.expr;
  doGetFooters = other1179.doGetFooters;
  type = other1179.type;
  __isset = other1179.__isset;
}
GetFileMetadataByExprRequest& GetFileMetadataByExprRequest::operator=(const GetFileMetadataByExprRequest& other1180) {
  fileIds = other1180.fileIds;
  expr = other1180.expr;
  doGetFooters = other1180.doGetFooters;
  type = other1180.type;
  __isset = other1180.__isset;
  return *this;
}
void GetFileMetadataByExprRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetFileMetadataByExprRequest(";
  out << "fileIds=" << to_string(fileIds);
  out << ", " << "expr=" << to_string(expr);
  out << ", " << "doGetFooters="; (__isset.doGetFooters ? (out << to_string(doGetFooters)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ")";
}


GetFileMetadataResult::~GetFileMetadataResult() noexcept {
}


void GetFileMetadataResult::__set_metadata(const std::map<int64_t, std::string> & val) {
  this->metadata = val;
}

void GetFileMetadataResult::__set_isSupported(const bool val) {
  this->isSupported = val;
}
std::ostream& operator<<(std::ostream& out, const GetFileMetadataResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetFileMetadataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_metadata = false;
  bool isset_isSupported = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size1181;
            ::apache::thrift::protocol::TType _ktype1182;
            ::apache::thrift::protocol::TType _vtype1183;
            xfer += iprot->readMapBegin(_ktype1182, _vtype1183, _size1181);
            uint32_t _i1185;
            for (_i1185 = 0; _i1185 < _size1181; ++_i1185)
            {
              int64_t _key1186;
              xfer += iprot->readI64(_key1186);
              std::string& _val1187 = this->metadata[_key1186];
              xfer += iprot->readBinary(_val1187);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isSupported);
          isset_isSupported = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isSupported)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetFileMetadataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetFileMetadataResult");

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::map<int64_t, std::string> ::const_iterator _iter1188;
    for (_iter1188 = this->metadata.begin(); _iter1188 != this->metadata.end(); ++_iter1188)
    {
      xfer += oprot->writeI64(_iter1188->first);
      xfer += oprot->writeBinary(_iter1188->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isSupported", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->isSupported);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetFileMetadataResult &a, GetFileMetadataResult &b) {
  using ::std::swap;
  swap(a.metadata, b.metadata);
  swap(a.isSupported, b.isSupported);
}

GetFileMetadataResult::GetFileMetadataResult(const GetFileMetadataResult& other1189) {
  metadata = other1189.metadata;
  isSupported = other1189.isSupported;
}
GetFileMetadataResult& GetFileMetadataResult::operator=(const GetFileMetadataResult& other1190) {
  metadata = other1190.metadata;
  isSupported = other1190.isSupported;
  return *this;
}
void GetFileMetadataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetFileMetadataResult(";
  out << "metadata=" << to_string(metadata);
  out << ", " << "isSupported=" << to_string(isSupported);
  out << ")";
}


GetFileMetadataRequest::~GetFileMetadataRequest() noexcept {
}


void GetFileMetadataRequest::__set_fileIds(const std::vector<int64_t> & val) {
  this->fileIds = val;
}
std::ostream& operator<<(std::ostream& out, const GetFileMetadataRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetFileMetadataRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fileIds = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fileIds.clear();
            uint32_t _size1191;
            ::apache::thrift::protocol::TType _etype1194;
            xfer += iprot->readListBegin(_etype1194, _size1191);
            this->fileIds.resize(_size1191);
            uint32_t _i1195;
            for (_i1195 = 0; _i1195 < _size1191; ++_i1195)
            {
              xfer += iprot->readI64(this->fileIds[_i1195]);
            }
            xfer += iprot->readListEnd();
          }
          isset_fileIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fileIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetFileMetadataRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetFileMetadataRequest");

  xfer += oprot->writeFieldBegin("fileIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->fileIds.size()));
    std::vector<int64_t> ::const_iterator _iter1196;
    for (_iter1196 = this->fileIds.begin(); _iter1196 != this->fileIds.end(); ++_iter1196)
    {
      xfer += oprot->writeI64((*_iter1196));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetFileMetadataRequest &a, GetFileMetadataRequest &b) {
  using ::std::swap;
  swap(a.fileIds, b.fileIds);
}

GetFileMetadataRequest::GetFileMetadataRequest(const GetFileMetadataRequest& other1197) {
  fileIds = other1197.fileIds;
}
GetFileMetadataRequest& GetFileMetadataRequest::operator=(const GetFileMetadataRequest& other1198) {
  fileIds = other1198.fileIds;
  return *this;
}
void GetFileMetadataRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetFileMetadataRequest(";
  out << "fileIds=" << to_string(fileIds);
  out << ")";
}


PutFileMetadataResult::~PutFileMetadataResult() noexcept {
}

std::ostream& operator<<(std::ostream& out, const PutFileMetadataResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PutFileMetadataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PutFileMetadataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PutFileMetadataResult");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PutFileMetadataResult &a, PutFileMetadataResult &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

PutFileMetadataResult::PutFileMetadataResult(const PutFileMetadataResult& other1199) noexcept {
  (void) other1199;
}
PutFileMetadataResult& PutFileMetadataResult::operator=(const PutFileMetadataResult& other1200) noexcept {
  (void) other1200;
  return *this;
}
void PutFileMetadataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PutFileMetadataResult(";
  out << ")";
}


PutFileMetadataRequest::~PutFileMetadataRequest() noexcept {
}


void PutFileMetadataRequest::__set_fileIds(const std::vector<int64_t> & val) {
  this->fileIds = val;
}

void PutFileMetadataRequest::__set_metadata(const std::vector<std::string> & val) {
  this->metadata = val;
}

void PutFileMetadataRequest::__set_type(const FileMetadataExprType::type val) {
  this->type = val;
__isset.type = true;
}
std::ostream& operator<<(std::ostream& out, const PutFileMetadataRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PutFileMetadataRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fileIds = false;
  bool isset_metadata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fileIds.clear();
            uint32_t _size1201;
            ::apache::thrift::protocol::TType _etype1204;
            xfer += iprot->readListBegin(_etype1204, _size1201);
            this->fileIds.resize(_size1201);
            uint32_t _i1205;
            for (_i1205 = 0; _i1205 < _size1201; ++_i1205)
            {
              xfer += iprot->readI64(this->fileIds[_i1205]);
            }
            xfer += iprot->readListEnd();
          }
          isset_fileIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->metadata.clear();
            uint32_t _size1206;
            ::apache::thrift::protocol::TType _etype1209;
            xfer += iprot->readListBegin(_etype1209, _size1206);
            this->metadata.resize(_size1206);
            uint32_t _i1210;
            for (_i1210 = 0; _i1210 < _size1206; ++_i1210)
            {
              xfer += iprot->readBinary(this->metadata[_i1210]);
            }
            xfer += iprot->readListEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1211;
          xfer += iprot->readI32(ecast1211);
          this->type = static_cast<FileMetadataExprType::type>(ecast1211);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fileIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PutFileMetadataRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PutFileMetadataRequest");

  xfer += oprot->writeFieldBegin("fileIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->fileIds.size()));
    std::vector<int64_t> ::const_iterator _iter1212;
    for (_iter1212 = this->fileIds.begin(); _iter1212 != this->fileIds.end(); ++_iter1212)
    {
      xfer += oprot->writeI64((*_iter1212));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::vector<std::string> ::const_iterator _iter1213;
    for (_iter1213 = this->metadata.begin(); _iter1213 != this->metadata.end(); ++_iter1213)
    {
      xfer += oprot->writeBinary((*_iter1213));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(static_cast<int32_t>(this->type));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PutFileMetadataRequest &a, PutFileMetadataRequest &b) {
  using ::std::swap;
  swap(a.fileIds, b.fileIds);
  swap(a.metadata, b.metadata);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

PutFileMetadataRequest::PutFileMetadataRequest(const PutFileMetadataRequest& other1214) {
  fileIds = other1214.fileIds;
  metadata = other1214.metadata;
  type = other1214.type;
  __isset = other1214.__isset;
}
PutFileMetadataRequest& PutFileMetadataRequest::operator=(const PutFileMetadataRequest& other1215) {
  fileIds = other1215.fileIds;
  metadata = other1215.metadata;
  type = other1215.type;
  __isset = other1215.__isset;
  return *this;
}
void PutFileMetadataRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PutFileMetadataRequest(";
  out << "fileIds=" << to_string(fileIds);
  out << ", " << "metadata=" << to_string(metadata);
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ")";
}


ClearFileMetadataResult::~ClearFileMetadataResult() noexcept {
}

std::ostream& operator<<(std::ostream& out, const ClearFileMetadataResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ClearFileMetadataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClearFileMetadataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClearFileMetadataResult");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ClearFileMetadataResult &a, ClearFileMetadataResult &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

ClearFileMetadataResult::ClearFileMetadataResult(const ClearFileMetadataResult& other1216) noexcept {
  (void) other1216;
}
ClearFileMetadataResult& ClearFileMetadataResult::operator=(const ClearFileMetadataResult& other1217) noexcept {
  (void) other1217;
  return *this;
}
void ClearFileMetadataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ClearFileMetadataResult(";
  out << ")";
}


ClearFileMetadataRequest::~ClearFileMetadataRequest() noexcept {
}


void ClearFileMetadataRequest::__set_fileIds(const std::vector<int64_t> & val) {
  this->fileIds = val;
}
std::ostream& operator<<(std::ostream& out, const ClearFileMetadataRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ClearFileMetadataRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fileIds = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fileIds.clear();
            uint32_t _size1218;
            ::apache::thrift::protocol::TType _etype1221;
            xfer += iprot->readListBegin(_etype1221, _size1218);
            this->fileIds.resize(_size1218);
            uint32_t _i1222;
            for (_i1222 = 0; _i1222 < _size1218; ++_i1222)
            {
              xfer += iprot->readI64(this->fileIds[_i1222]);
            }
            xfer += iprot->readListEnd();
          }
          isset_fileIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fileIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ClearFileMetadataRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClearFileMetadataRequest");

  xfer += oprot->writeFieldBegin("fileIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->fileIds.size()));
    std::vector<int64_t> ::const_iterator _iter1223;
    for (_iter1223 = this->fileIds.begin(); _iter1223 != this->fileIds.end(); ++_iter1223)
    {
      xfer += oprot->writeI64((*_iter1223));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ClearFileMetadataRequest &a, ClearFileMetadataRequest &b) {
  using ::std::swap;
  swap(a.fileIds, b.fileIds);
}

ClearFileMetadataRequest::ClearFileMetadataRequest(const ClearFileMetadataRequest& other1224) {
  fileIds = other1224.fileIds;
}
ClearFileMetadataRequest& ClearFileMetadataRequest::operator=(const ClearFileMetadataRequest& other1225) {
  fileIds = other1225.fileIds;
  return *this;
}
void ClearFileMetadataRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ClearFileMetadataRequest(";
  out << "fileIds=" << to_string(fileIds);
  out << ")";
}


CacheFileMetadataResult::~CacheFileMetadataResult() noexcept {
}


void CacheFileMetadataResult::__set_isSupported(const bool val) {
  this->isSupported = val;
}
std::ostream& operator<<(std::ostream& out, const CacheFileMetadataResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CacheFileMetadataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_isSupported = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isSupported);
          isset_isSupported = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_isSupported)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CacheFileMetadataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CacheFileMetadataResult");

  xfer += oprot->writeFieldBegin("isSupported", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->isSupported);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CacheFileMetadataResult &a, CacheFileMetadataResult &b) {
  using ::std::swap;
  swap(a.isSupported, b.isSupported);
}

CacheFileMetadataResult::CacheFileMetadataResult(const CacheFileMetadataResult& other1226) noexcept {
  isSupported = other1226.isSupported;
}
CacheFileMetadataResult& CacheFileMetadataResult::operator=(const CacheFileMetadataResult& other1227) noexcept {
  isSupported = other1227.isSupported;
  return *this;
}
void CacheFileMetadataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CacheFileMetadataResult(";
  out << "isSupported=" << to_string(isSupported);
  out << ")";
}


CacheFileMetadataRequest::~CacheFileMetadataRequest() noexcept {
}


void CacheFileMetadataRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void CacheFileMetadataRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void CacheFileMetadataRequest::__set_partName(const std::string& val) {
  this->partName = val;
__isset.partName = true;
}

void CacheFileMetadataRequest::__set_isAllParts(const bool val) {
  this->isAllParts = val;
__isset.isAllParts = true;
}
std::ostream& operator<<(std::ostream& out, const CacheFileMetadataRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CacheFileMetadataRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partName);
          this->__isset.partName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAllParts);
          this->__isset.isAllParts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CacheFileMetadataRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CacheFileMetadataRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partName) {
    xfer += oprot->writeFieldBegin("partName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->partName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isAllParts) {
    xfer += oprot->writeFieldBegin("isAllParts", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->isAllParts);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CacheFileMetadataRequest &a, CacheFileMetadataRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.partName, b.partName);
  swap(a.isAllParts, b.isAllParts);
  swap(a.__isset, b.__isset);
}

CacheFileMetadataRequest::CacheFileMetadataRequest(const CacheFileMetadataRequest& other1228) {
  dbName = other1228.dbName;
  tblName = other1228.tblName;
  partName = other1228.partName;
  isAllParts = other1228.isAllParts;
  __isset = other1228.__isset;
}
CacheFileMetadataRequest& CacheFileMetadataRequest::operator=(const CacheFileMetadataRequest& other1229) {
  dbName = other1229.dbName;
  tblName = other1229.tblName;
  partName = other1229.partName;
  isAllParts = other1229.isAllParts;
  __isset = other1229.__isset;
  return *this;
}
void CacheFileMetadataRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CacheFileMetadataRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "partName="; (__isset.partName ? (out << to_string(partName)) : (out << "<null>"));
  out << ", " << "isAllParts="; (__isset.isAllParts ? (out << to_string(isAllParts)) : (out << "<null>"));
  out << ")";
}


GetAllFunctionsResponse::~GetAllFunctionsResponse() noexcept {
}


void GetAllFunctionsResponse::__set_functions(const std::vector<Function> & val) {
  this->functions = val;
__isset.functions = true;
}
std::ostream& operator<<(std::ostream& out, const GetAllFunctionsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetAllFunctionsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->functions.clear();
            uint32_t _size1230;
            ::apache::thrift::protocol::TType _etype1233;
            xfer += iprot->readListBegin(_etype1233, _size1230);
            this->functions.resize(_size1230);
            uint32_t _i1234;
            for (_i1234 = 0; _i1234 < _size1230; ++_i1234)
            {
              xfer += this->functions[_i1234].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.functions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetAllFunctionsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetAllFunctionsResponse");

  if (this->__isset.functions) {
    xfer += oprot->writeFieldBegin("functions", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->functions.size()));
      std::vector<Function> ::const_iterator _iter1235;
      for (_iter1235 = this->functions.begin(); _iter1235 != this->functions.end(); ++_iter1235)
      {
        xfer += (*_iter1235).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetAllFunctionsResponse &a, GetAllFunctionsResponse &b) {
  using ::std::swap;
  swap(a.functions, b.functions);
  swap(a.__isset, b.__isset);
}

GetAllFunctionsResponse::GetAllFunctionsResponse(const GetAllFunctionsResponse& other1236) {
  functions = other1236.functions;
  __isset = other1236.__isset;
}
GetAllFunctionsResponse& GetAllFunctionsResponse::operator=(const GetAllFunctionsResponse& other1237) {
  functions = other1237.functions;
  __isset = other1237.__isset;
  return *this;
}
void GetAllFunctionsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetAllFunctionsResponse(";
  out << "functions="; (__isset.functions ? (out << to_string(functions)) : (out << "<null>"));
  out << ")";
}


ClientCapabilities::~ClientCapabilities() noexcept {
}


void ClientCapabilities::__set_values(const std::vector<ClientCapability::type> & val) {
  this->values = val;
}
std::ostream& operator<<(std::ostream& out, const ClientCapabilities& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ClientCapabilities::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size1238;
            ::apache::thrift::protocol::TType _etype1241;
            xfer += iprot->readListBegin(_etype1241, _size1238);
            this->values.resize(_size1238);
            uint32_t _i1242;
            for (_i1242 = 0; _i1242 < _size1238; ++_i1242)
            {
              int32_t ecast1243;
              xfer += iprot->readI32(ecast1243);
              this->values[_i1242] = static_cast<ClientCapability::type>(ecast1243);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ClientCapabilities::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientCapabilities");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->values.size()));
    std::vector<ClientCapability::type> ::const_iterator _iter1244;
    for (_iter1244 = this->values.begin(); _iter1244 != this->values.end(); ++_iter1244)
    {
      xfer += oprot->writeI32(static_cast<int32_t>((*_iter1244)));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ClientCapabilities &a, ClientCapabilities &b) {
  using ::std::swap;
  swap(a.values, b.values);
}

ClientCapabilities::ClientCapabilities(const ClientCapabilities& other1245) {
  values = other1245.values;
}
ClientCapabilities& ClientCapabilities::operator=(const ClientCapabilities& other1246) {
  values = other1246.values;
  return *this;
}
void ClientCapabilities::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ClientCapabilities(";
  out << "values=" << to_string(values);
  out << ")";
}


GetProjectionsSpec::~GetProjectionsSpec() noexcept {
}


void GetProjectionsSpec::__set_fieldList(const std::vector<std::string> & val) {
  this->fieldList = val;
}

void GetProjectionsSpec::__set_includeParamKeyPattern(const std::string& val) {
  this->includeParamKeyPattern = val;
}

void GetProjectionsSpec::__set_excludeParamKeyPattern(const std::string& val) {
  this->excludeParamKeyPattern = val;
}
std::ostream& operator<<(std::ostream& out, const GetProjectionsSpec& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProjectionsSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fieldList.clear();
            uint32_t _size1247;
            ::apache::thrift::protocol::TType _etype1250;
            xfer += iprot->readListBegin(_etype1250, _size1247);
            this->fieldList.resize(_size1247);
            uint32_t _i1251;
            for (_i1251 = 0; _i1251 < _size1247; ++_i1251)
            {
              xfer += iprot->readString(this->fieldList[_i1251]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->includeParamKeyPattern);
          this->__isset.includeParamKeyPattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->excludeParamKeyPattern);
          this->__isset.excludeParamKeyPattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetProjectionsSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProjectionsSpec");

  xfer += oprot->writeFieldBegin("fieldList", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fieldList.size()));
    std::vector<std::string> ::const_iterator _iter1252;
    for (_iter1252 = this->fieldList.begin(); _iter1252 != this->fieldList.end(); ++_iter1252)
    {
      xfer += oprot->writeString((*_iter1252));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("includeParamKeyPattern", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->includeParamKeyPattern);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("excludeParamKeyPattern", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->excludeParamKeyPattern);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProjectionsSpec &a, GetProjectionsSpec &b) {
  using ::std::swap;
  swap(a.fieldList, b.fieldList);
  swap(a.includeParamKeyPattern, b.includeParamKeyPattern);
  swap(a.excludeParamKeyPattern, b.excludeParamKeyPattern);
  swap(a.__isset, b.__isset);
}

GetProjectionsSpec::GetProjectionsSpec(const GetProjectionsSpec& other1253) {
  fieldList = other1253.fieldList;
  includeParamKeyPattern = other1253.includeParamKeyPattern;
  excludeParamKeyPattern = other1253.excludeParamKeyPattern;
  __isset = other1253.__isset;
}
GetProjectionsSpec& GetProjectionsSpec::operator=(const GetProjectionsSpec& other1254) {
  fieldList = other1254.fieldList;
  includeParamKeyPattern = other1254.includeParamKeyPattern;
  excludeParamKeyPattern = other1254.excludeParamKeyPattern;
  __isset = other1254.__isset;
  return *this;
}
void GetProjectionsSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProjectionsSpec(";
  out << "fieldList=" << to_string(fieldList);
  out << ", " << "includeParamKeyPattern=" << to_string(includeParamKeyPattern);
  out << ", " << "excludeParamKeyPattern=" << to_string(excludeParamKeyPattern);
  out << ")";
}


GetTableRequest::~GetTableRequest() noexcept {
}


void GetTableRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void GetTableRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void GetTableRequest::__set_capabilities(const ClientCapabilities& val) {
  this->capabilities = val;
__isset.capabilities = true;
}

void GetTableRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void GetTableRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void GetTableRequest::__set_getColumnStats(const bool val) {
  this->getColumnStats = val;
__isset.getColumnStats = true;
}

void GetTableRequest::__set_processorCapabilities(const std::vector<std::string> & val) {
  this->processorCapabilities = val;
__isset.processorCapabilities = true;
}

void GetTableRequest::__set_processorIdentifier(const std::string& val) {
  this->processorIdentifier = val;
__isset.processorIdentifier = true;
}

void GetTableRequest::__set_engine(const std::string& val) {
  this->engine = val;
__isset.engine = true;
}

void GetTableRequest::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}
std::ostream& operator<<(std::ostream& out, const GetTableRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTableRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->capabilities.read(iprot);
          this->__isset.capabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->getColumnStats);
          this->__isset.getColumnStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->processorCapabilities.clear();
            uint32_t _size1255;
            ::apache::thrift::protocol::TType _etype1258;
            xfer += iprot->readListBegin(_etype1258, _size1255);
            this->processorCapabilities.resize(_size1255);
            uint32_t _i1259;
            for (_i1259 = 0; _i1259 < _size1255; ++_i1259)
            {
              xfer += iprot->readString(this->processorCapabilities[_i1259]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.processorCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->processorIdentifier);
          this->__isset.processorIdentifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->engine);
          this->__isset.engine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetTableRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTableRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.capabilities) {
    xfer += oprot->writeFieldBegin("capabilities", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->capabilities.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.getColumnStats) {
    xfer += oprot->writeFieldBegin("getColumnStats", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->getColumnStats);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorCapabilities) {
    xfer += oprot->writeFieldBegin("processorCapabilities", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->processorCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter1260;
      for (_iter1260 = this->processorCapabilities.begin(); _iter1260 != this->processorCapabilities.end(); ++_iter1260)
      {
        xfer += oprot->writeString((*_iter1260));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorIdentifier) {
    xfer += oprot->writeFieldBegin("processorIdentifier", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->processorIdentifier);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.engine) {
    xfer += oprot->writeFieldBegin("engine", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->engine);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTableRequest &a, GetTableRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.capabilities, b.capabilities);
  swap(a.catName, b.catName);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.getColumnStats, b.getColumnStats);
  swap(a.processorCapabilities, b.processorCapabilities);
  swap(a.processorIdentifier, b.processorIdentifier);
  swap(a.engine, b.engine);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

GetTableRequest::GetTableRequest(const GetTableRequest& other1261) {
  dbName = other1261.dbName;
  tblName = other1261.tblName;
  capabilities = other1261.capabilities;
  catName = other1261.catName;
  validWriteIdList = other1261.validWriteIdList;
  getColumnStats = other1261.getColumnStats;
  processorCapabilities = other1261.processorCapabilities;
  processorIdentifier = other1261.processorIdentifier;
  engine = other1261.engine;
  id = other1261.id;
  __isset = other1261.__isset;
}
GetTableRequest& GetTableRequest::operator=(const GetTableRequest& other1262) {
  dbName = other1262.dbName;
  tblName = other1262.tblName;
  capabilities = other1262.capabilities;
  catName = other1262.catName;
  validWriteIdList = other1262.validWriteIdList;
  getColumnStats = other1262.getColumnStats;
  processorCapabilities = other1262.processorCapabilities;
  processorIdentifier = other1262.processorIdentifier;
  engine = other1262.engine;
  id = other1262.id;
  __isset = other1262.__isset;
  return *this;
}
void GetTableRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTableRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "capabilities="; (__isset.capabilities ? (out << to_string(capabilities)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "getColumnStats="; (__isset.getColumnStats ? (out << to_string(getColumnStats)) : (out << "<null>"));
  out << ", " << "processorCapabilities="; (__isset.processorCapabilities ? (out << to_string(processorCapabilities)) : (out << "<null>"));
  out << ", " << "processorIdentifier="; (__isset.processorIdentifier ? (out << to_string(processorIdentifier)) : (out << "<null>"));
  out << ", " << "engine="; (__isset.engine ? (out << to_string(engine)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


GetTableResult::~GetTableResult() noexcept {
}


void GetTableResult::__set_table(const Table& val) {
  this->table = val;
}

void GetTableResult::__set_isStatsCompliant(const bool val) {
  this->isStatsCompliant = val;
__isset.isStatsCompliant = true;
}
std::ostream& operator<<(std::ostream& out, const GetTableResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTableResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table.read(iprot);
          isset_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isStatsCompliant);
          this->__isset.isStatsCompliant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetTableResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTableResult");

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.isStatsCompliant) {
    xfer += oprot->writeFieldBegin("isStatsCompliant", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->isStatsCompliant);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTableResult &a, GetTableResult &b) {
  using ::std::swap;
  swap(a.table, b.table);
  swap(a.isStatsCompliant, b.isStatsCompliant);
  swap(a.__isset, b.__isset);
}

GetTableResult::GetTableResult(const GetTableResult& other1263) {
  table = other1263.table;
  isStatsCompliant = other1263.isStatsCompliant;
  __isset = other1263.__isset;
}
GetTableResult& GetTableResult::operator=(const GetTableResult& other1264) {
  table = other1264.table;
  isStatsCompliant = other1264.isStatsCompliant;
  __isset = other1264.__isset;
  return *this;
}
void GetTableResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTableResult(";
  out << "table=" << to_string(table);
  out << ", " << "isStatsCompliant="; (__isset.isStatsCompliant ? (out << to_string(isStatsCompliant)) : (out << "<null>"));
  out << ")";
}


GetTablesRequest::~GetTablesRequest() noexcept {
}


void GetTablesRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void GetTablesRequest::__set_tblNames(const std::vector<std::string> & val) {
  this->tblNames = val;
__isset.tblNames = true;
}

void GetTablesRequest::__set_capabilities(const ClientCapabilities& val) {
  this->capabilities = val;
__isset.capabilities = true;
}

void GetTablesRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void GetTablesRequest::__set_processorCapabilities(const std::vector<std::string> & val) {
  this->processorCapabilities = val;
__isset.processorCapabilities = true;
}

void GetTablesRequest::__set_processorIdentifier(const std::string& val) {
  this->processorIdentifier = val;
__isset.processorIdentifier = true;
}

void GetTablesRequest::__set_projectionSpec(const GetProjectionsSpec& val) {
  this->projectionSpec = val;
__isset.projectionSpec = true;
}

void GetTablesRequest::__set_tablesPattern(const std::string& val) {
  this->tablesPattern = val;
__isset.tablesPattern = true;
}
std::ostream& operator<<(std::ostream& out, const GetTablesRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTablesRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tblNames.clear();
            uint32_t _size1265;
            ::apache::thrift::protocol::TType _etype1268;
            xfer += iprot->readListBegin(_etype1268, _size1265);
            this->tblNames.resize(_size1265);
            uint32_t _i1269;
            for (_i1269 = 0; _i1269 < _size1265; ++_i1269)
            {
              xfer += iprot->readString(this->tblNames[_i1269]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tblNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->capabilities.read(iprot);
          this->__isset.capabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->processorCapabilities.clear();
            uint32_t _size1270;
            ::apache::thrift::protocol::TType _etype1273;
            xfer += iprot->readListBegin(_etype1273, _size1270);
            this->processorCapabilities.resize(_size1270);
            uint32_t _i1274;
            for (_i1274 = 0; _i1274 < _size1270; ++_i1274)
            {
              xfer += iprot->readString(this->processorCapabilities[_i1274]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.processorCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->processorIdentifier);
          this->__isset.processorIdentifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->projectionSpec.read(iprot);
          this->__isset.projectionSpec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablesPattern);
          this->__isset.tablesPattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetTablesRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTablesRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tblNames) {
    xfer += oprot->writeFieldBegin("tblNames", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tblNames.size()));
      std::vector<std::string> ::const_iterator _iter1275;
      for (_iter1275 = this->tblNames.begin(); _iter1275 != this->tblNames.end(); ++_iter1275)
      {
        xfer += oprot->writeString((*_iter1275));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.capabilities) {
    xfer += oprot->writeFieldBegin("capabilities", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->capabilities.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorCapabilities) {
    xfer += oprot->writeFieldBegin("processorCapabilities", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->processorCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter1276;
      for (_iter1276 = this->processorCapabilities.begin(); _iter1276 != this->processorCapabilities.end(); ++_iter1276)
      {
        xfer += oprot->writeString((*_iter1276));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorIdentifier) {
    xfer += oprot->writeFieldBegin("processorIdentifier", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->processorIdentifier);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.projectionSpec) {
    xfer += oprot->writeFieldBegin("projectionSpec", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->projectionSpec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tablesPattern) {
    xfer += oprot->writeFieldBegin("tablesPattern", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->tablesPattern);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTablesRequest &a, GetTablesRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblNames, b.tblNames);
  swap(a.capabilities, b.capabilities);
  swap(a.catName, b.catName);
  swap(a.processorCapabilities, b.processorCapabilities);
  swap(a.processorIdentifier, b.processorIdentifier);
  swap(a.projectionSpec, b.projectionSpec);
  swap(a.tablesPattern, b.tablesPattern);
  swap(a.__isset, b.__isset);
}

GetTablesRequest::GetTablesRequest(const GetTablesRequest& other1277) {
  dbName = other1277.dbName;
  tblNames = other1277.tblNames;
  capabilities = other1277.capabilities;
  catName = other1277.catName;
  processorCapabilities = other1277.processorCapabilities;
  processorIdentifier = other1277.processorIdentifier;
  projectionSpec = other1277.projectionSpec;
  tablesPattern = other1277.tablesPattern;
  __isset = other1277.__isset;
}
GetTablesRequest& GetTablesRequest::operator=(const GetTablesRequest& other1278) {
  dbName = other1278.dbName;
  tblNames = other1278.tblNames;
  capabilities = other1278.capabilities;
  catName = other1278.catName;
  processorCapabilities = other1278.processorCapabilities;
  processorIdentifier = other1278.processorIdentifier;
  projectionSpec = other1278.projectionSpec;
  tablesPattern = other1278.tablesPattern;
  __isset = other1278.__isset;
  return *this;
}
void GetTablesRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTablesRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblNames="; (__isset.tblNames ? (out << to_string(tblNames)) : (out << "<null>"));
  out << ", " << "capabilities="; (__isset.capabilities ? (out << to_string(capabilities)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "processorCapabilities="; (__isset.processorCapabilities ? (out << to_string(processorCapabilities)) : (out << "<null>"));
  out << ", " << "processorIdentifier="; (__isset.processorIdentifier ? (out << to_string(processorIdentifier)) : (out << "<null>"));
  out << ", " << "projectionSpec="; (__isset.projectionSpec ? (out << to_string(projectionSpec)) : (out << "<null>"));
  out << ", " << "tablesPattern="; (__isset.tablesPattern ? (out << to_string(tablesPattern)) : (out << "<null>"));
  out << ")";
}


GetTablesResult::~GetTablesResult() noexcept {
}


void GetTablesResult::__set_tables(const std::vector<Table> & val) {
  this->tables = val;
}
std::ostream& operator<<(std::ostream& out, const GetTablesResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTablesResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tables = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tables.clear();
            uint32_t _size1279;
            ::apache::thrift::protocol::TType _etype1282;
            xfer += iprot->readListBegin(_etype1282, _size1279);
            this->tables.resize(_size1279);
            uint32_t _i1283;
            for (_i1283 = 0; _i1283 < _size1279; ++_i1283)
            {
              xfer += this->tables[_i1283].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_tables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tables)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetTablesResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTablesResult");

  xfer += oprot->writeFieldBegin("tables", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tables.size()));
    std::vector<Table> ::const_iterator _iter1284;
    for (_iter1284 = this->tables.begin(); _iter1284 != this->tables.end(); ++_iter1284)
    {
      xfer += (*_iter1284).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTablesResult &a, GetTablesResult &b) {
  using ::std::swap;
  swap(a.tables, b.tables);
}

GetTablesResult::GetTablesResult(const GetTablesResult& other1285) {
  tables = other1285.tables;
}
GetTablesResult& GetTablesResult::operator=(const GetTablesResult& other1286) {
  tables = other1286.tables;
  return *this;
}
void GetTablesResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTablesResult(";
  out << "tables=" << to_string(tables);
  out << ")";
}


GetTablesExtRequest::~GetTablesExtRequest() noexcept {
}


void GetTablesExtRequest::__set_catalog(const std::string& val) {
  this->catalog = val;
}

void GetTablesExtRequest::__set_database(const std::string& val) {
  this->database = val;
}

void GetTablesExtRequest::__set_tableNamePattern(const std::string& val) {
  this->tableNamePattern = val;
}

void GetTablesExtRequest::__set_requestedFields(const int32_t val) {
  this->requestedFields = val;
}

void GetTablesExtRequest::__set_limit(const int32_t val) {
  this->limit = val;
__isset.limit = true;
}

void GetTablesExtRequest::__set_processorCapabilities(const std::vector<std::string> & val) {
  this->processorCapabilities = val;
__isset.processorCapabilities = true;
}

void GetTablesExtRequest::__set_processorIdentifier(const std::string& val) {
  this->processorIdentifier = val;
__isset.processorIdentifier = true;
}
std::ostream& operator<<(std::ostream& out, const GetTablesExtRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTablesExtRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catalog = false;
  bool isset_database = false;
  bool isset_tableNamePattern = false;
  bool isset_requestedFields = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalog);
          isset_catalog = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->database);
          isset_database = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableNamePattern);
          isset_tableNamePattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->requestedFields);
          isset_requestedFields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->processorCapabilities.clear();
            uint32_t _size1287;
            ::apache::thrift::protocol::TType _etype1290;
            xfer += iprot->readListBegin(_etype1290, _size1287);
            this->processorCapabilities.resize(_size1287);
            uint32_t _i1291;
            for (_i1291 = 0; _i1291 < _size1287; ++_i1291)
            {
              xfer += iprot->readString(this->processorCapabilities[_i1291]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.processorCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->processorIdentifier);
          this->__isset.processorIdentifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catalog)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_database)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableNamePattern)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_requestedFields)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetTablesExtRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTablesExtRequest");

  xfer += oprot->writeFieldBegin("catalog", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catalog);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("database", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->database);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableNamePattern", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableNamePattern);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("requestedFields", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->requestedFields);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.limit) {
    xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorCapabilities) {
    xfer += oprot->writeFieldBegin("processorCapabilities", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->processorCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter1292;
      for (_iter1292 = this->processorCapabilities.begin(); _iter1292 != this->processorCapabilities.end(); ++_iter1292)
      {
        xfer += oprot->writeString((*_iter1292));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorIdentifier) {
    xfer += oprot->writeFieldBegin("processorIdentifier", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->processorIdentifier);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTablesExtRequest &a, GetTablesExtRequest &b) {
  using ::std::swap;
  swap(a.catalog, b.catalog);
  swap(a.database, b.database);
  swap(a.tableNamePattern, b.tableNamePattern);
  swap(a.requestedFields, b.requestedFields);
  swap(a.limit, b.limit);
  swap(a.processorCapabilities, b.processorCapabilities);
  swap(a.processorIdentifier, b.processorIdentifier);
  swap(a.__isset, b.__isset);
}

GetTablesExtRequest::GetTablesExtRequest(const GetTablesExtRequest& other1293) {
  catalog = other1293.catalog;
  database = other1293.database;
  tableNamePattern = other1293.tableNamePattern;
  requestedFields = other1293.requestedFields;
  limit = other1293.limit;
  processorCapabilities = other1293.processorCapabilities;
  processorIdentifier = other1293.processorIdentifier;
  __isset = other1293.__isset;
}
GetTablesExtRequest& GetTablesExtRequest::operator=(const GetTablesExtRequest& other1294) {
  catalog = other1294.catalog;
  database = other1294.database;
  tableNamePattern = other1294.tableNamePattern;
  requestedFields = other1294.requestedFields;
  limit = other1294.limit;
  processorCapabilities = other1294.processorCapabilities;
  processorIdentifier = other1294.processorIdentifier;
  __isset = other1294.__isset;
  return *this;
}
void GetTablesExtRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTablesExtRequest(";
  out << "catalog=" << to_string(catalog);
  out << ", " << "database=" << to_string(database);
  out << ", " << "tableNamePattern=" << to_string(tableNamePattern);
  out << ", " << "requestedFields=" << to_string(requestedFields);
  out << ", " << "limit="; (__isset.limit ? (out << to_string(limit)) : (out << "<null>"));
  out << ", " << "processorCapabilities="; (__isset.processorCapabilities ? (out << to_string(processorCapabilities)) : (out << "<null>"));
  out << ", " << "processorIdentifier="; (__isset.processorIdentifier ? (out << to_string(processorIdentifier)) : (out << "<null>"));
  out << ")";
}


ExtendedTableInfo::~ExtendedTableInfo() noexcept {
}


void ExtendedTableInfo::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void ExtendedTableInfo::__set_accessType(const int32_t val) {
  this->accessType = val;
__isset.accessType = true;
}

void ExtendedTableInfo::__set_requiredReadCapabilities(const std::vector<std::string> & val) {
  this->requiredReadCapabilities = val;
__isset.requiredReadCapabilities = true;
}

void ExtendedTableInfo::__set_requiredWriteCapabilities(const std::vector<std::string> & val) {
  this->requiredWriteCapabilities = val;
__isset.requiredWriteCapabilities = true;
}
std::ostream& operator<<(std::ostream& out, const ExtendedTableInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ExtendedTableInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tblName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->accessType);
          this->__isset.accessType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->requiredReadCapabilities.clear();
            uint32_t _size1295;
            ::apache::thrift::protocol::TType _etype1298;
            xfer += iprot->readListBegin(_etype1298, _size1295);
            this->requiredReadCapabilities.resize(_size1295);
            uint32_t _i1299;
            for (_i1299 = 0; _i1299 < _size1295; ++_i1299)
            {
              xfer += iprot->readString(this->requiredReadCapabilities[_i1299]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.requiredReadCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->requiredWriteCapabilities.clear();
            uint32_t _size1300;
            ::apache::thrift::protocol::TType _etype1303;
            xfer += iprot->readListBegin(_etype1303, _size1300);
            this->requiredWriteCapabilities.resize(_size1300);
            uint32_t _i1304;
            for (_i1304 = 0; _i1304 < _size1300; ++_i1304)
            {
              xfer += iprot->readString(this->requiredWriteCapabilities[_i1304]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.requiredWriteCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ExtendedTableInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ExtendedTableInfo");

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.accessType) {
    xfer += oprot->writeFieldBegin("accessType", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->accessType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.requiredReadCapabilities) {
    xfer += oprot->writeFieldBegin("requiredReadCapabilities", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->requiredReadCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter1305;
      for (_iter1305 = this->requiredReadCapabilities.begin(); _iter1305 != this->requiredReadCapabilities.end(); ++_iter1305)
      {
        xfer += oprot->writeString((*_iter1305));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.requiredWriteCapabilities) {
    xfer += oprot->writeFieldBegin("requiredWriteCapabilities", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->requiredWriteCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter1306;
      for (_iter1306 = this->requiredWriteCapabilities.begin(); _iter1306 != this->requiredWriteCapabilities.end(); ++_iter1306)
      {
        xfer += oprot->writeString((*_iter1306));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExtendedTableInfo &a, ExtendedTableInfo &b) {
  using ::std::swap;
  swap(a.tblName, b.tblName);
  swap(a.accessType, b.accessType);
  swap(a.requiredReadCapabilities, b.requiredReadCapabilities);
  swap(a.requiredWriteCapabilities, b.requiredWriteCapabilities);
  swap(a.__isset, b.__isset);
}

ExtendedTableInfo::ExtendedTableInfo(const ExtendedTableInfo& other1307) {
  tblName = other1307.tblName;
  accessType = other1307.accessType;
  requiredReadCapabilities = other1307.requiredReadCapabilities;
  requiredWriteCapabilities = other1307.requiredWriteCapabilities;
  __isset = other1307.__isset;
}
ExtendedTableInfo& ExtendedTableInfo::operator=(const ExtendedTableInfo& other1308) {
  tblName = other1308.tblName;
  accessType = other1308.accessType;
  requiredReadCapabilities = other1308.requiredReadCapabilities;
  requiredWriteCapabilities = other1308.requiredWriteCapabilities;
  __isset = other1308.__isset;
  return *this;
}
void ExtendedTableInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ExtendedTableInfo(";
  out << "tblName=" << to_string(tblName);
  out << ", " << "accessType="; (__isset.accessType ? (out << to_string(accessType)) : (out << "<null>"));
  out << ", " << "requiredReadCapabilities="; (__isset.requiredReadCapabilities ? (out << to_string(requiredReadCapabilities)) : (out << "<null>"));
  out << ", " << "requiredWriteCapabilities="; (__isset.requiredWriteCapabilities ? (out << to_string(requiredWriteCapabilities)) : (out << "<null>"));
  out << ")";
}


GetDatabaseRequest::~GetDatabaseRequest() noexcept {
}


void GetDatabaseRequest::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void GetDatabaseRequest::__set_catalogName(const std::string& val) {
  this->catalogName = val;
__isset.catalogName = true;
}

void GetDatabaseRequest::__set_processorCapabilities(const std::vector<std::string> & val) {
  this->processorCapabilities = val;
__isset.processorCapabilities = true;
}

void GetDatabaseRequest::__set_processorIdentifier(const std::string& val) {
  this->processorIdentifier = val;
__isset.processorIdentifier = true;
}
std::ostream& operator<<(std::ostream& out, const GetDatabaseRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetDatabaseRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogName);
          this->__isset.catalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->processorCapabilities.clear();
            uint32_t _size1309;
            ::apache::thrift::protocol::TType _etype1312;
            xfer += iprot->readListBegin(_etype1312, _size1309);
            this->processorCapabilities.resize(_size1309);
            uint32_t _i1313;
            for (_i1313 = 0; _i1313 < _size1309; ++_i1313)
            {
              xfer += iprot->readString(this->processorCapabilities[_i1313]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.processorCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->processorIdentifier);
          this->__isset.processorIdentifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetDatabaseRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetDatabaseRequest");

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalogName) {
    xfer += oprot->writeFieldBegin("catalogName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->catalogName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorCapabilities) {
    xfer += oprot->writeFieldBegin("processorCapabilities", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->processorCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter1314;
      for (_iter1314 = this->processorCapabilities.begin(); _iter1314 != this->processorCapabilities.end(); ++_iter1314)
      {
        xfer += oprot->writeString((*_iter1314));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorIdentifier) {
    xfer += oprot->writeFieldBegin("processorIdentifier", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->processorIdentifier);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetDatabaseRequest &a, GetDatabaseRequest &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.catalogName, b.catalogName);
  swap(a.processorCapabilities, b.processorCapabilities);
  swap(a.processorIdentifier, b.processorIdentifier);
  swap(a.__isset, b.__isset);
}

GetDatabaseRequest::GetDatabaseRequest(const GetDatabaseRequest& other1315) {
  name = other1315.name;
  catalogName = other1315.catalogName;
  processorCapabilities = other1315.processorCapabilities;
  processorIdentifier = other1315.processorIdentifier;
  __isset = other1315.__isset;
}
GetDatabaseRequest& GetDatabaseRequest::operator=(const GetDatabaseRequest& other1316) {
  name = other1316.name;
  catalogName = other1316.catalogName;
  processorCapabilities = other1316.processorCapabilities;
  processorIdentifier = other1316.processorIdentifier;
  __isset = other1316.__isset;
  return *this;
}
void GetDatabaseRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetDatabaseRequest(";
  out << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "catalogName="; (__isset.catalogName ? (out << to_string(catalogName)) : (out << "<null>"));
  out << ", " << "processorCapabilities="; (__isset.processorCapabilities ? (out << to_string(processorCapabilities)) : (out << "<null>"));
  out << ", " << "processorIdentifier="; (__isset.processorIdentifier ? (out << to_string(processorIdentifier)) : (out << "<null>"));
  out << ")";
}


DropDatabaseRequest::~DropDatabaseRequest() noexcept {
}


void DropDatabaseRequest::__set_name(const std::string& val) {
  this->name = val;
}

void DropDatabaseRequest::__set_catalogName(const std::string& val) {
  this->catalogName = val;
__isset.catalogName = true;
}

void DropDatabaseRequest::__set_ignoreUnknownDb(const bool val) {
  this->ignoreUnknownDb = val;
}

void DropDatabaseRequest::__set_deleteData(const bool val) {
  this->deleteData = val;
}

void DropDatabaseRequest::__set_cascade(const bool val) {
  this->cascade = val;
}

void DropDatabaseRequest::__set_softDelete(const bool val) {
  this->softDelete = val;
__isset.softDelete = true;
}

void DropDatabaseRequest::__set_txnId(const int64_t val) {
  this->txnId = val;
__isset.txnId = true;
}

void DropDatabaseRequest::__set_deleteManagedDir(const bool val) {
  this->deleteManagedDir = val;
__isset.deleteManagedDir = true;
}
std::ostream& operator<<(std::ostream& out, const DropDatabaseRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropDatabaseRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_ignoreUnknownDb = false;
  bool isset_deleteData = false;
  bool isset_cascade = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogName);
          this->__isset.catalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ignoreUnknownDb);
          isset_ignoreUnknownDb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->deleteData);
          isset_deleteData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->cascade);
          isset_cascade = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->softDelete);
          this->__isset.softDelete = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnId);
          this->__isset.txnId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->deleteManagedDir);
          this->__isset.deleteManagedDir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ignoreUnknownDb)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_deleteData)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cascade)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DropDatabaseRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropDatabaseRequest");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catalogName) {
    xfer += oprot->writeFieldBegin("catalogName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->catalogName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("ignoreUnknownDb", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->ignoreUnknownDb);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deleteData", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->deleteData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cascade", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->cascade);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.softDelete) {
    xfer += oprot->writeFieldBegin("softDelete", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->softDelete);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.txnId) {
    xfer += oprot->writeFieldBegin("txnId", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->txnId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deleteManagedDir) {
    xfer += oprot->writeFieldBegin("deleteManagedDir", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->deleteManagedDir);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropDatabaseRequest &a, DropDatabaseRequest &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.catalogName, b.catalogName);
  swap(a.ignoreUnknownDb, b.ignoreUnknownDb);
  swap(a.deleteData, b.deleteData);
  swap(a.cascade, b.cascade);
  swap(a.softDelete, b.softDelete);
  swap(a.txnId, b.txnId);
  swap(a.deleteManagedDir, b.deleteManagedDir);
  swap(a.__isset, b.__isset);
}

DropDatabaseRequest::DropDatabaseRequest(const DropDatabaseRequest& other1317) {
  name = other1317.name;
  catalogName = other1317.catalogName;
  ignoreUnknownDb = other1317.ignoreUnknownDb;
  deleteData = other1317.deleteData;
  cascade = other1317.cascade;
  softDelete = other1317.softDelete;
  txnId = other1317.txnId;
  deleteManagedDir = other1317.deleteManagedDir;
  __isset = other1317.__isset;
}
DropDatabaseRequest& DropDatabaseRequest::operator=(const DropDatabaseRequest& other1318) {
  name = other1318.name;
  catalogName = other1318.catalogName;
  ignoreUnknownDb = other1318.ignoreUnknownDb;
  deleteData = other1318.deleteData;
  cascade = other1318.cascade;
  softDelete = other1318.softDelete;
  txnId = other1318.txnId;
  deleteManagedDir = other1318.deleteManagedDir;
  __isset = other1318.__isset;
  return *this;
}
void DropDatabaseRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropDatabaseRequest(";
  out << "name=" << to_string(name);
  out << ", " << "catalogName="; (__isset.catalogName ? (out << to_string(catalogName)) : (out << "<null>"));
  out << ", " << "ignoreUnknownDb=" << to_string(ignoreUnknownDb);
  out << ", " << "deleteData=" << to_string(deleteData);
  out << ", " << "cascade=" << to_string(cascade);
  out << ", " << "softDelete="; (__isset.softDelete ? (out << to_string(softDelete)) : (out << "<null>"));
  out << ", " << "txnId="; (__isset.txnId ? (out << to_string(txnId)) : (out << "<null>"));
  out << ", " << "deleteManagedDir="; (__isset.deleteManagedDir ? (out << to_string(deleteManagedDir)) : (out << "<null>"));
  out << ")";
}


CmRecycleRequest::~CmRecycleRequest() noexcept {
}


void CmRecycleRequest::__set_dataPath(const std::string& val) {
  this->dataPath = val;
}

void CmRecycleRequest::__set_purge(const bool val) {
  this->purge = val;
}
std::ostream& operator<<(std::ostream& out, const CmRecycleRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CmRecycleRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dataPath = false;
  bool isset_purge = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataPath);
          isset_dataPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->purge);
          isset_purge = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dataPath)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_purge)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CmRecycleRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CmRecycleRequest");

  xfer += oprot->writeFieldBegin("dataPath", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dataPath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("purge", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->purge);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CmRecycleRequest &a, CmRecycleRequest &b) {
  using ::std::swap;
  swap(a.dataPath, b.dataPath);
  swap(a.purge, b.purge);
}

CmRecycleRequest::CmRecycleRequest(const CmRecycleRequest& other1319) {
  dataPath = other1319.dataPath;
  purge = other1319.purge;
}
CmRecycleRequest& CmRecycleRequest::operator=(const CmRecycleRequest& other1320) {
  dataPath = other1320.dataPath;
  purge = other1320.purge;
  return *this;
}
void CmRecycleRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CmRecycleRequest(";
  out << "dataPath=" << to_string(dataPath);
  out << ", " << "purge=" << to_string(purge);
  out << ")";
}


CmRecycleResponse::~CmRecycleResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const CmRecycleResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CmRecycleResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CmRecycleResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CmRecycleResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CmRecycleResponse &a, CmRecycleResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CmRecycleResponse::CmRecycleResponse(const CmRecycleResponse& other1321) noexcept {
  (void) other1321;
}
CmRecycleResponse& CmRecycleResponse::operator=(const CmRecycleResponse& other1322) noexcept {
  (void) other1322;
  return *this;
}
void CmRecycleResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CmRecycleResponse(";
  out << ")";
}


TableMeta::~TableMeta() noexcept {
}


void TableMeta::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void TableMeta::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void TableMeta::__set_tableType(const std::string& val) {
  this->tableType = val;
}

void TableMeta::__set_comments(const std::string& val) {
  this->comments = val;
__isset.comments = true;
}

void TableMeta::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void TableMeta::__set_ownerName(const std::string& val) {
  this->ownerName = val;
__isset.ownerName = true;
}

void TableMeta::__set_ownerType(const PrincipalType::type val) {
  this->ownerType = val;
__isset.ownerType = true;
}
std::ostream& operator<<(std::ostream& out, const TableMeta& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TableMeta::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tableName = false;
  bool isset_tableType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableType);
          isset_tableType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comments);
          this->__isset.comments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1323;
          xfer += iprot->readI32(ecast1323);
          this->ownerType = static_cast<PrincipalType::type>(ecast1323);
          this->__isset.ownerType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TableMeta::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TableMeta");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableType", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comments) {
    xfer += oprot->writeFieldBegin("comments", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->comments);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ownerName) {
    xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->ownerName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ownerType) {
    xfer += oprot->writeFieldBegin("ownerType", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(static_cast<int32_t>(this->ownerType));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableMeta &a, TableMeta &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.tableType, b.tableType);
  swap(a.comments, b.comments);
  swap(a.catName, b.catName);
  swap(a.ownerName, b.ownerName);
  swap(a.ownerType, b.ownerType);
  swap(a.__isset, b.__isset);
}

TableMeta::TableMeta(const TableMeta& other1324) {
  dbName = other1324.dbName;
  tableName = other1324.tableName;
  tableType = other1324.tableType;
  comments = other1324.comments;
  catName = other1324.catName;
  ownerName = other1324.ownerName;
  ownerType = other1324.ownerType;
  __isset = other1324.__isset;
}
TableMeta& TableMeta::operator=(const TableMeta& other1325) {
  dbName = other1325.dbName;
  tableName = other1325.tableName;
  tableType = other1325.tableType;
  comments = other1325.comments;
  catName = other1325.catName;
  ownerName = other1325.ownerName;
  ownerType = other1325.ownerType;
  __isset = other1325.__isset;
  return *this;
}
void TableMeta::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TableMeta(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "tableType=" << to_string(tableType);
  out << ", " << "comments="; (__isset.comments ? (out << to_string(comments)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "ownerName="; (__isset.ownerName ? (out << to_string(ownerName)) : (out << "<null>"));
  out << ", " << "ownerType="; (__isset.ownerType ? (out << to_string(ownerType)) : (out << "<null>"));
  out << ")";
}


Materialization::~Materialization() noexcept {
}


void Materialization::__set_sourceTablesUpdateDeleteModified(const bool val) {
  this->sourceTablesUpdateDeleteModified = val;
}

void Materialization::__set_sourceTablesCompacted(const bool val) {
  this->sourceTablesCompacted = val;
}
std::ostream& operator<<(std::ostream& out, const Materialization& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Materialization::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sourceTablesUpdateDeleteModified = false;
  bool isset_sourceTablesCompacted = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sourceTablesUpdateDeleteModified);
          isset_sourceTablesUpdateDeleteModified = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sourceTablesCompacted);
          isset_sourceTablesCompacted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sourceTablesUpdateDeleteModified)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sourceTablesCompacted)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Materialization::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Materialization");

  xfer += oprot->writeFieldBegin("sourceTablesUpdateDeleteModified", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->sourceTablesUpdateDeleteModified);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sourceTablesCompacted", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->sourceTablesCompacted);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Materialization &a, Materialization &b) {
  using ::std::swap;
  swap(a.sourceTablesUpdateDeleteModified, b.sourceTablesUpdateDeleteModified);
  swap(a.sourceTablesCompacted, b.sourceTablesCompacted);
}

Materialization::Materialization(const Materialization& other1326) noexcept {
  sourceTablesUpdateDeleteModified = other1326.sourceTablesUpdateDeleteModified;
  sourceTablesCompacted = other1326.sourceTablesCompacted;
}
Materialization& Materialization::operator=(const Materialization& other1327) noexcept {
  sourceTablesUpdateDeleteModified = other1327.sourceTablesUpdateDeleteModified;
  sourceTablesCompacted = other1327.sourceTablesCompacted;
  return *this;
}
void Materialization::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Materialization(";
  out << "sourceTablesUpdateDeleteModified=" << to_string(sourceTablesUpdateDeleteModified);
  out << ", " << "sourceTablesCompacted=" << to_string(sourceTablesCompacted);
  out << ")";
}


WMResourcePlan::~WMResourcePlan() noexcept {
}


void WMResourcePlan::__set_name(const std::string& val) {
  this->name = val;
}

void WMResourcePlan::__set_status(const WMResourcePlanStatus::type val) {
  this->status = val;
__isset.status = true;
}

void WMResourcePlan::__set_queryParallelism(const int32_t val) {
  this->queryParallelism = val;
__isset.queryParallelism = true;
}

void WMResourcePlan::__set_defaultPoolPath(const std::string& val) {
  this->defaultPoolPath = val;
__isset.defaultPoolPath = true;
}

void WMResourcePlan::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMResourcePlan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMResourcePlan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1328;
          xfer += iprot->readI32(ecast1328);
          this->status = static_cast<WMResourcePlanStatus::type>(ecast1328);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->queryParallelism);
          this->__isset.queryParallelism = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->defaultPoolPath);
          this->__isset.defaultPoolPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WMResourcePlan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMResourcePlan");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(static_cast<int32_t>(this->status));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queryParallelism) {
    xfer += oprot->writeFieldBegin("queryParallelism", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->queryParallelism);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.defaultPoolPath) {
    xfer += oprot->writeFieldBegin("defaultPoolPath", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->defaultPoolPath);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMResourcePlan &a, WMResourcePlan &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.status, b.status);
  swap(a.queryParallelism, b.queryParallelism);
  swap(a.defaultPoolPath, b.defaultPoolPath);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMResourcePlan::WMResourcePlan(const WMResourcePlan& other1329) {
  name = other1329.name;
  status = other1329.status;
  queryParallelism = other1329.queryParallelism;
  defaultPoolPath = other1329.defaultPoolPath;
  ns = other1329.ns;
  __isset = other1329.__isset;
}
WMResourcePlan& WMResourcePlan::operator=(const WMResourcePlan& other1330) {
  name = other1330.name;
  status = other1330.status;
  queryParallelism = other1330.queryParallelism;
  defaultPoolPath = other1330.defaultPoolPath;
  ns = other1330.ns;
  __isset = other1330.__isset;
  return *this;
}
void WMResourcePlan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMResourcePlan(";
  out << "name=" << to_string(name);
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ", " << "queryParallelism="; (__isset.queryParallelism ? (out << to_string(queryParallelism)) : (out << "<null>"));
  out << ", " << "defaultPoolPath="; (__isset.defaultPoolPath ? (out << to_string(defaultPoolPath)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMNullableResourcePlan::~WMNullableResourcePlan() noexcept {
}


void WMNullableResourcePlan::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void WMNullableResourcePlan::__set_status(const WMResourcePlanStatus::type val) {
  this->status = val;
__isset.status = true;
}

void WMNullableResourcePlan::__set_queryParallelism(const int32_t val) {
  this->queryParallelism = val;
__isset.queryParallelism = true;
}

void WMNullableResourcePlan::__set_isSetQueryParallelism(const bool val) {
  this->isSetQueryParallelism = val;
__isset.isSetQueryParallelism = true;
}

void WMNullableResourcePlan::__set_defaultPoolPath(const std::string& val) {
  this->defaultPoolPath = val;
__isset.defaultPoolPath = true;
}

void WMNullableResourcePlan::__set_isSetDefaultPoolPath(const bool val) {
  this->isSetDefaultPoolPath = val;
__isset.isSetDefaultPoolPath = true;
}

void WMNullableResourcePlan::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMNullableResourcePlan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMNullableResourcePlan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1331;
          xfer += iprot->readI32(ecast1331);
          this->status = static_cast<WMResourcePlanStatus::type>(ecast1331);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->queryParallelism);
          this->__isset.queryParallelism = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isSetQueryParallelism);
          this->__isset.isSetQueryParallelism = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->defaultPoolPath);
          this->__isset.defaultPoolPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isSetDefaultPoolPath);
          this->__isset.isSetDefaultPoolPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMNullableResourcePlan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMNullableResourcePlan");

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(static_cast<int32_t>(this->status));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queryParallelism) {
    xfer += oprot->writeFieldBegin("queryParallelism", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->queryParallelism);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isSetQueryParallelism) {
    xfer += oprot->writeFieldBegin("isSetQueryParallelism", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->isSetQueryParallelism);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.defaultPoolPath) {
    xfer += oprot->writeFieldBegin("defaultPoolPath", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->defaultPoolPath);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isSetDefaultPoolPath) {
    xfer += oprot->writeFieldBegin("isSetDefaultPoolPath", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->isSetDefaultPoolPath);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMNullableResourcePlan &a, WMNullableResourcePlan &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.status, b.status);
  swap(a.queryParallelism, b.queryParallelism);
  swap(a.isSetQueryParallelism, b.isSetQueryParallelism);
  swap(a.defaultPoolPath, b.defaultPoolPath);
  swap(a.isSetDefaultPoolPath, b.isSetDefaultPoolPath);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMNullableResourcePlan::WMNullableResourcePlan(const WMNullableResourcePlan& other1332) {
  name = other1332.name;
  status = other1332.status;
  queryParallelism = other1332.queryParallelism;
  isSetQueryParallelism = other1332.isSetQueryParallelism;
  defaultPoolPath = other1332.defaultPoolPath;
  isSetDefaultPoolPath = other1332.isSetDefaultPoolPath;
  ns = other1332.ns;
  __isset = other1332.__isset;
}
WMNullableResourcePlan& WMNullableResourcePlan::operator=(const WMNullableResourcePlan& other1333) {
  name = other1333.name;
  status = other1333.status;
  queryParallelism = other1333.queryParallelism;
  isSetQueryParallelism = other1333.isSetQueryParallelism;
  defaultPoolPath = other1333.defaultPoolPath;
  isSetDefaultPoolPath = other1333.isSetDefaultPoolPath;
  ns = other1333.ns;
  __isset = other1333.__isset;
  return *this;
}
void WMNullableResourcePlan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMNullableResourcePlan(";
  out << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ", " << "queryParallelism="; (__isset.queryParallelism ? (out << to_string(queryParallelism)) : (out << "<null>"));
  out << ", " << "isSetQueryParallelism="; (__isset.isSetQueryParallelism ? (out << to_string(isSetQueryParallelism)) : (out << "<null>"));
  out << ", " << "defaultPoolPath="; (__isset.defaultPoolPath ? (out << to_string(defaultPoolPath)) : (out << "<null>"));
  out << ", " << "isSetDefaultPoolPath="; (__isset.isSetDefaultPoolPath ? (out << to_string(isSetDefaultPoolPath)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMPool::~WMPool() noexcept {
}


void WMPool::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
}

void WMPool::__set_poolPath(const std::string& val) {
  this->poolPath = val;
}

void WMPool::__set_allocFraction(const double val) {
  this->allocFraction = val;
__isset.allocFraction = true;
}

void WMPool::__set_queryParallelism(const int32_t val) {
  this->queryParallelism = val;
__isset.queryParallelism = true;
}

void WMPool::__set_schedulingPolicy(const std::string& val) {
  this->schedulingPolicy = val;
__isset.schedulingPolicy = true;
}

void WMPool::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMPool& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMPool::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resourcePlanName = false;
  bool isset_poolPath = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          isset_resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->poolPath);
          isset_poolPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->allocFraction);
          this->__isset.allocFraction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->queryParallelism);
          this->__isset.queryParallelism = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schedulingPolicy);
          this->__isset.schedulingPolicy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resourcePlanName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_poolPath)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WMPool::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMPool");

  xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->resourcePlanName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("poolPath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->poolPath);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.allocFraction) {
    xfer += oprot->writeFieldBegin("allocFraction", ::apache::thrift::protocol::T_DOUBLE, 3);
    xfer += oprot->writeDouble(this->allocFraction);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queryParallelism) {
    xfer += oprot->writeFieldBegin("queryParallelism", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->queryParallelism);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schedulingPolicy) {
    xfer += oprot->writeFieldBegin("schedulingPolicy", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->schedulingPolicy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMPool &a, WMPool &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.poolPath, b.poolPath);
  swap(a.allocFraction, b.allocFraction);
  swap(a.queryParallelism, b.queryParallelism);
  swap(a.schedulingPolicy, b.schedulingPolicy);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMPool::WMPool(const WMPool& other1334) {
  resourcePlanName = other1334.resourcePlanName;
  poolPath = other1334.poolPath;
  allocFraction = other1334.allocFraction;
  queryParallelism = other1334.queryParallelism;
  schedulingPolicy = other1334.schedulingPolicy;
  ns = other1334.ns;
  __isset = other1334.__isset;
}
WMPool& WMPool::operator=(const WMPool& other1335) {
  resourcePlanName = other1335.resourcePlanName;
  poolPath = other1335.poolPath;
  allocFraction = other1335.allocFraction;
  queryParallelism = other1335.queryParallelism;
  schedulingPolicy = other1335.schedulingPolicy;
  ns = other1335.ns;
  __isset = other1335.__isset;
  return *this;
}
void WMPool::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMPool(";
  out << "resourcePlanName=" << to_string(resourcePlanName);
  out << ", " << "poolPath=" << to_string(poolPath);
  out << ", " << "allocFraction="; (__isset.allocFraction ? (out << to_string(allocFraction)) : (out << "<null>"));
  out << ", " << "queryParallelism="; (__isset.queryParallelism ? (out << to_string(queryParallelism)) : (out << "<null>"));
  out << ", " << "schedulingPolicy="; (__isset.schedulingPolicy ? (out << to_string(schedulingPolicy)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMNullablePool::~WMNullablePool() noexcept {
}


void WMNullablePool::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
}

void WMNullablePool::__set_poolPath(const std::string& val) {
  this->poolPath = val;
}

void WMNullablePool::__set_allocFraction(const double val) {
  this->allocFraction = val;
__isset.allocFraction = true;
}

void WMNullablePool::__set_queryParallelism(const int32_t val) {
  this->queryParallelism = val;
__isset.queryParallelism = true;
}

void WMNullablePool::__set_schedulingPolicy(const std::string& val) {
  this->schedulingPolicy = val;
__isset.schedulingPolicy = true;
}

void WMNullablePool::__set_isSetSchedulingPolicy(const bool val) {
  this->isSetSchedulingPolicy = val;
__isset.isSetSchedulingPolicy = true;
}

void WMNullablePool::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMNullablePool& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMNullablePool::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resourcePlanName = false;
  bool isset_poolPath = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          isset_resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->poolPath);
          isset_poolPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->allocFraction);
          this->__isset.allocFraction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->queryParallelism);
          this->__isset.queryParallelism = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schedulingPolicy);
          this->__isset.schedulingPolicy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isSetSchedulingPolicy);
          this->__isset.isSetSchedulingPolicy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resourcePlanName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_poolPath)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WMNullablePool::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMNullablePool");

  xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->resourcePlanName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("poolPath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->poolPath);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.allocFraction) {
    xfer += oprot->writeFieldBegin("allocFraction", ::apache::thrift::protocol::T_DOUBLE, 3);
    xfer += oprot->writeDouble(this->allocFraction);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queryParallelism) {
    xfer += oprot->writeFieldBegin("queryParallelism", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->queryParallelism);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schedulingPolicy) {
    xfer += oprot->writeFieldBegin("schedulingPolicy", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->schedulingPolicy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isSetSchedulingPolicy) {
    xfer += oprot->writeFieldBegin("isSetSchedulingPolicy", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->isSetSchedulingPolicy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMNullablePool &a, WMNullablePool &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.poolPath, b.poolPath);
  swap(a.allocFraction, b.allocFraction);
  swap(a.queryParallelism, b.queryParallelism);
  swap(a.schedulingPolicy, b.schedulingPolicy);
  swap(a.isSetSchedulingPolicy, b.isSetSchedulingPolicy);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMNullablePool::WMNullablePool(const WMNullablePool& other1336) {
  resourcePlanName = other1336.resourcePlanName;
  poolPath = other1336.poolPath;
  allocFraction = other1336.allocFraction;
  queryParallelism = other1336.queryParallelism;
  schedulingPolicy = other1336.schedulingPolicy;
  isSetSchedulingPolicy = other1336.isSetSchedulingPolicy;
  ns = other1336.ns;
  __isset = other1336.__isset;
}
WMNullablePool& WMNullablePool::operator=(const WMNullablePool& other1337) {
  resourcePlanName = other1337.resourcePlanName;
  poolPath = other1337.poolPath;
  allocFraction = other1337.allocFraction;
  queryParallelism = other1337.queryParallelism;
  schedulingPolicy = other1337.schedulingPolicy;
  isSetSchedulingPolicy = other1337.isSetSchedulingPolicy;
  ns = other1337.ns;
  __isset = other1337.__isset;
  return *this;
}
void WMNullablePool::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMNullablePool(";
  out << "resourcePlanName=" << to_string(resourcePlanName);
  out << ", " << "poolPath=" << to_string(poolPath);
  out << ", " << "allocFraction="; (__isset.allocFraction ? (out << to_string(allocFraction)) : (out << "<null>"));
  out << ", " << "queryParallelism="; (__isset.queryParallelism ? (out << to_string(queryParallelism)) : (out << "<null>"));
  out << ", " << "schedulingPolicy="; (__isset.schedulingPolicy ? (out << to_string(schedulingPolicy)) : (out << "<null>"));
  out << ", " << "isSetSchedulingPolicy="; (__isset.isSetSchedulingPolicy ? (out << to_string(isSetSchedulingPolicy)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMTrigger::~WMTrigger() noexcept {
}


void WMTrigger::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
}

void WMTrigger::__set_triggerName(const std::string& val) {
  this->triggerName = val;
}

void WMTrigger::__set_triggerExpression(const std::string& val) {
  this->triggerExpression = val;
__isset.triggerExpression = true;
}

void WMTrigger::__set_actionExpression(const std::string& val) {
  this->actionExpression = val;
__isset.actionExpression = true;
}

void WMTrigger::__set_isInUnmanaged(const bool val) {
  this->isInUnmanaged = val;
__isset.isInUnmanaged = true;
}

void WMTrigger::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMTrigger& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMTrigger::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resourcePlanName = false;
  bool isset_triggerName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          isset_resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->triggerName);
          isset_triggerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->triggerExpression);
          this->__isset.triggerExpression = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->actionExpression);
          this->__isset.actionExpression = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isInUnmanaged);
          this->__isset.isInUnmanaged = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resourcePlanName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_triggerName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WMTrigger::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMTrigger");

  xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->resourcePlanName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("triggerName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->triggerName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.triggerExpression) {
    xfer += oprot->writeFieldBegin("triggerExpression", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->triggerExpression);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.actionExpression) {
    xfer += oprot->writeFieldBegin("actionExpression", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->actionExpression);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isInUnmanaged) {
    xfer += oprot->writeFieldBegin("isInUnmanaged", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->isInUnmanaged);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMTrigger &a, WMTrigger &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.triggerName, b.triggerName);
  swap(a.triggerExpression, b.triggerExpression);
  swap(a.actionExpression, b.actionExpression);
  swap(a.isInUnmanaged, b.isInUnmanaged);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMTrigger::WMTrigger(const WMTrigger& other1338) {
  resourcePlanName = other1338.resourcePlanName;
  triggerName = other1338.triggerName;
  triggerExpression = other1338.triggerExpression;
  actionExpression = other1338.actionExpression;
  isInUnmanaged = other1338.isInUnmanaged;
  ns = other1338.ns;
  __isset = other1338.__isset;
}
WMTrigger& WMTrigger::operator=(const WMTrigger& other1339) {
  resourcePlanName = other1339.resourcePlanName;
  triggerName = other1339.triggerName;
  triggerExpression = other1339.triggerExpression;
  actionExpression = other1339.actionExpression;
  isInUnmanaged = other1339.isInUnmanaged;
  ns = other1339.ns;
  __isset = other1339.__isset;
  return *this;
}
void WMTrigger::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMTrigger(";
  out << "resourcePlanName=" << to_string(resourcePlanName);
  out << ", " << "triggerName=" << to_string(triggerName);
  out << ", " << "triggerExpression="; (__isset.triggerExpression ? (out << to_string(triggerExpression)) : (out << "<null>"));
  out << ", " << "actionExpression="; (__isset.actionExpression ? (out << to_string(actionExpression)) : (out << "<null>"));
  out << ", " << "isInUnmanaged="; (__isset.isInUnmanaged ? (out << to_string(isInUnmanaged)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMMapping::~WMMapping() noexcept {
}


void WMMapping::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
}

void WMMapping::__set_entityType(const std::string& val) {
  this->entityType = val;
}

void WMMapping::__set_entityName(const std::string& val) {
  this->entityName = val;
}

void WMMapping::__set_poolPath(const std::string& val) {
  this->poolPath = val;
__isset.poolPath = true;
}

void WMMapping::__set_ordering(const int32_t val) {
  this->ordering = val;
__isset.ordering = true;
}

void WMMapping::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMMapping& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMMapping::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resourcePlanName = false;
  bool isset_entityType = false;
  bool isset_entityName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          isset_resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->entityType);
          isset_entityType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->entityName);
          isset_entityName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->poolPath);
          this->__isset.poolPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ordering);
          this->__isset.ordering = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resourcePlanName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_entityType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_entityName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WMMapping::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMMapping");

  xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->resourcePlanName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entityType", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->entityType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entityName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->entityName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.poolPath) {
    xfer += oprot->writeFieldBegin("poolPath", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->poolPath);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ordering) {
    xfer += oprot->writeFieldBegin("ordering", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->ordering);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMMapping &a, WMMapping &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.entityType, b.entityType);
  swap(a.entityName, b.entityName);
  swap(a.poolPath, b.poolPath);
  swap(a.ordering, b.ordering);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMMapping::WMMapping(const WMMapping& other1340) {
  resourcePlanName = other1340.resourcePlanName;
  entityType = other1340.entityType;
  entityName = other1340.entityName;
  poolPath = other1340.poolPath;
  ordering = other1340.ordering;
  ns = other1340.ns;
  __isset = other1340.__isset;
}
WMMapping& WMMapping::operator=(const WMMapping& other1341) {
  resourcePlanName = other1341.resourcePlanName;
  entityType = other1341.entityType;
  entityName = other1341.entityName;
  poolPath = other1341.poolPath;
  ordering = other1341.ordering;
  ns = other1341.ns;
  __isset = other1341.__isset;
  return *this;
}
void WMMapping::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMMapping(";
  out << "resourcePlanName=" << to_string(resourcePlanName);
  out << ", " << "entityType=" << to_string(entityType);
  out << ", " << "entityName=" << to_string(entityName);
  out << ", " << "poolPath="; (__isset.poolPath ? (out << to_string(poolPath)) : (out << "<null>"));
  out << ", " << "ordering="; (__isset.ordering ? (out << to_string(ordering)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMPoolTrigger::~WMPoolTrigger() noexcept {
}


void WMPoolTrigger::__set_pool(const std::string& val) {
  this->pool = val;
}

void WMPoolTrigger::__set_trigger(const std::string& val) {
  this->trigger = val;
}

void WMPoolTrigger::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMPoolTrigger& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMPoolTrigger::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_pool = false;
  bool isset_trigger = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pool);
          isset_pool = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->trigger);
          isset_trigger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_pool)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_trigger)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WMPoolTrigger::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMPoolTrigger");

  xfer += oprot->writeFieldBegin("pool", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->pool);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("trigger", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->trigger);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMPoolTrigger &a, WMPoolTrigger &b) {
  using ::std::swap;
  swap(a.pool, b.pool);
  swap(a.trigger, b.trigger);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMPoolTrigger::WMPoolTrigger(const WMPoolTrigger& other1342) {
  pool = other1342.pool;
  trigger = other1342.trigger;
  ns = other1342.ns;
  __isset = other1342.__isset;
}
WMPoolTrigger& WMPoolTrigger::operator=(const WMPoolTrigger& other1343) {
  pool = other1343.pool;
  trigger = other1343.trigger;
  ns = other1343.ns;
  __isset = other1343.__isset;
  return *this;
}
void WMPoolTrigger::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMPoolTrigger(";
  out << "pool=" << to_string(pool);
  out << ", " << "trigger=" << to_string(trigger);
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMFullResourcePlan::~WMFullResourcePlan() noexcept {
}


void WMFullResourcePlan::__set_plan(const WMResourcePlan& val) {
  this->plan = val;
}

void WMFullResourcePlan::__set_pools(const std::vector<WMPool> & val) {
  this->pools = val;
}

void WMFullResourcePlan::__set_mappings(const std::vector<WMMapping> & val) {
  this->mappings = val;
__isset.mappings = true;
}

void WMFullResourcePlan::__set_triggers(const std::vector<WMTrigger> & val) {
  this->triggers = val;
__isset.triggers = true;
}

void WMFullResourcePlan::__set_poolTriggers(const std::vector<WMPoolTrigger> & val) {
  this->poolTriggers = val;
__isset.poolTriggers = true;
}
std::ostream& operator<<(std::ostream& out, const WMFullResourcePlan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMFullResourcePlan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_plan = false;
  bool isset_pools = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->plan.read(iprot);
          isset_plan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pools.clear();
            uint32_t _size1344;
            ::apache::thrift::protocol::TType _etype1347;
            xfer += iprot->readListBegin(_etype1347, _size1344);
            this->pools.resize(_size1344);
            uint32_t _i1348;
            for (_i1348 = 0; _i1348 < _size1344; ++_i1348)
            {
              xfer += this->pools[_i1348].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_pools = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->mappings.clear();
            uint32_t _size1349;
            ::apache::thrift::protocol::TType _etype1352;
            xfer += iprot->readListBegin(_etype1352, _size1349);
            this->mappings.resize(_size1349);
            uint32_t _i1353;
            for (_i1353 = 0; _i1353 < _size1349; ++_i1353)
            {
              xfer += this->mappings[_i1353].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.mappings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->triggers.clear();
            uint32_t _size1354;
            ::apache::thrift::protocol::TType _etype1357;
            xfer += iprot->readListBegin(_etype1357, _size1354);
            this->triggers.resize(_size1354);
            uint32_t _i1358;
            for (_i1358 = 0; _i1358 < _size1354; ++_i1358)
            {
              xfer += this->triggers[_i1358].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.triggers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->poolTriggers.clear();
            uint32_t _size1359;
            ::apache::thrift::protocol::TType _etype1362;
            xfer += iprot->readListBegin(_etype1362, _size1359);
            this->poolTriggers.resize(_size1359);
            uint32_t _i1363;
            for (_i1363 = 0; _i1363 < _size1359; ++_i1363)
            {
              xfer += this->poolTriggers[_i1363].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.poolTriggers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_plan)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_pools)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WMFullResourcePlan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMFullResourcePlan");

  xfer += oprot->writeFieldBegin("plan", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->plan.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pools", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->pools.size()));
    std::vector<WMPool> ::const_iterator _iter1364;
    for (_iter1364 = this->pools.begin(); _iter1364 != this->pools.end(); ++_iter1364)
    {
      xfer += (*_iter1364).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.mappings) {
    xfer += oprot->writeFieldBegin("mappings", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->mappings.size()));
      std::vector<WMMapping> ::const_iterator _iter1365;
      for (_iter1365 = this->mappings.begin(); _iter1365 != this->mappings.end(); ++_iter1365)
      {
        xfer += (*_iter1365).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.triggers) {
    xfer += oprot->writeFieldBegin("triggers", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->triggers.size()));
      std::vector<WMTrigger> ::const_iterator _iter1366;
      for (_iter1366 = this->triggers.begin(); _iter1366 != this->triggers.end(); ++_iter1366)
      {
        xfer += (*_iter1366).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.poolTriggers) {
    xfer += oprot->writeFieldBegin("poolTriggers", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->poolTriggers.size()));
      std::vector<WMPoolTrigger> ::const_iterator _iter1367;
      for (_iter1367 = this->poolTriggers.begin(); _iter1367 != this->poolTriggers.end(); ++_iter1367)
      {
        xfer += (*_iter1367).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMFullResourcePlan &a, WMFullResourcePlan &b) {
  using ::std::swap;
  swap(a.plan, b.plan);
  swap(a.pools, b.pools);
  swap(a.mappings, b.mappings);
  swap(a.triggers, b.triggers);
  swap(a.poolTriggers, b.poolTriggers);
  swap(a.__isset, b.__isset);
}

WMFullResourcePlan::WMFullResourcePlan(const WMFullResourcePlan& other1368) {
  plan = other1368.plan;
  pools = other1368.pools;
  mappings = other1368.mappings;
  triggers = other1368.triggers;
  poolTriggers = other1368.poolTriggers;
  __isset = other1368.__isset;
}
WMFullResourcePlan& WMFullResourcePlan::operator=(const WMFullResourcePlan& other1369) {
  plan = other1369.plan;
  pools = other1369.pools;
  mappings = other1369.mappings;
  triggers = other1369.triggers;
  poolTriggers = other1369.poolTriggers;
  __isset = other1369.__isset;
  return *this;
}
void WMFullResourcePlan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMFullResourcePlan(";
  out << "plan=" << to_string(plan);
  out << ", " << "pools=" << to_string(pools);
  out << ", " << "mappings="; (__isset.mappings ? (out << to_string(mappings)) : (out << "<null>"));
  out << ", " << "triggers="; (__isset.triggers ? (out << to_string(triggers)) : (out << "<null>"));
  out << ", " << "poolTriggers="; (__isset.poolTriggers ? (out << to_string(poolTriggers)) : (out << "<null>"));
  out << ")";
}


WMCreateResourcePlanRequest::~WMCreateResourcePlanRequest() noexcept {
}


void WMCreateResourcePlanRequest::__set_resourcePlan(const WMResourcePlan& val) {
  this->resourcePlan = val;
__isset.resourcePlan = true;
}

void WMCreateResourcePlanRequest::__set_copyFrom(const std::string& val) {
  this->copyFrom = val;
__isset.copyFrom = true;
}
std::ostream& operator<<(std::ostream& out, const WMCreateResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreateResourcePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resourcePlan.read(iprot);
          this->__isset.resourcePlan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->copyFrom);
          this->__isset.copyFrom = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreateResourcePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreateResourcePlanRequest");

  if (this->__isset.resourcePlan) {
    xfer += oprot->writeFieldBegin("resourcePlan", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->resourcePlan.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.copyFrom) {
    xfer += oprot->writeFieldBegin("copyFrom", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->copyFrom);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreateResourcePlanRequest &a, WMCreateResourcePlanRequest &b) {
  using ::std::swap;
  swap(a.resourcePlan, b.resourcePlan);
  swap(a.copyFrom, b.copyFrom);
  swap(a.__isset, b.__isset);
}

WMCreateResourcePlanRequest::WMCreateResourcePlanRequest(const WMCreateResourcePlanRequest& other1370) {
  resourcePlan = other1370.resourcePlan;
  copyFrom = other1370.copyFrom;
  __isset = other1370.__isset;
}
WMCreateResourcePlanRequest& WMCreateResourcePlanRequest::operator=(const WMCreateResourcePlanRequest& other1371) {
  resourcePlan = other1371.resourcePlan;
  copyFrom = other1371.copyFrom;
  __isset = other1371.__isset;
  return *this;
}
void WMCreateResourcePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreateResourcePlanRequest(";
  out << "resourcePlan="; (__isset.resourcePlan ? (out << to_string(resourcePlan)) : (out << "<null>"));
  out << ", " << "copyFrom="; (__isset.copyFrom ? (out << to_string(copyFrom)) : (out << "<null>"));
  out << ")";
}


WMCreateResourcePlanResponse::~WMCreateResourcePlanResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMCreateResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreateResourcePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreateResourcePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreateResourcePlanResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreateResourcePlanResponse &a, WMCreateResourcePlanResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMCreateResourcePlanResponse::WMCreateResourcePlanResponse(const WMCreateResourcePlanResponse& other1372) noexcept {
  (void) other1372;
}
WMCreateResourcePlanResponse& WMCreateResourcePlanResponse::operator=(const WMCreateResourcePlanResponse& other1373) noexcept {
  (void) other1373;
  return *this;
}
void WMCreateResourcePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreateResourcePlanResponse(";
  out << ")";
}


WMGetActiveResourcePlanRequest::~WMGetActiveResourcePlanRequest() noexcept {
}


void WMGetActiveResourcePlanRequest::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetActiveResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetActiveResourcePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetActiveResourcePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetActiveResourcePlanRequest");

  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetActiveResourcePlanRequest &a, WMGetActiveResourcePlanRequest &b) {
  using ::std::swap;
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMGetActiveResourcePlanRequest::WMGetActiveResourcePlanRequest(const WMGetActiveResourcePlanRequest& other1374) {
  ns = other1374.ns;
  __isset = other1374.__isset;
}
WMGetActiveResourcePlanRequest& WMGetActiveResourcePlanRequest::operator=(const WMGetActiveResourcePlanRequest& other1375) {
  ns = other1375.ns;
  __isset = other1375.__isset;
  return *this;
}
void WMGetActiveResourcePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetActiveResourcePlanRequest(";
  out << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMGetActiveResourcePlanResponse::~WMGetActiveResourcePlanResponse() noexcept {
}


void WMGetActiveResourcePlanResponse::__set_resourcePlan(const WMFullResourcePlan& val) {
  this->resourcePlan = val;
__isset.resourcePlan = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetActiveResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetActiveResourcePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resourcePlan.read(iprot);
          this->__isset.resourcePlan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetActiveResourcePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetActiveResourcePlanResponse");

  if (this->__isset.resourcePlan) {
    xfer += oprot->writeFieldBegin("resourcePlan", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->resourcePlan.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetActiveResourcePlanResponse &a, WMGetActiveResourcePlanResponse &b) {
  using ::std::swap;
  swap(a.resourcePlan, b.resourcePlan);
  swap(a.__isset, b.__isset);
}

WMGetActiveResourcePlanResponse::WMGetActiveResourcePlanResponse(const WMGetActiveResourcePlanResponse& other1376) {
  resourcePlan = other1376.resourcePlan;
  __isset = other1376.__isset;
}
WMGetActiveResourcePlanResponse& WMGetActiveResourcePlanResponse::operator=(const WMGetActiveResourcePlanResponse& other1377) {
  resourcePlan = other1377.resourcePlan;
  __isset = other1377.__isset;
  return *this;
}
void WMGetActiveResourcePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetActiveResourcePlanResponse(";
  out << "resourcePlan="; (__isset.resourcePlan ? (out << to_string(resourcePlan)) : (out << "<null>"));
  out << ")";
}


WMGetResourcePlanRequest::~WMGetResourcePlanRequest() noexcept {
}


void WMGetResourcePlanRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}

void WMGetResourcePlanRequest::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetResourcePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetResourcePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetResourcePlanRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetResourcePlanRequest &a, WMGetResourcePlanRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMGetResourcePlanRequest::WMGetResourcePlanRequest(const WMGetResourcePlanRequest& other1378) {
  resourcePlanName = other1378.resourcePlanName;
  ns = other1378.ns;
  __isset = other1378.__isset;
}
WMGetResourcePlanRequest& WMGetResourcePlanRequest::operator=(const WMGetResourcePlanRequest& other1379) {
  resourcePlanName = other1379.resourcePlanName;
  ns = other1379.ns;
  __isset = other1379.__isset;
  return *this;
}
void WMGetResourcePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetResourcePlanRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMGetResourcePlanResponse::~WMGetResourcePlanResponse() noexcept {
}


void WMGetResourcePlanResponse::__set_resourcePlan(const WMFullResourcePlan& val) {
  this->resourcePlan = val;
__isset.resourcePlan = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetResourcePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resourcePlan.read(iprot);
          this->__isset.resourcePlan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetResourcePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetResourcePlanResponse");

  if (this->__isset.resourcePlan) {
    xfer += oprot->writeFieldBegin("resourcePlan", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->resourcePlan.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetResourcePlanResponse &a, WMGetResourcePlanResponse &b) {
  using ::std::swap;
  swap(a.resourcePlan, b.resourcePlan);
  swap(a.__isset, b.__isset);
}

WMGetResourcePlanResponse::WMGetResourcePlanResponse(const WMGetResourcePlanResponse& other1380) {
  resourcePlan = other1380.resourcePlan;
  __isset = other1380.__isset;
}
WMGetResourcePlanResponse& WMGetResourcePlanResponse::operator=(const WMGetResourcePlanResponse& other1381) {
  resourcePlan = other1381.resourcePlan;
  __isset = other1381.__isset;
  return *this;
}
void WMGetResourcePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetResourcePlanResponse(";
  out << "resourcePlan="; (__isset.resourcePlan ? (out << to_string(resourcePlan)) : (out << "<null>"));
  out << ")";
}


WMGetAllResourcePlanRequest::~WMGetAllResourcePlanRequest() noexcept {
}


void WMGetAllResourcePlanRequest::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetAllResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetAllResourcePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetAllResourcePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetAllResourcePlanRequest");

  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetAllResourcePlanRequest &a, WMGetAllResourcePlanRequest &b) {
  using ::std::swap;
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMGetAllResourcePlanRequest::WMGetAllResourcePlanRequest(const WMGetAllResourcePlanRequest& other1382) {
  ns = other1382.ns;
  __isset = other1382.__isset;
}
WMGetAllResourcePlanRequest& WMGetAllResourcePlanRequest::operator=(const WMGetAllResourcePlanRequest& other1383) {
  ns = other1383.ns;
  __isset = other1383.__isset;
  return *this;
}
void WMGetAllResourcePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetAllResourcePlanRequest(";
  out << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMGetAllResourcePlanResponse::~WMGetAllResourcePlanResponse() noexcept {
}


void WMGetAllResourcePlanResponse::__set_resourcePlans(const std::vector<WMResourcePlan> & val) {
  this->resourcePlans = val;
__isset.resourcePlans = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetAllResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetAllResourcePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->resourcePlans.clear();
            uint32_t _size1384;
            ::apache::thrift::protocol::TType _etype1387;
            xfer += iprot->readListBegin(_etype1387, _size1384);
            this->resourcePlans.resize(_size1384);
            uint32_t _i1388;
            for (_i1388 = 0; _i1388 < _size1384; ++_i1388)
            {
              xfer += this->resourcePlans[_i1388].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.resourcePlans = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetAllResourcePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetAllResourcePlanResponse");

  if (this->__isset.resourcePlans) {
    xfer += oprot->writeFieldBegin("resourcePlans", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->resourcePlans.size()));
      std::vector<WMResourcePlan> ::const_iterator _iter1389;
      for (_iter1389 = this->resourcePlans.begin(); _iter1389 != this->resourcePlans.end(); ++_iter1389)
      {
        xfer += (*_iter1389).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetAllResourcePlanResponse &a, WMGetAllResourcePlanResponse &b) {
  using ::std::swap;
  swap(a.resourcePlans, b.resourcePlans);
  swap(a.__isset, b.__isset);
}

WMGetAllResourcePlanResponse::WMGetAllResourcePlanResponse(const WMGetAllResourcePlanResponse& other1390) {
  resourcePlans = other1390.resourcePlans;
  __isset = other1390.__isset;
}
WMGetAllResourcePlanResponse& WMGetAllResourcePlanResponse::operator=(const WMGetAllResourcePlanResponse& other1391) {
  resourcePlans = other1391.resourcePlans;
  __isset = other1391.__isset;
  return *this;
}
void WMGetAllResourcePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetAllResourcePlanResponse(";
  out << "resourcePlans="; (__isset.resourcePlans ? (out << to_string(resourcePlans)) : (out << "<null>"));
  out << ")";
}


WMAlterResourcePlanRequest::~WMAlterResourcePlanRequest() noexcept {
}


void WMAlterResourcePlanRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}

void WMAlterResourcePlanRequest::__set_resourcePlan(const WMNullableResourcePlan& val) {
  this->resourcePlan = val;
__isset.resourcePlan = true;
}

void WMAlterResourcePlanRequest::__set_isEnableAndActivate(const bool val) {
  this->isEnableAndActivate = val;
__isset.isEnableAndActivate = true;
}

void WMAlterResourcePlanRequest::__set_isForceDeactivate(const bool val) {
  this->isForceDeactivate = val;
__isset.isForceDeactivate = true;
}

void WMAlterResourcePlanRequest::__set_isReplace(const bool val) {
  this->isReplace = val;
__isset.isReplace = true;
}

void WMAlterResourcePlanRequest::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMAlterResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMAlterResourcePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resourcePlan.read(iprot);
          this->__isset.resourcePlan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isEnableAndActivate);
          this->__isset.isEnableAndActivate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isForceDeactivate);
          this->__isset.isForceDeactivate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isReplace);
          this->__isset.isReplace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMAlterResourcePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMAlterResourcePlanRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resourcePlan) {
    xfer += oprot->writeFieldBegin("resourcePlan", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->resourcePlan.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isEnableAndActivate) {
    xfer += oprot->writeFieldBegin("isEnableAndActivate", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->isEnableAndActivate);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isForceDeactivate) {
    xfer += oprot->writeFieldBegin("isForceDeactivate", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->isForceDeactivate);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isReplace) {
    xfer += oprot->writeFieldBegin("isReplace", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->isReplace);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMAlterResourcePlanRequest &a, WMAlterResourcePlanRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.resourcePlan, b.resourcePlan);
  swap(a.isEnableAndActivate, b.isEnableAndActivate);
  swap(a.isForceDeactivate, b.isForceDeactivate);
  swap(a.isReplace, b.isReplace);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMAlterResourcePlanRequest::WMAlterResourcePlanRequest(const WMAlterResourcePlanRequest& other1392) {
  resourcePlanName = other1392.resourcePlanName;
  resourcePlan = other1392.resourcePlan;
  isEnableAndActivate = other1392.isEnableAndActivate;
  isForceDeactivate = other1392.isForceDeactivate;
  isReplace = other1392.isReplace;
  ns = other1392.ns;
  __isset = other1392.__isset;
}
WMAlterResourcePlanRequest& WMAlterResourcePlanRequest::operator=(const WMAlterResourcePlanRequest& other1393) {
  resourcePlanName = other1393.resourcePlanName;
  resourcePlan = other1393.resourcePlan;
  isEnableAndActivate = other1393.isEnableAndActivate;
  isForceDeactivate = other1393.isForceDeactivate;
  isReplace = other1393.isReplace;
  ns = other1393.ns;
  __isset = other1393.__isset;
  return *this;
}
void WMAlterResourcePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMAlterResourcePlanRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ", " << "resourcePlan="; (__isset.resourcePlan ? (out << to_string(resourcePlan)) : (out << "<null>"));
  out << ", " << "isEnableAndActivate="; (__isset.isEnableAndActivate ? (out << to_string(isEnableAndActivate)) : (out << "<null>"));
  out << ", " << "isForceDeactivate="; (__isset.isForceDeactivate ? (out << to_string(isForceDeactivate)) : (out << "<null>"));
  out << ", " << "isReplace="; (__isset.isReplace ? (out << to_string(isReplace)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMAlterResourcePlanResponse::~WMAlterResourcePlanResponse() noexcept {
}


void WMAlterResourcePlanResponse::__set_fullResourcePlan(const WMFullResourcePlan& val) {
  this->fullResourcePlan = val;
__isset.fullResourcePlan = true;
}
std::ostream& operator<<(std::ostream& out, const WMAlterResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMAlterResourcePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fullResourcePlan.read(iprot);
          this->__isset.fullResourcePlan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMAlterResourcePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMAlterResourcePlanResponse");

  if (this->__isset.fullResourcePlan) {
    xfer += oprot->writeFieldBegin("fullResourcePlan", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->fullResourcePlan.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMAlterResourcePlanResponse &a, WMAlterResourcePlanResponse &b) {
  using ::std::swap;
  swap(a.fullResourcePlan, b.fullResourcePlan);
  swap(a.__isset, b.__isset);
}

WMAlterResourcePlanResponse::WMAlterResourcePlanResponse(const WMAlterResourcePlanResponse& other1394) {
  fullResourcePlan = other1394.fullResourcePlan;
  __isset = other1394.__isset;
}
WMAlterResourcePlanResponse& WMAlterResourcePlanResponse::operator=(const WMAlterResourcePlanResponse& other1395) {
  fullResourcePlan = other1395.fullResourcePlan;
  __isset = other1395.__isset;
  return *this;
}
void WMAlterResourcePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMAlterResourcePlanResponse(";
  out << "fullResourcePlan="; (__isset.fullResourcePlan ? (out << to_string(fullResourcePlan)) : (out << "<null>"));
  out << ")";
}


WMValidateResourcePlanRequest::~WMValidateResourcePlanRequest() noexcept {
}


void WMValidateResourcePlanRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}

void WMValidateResourcePlanRequest::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMValidateResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMValidateResourcePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMValidateResourcePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMValidateResourcePlanRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMValidateResourcePlanRequest &a, WMValidateResourcePlanRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMValidateResourcePlanRequest::WMValidateResourcePlanRequest(const WMValidateResourcePlanRequest& other1396) {
  resourcePlanName = other1396.resourcePlanName;
  ns = other1396.ns;
  __isset = other1396.__isset;
}
WMValidateResourcePlanRequest& WMValidateResourcePlanRequest::operator=(const WMValidateResourcePlanRequest& other1397) {
  resourcePlanName = other1397.resourcePlanName;
  ns = other1397.ns;
  __isset = other1397.__isset;
  return *this;
}
void WMValidateResourcePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMValidateResourcePlanRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMValidateResourcePlanResponse::~WMValidateResourcePlanResponse() noexcept {
}


void WMValidateResourcePlanResponse::__set_errors(const std::vector<std::string> & val) {
  this->errors = val;
__isset.errors = true;
}

void WMValidateResourcePlanResponse::__set_warnings(const std::vector<std::string> & val) {
  this->warnings = val;
__isset.warnings = true;
}
std::ostream& operator<<(std::ostream& out, const WMValidateResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMValidateResourcePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->errors.clear();
            uint32_t _size1398;
            ::apache::thrift::protocol::TType _etype1401;
            xfer += iprot->readListBegin(_etype1401, _size1398);
            this->errors.resize(_size1398);
            uint32_t _i1402;
            for (_i1402 = 0; _i1402 < _size1398; ++_i1402)
            {
              xfer += iprot->readString(this->errors[_i1402]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.errors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->warnings.clear();
            uint32_t _size1403;
            ::apache::thrift::protocol::TType _etype1406;
            xfer += iprot->readListBegin(_etype1406, _size1403);
            this->warnings.resize(_size1403);
            uint32_t _i1407;
            for (_i1407 = 0; _i1407 < _size1403; ++_i1407)
            {
              xfer += iprot->readString(this->warnings[_i1407]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.warnings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMValidateResourcePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMValidateResourcePlanResponse");

  if (this->__isset.errors) {
    xfer += oprot->writeFieldBegin("errors", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->errors.size()));
      std::vector<std::string> ::const_iterator _iter1408;
      for (_iter1408 = this->errors.begin(); _iter1408 != this->errors.end(); ++_iter1408)
      {
        xfer += oprot->writeString((*_iter1408));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.warnings) {
    xfer += oprot->writeFieldBegin("warnings", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->warnings.size()));
      std::vector<std::string> ::const_iterator _iter1409;
      for (_iter1409 = this->warnings.begin(); _iter1409 != this->warnings.end(); ++_iter1409)
      {
        xfer += oprot->writeString((*_iter1409));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMValidateResourcePlanResponse &a, WMValidateResourcePlanResponse &b) {
  using ::std::swap;
  swap(a.errors, b.errors);
  swap(a.warnings, b.warnings);
  swap(a.__isset, b.__isset);
}

WMValidateResourcePlanResponse::WMValidateResourcePlanResponse(const WMValidateResourcePlanResponse& other1410) {
  errors = other1410.errors;
  warnings = other1410.warnings;
  __isset = other1410.__isset;
}
WMValidateResourcePlanResponse& WMValidateResourcePlanResponse::operator=(const WMValidateResourcePlanResponse& other1411) {
  errors = other1411.errors;
  warnings = other1411.warnings;
  __isset = other1411.__isset;
  return *this;
}
void WMValidateResourcePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMValidateResourcePlanResponse(";
  out << "errors="; (__isset.errors ? (out << to_string(errors)) : (out << "<null>"));
  out << ", " << "warnings="; (__isset.warnings ? (out << to_string(warnings)) : (out << "<null>"));
  out << ")";
}


WMDropResourcePlanRequest::~WMDropResourcePlanRequest() noexcept {
}


void WMDropResourcePlanRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}

void WMDropResourcePlanRequest::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMDropResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMDropResourcePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMDropResourcePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMDropResourcePlanRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMDropResourcePlanRequest &a, WMDropResourcePlanRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMDropResourcePlanRequest::WMDropResourcePlanRequest(const WMDropResourcePlanRequest& other1412) {
  resourcePlanName = other1412.resourcePlanName;
  ns = other1412.ns;
  __isset = other1412.__isset;
}
WMDropResourcePlanRequest& WMDropResourcePlanRequest::operator=(const WMDropResourcePlanRequest& other1413) {
  resourcePlanName = other1413.resourcePlanName;
  ns = other1413.ns;
  __isset = other1413.__isset;
  return *this;
}
void WMDropResourcePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMDropResourcePlanRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMDropResourcePlanResponse::~WMDropResourcePlanResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMDropResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMDropResourcePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMDropResourcePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMDropResourcePlanResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMDropResourcePlanResponse &a, WMDropResourcePlanResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMDropResourcePlanResponse::WMDropResourcePlanResponse(const WMDropResourcePlanResponse& other1414) noexcept {
  (void) other1414;
}
WMDropResourcePlanResponse& WMDropResourcePlanResponse::operator=(const WMDropResourcePlanResponse& other1415) noexcept {
  (void) other1415;
  return *this;
}
void WMDropResourcePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMDropResourcePlanResponse(";
  out << ")";
}


WMCreateTriggerRequest::~WMCreateTriggerRequest() noexcept {
}


void WMCreateTriggerRequest::__set_trigger(const WMTrigger& val) {
  this->trigger = val;
__isset.trigger = true;
}
std::ostream& operator<<(std::ostream& out, const WMCreateTriggerRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreateTriggerRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->trigger.read(iprot);
          this->__isset.trigger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreateTriggerRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreateTriggerRequest");

  if (this->__isset.trigger) {
    xfer += oprot->writeFieldBegin("trigger", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->trigger.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreateTriggerRequest &a, WMCreateTriggerRequest &b) {
  using ::std::swap;
  swap(a.trigger, b.trigger);
  swap(a.__isset, b.__isset);
}

WMCreateTriggerRequest::WMCreateTriggerRequest(const WMCreateTriggerRequest& other1416) {
  trigger = other1416.trigger;
  __isset = other1416.__isset;
}
WMCreateTriggerRequest& WMCreateTriggerRequest::operator=(const WMCreateTriggerRequest& other1417) {
  trigger = other1417.trigger;
  __isset = other1417.__isset;
  return *this;
}
void WMCreateTriggerRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreateTriggerRequest(";
  out << "trigger="; (__isset.trigger ? (out << to_string(trigger)) : (out << "<null>"));
  out << ")";
}


WMCreateTriggerResponse::~WMCreateTriggerResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMCreateTriggerResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreateTriggerResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreateTriggerResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreateTriggerResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreateTriggerResponse &a, WMCreateTriggerResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMCreateTriggerResponse::WMCreateTriggerResponse(const WMCreateTriggerResponse& other1418) noexcept {
  (void) other1418;
}
WMCreateTriggerResponse& WMCreateTriggerResponse::operator=(const WMCreateTriggerResponse& other1419) noexcept {
  (void) other1419;
  return *this;
}
void WMCreateTriggerResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreateTriggerResponse(";
  out << ")";
}


WMAlterTriggerRequest::~WMAlterTriggerRequest() noexcept {
}


void WMAlterTriggerRequest::__set_trigger(const WMTrigger& val) {
  this->trigger = val;
__isset.trigger = true;
}
std::ostream& operator<<(std::ostream& out, const WMAlterTriggerRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMAlterTriggerRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->trigger.read(iprot);
          this->__isset.trigger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMAlterTriggerRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMAlterTriggerRequest");

  if (this->__isset.trigger) {
    xfer += oprot->writeFieldBegin("trigger", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->trigger.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMAlterTriggerRequest &a, WMAlterTriggerRequest &b) {
  using ::std::swap;
  swap(a.trigger, b.trigger);
  swap(a.__isset, b.__isset);
}

WMAlterTriggerRequest::WMAlterTriggerRequest(const WMAlterTriggerRequest& other1420) {
  trigger = other1420.trigger;
  __isset = other1420.__isset;
}
WMAlterTriggerRequest& WMAlterTriggerRequest::operator=(const WMAlterTriggerRequest& other1421) {
  trigger = other1421.trigger;
  __isset = other1421.__isset;
  return *this;
}
void WMAlterTriggerRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMAlterTriggerRequest(";
  out << "trigger="; (__isset.trigger ? (out << to_string(trigger)) : (out << "<null>"));
  out << ")";
}


WMAlterTriggerResponse::~WMAlterTriggerResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMAlterTriggerResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMAlterTriggerResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMAlterTriggerResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMAlterTriggerResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMAlterTriggerResponse &a, WMAlterTriggerResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMAlterTriggerResponse::WMAlterTriggerResponse(const WMAlterTriggerResponse& other1422) noexcept {
  (void) other1422;
}
WMAlterTriggerResponse& WMAlterTriggerResponse::operator=(const WMAlterTriggerResponse& other1423) noexcept {
  (void) other1423;
  return *this;
}
void WMAlterTriggerResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMAlterTriggerResponse(";
  out << ")";
}


WMDropTriggerRequest::~WMDropTriggerRequest() noexcept {
}


void WMDropTriggerRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}

void WMDropTriggerRequest::__set_triggerName(const std::string& val) {
  this->triggerName = val;
__isset.triggerName = true;
}

void WMDropTriggerRequest::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMDropTriggerRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMDropTriggerRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->triggerName);
          this->__isset.triggerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMDropTriggerRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMDropTriggerRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.triggerName) {
    xfer += oprot->writeFieldBegin("triggerName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->triggerName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMDropTriggerRequest &a, WMDropTriggerRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.triggerName, b.triggerName);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMDropTriggerRequest::WMDropTriggerRequest(const WMDropTriggerRequest& other1424) {
  resourcePlanName = other1424.resourcePlanName;
  triggerName = other1424.triggerName;
  ns = other1424.ns;
  __isset = other1424.__isset;
}
WMDropTriggerRequest& WMDropTriggerRequest::operator=(const WMDropTriggerRequest& other1425) {
  resourcePlanName = other1425.resourcePlanName;
  triggerName = other1425.triggerName;
  ns = other1425.ns;
  __isset = other1425.__isset;
  return *this;
}
void WMDropTriggerRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMDropTriggerRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ", " << "triggerName="; (__isset.triggerName ? (out << to_string(triggerName)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMDropTriggerResponse::~WMDropTriggerResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMDropTriggerResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMDropTriggerResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMDropTriggerResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMDropTriggerResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMDropTriggerResponse &a, WMDropTriggerResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMDropTriggerResponse::WMDropTriggerResponse(const WMDropTriggerResponse& other1426) noexcept {
  (void) other1426;
}
WMDropTriggerResponse& WMDropTriggerResponse::operator=(const WMDropTriggerResponse& other1427) noexcept {
  (void) other1427;
  return *this;
}
void WMDropTriggerResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMDropTriggerResponse(";
  out << ")";
}


WMGetTriggersForResourePlanRequest::~WMGetTriggersForResourePlanRequest() noexcept {
}


void WMGetTriggersForResourePlanRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}

void WMGetTriggersForResourePlanRequest::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetTriggersForResourePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetTriggersForResourePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetTriggersForResourePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetTriggersForResourePlanRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetTriggersForResourePlanRequest &a, WMGetTriggersForResourePlanRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMGetTriggersForResourePlanRequest::WMGetTriggersForResourePlanRequest(const WMGetTriggersForResourePlanRequest& other1428) {
  resourcePlanName = other1428.resourcePlanName;
  ns = other1428.ns;
  __isset = other1428.__isset;
}
WMGetTriggersForResourePlanRequest& WMGetTriggersForResourePlanRequest::operator=(const WMGetTriggersForResourePlanRequest& other1429) {
  resourcePlanName = other1429.resourcePlanName;
  ns = other1429.ns;
  __isset = other1429.__isset;
  return *this;
}
void WMGetTriggersForResourePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetTriggersForResourePlanRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMGetTriggersForResourePlanResponse::~WMGetTriggersForResourePlanResponse() noexcept {
}


void WMGetTriggersForResourePlanResponse::__set_triggers(const std::vector<WMTrigger> & val) {
  this->triggers = val;
__isset.triggers = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetTriggersForResourePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetTriggersForResourePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->triggers.clear();
            uint32_t _size1430;
            ::apache::thrift::protocol::TType _etype1433;
            xfer += iprot->readListBegin(_etype1433, _size1430);
            this->triggers.resize(_size1430);
            uint32_t _i1434;
            for (_i1434 = 0; _i1434 < _size1430; ++_i1434)
            {
              xfer += this->triggers[_i1434].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.triggers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetTriggersForResourePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetTriggersForResourePlanResponse");

  if (this->__isset.triggers) {
    xfer += oprot->writeFieldBegin("triggers", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->triggers.size()));
      std::vector<WMTrigger> ::const_iterator _iter1435;
      for (_iter1435 = this->triggers.begin(); _iter1435 != this->triggers.end(); ++_iter1435)
      {
        xfer += (*_iter1435).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetTriggersForResourePlanResponse &a, WMGetTriggersForResourePlanResponse &b) {
  using ::std::swap;
  swap(a.triggers, b.triggers);
  swap(a.__isset, b.__isset);
}

WMGetTriggersForResourePlanResponse::WMGetTriggersForResourePlanResponse(const WMGetTriggersForResourePlanResponse& other1436) {
  triggers = other1436.triggers;
  __isset = other1436.__isset;
}
WMGetTriggersForResourePlanResponse& WMGetTriggersForResourePlanResponse::operator=(const WMGetTriggersForResourePlanResponse& other1437) {
  triggers = other1437.triggers;
  __isset = other1437.__isset;
  return *this;
}
void WMGetTriggersForResourePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetTriggersForResourePlanResponse(";
  out << "triggers="; (__isset.triggers ? (out << to_string(triggers)) : (out << "<null>"));
  out << ")";
}


WMCreatePoolRequest::~WMCreatePoolRequest() noexcept {
}


void WMCreatePoolRequest::__set_pool(const WMPool& val) {
  this->pool = val;
__isset.pool = true;
}
std::ostream& operator<<(std::ostream& out, const WMCreatePoolRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreatePoolRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pool.read(iprot);
          this->__isset.pool = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreatePoolRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreatePoolRequest");

  if (this->__isset.pool) {
    xfer += oprot->writeFieldBegin("pool", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->pool.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreatePoolRequest &a, WMCreatePoolRequest &b) {
  using ::std::swap;
  swap(a.pool, b.pool);
  swap(a.__isset, b.__isset);
}

WMCreatePoolRequest::WMCreatePoolRequest(const WMCreatePoolRequest& other1438) {
  pool = other1438.pool;
  __isset = other1438.__isset;
}
WMCreatePoolRequest& WMCreatePoolRequest::operator=(const WMCreatePoolRequest& other1439) {
  pool = other1439.pool;
  __isset = other1439.__isset;
  return *this;
}
void WMCreatePoolRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreatePoolRequest(";
  out << "pool="; (__isset.pool ? (out << to_string(pool)) : (out << "<null>"));
  out << ")";
}


WMCreatePoolResponse::~WMCreatePoolResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMCreatePoolResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreatePoolResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreatePoolResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreatePoolResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreatePoolResponse &a, WMCreatePoolResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMCreatePoolResponse::WMCreatePoolResponse(const WMCreatePoolResponse& other1440) noexcept {
  (void) other1440;
}
WMCreatePoolResponse& WMCreatePoolResponse::operator=(const WMCreatePoolResponse& other1441) noexcept {
  (void) other1441;
  return *this;
}
void WMCreatePoolResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreatePoolResponse(";
  out << ")";
}


WMAlterPoolRequest::~WMAlterPoolRequest() noexcept {
}


void WMAlterPoolRequest::__set_pool(const WMNullablePool& val) {
  this->pool = val;
__isset.pool = true;
}

void WMAlterPoolRequest::__set_poolPath(const std::string& val) {
  this->poolPath = val;
__isset.poolPath = true;
}
std::ostream& operator<<(std::ostream& out, const WMAlterPoolRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMAlterPoolRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pool.read(iprot);
          this->__isset.pool = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->poolPath);
          this->__isset.poolPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMAlterPoolRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMAlterPoolRequest");

  if (this->__isset.pool) {
    xfer += oprot->writeFieldBegin("pool", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->pool.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.poolPath) {
    xfer += oprot->writeFieldBegin("poolPath", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->poolPath);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMAlterPoolRequest &a, WMAlterPoolRequest &b) {
  using ::std::swap;
  swap(a.pool, b.pool);
  swap(a.poolPath, b.poolPath);
  swap(a.__isset, b.__isset);
}

WMAlterPoolRequest::WMAlterPoolRequest(const WMAlterPoolRequest& other1442) {
  pool = other1442.pool;
  poolPath = other1442.poolPath;
  __isset = other1442.__isset;
}
WMAlterPoolRequest& WMAlterPoolRequest::operator=(const WMAlterPoolRequest& other1443) {
  pool = other1443.pool;
  poolPath = other1443.poolPath;
  __isset = other1443.__isset;
  return *this;
}
void WMAlterPoolRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMAlterPoolRequest(";
  out << "pool="; (__isset.pool ? (out << to_string(pool)) : (out << "<null>"));
  out << ", " << "poolPath="; (__isset.poolPath ? (out << to_string(poolPath)) : (out << "<null>"));
  out << ")";
}


WMAlterPoolResponse::~WMAlterPoolResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMAlterPoolResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMAlterPoolResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMAlterPoolResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMAlterPoolResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMAlterPoolResponse &a, WMAlterPoolResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMAlterPoolResponse::WMAlterPoolResponse(const WMAlterPoolResponse& other1444) noexcept {
  (void) other1444;
}
WMAlterPoolResponse& WMAlterPoolResponse::operator=(const WMAlterPoolResponse& other1445) noexcept {
  (void) other1445;
  return *this;
}
void WMAlterPoolResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMAlterPoolResponse(";
  out << ")";
}


WMDropPoolRequest::~WMDropPoolRequest() noexcept {
}


void WMDropPoolRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}

void WMDropPoolRequest::__set_poolPath(const std::string& val) {
  this->poolPath = val;
__isset.poolPath = true;
}

void WMDropPoolRequest::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMDropPoolRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMDropPoolRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->poolPath);
          this->__isset.poolPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMDropPoolRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMDropPoolRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.poolPath) {
    xfer += oprot->writeFieldBegin("poolPath", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->poolPath);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMDropPoolRequest &a, WMDropPoolRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.poolPath, b.poolPath);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMDropPoolRequest::WMDropPoolRequest(const WMDropPoolRequest& other1446) {
  resourcePlanName = other1446.resourcePlanName;
  poolPath = other1446.poolPath;
  ns = other1446.ns;
  __isset = other1446.__isset;
}
WMDropPoolRequest& WMDropPoolRequest::operator=(const WMDropPoolRequest& other1447) {
  resourcePlanName = other1447.resourcePlanName;
  poolPath = other1447.poolPath;
  ns = other1447.ns;
  __isset = other1447.__isset;
  return *this;
}
void WMDropPoolRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMDropPoolRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ", " << "poolPath="; (__isset.poolPath ? (out << to_string(poolPath)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMDropPoolResponse::~WMDropPoolResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMDropPoolResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMDropPoolResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMDropPoolResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMDropPoolResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMDropPoolResponse &a, WMDropPoolResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMDropPoolResponse::WMDropPoolResponse(const WMDropPoolResponse& other1448) noexcept {
  (void) other1448;
}
WMDropPoolResponse& WMDropPoolResponse::operator=(const WMDropPoolResponse& other1449) noexcept {
  (void) other1449;
  return *this;
}
void WMDropPoolResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMDropPoolResponse(";
  out << ")";
}


WMCreateOrUpdateMappingRequest::~WMCreateOrUpdateMappingRequest() noexcept {
}


void WMCreateOrUpdateMappingRequest::__set_mapping(const WMMapping& val) {
  this->mapping = val;
__isset.mapping = true;
}

void WMCreateOrUpdateMappingRequest::__set_update(const bool val) {
  this->update = val;
__isset.update = true;
}
std::ostream& operator<<(std::ostream& out, const WMCreateOrUpdateMappingRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreateOrUpdateMappingRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mapping.read(iprot);
          this->__isset.mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->update);
          this->__isset.update = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreateOrUpdateMappingRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreateOrUpdateMappingRequest");

  if (this->__isset.mapping) {
    xfer += oprot->writeFieldBegin("mapping", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->mapping.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.update) {
    xfer += oprot->writeFieldBegin("update", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->update);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreateOrUpdateMappingRequest &a, WMCreateOrUpdateMappingRequest &b) {
  using ::std::swap;
  swap(a.mapping, b.mapping);
  swap(a.update, b.update);
  swap(a.__isset, b.__isset);
}

WMCreateOrUpdateMappingRequest::WMCreateOrUpdateMappingRequest(const WMCreateOrUpdateMappingRequest& other1450) {
  mapping = other1450.mapping;
  update = other1450.update;
  __isset = other1450.__isset;
}
WMCreateOrUpdateMappingRequest& WMCreateOrUpdateMappingRequest::operator=(const WMCreateOrUpdateMappingRequest& other1451) {
  mapping = other1451.mapping;
  update = other1451.update;
  __isset = other1451.__isset;
  return *this;
}
void WMCreateOrUpdateMappingRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreateOrUpdateMappingRequest(";
  out << "mapping="; (__isset.mapping ? (out << to_string(mapping)) : (out << "<null>"));
  out << ", " << "update="; (__isset.update ? (out << to_string(update)) : (out << "<null>"));
  out << ")";
}


WMCreateOrUpdateMappingResponse::~WMCreateOrUpdateMappingResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMCreateOrUpdateMappingResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreateOrUpdateMappingResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreateOrUpdateMappingResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreateOrUpdateMappingResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreateOrUpdateMappingResponse &a, WMCreateOrUpdateMappingResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMCreateOrUpdateMappingResponse::WMCreateOrUpdateMappingResponse(const WMCreateOrUpdateMappingResponse& other1452) noexcept {
  (void) other1452;
}
WMCreateOrUpdateMappingResponse& WMCreateOrUpdateMappingResponse::operator=(const WMCreateOrUpdateMappingResponse& other1453) noexcept {
  (void) other1453;
  return *this;
}
void WMCreateOrUpdateMappingResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreateOrUpdateMappingResponse(";
  out << ")";
}


WMDropMappingRequest::~WMDropMappingRequest() noexcept {
}


void WMDropMappingRequest::__set_mapping(const WMMapping& val) {
  this->mapping = val;
__isset.mapping = true;
}
std::ostream& operator<<(std::ostream& out, const WMDropMappingRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMDropMappingRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mapping.read(iprot);
          this->__isset.mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMDropMappingRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMDropMappingRequest");

  if (this->__isset.mapping) {
    xfer += oprot->writeFieldBegin("mapping", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->mapping.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMDropMappingRequest &a, WMDropMappingRequest &b) {
  using ::std::swap;
  swap(a.mapping, b.mapping);
  swap(a.__isset, b.__isset);
}

WMDropMappingRequest::WMDropMappingRequest(const WMDropMappingRequest& other1454) {
  mapping = other1454.mapping;
  __isset = other1454.__isset;
}
WMDropMappingRequest& WMDropMappingRequest::operator=(const WMDropMappingRequest& other1455) {
  mapping = other1455.mapping;
  __isset = other1455.__isset;
  return *this;
}
void WMDropMappingRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMDropMappingRequest(";
  out << "mapping="; (__isset.mapping ? (out << to_string(mapping)) : (out << "<null>"));
  out << ")";
}


WMDropMappingResponse::~WMDropMappingResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMDropMappingResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMDropMappingResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMDropMappingResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMDropMappingResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMDropMappingResponse &a, WMDropMappingResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMDropMappingResponse::WMDropMappingResponse(const WMDropMappingResponse& other1456) noexcept {
  (void) other1456;
}
WMDropMappingResponse& WMDropMappingResponse::operator=(const WMDropMappingResponse& other1457) noexcept {
  (void) other1457;
  return *this;
}
void WMDropMappingResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMDropMappingResponse(";
  out << ")";
}


WMCreateOrDropTriggerToPoolMappingRequest::~WMCreateOrDropTriggerToPoolMappingRequest() noexcept {
}


void WMCreateOrDropTriggerToPoolMappingRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}

void WMCreateOrDropTriggerToPoolMappingRequest::__set_triggerName(const std::string& val) {
  this->triggerName = val;
__isset.triggerName = true;
}

void WMCreateOrDropTriggerToPoolMappingRequest::__set_poolPath(const std::string& val) {
  this->poolPath = val;
__isset.poolPath = true;
}

void WMCreateOrDropTriggerToPoolMappingRequest::__set_drop(const bool val) {
  this->drop = val;
__isset.drop = true;
}

void WMCreateOrDropTriggerToPoolMappingRequest::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMCreateOrDropTriggerToPoolMappingRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreateOrDropTriggerToPoolMappingRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->triggerName);
          this->__isset.triggerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->poolPath);
          this->__isset.poolPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->drop);
          this->__isset.drop = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreateOrDropTriggerToPoolMappingRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreateOrDropTriggerToPoolMappingRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.triggerName) {
    xfer += oprot->writeFieldBegin("triggerName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->triggerName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.poolPath) {
    xfer += oprot->writeFieldBegin("poolPath", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->poolPath);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drop) {
    xfer += oprot->writeFieldBegin("drop", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->drop);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreateOrDropTriggerToPoolMappingRequest &a, WMCreateOrDropTriggerToPoolMappingRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.triggerName, b.triggerName);
  swap(a.poolPath, b.poolPath);
  swap(a.drop, b.drop);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMCreateOrDropTriggerToPoolMappingRequest::WMCreateOrDropTriggerToPoolMappingRequest(const WMCreateOrDropTriggerToPoolMappingRequest& other1458) {
  resourcePlanName = other1458.resourcePlanName;
  triggerName = other1458.triggerName;
  poolPath = other1458.poolPath;
  drop = other1458.drop;
  ns = other1458.ns;
  __isset = other1458.__isset;
}
WMCreateOrDropTriggerToPoolMappingRequest& WMCreateOrDropTriggerToPoolMappingRequest::operator=(const WMCreateOrDropTriggerToPoolMappingRequest& other1459) {
  resourcePlanName = other1459.resourcePlanName;
  triggerName = other1459.triggerName;
  poolPath = other1459.poolPath;
  drop = other1459.drop;
  ns = other1459.ns;
  __isset = other1459.__isset;
  return *this;
}
void WMCreateOrDropTriggerToPoolMappingRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreateOrDropTriggerToPoolMappingRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ", " << "triggerName="; (__isset.triggerName ? (out << to_string(triggerName)) : (out << "<null>"));
  out << ", " << "poolPath="; (__isset.poolPath ? (out << to_string(poolPath)) : (out << "<null>"));
  out << ", " << "drop="; (__isset.drop ? (out << to_string(drop)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMCreateOrDropTriggerToPoolMappingResponse::~WMCreateOrDropTriggerToPoolMappingResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMCreateOrDropTriggerToPoolMappingResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreateOrDropTriggerToPoolMappingResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreateOrDropTriggerToPoolMappingResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreateOrDropTriggerToPoolMappingResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreateOrDropTriggerToPoolMappingResponse &a, WMCreateOrDropTriggerToPoolMappingResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMCreateOrDropTriggerToPoolMappingResponse::WMCreateOrDropTriggerToPoolMappingResponse(const WMCreateOrDropTriggerToPoolMappingResponse& other1460) noexcept {
  (void) other1460;
}
WMCreateOrDropTriggerToPoolMappingResponse& WMCreateOrDropTriggerToPoolMappingResponse::operator=(const WMCreateOrDropTriggerToPoolMappingResponse& other1461) noexcept {
  (void) other1461;
  return *this;
}
void WMCreateOrDropTriggerToPoolMappingResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreateOrDropTriggerToPoolMappingResponse(";
  out << ")";
}


ISchema::~ISchema() noexcept {
}


void ISchema::__set_schemaType(const SchemaType::type val) {
  this->schemaType = val;
}

void ISchema::__set_name(const std::string& val) {
  this->name = val;
}

void ISchema::__set_catName(const std::string& val) {
  this->catName = val;
}

void ISchema::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void ISchema::__set_compatibility(const SchemaCompatibility::type val) {
  this->compatibility = val;
}

void ISchema::__set_validationLevel(const SchemaValidation::type val) {
  this->validationLevel = val;
}

void ISchema::__set_canEvolve(const bool val) {
  this->canEvolve = val;
}

void ISchema::__set_schemaGroup(const std::string& val) {
  this->schemaGroup = val;
__isset.schemaGroup = true;
}

void ISchema::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}
std::ostream& operator<<(std::ostream& out, const ISchema& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ISchema::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1462;
          xfer += iprot->readI32(ecast1462);
          this->schemaType = static_cast<SchemaType::type>(ecast1462);
          this->__isset.schemaType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1463;
          xfer += iprot->readI32(ecast1463);
          this->compatibility = static_cast<SchemaCompatibility::type>(ecast1463);
          this->__isset.compatibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1464;
          xfer += iprot->readI32(ecast1464);
          this->validationLevel = static_cast<SchemaValidation::type>(ecast1464);
          this->__isset.validationLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->canEvolve);
          this->__isset.canEvolve = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaGroup);
          this->__isset.schemaGroup = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ISchema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ISchema");

  xfer += oprot->writeFieldBegin("schemaType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->schemaType));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compatibility", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(static_cast<int32_t>(this->compatibility));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validationLevel", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(static_cast<int32_t>(this->validationLevel));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("canEvolve", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->canEvolve);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.schemaGroup) {
    xfer += oprot->writeFieldBegin("schemaGroup", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->schemaGroup);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ISchema &a, ISchema &b) {
  using ::std::swap;
  swap(a.schemaType, b.schemaType);
  swap(a.name, b.name);
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.compatibility, b.compatibility);
  swap(a.validationLevel, b.validationLevel);
  swap(a.canEvolve, b.canEvolve);
  swap(a.schemaGroup, b.schemaGroup);
  swap(a.description, b.description);
  swap(a.__isset, b.__isset);
}

ISchema::ISchema(const ISchema& other1465) {
  schemaType = other1465.schemaType;
  name = other1465.name;
  catName = other1465.catName;
  dbName = other1465.dbName;
  compatibility = other1465.compatibility;
  validationLevel = other1465.validationLevel;
  canEvolve = other1465.canEvolve;
  schemaGroup = other1465.schemaGroup;
  description = other1465.description;
  __isset = other1465.__isset;
}
ISchema& ISchema::operator=(const ISchema& other1466) {
  schemaType = other1466.schemaType;
  name = other1466.name;
  catName = other1466.catName;
  dbName = other1466.dbName;
  compatibility = other1466.compatibility;
  validationLevel = other1466.validationLevel;
  canEvolve = other1466.canEvolve;
  schemaGroup = other1466.schemaGroup;
  description = other1466.description;
  __isset = other1466.__isset;
  return *this;
}
void ISchema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ISchema(";
  out << "schemaType=" << to_string(schemaType);
  out << ", " << "name=" << to_string(name);
  out << ", " << "catName=" << to_string(catName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "compatibility=" << to_string(compatibility);
  out << ", " << "validationLevel=" << to_string(validationLevel);
  out << ", " << "canEvolve=" << to_string(canEvolve);
  out << ", " << "schemaGroup="; (__isset.schemaGroup ? (out << to_string(schemaGroup)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ")";
}


ISchemaName::~ISchemaName() noexcept {
}


void ISchemaName::__set_catName(const std::string& val) {
  this->catName = val;
}

void ISchemaName::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void ISchemaName::__set_schemaName(const std::string& val) {
  this->schemaName = val;
}
std::ostream& operator<<(std::ostream& out, const ISchemaName& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ISchemaName::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaName);
          this->__isset.schemaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ISchemaName::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ISchemaName");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schemaName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->schemaName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ISchemaName &a, ISchemaName &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.schemaName, b.schemaName);
  swap(a.__isset, b.__isset);
}

ISchemaName::ISchemaName(const ISchemaName& other1467) {
  catName = other1467.catName;
  dbName = other1467.dbName;
  schemaName = other1467.schemaName;
  __isset = other1467.__isset;
}
ISchemaName& ISchemaName::operator=(const ISchemaName& other1468) {
  catName = other1468.catName;
  dbName = other1468.dbName;
  schemaName = other1468.schemaName;
  __isset = other1468.__isset;
  return *this;
}
void ISchemaName::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ISchemaName(";
  out << "catName=" << to_string(catName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "schemaName=" << to_string(schemaName);
  out << ")";
}


AlterISchemaRequest::~AlterISchemaRequest() noexcept {
}


void AlterISchemaRequest::__set_name(const ISchemaName& val) {
  this->name = val;
}

void AlterISchemaRequest::__set_newSchema(const ISchema& val) {
  this->newSchema = val;
}
std::ostream& operator<<(std::ostream& out, const AlterISchemaRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AlterISchemaRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->name.read(iprot);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->newSchema.read(iprot);
          this->__isset.newSchema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlterISchemaRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AlterISchemaRequest");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->name.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newSchema", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->newSchema.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlterISchemaRequest &a, AlterISchemaRequest &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.newSchema, b.newSchema);
  swap(a.__isset, b.__isset);
}

AlterISchemaRequest::AlterISchemaRequest(const AlterISchemaRequest& other1469) {
  name = other1469.name;
  newSchema = other1469.newSchema;
  __isset = other1469.__isset;
}
AlterISchemaRequest& AlterISchemaRequest::operator=(const AlterISchemaRequest& other1470) {
  name = other1470.name;
  newSchema = other1470.newSchema;
  __isset = other1470.__isset;
  return *this;
}
void AlterISchemaRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AlterISchemaRequest(";
  out << "name=" << to_string(name);
  out << ", " << "newSchema=" << to_string(newSchema);
  out << ")";
}


SchemaVersion::~SchemaVersion() noexcept {
}


void SchemaVersion::__set_schema(const ISchemaName& val) {
  this->schema = val;
}

void SchemaVersion::__set_version(const int32_t val) {
  this->version = val;
}

void SchemaVersion::__set_createdAt(const int64_t val) {
  this->createdAt = val;
}

void SchemaVersion::__set_cols(const std::vector<FieldSchema> & val) {
  this->cols = val;
}

void SchemaVersion::__set_state(const SchemaVersionState::type val) {
  this->state = val;
__isset.state = true;
}

void SchemaVersion::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void SchemaVersion::__set_schemaText(const std::string& val) {
  this->schemaText = val;
__isset.schemaText = true;
}

void SchemaVersion::__set_fingerprint(const std::string& val) {
  this->fingerprint = val;
__isset.fingerprint = true;
}

void SchemaVersion::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void SchemaVersion::__set_serDe(const SerDeInfo& val) {
  this->serDe = val;
__isset.serDe = true;
}
std::ostream& operator<<(std::ostream& out, const SchemaVersion& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SchemaVersion::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schema.read(iprot);
          this->__isset.schema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createdAt);
          this->__isset.createdAt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cols.clear();
            uint32_t _size1471;
            ::apache::thrift::protocol::TType _etype1474;
            xfer += iprot->readListBegin(_etype1474, _size1471);
            this->cols.resize(_size1471);
            uint32_t _i1475;
            for (_i1475 = 0; _i1475 < _size1471; ++_i1475)
            {
              xfer += this->cols[_i1475].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1476;
          xfer += iprot->readI32(ecast1476);
          this->state = static_cast<SchemaVersionState::type>(ecast1476);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaText);
          this->__isset.schemaText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fingerprint);
          this->__isset.fingerprint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->serDe.read(iprot);
          this->__isset.serDe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SchemaVersion::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SchemaVersion");

  xfer += oprot->writeFieldBegin("schema", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->schema.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createdAt", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->createdAt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cols", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cols.size()));
    std::vector<FieldSchema> ::const_iterator _iter1477;
    for (_iter1477 = this->cols.begin(); _iter1477 != this->cols.end(); ++_iter1477)
    {
      xfer += (*_iter1477).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(static_cast<int32_t>(this->state));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schemaText) {
    xfer += oprot->writeFieldBegin("schemaText", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->schemaText);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fingerprint) {
    xfer += oprot->writeFieldBegin("fingerprint", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->fingerprint);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.serDe) {
    xfer += oprot->writeFieldBegin("serDe", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->serDe.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SchemaVersion &a, SchemaVersion &b) {
  using ::std::swap;
  swap(a.schema, b.schema);
  swap(a.version, b.version);
  swap(a.createdAt, b.createdAt);
  swap(a.cols, b.cols);
  swap(a.state, b.state);
  swap(a.description, b.description);
  swap(a.schemaText, b.schemaText);
  swap(a.fingerprint, b.fingerprint);
  swap(a.name, b.name);
  swap(a.serDe, b.serDe);
  swap(a.__isset, b.__isset);
}

SchemaVersion::SchemaVersion(const SchemaVersion& other1478) {
  schema = other1478.schema;
  version = other1478.version;
  createdAt = other1478.createdAt;
  cols = other1478.cols;
  state = other1478.state;
  description = other1478.description;
  schemaText = other1478.schemaText;
  fingerprint = other1478.fingerprint;
  name = other1478.name;
  serDe = other1478.serDe;
  __isset = other1478.__isset;
}
SchemaVersion& SchemaVersion::operator=(const SchemaVersion& other1479) {
  schema = other1479.schema;
  version = other1479.version;
  createdAt = other1479.createdAt;
  cols = other1479.cols;
  state = other1479.state;
  description = other1479.description;
  schemaText = other1479.schemaText;
  fingerprint = other1479.fingerprint;
  name = other1479.name;
  serDe = other1479.serDe;
  __isset = other1479.__isset;
  return *this;
}
void SchemaVersion::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SchemaVersion(";
  out << "schema=" << to_string(schema);
  out << ", " << "version=" << to_string(version);
  out << ", " << "createdAt=" << to_string(createdAt);
  out << ", " << "cols=" << to_string(cols);
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "schemaText="; (__isset.schemaText ? (out << to_string(schemaText)) : (out << "<null>"));
  out << ", " << "fingerprint="; (__isset.fingerprint ? (out << to_string(fingerprint)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "serDe="; (__isset.serDe ? (out << to_string(serDe)) : (out << "<null>"));
  out << ")";
}


SchemaVersionDescriptor::~SchemaVersionDescriptor() noexcept {
}


void SchemaVersionDescriptor::__set_schema(const ISchemaName& val) {
  this->schema = val;
}

void SchemaVersionDescriptor::__set_version(const int32_t val) {
  this->version = val;
}
std::ostream& operator<<(std::ostream& out, const SchemaVersionDescriptor& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SchemaVersionDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schema.read(iprot);
          this->__isset.schema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SchemaVersionDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SchemaVersionDescriptor");

  xfer += oprot->writeFieldBegin("schema", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->schema.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SchemaVersionDescriptor &a, SchemaVersionDescriptor &b) {
  using ::std::swap;
  swap(a.schema, b.schema);
  swap(a.version, b.version);
  swap(a.__isset, b.__isset);
}

SchemaVersionDescriptor::SchemaVersionDescriptor(const SchemaVersionDescriptor& other1480) {
  schema = other1480.schema;
  version = other1480.version;
  __isset = other1480.__isset;
}
SchemaVersionDescriptor& SchemaVersionDescriptor::operator=(const SchemaVersionDescriptor& other1481) {
  schema = other1481.schema;
  version = other1481.version;
  __isset = other1481.__isset;
  return *this;
}
void SchemaVersionDescriptor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SchemaVersionDescriptor(";
  out << "schema=" << to_string(schema);
  out << ", " << "version=" << to_string(version);
  out << ")";
}


FindSchemasByColsRqst::~FindSchemasByColsRqst() noexcept {
}


void FindSchemasByColsRqst::__set_colName(const std::string& val) {
  this->colName = val;
__isset.colName = true;
}

void FindSchemasByColsRqst::__set_colNamespace(const std::string& val) {
  this->colNamespace = val;
__isset.colNamespace = true;
}

void FindSchemasByColsRqst::__set_type(const std::string& val) {
  this->type = val;
__isset.type = true;
}
std::ostream& operator<<(std::ostream& out, const FindSchemasByColsRqst& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FindSchemasByColsRqst::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->colName);
          this->__isset.colName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->colNamespace);
          this->__isset.colNamespace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FindSchemasByColsRqst::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FindSchemasByColsRqst");

  if (this->__isset.colName) {
    xfer += oprot->writeFieldBegin("colName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->colName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.colNamespace) {
    xfer += oprot->writeFieldBegin("colNamespace", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->colNamespace);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FindSchemasByColsRqst &a, FindSchemasByColsRqst &b) {
  using ::std::swap;
  swap(a.colName, b.colName);
  swap(a.colNamespace, b.colNamespace);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

FindSchemasByColsRqst::FindSchemasByColsRqst(const FindSchemasByColsRqst& other1482) {
  colName = other1482.colName;
  colNamespace = other1482.colNamespace;
  type = other1482.type;
  __isset = other1482.__isset;
}
FindSchemasByColsRqst& FindSchemasByColsRqst::operator=(const FindSchemasByColsRqst& other1483) {
  colName = other1483.colName;
  colNamespace = other1483.colNamespace;
  type = other1483.type;
  __isset = other1483.__isset;
  return *this;
}
void FindSchemasByColsRqst::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FindSchemasByColsRqst(";
  out << "colName="; (__isset.colName ? (out << to_string(colName)) : (out << "<null>"));
  out << ", " << "colNamespace="; (__isset.colNamespace ? (out << to_string(colNamespace)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ")";
}


FindSchemasByColsResp::~FindSchemasByColsResp() noexcept {
}


void FindSchemasByColsResp::__set_schemaVersions(const std::vector<SchemaVersionDescriptor> & val) {
  this->schemaVersions = val;
}
std::ostream& operator<<(std::ostream& out, const FindSchemasByColsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FindSchemasByColsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->schemaVersions.clear();
            uint32_t _size1484;
            ::apache::thrift::protocol::TType _etype1487;
            xfer += iprot->readListBegin(_etype1487, _size1484);
            this->schemaVersions.resize(_size1484);
            uint32_t _i1488;
            for (_i1488 = 0; _i1488 < _size1484; ++_i1488)
            {
              xfer += this->schemaVersions[_i1488].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.schemaVersions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FindSchemasByColsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FindSchemasByColsResp");

  xfer += oprot->writeFieldBegin("schemaVersions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->schemaVersions.size()));
    std::vector<SchemaVersionDescriptor> ::const_iterator _iter1489;
    for (_iter1489 = this->schemaVersions.begin(); _iter1489 != this->schemaVersions.end(); ++_iter1489)
    {
      xfer += (*_iter1489).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FindSchemasByColsResp &a, FindSchemasByColsResp &b) {
  using ::std::swap;
  swap(a.schemaVersions, b.schemaVersions);
  swap(a.__isset, b.__isset);
}

FindSchemasByColsResp::FindSchemasByColsResp(const FindSchemasByColsResp& other1490) {
  schemaVersions = other1490.schemaVersions;
  __isset = other1490.__isset;
}
FindSchemasByColsResp& FindSchemasByColsResp::operator=(const FindSchemasByColsResp& other1491) {
  schemaVersions = other1491.schemaVersions;
  __isset = other1491.__isset;
  return *this;
}
void FindSchemasByColsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FindSchemasByColsResp(";
  out << "schemaVersions=" << to_string(schemaVersions);
  out << ")";
}


MapSchemaVersionToSerdeRequest::~MapSchemaVersionToSerdeRequest() noexcept {
}


void MapSchemaVersionToSerdeRequest::__set_schemaVersion(const SchemaVersionDescriptor& val) {
  this->schemaVersion = val;
}

void MapSchemaVersionToSerdeRequest::__set_serdeName(const std::string& val) {
  this->serdeName = val;
}
std::ostream& operator<<(std::ostream& out, const MapSchemaVersionToSerdeRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MapSchemaVersionToSerdeRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schemaVersion.read(iprot);
          this->__isset.schemaVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serdeName);
          this->__isset.serdeName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MapSchemaVersionToSerdeRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MapSchemaVersionToSerdeRequest");

  xfer += oprot->writeFieldBegin("schemaVersion", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->schemaVersion.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serdeName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->serdeName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MapSchemaVersionToSerdeRequest &a, MapSchemaVersionToSerdeRequest &b) {
  using ::std::swap;
  swap(a.schemaVersion, b.schemaVersion);
  swap(a.serdeName, b.serdeName);
  swap(a.__isset, b.__isset);
}

MapSchemaVersionToSerdeRequest::MapSchemaVersionToSerdeRequest(const MapSchemaVersionToSerdeRequest& other1492) {
  schemaVersion = other1492.schemaVersion;
  serdeName = other1492.serdeName;
  __isset = other1492.__isset;
}
MapSchemaVersionToSerdeRequest& MapSchemaVersionToSerdeRequest::operator=(const MapSchemaVersionToSerdeRequest& other1493) {
  schemaVersion = other1493.schemaVersion;
  serdeName = other1493.serdeName;
  __isset = other1493.__isset;
  return *this;
}
void MapSchemaVersionToSerdeRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MapSchemaVersionToSerdeRequest(";
  out << "schemaVersion=" << to_string(schemaVersion);
  out << ", " << "serdeName=" << to_string(serdeName);
  out << ")";
}


SetSchemaVersionStateRequest::~SetSchemaVersionStateRequest() noexcept {
}


void SetSchemaVersionStateRequest::__set_schemaVersion(const SchemaVersionDescriptor& val) {
  this->schemaVersion = val;
}

void SetSchemaVersionStateRequest::__set_state(const SchemaVersionState::type val) {
  this->state = val;
}
std::ostream& operator<<(std::ostream& out, const SetSchemaVersionStateRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SetSchemaVersionStateRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schemaVersion.read(iprot);
          this->__isset.schemaVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1494;
          xfer += iprot->readI32(ecast1494);
          this->state = static_cast<SchemaVersionState::type>(ecast1494);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SetSchemaVersionStateRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SetSchemaVersionStateRequest");

  xfer += oprot->writeFieldBegin("schemaVersion", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->schemaVersion.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->state));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SetSchemaVersionStateRequest &a, SetSchemaVersionStateRequest &b) {
  using ::std::swap;
  swap(a.schemaVersion, b.schemaVersion);
  swap(a.state, b.state);
  swap(a.__isset, b.__isset);
}

SetSchemaVersionStateRequest::SetSchemaVersionStateRequest(const SetSchemaVersionStateRequest& other1495) {
  schemaVersion = other1495.schemaVersion;
  state = other1495.state;
  __isset = other1495.__isset;
}
SetSchemaVersionStateRequest& SetSchemaVersionStateRequest::operator=(const SetSchemaVersionStateRequest& other1496) {
  schemaVersion = other1496.schemaVersion;
  state = other1496.state;
  __isset = other1496.__isset;
  return *this;
}
void SetSchemaVersionStateRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SetSchemaVersionStateRequest(";
  out << "schemaVersion=" << to_string(schemaVersion);
  out << ", " << "state=" << to_string(state);
  out << ")";
}


GetSerdeRequest::~GetSerdeRequest() noexcept {
}


void GetSerdeRequest::__set_serdeName(const std::string& val) {
  this->serdeName = val;
}
std::ostream& operator<<(std::ostream& out, const GetSerdeRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetSerdeRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serdeName);
          this->__isset.serdeName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetSerdeRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetSerdeRequest");

  xfer += oprot->writeFieldBegin("serdeName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->serdeName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetSerdeRequest &a, GetSerdeRequest &b) {
  using ::std::swap;
  swap(a.serdeName, b.serdeName);
  swap(a.__isset, b.__isset);
}

GetSerdeRequest::GetSerdeRequest(const GetSerdeRequest& other1497) {
  serdeName = other1497.serdeName;
  __isset = other1497.__isset;
}
GetSerdeRequest& GetSerdeRequest::operator=(const GetSerdeRequest& other1498) {
  serdeName = other1498.serdeName;
  __isset = other1498.__isset;
  return *this;
}
void GetSerdeRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetSerdeRequest(";
  out << "serdeName=" << to_string(serdeName);
  out << ")";
}


RuntimeStat::~RuntimeStat() noexcept {
}


void RuntimeStat::__set_createTime(const int32_t val) {
  this->createTime = val;
__isset.createTime = true;
}

void RuntimeStat::__set_weight(const int32_t val) {
  this->weight = val;
}

void RuntimeStat::__set_payload(const std::string& val) {
  this->payload = val;
}
std::ostream& operator<<(std::ostream& out, const RuntimeStat& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RuntimeStat::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_weight = false;
  bool isset_payload = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->weight);
          isset_weight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->payload);
          isset_payload = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_weight)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_payload)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RuntimeStat::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RuntimeStat");

  if (this->__isset.createTime) {
    xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->createTime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("weight", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->weight);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("payload", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->payload);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RuntimeStat &a, RuntimeStat &b) {
  using ::std::swap;
  swap(a.createTime, b.createTime);
  swap(a.weight, b.weight);
  swap(a.payload, b.payload);
  swap(a.__isset, b.__isset);
}

RuntimeStat::RuntimeStat(const RuntimeStat& other1499) {
  createTime = other1499.createTime;
  weight = other1499.weight;
  payload = other1499.payload;
  __isset = other1499.__isset;
}
RuntimeStat& RuntimeStat::operator=(const RuntimeStat& other1500) {
  createTime = other1500.createTime;
  weight = other1500.weight;
  payload = other1500.payload;
  __isset = other1500.__isset;
  return *this;
}
void RuntimeStat::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RuntimeStat(";
  out << "createTime="; (__isset.createTime ? (out << to_string(createTime)) : (out << "<null>"));
  out << ", " << "weight=" << to_string(weight);
  out << ", " << "payload=" << to_string(payload);
  out << ")";
}


GetRuntimeStatsRequest::~GetRuntimeStatsRequest() noexcept {
}


void GetRuntimeStatsRequest::__set_maxWeight(const int32_t val) {
  this->maxWeight = val;
}

void GetRuntimeStatsRequest::__set_maxCreateTime(const int32_t val) {
  this->maxCreateTime = val;
}
std::ostream& operator<<(std::ostream& out, const GetRuntimeStatsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetRuntimeStatsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_maxWeight = false;
  bool isset_maxCreateTime = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxWeight);
          isset_maxWeight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxCreateTime);
          isset_maxCreateTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_maxWeight)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxCreateTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetRuntimeStatsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetRuntimeStatsRequest");

  xfer += oprot->writeFieldBegin("maxWeight", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->maxWeight);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxCreateTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->maxCreateTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetRuntimeStatsRequest &a, GetRuntimeStatsRequest &b) {
  using ::std::swap;
  swap(a.maxWeight, b.maxWeight);
  swap(a.maxCreateTime, b.maxCreateTime);
}

GetRuntimeStatsRequest::GetRuntimeStatsRequest(const GetRuntimeStatsRequest& other1501) noexcept {
  maxWeight = other1501.maxWeight;
  maxCreateTime = other1501.maxCreateTime;
}
GetRuntimeStatsRequest& GetRuntimeStatsRequest::operator=(const GetRuntimeStatsRequest& other1502) noexcept {
  maxWeight = other1502.maxWeight;
  maxCreateTime = other1502.maxCreateTime;
  return *this;
}
void GetRuntimeStatsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetRuntimeStatsRequest(";
  out << "maxWeight=" << to_string(maxWeight);
  out << ", " << "maxCreateTime=" << to_string(maxCreateTime);
  out << ")";
}


CreateTableRequest::~CreateTableRequest() noexcept {
}


void CreateTableRequest::__set_table(const Table& val) {
  this->table = val;
}

void CreateTableRequest::__set_envContext(const EnvironmentContext& val) {
  this->envContext = val;
__isset.envContext = true;
}

void CreateTableRequest::__set_primaryKeys(const std::vector<SQLPrimaryKey> & val) {
  this->primaryKeys = val;
__isset.primaryKeys = true;
}

void CreateTableRequest::__set_foreignKeys(const std::vector<SQLForeignKey> & val) {
  this->foreignKeys = val;
__isset.foreignKeys = true;
}

void CreateTableRequest::__set_uniqueConstraints(const std::vector<SQLUniqueConstraint> & val) {
  this->uniqueConstraints = val;
__isset.uniqueConstraints = true;
}

void CreateTableRequest::__set_notNullConstraints(const std::vector<SQLNotNullConstraint> & val) {
  this->notNullConstraints = val;
__isset.notNullConstraints = true;
}

void CreateTableRequest::__set_defaultConstraints(const std::vector<SQLDefaultConstraint> & val) {
  this->defaultConstraints = val;
__isset.defaultConstraints = true;
}

void CreateTableRequest::__set_checkConstraints(const std::vector<SQLCheckConstraint> & val) {
  this->checkConstraints = val;
__isset.checkConstraints = true;
}

void CreateTableRequest::__set_processorCapabilities(const std::vector<std::string> & val) {
  this->processorCapabilities = val;
__isset.processorCapabilities = true;
}

void CreateTableRequest::__set_processorIdentifier(const std::string& val) {
  this->processorIdentifier = val;
__isset.processorIdentifier = true;
}
std::ostream& operator<<(std::ostream& out, const CreateTableRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateTableRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table.read(iprot);
          isset_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->envContext.read(iprot);
          this->__isset.envContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->primaryKeys.clear();
            uint32_t _size1503;
            ::apache::thrift::protocol::TType _etype1506;
            xfer += iprot->readListBegin(_etype1506, _size1503);
            this->primaryKeys.resize(_size1503);
            uint32_t _i1507;
            for (_i1507 = 0; _i1507 < _size1503; ++_i1507)
            {
              xfer += this->primaryKeys[_i1507].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.primaryKeys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->foreignKeys.clear();
            uint32_t _size1508;
            ::apache::thrift::protocol::TType _etype1511;
            xfer += iprot->readListBegin(_etype1511, _size1508);
            this->foreignKeys.resize(_size1508);
            uint32_t _i1512;
            for (_i1512 = 0; _i1512 < _size1508; ++_i1512)
            {
              xfer += this->foreignKeys[_i1512].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.foreignKeys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->uniqueConstraints.clear();
            uint32_t _size1513;
            ::apache::thrift::protocol::TType _etype1516;
            xfer += iprot->readListBegin(_etype1516, _size1513);
            this->uniqueConstraints.resize(_size1513);
            uint32_t _i1517;
            for (_i1517 = 0; _i1517 < _size1513; ++_i1517)
            {
              xfer += this->uniqueConstraints[_i1517].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.uniqueConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->notNullConstraints.clear();
            uint32_t _size1518;
            ::apache::thrift::protocol::TType _etype1521;
            xfer += iprot->readListBegin(_etype1521, _size1518);
            this->notNullConstraints.resize(_size1518);
            uint32_t _i1522;
            for (_i1522 = 0; _i1522 < _size1518; ++_i1522)
            {
              xfer += this->notNullConstraints[_i1522].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.notNullConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->defaultConstraints.clear();
            uint32_t _size1523;
            ::apache::thrift::protocol::TType _etype1526;
            xfer += iprot->readListBegin(_etype1526, _size1523);
            this->defaultConstraints.resize(_size1523);
            uint32_t _i1527;
            for (_i1527 = 0; _i1527 < _size1523; ++_i1527)
            {
              xfer += this->defaultConstraints[_i1527].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.defaultConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->checkConstraints.clear();
            uint32_t _size1528;
            ::apache::thrift::protocol::TType _etype1531;
            xfer += iprot->readListBegin(_etype1531, _size1528);
            this->checkConstraints.resize(_size1528);
            uint32_t _i1532;
            for (_i1532 = 0; _i1532 < _size1528; ++_i1532)
            {
              xfer += this->checkConstraints[_i1532].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.checkConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->processorCapabilities.clear();
            uint32_t _size1533;
            ::apache::thrift::protocol::TType _etype1536;
            xfer += iprot->readListBegin(_etype1536, _size1533);
            this->processorCapabilities.resize(_size1533);
            uint32_t _i1537;
            for (_i1537 = 0; _i1537 < _size1533; ++_i1537)
            {
              xfer += iprot->readString(this->processorCapabilities[_i1537]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.processorCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->processorIdentifier);
          this->__isset.processorIdentifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CreateTableRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateTableRequest");

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.envContext) {
    xfer += oprot->writeFieldBegin("envContext", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->envContext.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.primaryKeys) {
    xfer += oprot->writeFieldBegin("primaryKeys", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->primaryKeys.size()));
      std::vector<SQLPrimaryKey> ::const_iterator _iter1538;
      for (_iter1538 = this->primaryKeys.begin(); _iter1538 != this->primaryKeys.end(); ++_iter1538)
      {
        xfer += (*_iter1538).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.foreignKeys) {
    xfer += oprot->writeFieldBegin("foreignKeys", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->foreignKeys.size()));
      std::vector<SQLForeignKey> ::const_iterator _iter1539;
      for (_iter1539 = this->foreignKeys.begin(); _iter1539 != this->foreignKeys.end(); ++_iter1539)
      {
        xfer += (*_iter1539).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.uniqueConstraints) {
    xfer += oprot->writeFieldBegin("uniqueConstraints", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->uniqueConstraints.size()));
      std::vector<SQLUniqueConstraint> ::const_iterator _iter1540;
      for (_iter1540 = this->uniqueConstraints.begin(); _iter1540 != this->uniqueConstraints.end(); ++_iter1540)
      {
        xfer += (*_iter1540).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.notNullConstraints) {
    xfer += oprot->writeFieldBegin("notNullConstraints", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->notNullConstraints.size()));
      std::vector<SQLNotNullConstraint> ::const_iterator _iter1541;
      for (_iter1541 = this->notNullConstraints.begin(); _iter1541 != this->notNullConstraints.end(); ++_iter1541)
      {
        xfer += (*_iter1541).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.defaultConstraints) {
    xfer += oprot->writeFieldBegin("defaultConstraints", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->defaultConstraints.size()));
      std::vector<SQLDefaultConstraint> ::const_iterator _iter1542;
      for (_iter1542 = this->defaultConstraints.begin(); _iter1542 != this->defaultConstraints.end(); ++_iter1542)
      {
        xfer += (*_iter1542).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.checkConstraints) {
    xfer += oprot->writeFieldBegin("checkConstraints", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->checkConstraints.size()));
      std::vector<SQLCheckConstraint> ::const_iterator _iter1543;
      for (_iter1543 = this->checkConstraints.begin(); _iter1543 != this->checkConstraints.end(); ++_iter1543)
      {
        xfer += (*_iter1543).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorCapabilities) {
    xfer += oprot->writeFieldBegin("processorCapabilities", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->processorCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter1544;
      for (_iter1544 = this->processorCapabilities.begin(); _iter1544 != this->processorCapabilities.end(); ++_iter1544)
      {
        xfer += oprot->writeString((*_iter1544));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorIdentifier) {
    xfer += oprot->writeFieldBegin("processorIdentifier", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->processorIdentifier);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateTableRequest &a, CreateTableRequest &b) {
  using ::std::swap;
  swap(a.table, b.table);
  swap(a.envContext, b.envContext);
  swap(a.primaryKeys, b.primaryKeys);
  swap(a.foreignKeys, b.foreignKeys);
  swap(a.uniqueConstraints, b.uniqueConstraints);
  swap(a.notNullConstraints, b.notNullConstraints);
  swap(a.defaultConstraints, b.defaultConstraints);
  swap(a.checkConstraints, b.checkConstraints);
  swap(a.processorCapabilities, b.processorCapabilities);
  swap(a.processorIdentifier, b.processorIdentifier);
  swap(a.__isset, b.__isset);
}

CreateTableRequest::CreateTableRequest(const CreateTableRequest& other1545) {
  table = other1545.table;
  envContext = other1545.envContext;
  primaryKeys = other1545.primaryKeys;
  foreignKeys = other1545.foreignKeys;
  uniqueConstraints = other1545.uniqueConstraints;
  notNullConstraints = other1545.notNullConstraints;
  defaultConstraints = other1545.defaultConstraints;
  checkConstraints = other1545.checkConstraints;
  processorCapabilities = other1545.processorCapabilities;
  processorIdentifier = other1545.processorIdentifier;
  __isset = other1545.__isset;
}
CreateTableRequest& CreateTableRequest::operator=(const CreateTableRequest& other1546) {
  table = other1546.table;
  envContext = other1546.envContext;
  primaryKeys = other1546.primaryKeys;
  foreignKeys = other1546.foreignKeys;
  uniqueConstraints = other1546.uniqueConstraints;
  notNullConstraints = other1546.notNullConstraints;
  defaultConstraints = other1546.defaultConstraints;
  checkConstraints = other1546.checkConstraints;
  processorCapabilities = other1546.processorCapabilities;
  processorIdentifier = other1546.processorIdentifier;
  __isset = other1546.__isset;
  return *this;
}
void CreateTableRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateTableRequest(";
  out << "table=" << to_string(table);
  out << ", " << "envContext="; (__isset.envContext ? (out << to_string(envContext)) : (out << "<null>"));
  out << ", " << "primaryKeys="; (__isset.primaryKeys ? (out << to_string(primaryKeys)) : (out << "<null>"));
  out << ", " << "foreignKeys="; (__isset.foreignKeys ? (out << to_string(foreignKeys)) : (out << "<null>"));
  out << ", " << "uniqueConstraints="; (__isset.uniqueConstraints ? (out << to_string(uniqueConstraints)) : (out << "<null>"));
  out << ", " << "notNullConstraints="; (__isset.notNullConstraints ? (out << to_string(notNullConstraints)) : (out << "<null>"));
  out << ", " << "defaultConstraints="; (__isset.defaultConstraints ? (out << to_string(defaultConstraints)) : (out << "<null>"));
  out << ", " << "checkConstraints="; (__isset.checkConstraints ? (out << to_string(checkConstraints)) : (out << "<null>"));
  out << ", " << "processorCapabilities="; (__isset.processorCapabilities ? (out << to_string(processorCapabilities)) : (out << "<null>"));
  out << ", " << "processorIdentifier="; (__isset.processorIdentifier ? (out << to_string(processorIdentifier)) : (out << "<null>"));
  out << ")";
}


CreateDatabaseRequest::~CreateDatabaseRequest() noexcept {
}


void CreateDatabaseRequest::__set_databaseName(const std::string& val) {
  this->databaseName = val;
}

void CreateDatabaseRequest::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void CreateDatabaseRequest::__set_locationUri(const std::string& val) {
  this->locationUri = val;
__isset.locationUri = true;
}

void CreateDatabaseRequest::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
__isset.parameters = true;
}

void CreateDatabaseRequest::__set_privileges(const PrincipalPrivilegeSet& val) {
  this->privileges = val;
__isset.privileges = true;
}

void CreateDatabaseRequest::__set_ownerName(const std::string& val) {
  this->ownerName = val;
__isset.ownerName = true;
}

void CreateDatabaseRequest::__set_ownerType(const PrincipalType::type val) {
  this->ownerType = val;
__isset.ownerType = true;
}

void CreateDatabaseRequest::__set_catalogName(const std::string& val) {
  this->catalogName = val;
__isset.catalogName = true;
}

void CreateDatabaseRequest::__set_createTime(const int32_t val) {
  this->createTime = val;
__isset.createTime = true;
}

void CreateDatabaseRequest::__set_managedLocationUri(const std::string& val) {
  this->managedLocationUri = val;
__isset.managedLocationUri = true;
}

void CreateDatabaseRequest::__set_type(const std::string& val) {
  this->type = val;
__isset.type = true;
}

void CreateDatabaseRequest::__set_dataConnectorName(const std::string& val) {
  this->dataConnectorName = val;
__isset.dataConnectorName = true;
}
std::ostream& operator<<(std::ostream& out, const CreateDatabaseRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateDatabaseRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_databaseName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->databaseName);
          isset_databaseName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->locationUri);
          this->__isset.locationUri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size1547;
            ::apache::thrift::protocol::TType _ktype1548;
            ::apache::thrift::protocol::TType _vtype1549;
            xfer += iprot->readMapBegin(_ktype1548, _vtype1549, _size1547);
            uint32_t _i1551;
            for (_i1551 = 0; _i1551 < _size1547; ++_i1551)
            {
              std::string _key1552;
              xfer += iprot->readString(_key1552);
              std::string& _val1553 = this->parameters[_key1552];
              xfer += iprot->readString(_val1553);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1554;
          xfer += iprot->readI32(ecast1554);
          this->ownerType = static_cast<PrincipalType::type>(ecast1554);
          this->__isset.ownerType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogName);
          this->__isset.catalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->managedLocationUri);
          this->__isset.managedLocationUri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataConnectorName);
          this->__isset.dataConnectorName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_databaseName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CreateDatabaseRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateDatabaseRequest");

  xfer += oprot->writeFieldBegin("databaseName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->databaseName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.locationUri) {
    xfer += oprot->writeFieldBegin("locationUri", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->locationUri);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parameters) {
    xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
      std::map<std::string, std::string> ::const_iterator _iter1555;
      for (_iter1555 = this->parameters.begin(); _iter1555 != this->parameters.end(); ++_iter1555)
      {
        xfer += oprot->writeString(_iter1555->first);
        xfer += oprot->writeString(_iter1555->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.privileges) {
    xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->privileges.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ownerName) {
    xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->ownerName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ownerType) {
    xfer += oprot->writeFieldBegin("ownerType", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(static_cast<int32_t>(this->ownerType));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalogName) {
    xfer += oprot->writeFieldBegin("catalogName", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->catalogName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTime) {
    xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->createTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.managedLocationUri) {
    xfer += oprot->writeFieldBegin("managedLocationUri", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->managedLocationUri);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dataConnectorName) {
    xfer += oprot->writeFieldBegin("dataConnectorName", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->dataConnectorName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateDatabaseRequest &a, CreateDatabaseRequest &b) {
  using ::std::swap;
  swap(a.databaseName, b.databaseName);
  swap(a.description, b.description);
  swap(a.locationUri, b.locationUri);
  swap(a.parameters, b.parameters);
  swap(a.privileges, b.privileges);
  swap(a.ownerName, b.ownerName);
  swap(a.ownerType, b.ownerType);
  swap(a.catalogName, b.catalogName);
  swap(a.createTime, b.createTime);
  swap(a.managedLocationUri, b.managedLocationUri);
  swap(a.type, b.type);
  swap(a.dataConnectorName, b.dataConnectorName);
  swap(a.__isset, b.__isset);
}

CreateDatabaseRequest::CreateDatabaseRequest(const CreateDatabaseRequest& other1556) {
  databaseName = other1556.databaseName;
  description = other1556.description;
  locationUri = other1556.locationUri;
  parameters = other1556.parameters;
  privileges = other1556.privileges;
  ownerName = other1556.ownerName;
  ownerType = other1556.ownerType;
  catalogName = other1556.catalogName;
  createTime = other1556.createTime;
  managedLocationUri = other1556.managedLocationUri;
  type = other1556.type;
  dataConnectorName = other1556.dataConnectorName;
  __isset = other1556.__isset;
}
CreateDatabaseRequest& CreateDatabaseRequest::operator=(const CreateDatabaseRequest& other1557) {
  databaseName = other1557.databaseName;
  description = other1557.description;
  locationUri = other1557.locationUri;
  parameters = other1557.parameters;
  privileges = other1557.privileges;
  ownerName = other1557.ownerName;
  ownerType = other1557.ownerType;
  catalogName = other1557.catalogName;
  createTime = other1557.createTime;
  managedLocationUri = other1557.managedLocationUri;
  type = other1557.type;
  dataConnectorName = other1557.dataConnectorName;
  __isset = other1557.__isset;
  return *this;
}
void CreateDatabaseRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateDatabaseRequest(";
  out << "databaseName=" << to_string(databaseName);
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "locationUri="; (__isset.locationUri ? (out << to_string(locationUri)) : (out << "<null>"));
  out << ", " << "parameters="; (__isset.parameters ? (out << to_string(parameters)) : (out << "<null>"));
  out << ", " << "privileges="; (__isset.privileges ? (out << to_string(privileges)) : (out << "<null>"));
  out << ", " << "ownerName="; (__isset.ownerName ? (out << to_string(ownerName)) : (out << "<null>"));
  out << ", " << "ownerType="; (__isset.ownerType ? (out << to_string(ownerType)) : (out << "<null>"));
  out << ", " << "catalogName="; (__isset.catalogName ? (out << to_string(catalogName)) : (out << "<null>"));
  out << ", " << "createTime="; (__isset.createTime ? (out << to_string(createTime)) : (out << "<null>"));
  out << ", " << "managedLocationUri="; (__isset.managedLocationUri ? (out << to_string(managedLocationUri)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "dataConnectorName="; (__isset.dataConnectorName ? (out << to_string(dataConnectorName)) : (out << "<null>"));
  out << ")";
}


CreateDataConnectorRequest::~CreateDataConnectorRequest() noexcept {
}


void CreateDataConnectorRequest::__set_connector(const DataConnector& val) {
  this->connector = val;
}
std::ostream& operator<<(std::ostream& out, const CreateDataConnectorRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateDataConnectorRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->connector.read(iprot);
          this->__isset.connector = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateDataConnectorRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateDataConnectorRequest");

  xfer += oprot->writeFieldBegin("connector", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->connector.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateDataConnectorRequest &a, CreateDataConnectorRequest &b) {
  using ::std::swap;
  swap(a.connector, b.connector);
  swap(a.__isset, b.__isset);
}

CreateDataConnectorRequest::CreateDataConnectorRequest(const CreateDataConnectorRequest& other1558) {
  connector = other1558.connector;
  __isset = other1558.__isset;
}
CreateDataConnectorRequest& CreateDataConnectorRequest::operator=(const CreateDataConnectorRequest& other1559) {
  connector = other1559.connector;
  __isset = other1559.__isset;
  return *this;
}
void CreateDataConnectorRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateDataConnectorRequest(";
  out << "connector=" << to_string(connector);
  out << ")";
}


GetDataConnectorRequest::~GetDataConnectorRequest() noexcept {
}


void GetDataConnectorRequest::__set_connectorName(const std::string& val) {
  this->connectorName = val;
}
std::ostream& operator<<(std::ostream& out, const GetDataConnectorRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetDataConnectorRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_connectorName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->connectorName);
          isset_connectorName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_connectorName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetDataConnectorRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetDataConnectorRequest");

  xfer += oprot->writeFieldBegin("connectorName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->connectorName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetDataConnectorRequest &a, GetDataConnectorRequest &b) {
  using ::std::swap;
  swap(a.connectorName, b.connectorName);
}

GetDataConnectorRequest::GetDataConnectorRequest(const GetDataConnectorRequest& other1560) {
  connectorName = other1560.connectorName;
}
GetDataConnectorRequest& GetDataConnectorRequest::operator=(const GetDataConnectorRequest& other1561) {
  connectorName = other1561.connectorName;
  return *this;
}
void GetDataConnectorRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetDataConnectorRequest(";
  out << "connectorName=" << to_string(connectorName);
  out << ")";
}


ScheduledQueryPollRequest::~ScheduledQueryPollRequest() noexcept {
}


void ScheduledQueryPollRequest::__set_clusterNamespace(const std::string& val) {
  this->clusterNamespace = val;
}
std::ostream& operator<<(std::ostream& out, const ScheduledQueryPollRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScheduledQueryPollRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_clusterNamespace = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clusterNamespace);
          isset_clusterNamespace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_clusterNamespace)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ScheduledQueryPollRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScheduledQueryPollRequest");

  xfer += oprot->writeFieldBegin("clusterNamespace", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->clusterNamespace);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScheduledQueryPollRequest &a, ScheduledQueryPollRequest &b) {
  using ::std::swap;
  swap(a.clusterNamespace, b.clusterNamespace);
}

ScheduledQueryPollRequest::ScheduledQueryPollRequest(const ScheduledQueryPollRequest& other1562) {
  clusterNamespace = other1562.clusterNamespace;
}
ScheduledQueryPollRequest& ScheduledQueryPollRequest::operator=(const ScheduledQueryPollRequest& other1563) {
  clusterNamespace = other1563.clusterNamespace;
  return *this;
}
void ScheduledQueryPollRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScheduledQueryPollRequest(";
  out << "clusterNamespace=" << to_string(clusterNamespace);
  out << ")";
}


ScheduledQueryKey::~ScheduledQueryKey() noexcept {
}


void ScheduledQueryKey::__set_scheduleName(const std::string& val) {
  this->scheduleName = val;
}

void ScheduledQueryKey::__set_clusterNamespace(const std::string& val) {
  this->clusterNamespace = val;
}
std::ostream& operator<<(std::ostream& out, const ScheduledQueryKey& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScheduledQueryKey::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_scheduleName = false;
  bool isset_clusterNamespace = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->scheduleName);
          isset_scheduleName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clusterNamespace);
          isset_clusterNamespace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_scheduleName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_clusterNamespace)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ScheduledQueryKey::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScheduledQueryKey");

  xfer += oprot->writeFieldBegin("scheduleName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->scheduleName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("clusterNamespace", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->clusterNamespace);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScheduledQueryKey &a, ScheduledQueryKey &b) {
  using ::std::swap;
  swap(a.scheduleName, b.scheduleName);
  swap(a.clusterNamespace, b.clusterNamespace);
}

ScheduledQueryKey::ScheduledQueryKey(const ScheduledQueryKey& other1564) {
  scheduleName = other1564.scheduleName;
  clusterNamespace = other1564.clusterNamespace;
}
ScheduledQueryKey& ScheduledQueryKey::operator=(const ScheduledQueryKey& other1565) {
  scheduleName = other1565.scheduleName;
  clusterNamespace = other1565.clusterNamespace;
  return *this;
}
void ScheduledQueryKey::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScheduledQueryKey(";
  out << "scheduleName=" << to_string(scheduleName);
  out << ", " << "clusterNamespace=" << to_string(clusterNamespace);
  out << ")";
}


ScheduledQueryPollResponse::~ScheduledQueryPollResponse() noexcept {
}


void ScheduledQueryPollResponse::__set_scheduleKey(const ScheduledQueryKey& val) {
  this->scheduleKey = val;
__isset.scheduleKey = true;
}

void ScheduledQueryPollResponse::__set_executionId(const int64_t val) {
  this->executionId = val;
__isset.executionId = true;
}

void ScheduledQueryPollResponse::__set_query(const std::string& val) {
  this->query = val;
__isset.query = true;
}

void ScheduledQueryPollResponse::__set_user(const std::string& val) {
  this->user = val;
__isset.user = true;
}
std::ostream& operator<<(std::ostream& out, const ScheduledQueryPollResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScheduledQueryPollResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scheduleKey.read(iprot);
          this->__isset.scheduleKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->executionId);
          this->__isset.executionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->query);
          this->__isset.query = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ScheduledQueryPollResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScheduledQueryPollResponse");

  if (this->__isset.scheduleKey) {
    xfer += oprot->writeFieldBegin("scheduleKey", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->scheduleKey.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.executionId) {
    xfer += oprot->writeFieldBegin("executionId", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->executionId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.query) {
    xfer += oprot->writeFieldBegin("query", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->query);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.user) {
    xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->user);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScheduledQueryPollResponse &a, ScheduledQueryPollResponse &b) {
  using ::std::swap;
  swap(a.scheduleKey, b.scheduleKey);
  swap(a.executionId, b.executionId);
  swap(a.query, b.query);
  swap(a.user, b.user);
  swap(a.__isset, b.__isset);
}

ScheduledQueryPollResponse::ScheduledQueryPollResponse(const ScheduledQueryPollResponse& other1566) {
  scheduleKey = other1566.scheduleKey;
  executionId = other1566.executionId;
  query = other1566.query;
  user = other1566.user;
  __isset = other1566.__isset;
}
ScheduledQueryPollResponse& ScheduledQueryPollResponse::operator=(const ScheduledQueryPollResponse& other1567) {
  scheduleKey = other1567.scheduleKey;
  executionId = other1567.executionId;
  query = other1567.query;
  user = other1567.user;
  __isset = other1567.__isset;
  return *this;
}
void ScheduledQueryPollResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScheduledQueryPollResponse(";
  out << "scheduleKey="; (__isset.scheduleKey ? (out << to_string(scheduleKey)) : (out << "<null>"));
  out << ", " << "executionId="; (__isset.executionId ? (out << to_string(executionId)) : (out << "<null>"));
  out << ", " << "query="; (__isset.query ? (out << to_string(query)) : (out << "<null>"));
  out << ", " << "user="; (__isset.user ? (out << to_string(user)) : (out << "<null>"));
  out << ")";
}


ScheduledQuery::~ScheduledQuery() noexcept {
}


void ScheduledQuery::__set_scheduleKey(const ScheduledQueryKey& val) {
  this->scheduleKey = val;
}

void ScheduledQuery::__set_enabled(const bool val) {
  this->enabled = val;
__isset.enabled = true;
}

void ScheduledQuery::__set_schedule(const std::string& val) {
  this->schedule = val;
__isset.schedule = true;
}

void ScheduledQuery::__set_user(const std::string& val) {
  this->user = val;
__isset.user = true;
}

void ScheduledQuery::__set_query(const std::string& val) {
  this->query = val;
__isset.query = true;
}

void ScheduledQuery::__set_nextExecution(const int32_t val) {
  this->nextExecution = val;
__isset.nextExecution = true;
}
std::ostream& operator<<(std::ostream& out, const ScheduledQuery& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScheduledQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_scheduleKey = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scheduleKey.read(iprot);
          isset_scheduleKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enabled);
          this->__isset.enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schedule);
          this->__isset.schedule = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->query);
          this->__isset.query = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nextExecution);
          this->__isset.nextExecution = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_scheduleKey)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ScheduledQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScheduledQuery");

  xfer += oprot->writeFieldBegin("scheduleKey", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->scheduleKey.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.enabled) {
    xfer += oprot->writeFieldBegin("enabled", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->enabled);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schedule) {
    xfer += oprot->writeFieldBegin("schedule", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->schedule);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.user) {
    xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->user);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.query) {
    xfer += oprot->writeFieldBegin("query", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->query);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nextExecution) {
    xfer += oprot->writeFieldBegin("nextExecution", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->nextExecution);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScheduledQuery &a, ScheduledQuery &b) {
  using ::std::swap;
  swap(a.scheduleKey, b.scheduleKey);
  swap(a.enabled, b.enabled);
  swap(a.schedule, b.schedule);
  swap(a.user, b.user);
  swap(a.query, b.query);
  swap(a.nextExecution, b.nextExecution);
  swap(a.__isset, b.__isset);
}

ScheduledQuery::ScheduledQuery(const ScheduledQuery& other1568) {
  scheduleKey = other1568.scheduleKey;
  enabled = other1568.enabled;
  schedule = other1568.schedule;
  user = other1568.user;
  query = other1568.query;
  nextExecution = other1568.nextExecution;
  __isset = other1568.__isset;
}
ScheduledQuery& ScheduledQuery::operator=(const ScheduledQuery& other1569) {
  scheduleKey = other1569.scheduleKey;
  enabled = other1569.enabled;
  schedule = other1569.schedule;
  user = other1569.user;
  query = other1569.query;
  nextExecution = other1569.nextExecution;
  __isset = other1569.__isset;
  return *this;
}
void ScheduledQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScheduledQuery(";
  out << "scheduleKey=" << to_string(scheduleKey);
  out << ", " << "enabled="; (__isset.enabled ? (out << to_string(enabled)) : (out << "<null>"));
  out << ", " << "schedule="; (__isset.schedule ? (out << to_string(schedule)) : (out << "<null>"));
  out << ", " << "user="; (__isset.user ? (out << to_string(user)) : (out << "<null>"));
  out << ", " << "query="; (__isset.query ? (out << to_string(query)) : (out << "<null>"));
  out << ", " << "nextExecution="; (__isset.nextExecution ? (out << to_string(nextExecution)) : (out << "<null>"));
  out << ")";
}


ScheduledQueryMaintenanceRequest::~ScheduledQueryMaintenanceRequest() noexcept {
}


void ScheduledQueryMaintenanceRequest::__set_type(const ScheduledQueryMaintenanceRequestType::type val) {
  this->type = val;
}

void ScheduledQueryMaintenanceRequest::__set_scheduledQuery(const ScheduledQuery& val) {
  this->scheduledQuery = val;
}
std::ostream& operator<<(std::ostream& out, const ScheduledQueryMaintenanceRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScheduledQueryMaintenanceRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;
  bool isset_scheduledQuery = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1570;
          xfer += iprot->readI32(ecast1570);
          this->type = static_cast<ScheduledQueryMaintenanceRequestType::type>(ecast1570);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scheduledQuery.read(iprot);
          isset_scheduledQuery = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_scheduledQuery)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ScheduledQueryMaintenanceRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScheduledQueryMaintenanceRequest");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scheduledQuery", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->scheduledQuery.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScheduledQueryMaintenanceRequest &a, ScheduledQueryMaintenanceRequest &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.scheduledQuery, b.scheduledQuery);
}

ScheduledQueryMaintenanceRequest::ScheduledQueryMaintenanceRequest(const ScheduledQueryMaintenanceRequest& other1571) {
  type = other1571.type;
  scheduledQuery = other1571.scheduledQuery;
}
ScheduledQueryMaintenanceRequest& ScheduledQueryMaintenanceRequest::operator=(const ScheduledQueryMaintenanceRequest& other1572) {
  type = other1572.type;
  scheduledQuery = other1572.scheduledQuery;
  return *this;
}
void ScheduledQueryMaintenanceRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScheduledQueryMaintenanceRequest(";
  out << "type=" << to_string(type);
  out << ", " << "scheduledQuery=" << to_string(scheduledQuery);
  out << ")";
}


ScheduledQueryProgressInfo::~ScheduledQueryProgressInfo() noexcept {
}


void ScheduledQueryProgressInfo::__set_scheduledExecutionId(const int64_t val) {
  this->scheduledExecutionId = val;
}

void ScheduledQueryProgressInfo::__set_state(const QueryState::type val) {
  this->state = val;
}

void ScheduledQueryProgressInfo::__set_executorQueryId(const std::string& val) {
  this->executorQueryId = val;
}

void ScheduledQueryProgressInfo::__set_errorMessage(const std::string& val) {
  this->errorMessage = val;
__isset.errorMessage = true;
}
std::ostream& operator<<(std::ostream& out, const ScheduledQueryProgressInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScheduledQueryProgressInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_scheduledExecutionId = false;
  bool isset_state = false;
  bool isset_executorQueryId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->scheduledExecutionId);
          isset_scheduledExecutionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1573;
          xfer += iprot->readI32(ecast1573);
          this->state = static_cast<QueryState::type>(ecast1573);
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->executorQueryId);
          isset_executorQueryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errorMessage);
          this->__isset.errorMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_scheduledExecutionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_executorQueryId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ScheduledQueryProgressInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScheduledQueryProgressInfo");

  xfer += oprot->writeFieldBegin("scheduledExecutionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->scheduledExecutionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->state));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("executorQueryId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->executorQueryId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.errorMessage) {
    xfer += oprot->writeFieldBegin("errorMessage", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->errorMessage);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScheduledQueryProgressInfo &a, ScheduledQueryProgressInfo &b) {
  using ::std::swap;
  swap(a.scheduledExecutionId, b.scheduledExecutionId);
  swap(a.state, b.state);
  swap(a.executorQueryId, b.executorQueryId);
  swap(a.errorMessage, b.errorMessage);
  swap(a.__isset, b.__isset);
}

ScheduledQueryProgressInfo::ScheduledQueryProgressInfo(const ScheduledQueryProgressInfo& other1574) {
  scheduledExecutionId = other1574.scheduledExecutionId;
  state = other1574.state;
  executorQueryId = other1574.executorQueryId;
  errorMessage = other1574.errorMessage;
  __isset = other1574.__isset;
}
ScheduledQueryProgressInfo& ScheduledQueryProgressInfo::operator=(const ScheduledQueryProgressInfo& other1575) {
  scheduledExecutionId = other1575.scheduledExecutionId;
  state = other1575.state;
  executorQueryId = other1575.executorQueryId;
  errorMessage = other1575.errorMessage;
  __isset = other1575.__isset;
  return *this;
}
void ScheduledQueryProgressInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScheduledQueryProgressInfo(";
  out << "scheduledExecutionId=" << to_string(scheduledExecutionId);
  out << ", " << "state=" << to_string(state);
  out << ", " << "executorQueryId=" << to_string(executorQueryId);
  out << ", " << "errorMessage="; (__isset.errorMessage ? (out << to_string(errorMessage)) : (out << "<null>"));
  out << ")";
}


AlterPartitionsRequest::~AlterPartitionsRequest() noexcept {
}


void AlterPartitionsRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void AlterPartitionsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void AlterPartitionsRequest::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void AlterPartitionsRequest::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
}

void AlterPartitionsRequest::__set_environmentContext(const EnvironmentContext& val) {
  this->environmentContext = val;
__isset.environmentContext = true;
}

void AlterPartitionsRequest::__set_writeId(const int64_t val) {
  this->writeId = val;
__isset.writeId = true;
}

void AlterPartitionsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}
std::ostream& operator<<(std::ostream& out, const AlterPartitionsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AlterPartitionsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tableName = false;
  bool isset_partitions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size1576;
            ::apache::thrift::protocol::TType _etype1579;
            xfer += iprot->readListBegin(_etype1579, _size1576);
            this->partitions.resize(_size1576);
            uint32_t _i1580;
            for (_i1580 = 0; _i1580 < _size1576; ++_i1580)
            {
              xfer += this->partitions[_i1580].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->environmentContext.read(iprot);
          this->__isset.environmentContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          this->__isset.writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AlterPartitionsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AlterPartitionsRequest");

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<Partition> ::const_iterator _iter1581;
    for (_iter1581 = this->partitions.begin(); _iter1581 != this->partitions.end(); ++_iter1581)
    {
      xfer += (*_iter1581).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.environmentContext) {
    xfer += oprot->writeFieldBegin("environmentContext", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->environmentContext.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writeId) {
    xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->writeId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlterPartitionsRequest &a, AlterPartitionsRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.partitions, b.partitions);
  swap(a.environmentContext, b.environmentContext);
  swap(a.writeId, b.writeId);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.__isset, b.__isset);
}

AlterPartitionsRequest::AlterPartitionsRequest(const AlterPartitionsRequest& other1582) {
  catName = other1582.catName;
  dbName = other1582.dbName;
  tableName = other1582.tableName;
  partitions = other1582.partitions;
  environmentContext = other1582.environmentContext;
  writeId = other1582.writeId;
  validWriteIdList = other1582.validWriteIdList;
  __isset = other1582.__isset;
}
AlterPartitionsRequest& AlterPartitionsRequest::operator=(const AlterPartitionsRequest& other1583) {
  catName = other1583.catName;
  dbName = other1583.dbName;
  tableName = other1583.tableName;
  partitions = other1583.partitions;
  environmentContext = other1583.environmentContext;
  writeId = other1583.writeId;
  validWriteIdList = other1583.validWriteIdList;
  __isset = other1583.__isset;
  return *this;
}
void AlterPartitionsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AlterPartitionsRequest(";
  out << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "partitions=" << to_string(partitions);
  out << ", " << "environmentContext="; (__isset.environmentContext ? (out << to_string(environmentContext)) : (out << "<null>"));
  out << ", " << "writeId="; (__isset.writeId ? (out << to_string(writeId)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ")";
}


AlterPartitionsResponse::~AlterPartitionsResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const AlterPartitionsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AlterPartitionsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlterPartitionsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AlterPartitionsResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlterPartitionsResponse &a, AlterPartitionsResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

AlterPartitionsResponse::AlterPartitionsResponse(const AlterPartitionsResponse& other1584) noexcept {
  (void) other1584;
}
AlterPartitionsResponse& AlterPartitionsResponse::operator=(const AlterPartitionsResponse& other1585) noexcept {
  (void) other1585;
  return *this;
}
void AlterPartitionsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AlterPartitionsResponse(";
  out << ")";
}


RenamePartitionRequest::~RenamePartitionRequest() noexcept {
}


void RenamePartitionRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void RenamePartitionRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void RenamePartitionRequest::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void RenamePartitionRequest::__set_partVals(const std::vector<std::string> & val) {
  this->partVals = val;
}

void RenamePartitionRequest::__set_newPart(const Partition& val) {
  this->newPart = val;
}

void RenamePartitionRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void RenamePartitionRequest::__set_txnId(const int64_t val) {
  this->txnId = val;
__isset.txnId = true;
}

void RenamePartitionRequest::__set_clonePart(const bool val) {
  this->clonePart = val;
__isset.clonePart = true;
}
std::ostream& operator<<(std::ostream& out, const RenamePartitionRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RenamePartitionRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tableName = false;
  bool isset_partVals = false;
  bool isset_newPart = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partVals.clear();
            uint32_t _size1586;
            ::apache::thrift::protocol::TType _etype1589;
            xfer += iprot->readListBegin(_etype1589, _size1586);
            this->partVals.resize(_size1586);
            uint32_t _i1590;
            for (_i1590 = 0; _i1590 < _size1586; ++_i1590)
            {
              xfer += iprot->readString(this->partVals[_i1590]);
            }
            xfer += iprot->readListEnd();
          }
          isset_partVals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->newPart.read(iprot);
          isset_newPart = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnId);
          this->__isset.txnId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->clonePart);
          this->__isset.clonePart = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partVals)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_newPart)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RenamePartitionRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RenamePartitionRequest");

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partVals", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partVals.size()));
    std::vector<std::string> ::const_iterator _iter1591;
    for (_iter1591 = this->partVals.begin(); _iter1591 != this->partVals.end(); ++_iter1591)
    {
      xfer += oprot->writeString((*_iter1591));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newPart", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->newPart.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.txnId) {
    xfer += oprot->writeFieldBegin("txnId", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->txnId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clonePart) {
    xfer += oprot->writeFieldBegin("clonePart", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->clonePart);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RenamePartitionRequest &a, RenamePartitionRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.partVals, b.partVals);
  swap(a.newPart, b.newPart);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.txnId, b.txnId);
  swap(a.clonePart, b.clonePart);
  swap(a.__isset, b.__isset);
}

RenamePartitionRequest::RenamePartitionRequest(const RenamePartitionRequest& other1592) {
  catName = other1592.catName;
  dbName = other1592.dbName;
  tableName = other1592.tableName;
  partVals = other1592.partVals;
  newPart = other1592.newPart;
  validWriteIdList = other1592.validWriteIdList;
  txnId = other1592.txnId;
  clonePart = other1592.clonePart;
  __isset = other1592.__isset;
}
RenamePartitionRequest& RenamePartitionRequest::operator=(const RenamePartitionRequest& other1593) {
  catName = other1593.catName;
  dbName = other1593.dbName;
  tableName = other1593.tableName;
  partVals = other1593.partVals;
  newPart = other1593.newPart;
  validWriteIdList = other1593.validWriteIdList;
  txnId = other1593.txnId;
  clonePart = other1593.clonePart;
  __isset = other1593.__isset;
  return *this;
}
void RenamePartitionRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RenamePartitionRequest(";
  out << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "partVals=" << to_string(partVals);
  out << ", " << "newPart=" << to_string(newPart);
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "txnId="; (__isset.txnId ? (out << to_string(txnId)) : (out << "<null>"));
  out << ", " << "clonePart="; (__isset.clonePart ? (out << to_string(clonePart)) : (out << "<null>"));
  out << ")";
}


RenamePartitionResponse::~RenamePartitionResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const RenamePartitionResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RenamePartitionResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RenamePartitionResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RenamePartitionResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RenamePartitionResponse &a, RenamePartitionResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

RenamePartitionResponse::RenamePartitionResponse(const RenamePartitionResponse& other1594) noexcept {
  (void) other1594;
}
RenamePartitionResponse& RenamePartitionResponse::operator=(const RenamePartitionResponse& other1595) noexcept {
  (void) other1595;
  return *this;
}
void RenamePartitionResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RenamePartitionResponse(";
  out << ")";
}


AlterTableRequest::~AlterTableRequest() noexcept {
}


void AlterTableRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void AlterTableRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void AlterTableRequest::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void AlterTableRequest::__set_table(const Table& val) {
  this->table = val;
}

void AlterTableRequest::__set_environmentContext(const EnvironmentContext& val) {
  this->environmentContext = val;
__isset.environmentContext = true;
}

void AlterTableRequest::__set_writeId(const int64_t val) {
  this->writeId = val;
__isset.writeId = true;
}

void AlterTableRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void AlterTableRequest::__set_processorCapabilities(const std::vector<std::string> & val) {
  this->processorCapabilities = val;
__isset.processorCapabilities = true;
}

void AlterTableRequest::__set_processorIdentifier(const std::string& val) {
  this->processorIdentifier = val;
__isset.processorIdentifier = true;
}

void AlterTableRequest::__set_expectedParameterKey(const std::string& val) {
  this->expectedParameterKey = val;
__isset.expectedParameterKey = true;
}

void AlterTableRequest::__set_expectedParameterValue(const std::string& val) {
  this->expectedParameterValue = val;
__isset.expectedParameterValue = true;
}
std::ostream& operator<<(std::ostream& out, const AlterTableRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AlterTableRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tableName = false;
  bool isset_table = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table.read(iprot);
          isset_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->environmentContext.read(iprot);
          this->__isset.environmentContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          this->__isset.writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->processorCapabilities.clear();
            uint32_t _size1596;
            ::apache::thrift::protocol::TType _etype1599;
            xfer += iprot->readListBegin(_etype1599, _size1596);
            this->processorCapabilities.resize(_size1596);
            uint32_t _i1600;
            for (_i1600 = 0; _i1600 < _size1596; ++_i1600)
            {
              xfer += iprot->readString(this->processorCapabilities[_i1600]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.processorCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->processorIdentifier);
          this->__isset.processorIdentifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->expectedParameterKey);
          this->__isset.expectedParameterKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->expectedParameterValue);
          this->__isset.expectedParameterValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AlterTableRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AlterTableRequest");

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->table.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.environmentContext) {
    xfer += oprot->writeFieldBegin("environmentContext", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->environmentContext.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writeId) {
    xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->writeId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorCapabilities) {
    xfer += oprot->writeFieldBegin("processorCapabilities", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->processorCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter1601;
      for (_iter1601 = this->processorCapabilities.begin(); _iter1601 != this->processorCapabilities.end(); ++_iter1601)
      {
        xfer += oprot->writeString((*_iter1601));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorIdentifier) {
    xfer += oprot->writeFieldBegin("processorIdentifier", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->processorIdentifier);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.expectedParameterKey) {
    xfer += oprot->writeFieldBegin("expectedParameterKey", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->expectedParameterKey);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.expectedParameterValue) {
    xfer += oprot->writeFieldBegin("expectedParameterValue", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->expectedParameterValue);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlterTableRequest &a, AlterTableRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.table, b.table);
  swap(a.environmentContext, b.environmentContext);
  swap(a.writeId, b.writeId);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.processorCapabilities, b.processorCapabilities);
  swap(a.processorIdentifier, b.processorIdentifier);
  swap(a.expectedParameterKey, b.expectedParameterKey);
  swap(a.expectedParameterValue, b.expectedParameterValue);
  swap(a.__isset, b.__isset);
}

AlterTableRequest::AlterTableRequest(const AlterTableRequest& other1602) {
  catName = other1602.catName;
  dbName = other1602.dbName;
  tableName = other1602.tableName;
  table = other1602.table;
  environmentContext = other1602.environmentContext;
  writeId = other1602.writeId;
  validWriteIdList = other1602.validWriteIdList;
  processorCapabilities = other1602.processorCapabilities;
  processorIdentifier = other1602.processorIdentifier;
  expectedParameterKey = other1602.expectedParameterKey;
  expectedParameterValue = other1602.expectedParameterValue;
  __isset = other1602.__isset;
}
AlterTableRequest& AlterTableRequest::operator=(const AlterTableRequest& other1603) {
  catName = other1603.catName;
  dbName = other1603.dbName;
  tableName = other1603.tableName;
  table = other1603.table;
  environmentContext = other1603.environmentContext;
  writeId = other1603.writeId;
  validWriteIdList = other1603.validWriteIdList;
  processorCapabilities = other1603.processorCapabilities;
  processorIdentifier = other1603.processorIdentifier;
  expectedParameterKey = other1603.expectedParameterKey;
  expectedParameterValue = other1603.expectedParameterValue;
  __isset = other1603.__isset;
  return *this;
}
void AlterTableRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AlterTableRequest(";
  out << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "table=" << to_string(table);
  out << ", " << "environmentContext="; (__isset.environmentContext ? (out << to_string(environmentContext)) : (out << "<null>"));
  out << ", " << "writeId="; (__isset.writeId ? (out << to_string(writeId)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "processorCapabilities="; (__isset.processorCapabilities ? (out << to_string(processorCapabilities)) : (out << "<null>"));
  out << ", " << "processorIdentifier="; (__isset.processorIdentifier ? (out << to_string(processorIdentifier)) : (out << "<null>"));
  out << ", " << "expectedParameterKey="; (__isset.expectedParameterKey ? (out << to_string(expectedParameterKey)) : (out << "<null>"));
  out << ", " << "expectedParameterValue="; (__isset.expectedParameterValue ? (out << to_string(expectedParameterValue)) : (out << "<null>"));
  out << ")";
}


AlterTableResponse::~AlterTableResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const AlterTableResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AlterTableResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlterTableResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AlterTableResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlterTableResponse &a, AlterTableResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

AlterTableResponse::AlterTableResponse(const AlterTableResponse& other1604) noexcept {
  (void) other1604;
}
AlterTableResponse& AlterTableResponse::operator=(const AlterTableResponse& other1605) noexcept {
  (void) other1605;
  return *this;
}
void AlterTableResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AlterTableResponse(";
  out << ")";
}


GetPartitionsFilterSpec::~GetPartitionsFilterSpec() noexcept {
}


void GetPartitionsFilterSpec::__set_filterMode(const PartitionFilterMode::type val) {
  this->filterMode = val;
__isset.filterMode = true;
}

void GetPartitionsFilterSpec::__set_filters(const std::vector<std::string> & val) {
  this->filters = val;
__isset.filters = true;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionsFilterSpec& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionsFilterSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1606;
          xfer += iprot->readI32(ecast1606);
          this->filterMode = static_cast<PartitionFilterMode::type>(ecast1606);
          this->__isset.filterMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->filters.clear();
            uint32_t _size1607;
            ::apache::thrift::protocol::TType _etype1610;
            xfer += iprot->readListBegin(_etype1610, _size1607);
            this->filters.resize(_size1607);
            uint32_t _i1611;
            for (_i1611 = 0; _i1611 < _size1607; ++_i1611)
            {
              xfer += iprot->readString(this->filters[_i1611]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.filters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetPartitionsFilterSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionsFilterSpec");

  if (this->__isset.filterMode) {
    xfer += oprot->writeFieldBegin("filterMode", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(static_cast<int32_t>(this->filterMode));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filters) {
    xfer += oprot->writeFieldBegin("filters", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->filters.size()));
      std::vector<std::string> ::const_iterator _iter1612;
      for (_iter1612 = this->filters.begin(); _iter1612 != this->filters.end(); ++_iter1612)
      {
        xfer += oprot->writeString((*_iter1612));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionsFilterSpec &a, GetPartitionsFilterSpec &b) {
  using ::std::swap;
  swap(a.filterMode, b.filterMode);
  swap(a.filters, b.filters);
  swap(a.__isset, b.__isset);
}

GetPartitionsFilterSpec::GetPartitionsFilterSpec(const GetPartitionsFilterSpec& other1613) {
  filterMode = other1613.filterMode;
  filters = other1613.filters;
  __isset = other1613.__isset;
}
GetPartitionsFilterSpec& GetPartitionsFilterSpec::operator=(const GetPartitionsFilterSpec& other1614) {
  filterMode = other1614.filterMode;
  filters = other1614.filters;
  __isset = other1614.__isset;
  return *this;
}
void GetPartitionsFilterSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionsFilterSpec(";
  out << "filterMode="; (__isset.filterMode ? (out << to_string(filterMode)) : (out << "<null>"));
  out << ", " << "filters="; (__isset.filters ? (out << to_string(filters)) : (out << "<null>"));
  out << ")";
}


GetPartitionsResponse::~GetPartitionsResponse() noexcept {
}


void GetPartitionsResponse::__set_partitionSpec(const std::vector<PartitionSpec> & val) {
  this->partitionSpec = val;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionSpec.clear();
            uint32_t _size1615;
            ::apache::thrift::protocol::TType _etype1618;
            xfer += iprot->readListBegin(_etype1618, _size1615);
            this->partitionSpec.resize(_size1615);
            uint32_t _i1619;
            for (_i1619 = 0; _i1619 < _size1615; ++_i1619)
            {
              xfer += this->partitionSpec[_i1619].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionSpec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetPartitionsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionsResponse");

  xfer += oprot->writeFieldBegin("partitionSpec", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitionSpec.size()));
    std::vector<PartitionSpec> ::const_iterator _iter1620;
    for (_iter1620 = this->partitionSpec.begin(); _iter1620 != this->partitionSpec.end(); ++_iter1620)
    {
      xfer += (*_iter1620).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionsResponse &a, GetPartitionsResponse &b) {
  using ::std::swap;
  swap(a.partitionSpec, b.partitionSpec);
  swap(a.__isset, b.__isset);
}

GetPartitionsResponse::GetPartitionsResponse(const GetPartitionsResponse& other1621) {
  partitionSpec = other1621.partitionSpec;
  __isset = other1621.__isset;
}
GetPartitionsResponse& GetPartitionsResponse::operator=(const GetPartitionsResponse& other1622) {
  partitionSpec = other1622.partitionSpec;
  __isset = other1622.__isset;
  return *this;
}
void GetPartitionsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionsResponse(";
  out << "partitionSpec=" << to_string(partitionSpec);
  out << ")";
}


GetPartitionsRequest::~GetPartitionsRequest() noexcept {
}


void GetPartitionsRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void GetPartitionsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void GetPartitionsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void GetPartitionsRequest::__set_withAuth(const bool val) {
  this->withAuth = val;
__isset.withAuth = true;
}

void GetPartitionsRequest::__set_user(const std::string& val) {
  this->user = val;
__isset.user = true;
}

void GetPartitionsRequest::__set_groupNames(const std::vector<std::string> & val) {
  this->groupNames = val;
__isset.groupNames = true;
}

void GetPartitionsRequest::__set_projectionSpec(const GetProjectionsSpec& val) {
  this->projectionSpec = val;
}

void GetPartitionsRequest::__set_filterSpec(const GetPartitionsFilterSpec& val) {
  this->filterSpec = val;
}

void GetPartitionsRequest::__set_processorCapabilities(const std::vector<std::string> & val) {
  this->processorCapabilities = val;
__isset.processorCapabilities = true;
}

void GetPartitionsRequest::__set_processorIdentifier(const std::string& val) {
  this->processorIdentifier = val;
__isset.processorIdentifier = true;
}

void GetPartitionsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          this->__isset.tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->withAuth);
          this->__isset.withAuth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->groupNames.clear();
            uint32_t _size1623;
            ::apache::thrift::protocol::TType _etype1626;
            xfer += iprot->readListBegin(_etype1626, _size1623);
            this->groupNames.resize(_size1623);
            uint32_t _i1627;
            for (_i1627 = 0; _i1627 < _size1623; ++_i1627)
            {
              xfer += iprot->readString(this->groupNames[_i1627]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.groupNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->projectionSpec.read(iprot);
          this->__isset.projectionSpec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->filterSpec.read(iprot);
          this->__isset.filterSpec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->processorCapabilities.clear();
            uint32_t _size1628;
            ::apache::thrift::protocol::TType _etype1631;
            xfer += iprot->readListBegin(_etype1631, _size1628);
            this->processorCapabilities.resize(_size1628);
            uint32_t _i1632;
            for (_i1632 = 0; _i1632 < _size1628; ++_i1632)
            {
              xfer += iprot->readString(this->processorCapabilities[_i1632]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.processorCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->processorIdentifier);
          this->__isset.processorIdentifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetPartitionsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionsRequest");

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.withAuth) {
    xfer += oprot->writeFieldBegin("withAuth", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->withAuth);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.user) {
    xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->user);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.groupNames) {
    xfer += oprot->writeFieldBegin("groupNames", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->groupNames.size()));
      std::vector<std::string> ::const_iterator _iter1633;
      for (_iter1633 = this->groupNames.begin(); _iter1633 != this->groupNames.end(); ++_iter1633)
      {
        xfer += oprot->writeString((*_iter1633));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("projectionSpec", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->projectionSpec.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filterSpec", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->filterSpec.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.processorCapabilities) {
    xfer += oprot->writeFieldBegin("processorCapabilities", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->processorCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter1634;
      for (_iter1634 = this->processorCapabilities.begin(); _iter1634 != this->processorCapabilities.end(); ++_iter1634)
      {
        xfer += oprot->writeString((*_iter1634));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorIdentifier) {
    xfer += oprot->writeFieldBegin("processorIdentifier", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->processorIdentifier);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionsRequest &a, GetPartitionsRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.withAuth, b.withAuth);
  swap(a.user, b.user);
  swap(a.groupNames, b.groupNames);
  swap(a.projectionSpec, b.projectionSpec);
  swap(a.filterSpec, b.filterSpec);
  swap(a.processorCapabilities, b.processorCapabilities);
  swap(a.processorIdentifier, b.processorIdentifier);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.__isset, b.__isset);
}

GetPartitionsRequest::GetPartitionsRequest(const GetPartitionsRequest& other1635) {
  catName = other1635.catName;
  dbName = other1635.dbName;
  tblName = other1635.tblName;
  withAuth = other1635.withAuth;
  user = other1635.user;
  groupNames = other1635.groupNames;
  projectionSpec = other1635.projectionSpec;
  filterSpec = other1635.filterSpec;
  processorCapabilities = other1635.processorCapabilities;
  processorIdentifier = other1635.processorIdentifier;
  validWriteIdList = other1635.validWriteIdList;
  __isset = other1635.__isset;
}
GetPartitionsRequest& GetPartitionsRequest::operator=(const GetPartitionsRequest& other1636) {
  catName = other1636.catName;
  dbName = other1636.dbName;
  tblName = other1636.tblName;
  withAuth = other1636.withAuth;
  user = other1636.user;
  groupNames = other1636.groupNames;
  projectionSpec = other1636.projectionSpec;
  filterSpec = other1636.filterSpec;
  processorCapabilities = other1636.processorCapabilities;
  processorIdentifier = other1636.processorIdentifier;
  validWriteIdList = other1636.validWriteIdList;
  __isset = other1636.__isset;
  return *this;
}
void GetPartitionsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionsRequest(";
  out << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "withAuth="; (__isset.withAuth ? (out << to_string(withAuth)) : (out << "<null>"));
  out << ", " << "user="; (__isset.user ? (out << to_string(user)) : (out << "<null>"));
  out << ", " << "groupNames="; (__isset.groupNames ? (out << to_string(groupNames)) : (out << "<null>"));
  out << ", " << "projectionSpec=" << to_string(projectionSpec);
  out << ", " << "filterSpec=" << to_string(filterSpec);
  out << ", " << "processorCapabilities="; (__isset.processorCapabilities ? (out << to_string(processorCapabilities)) : (out << "<null>"));
  out << ", " << "processorIdentifier="; (__isset.processorIdentifier ? (out << to_string(processorIdentifier)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ")";
}


GetFieldsRequest::~GetFieldsRequest() noexcept {
}


void GetFieldsRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void GetFieldsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void GetFieldsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void GetFieldsRequest::__set_envContext(const EnvironmentContext& val) {
  this->envContext = val;
__isset.envContext = true;
}

void GetFieldsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void GetFieldsRequest::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}
std::ostream& operator<<(std::ostream& out, const GetFieldsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetFieldsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->envContext.read(iprot);
          this->__isset.envContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetFieldsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetFieldsRequest");

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.envContext) {
    xfer += oprot->writeFieldBegin("envContext", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->envContext.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetFieldsRequest &a, GetFieldsRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.envContext, b.envContext);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

GetFieldsRequest::GetFieldsRequest(const GetFieldsRequest& other1637) {
  catName = other1637.catName;
  dbName = other1637.dbName;
  tblName = other1637.tblName;
  envContext = other1637.envContext;
  validWriteIdList = other1637.validWriteIdList;
  id = other1637.id;
  __isset = other1637.__isset;
}
GetFieldsRequest& GetFieldsRequest::operator=(const GetFieldsRequest& other1638) {
  catName = other1638.catName;
  dbName = other1638.dbName;
  tblName = other1638.tblName;
  envContext = other1638.envContext;
  validWriteIdList = other1638.validWriteIdList;
  id = other1638.id;
  __isset = other1638.__isset;
  return *this;
}
void GetFieldsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetFieldsRequest(";
  out << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "envContext="; (__isset.envContext ? (out << to_string(envContext)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


GetFieldsResponse::~GetFieldsResponse() noexcept {
}


void GetFieldsResponse::__set_fields(const std::vector<FieldSchema> & val) {
  this->fields = val;
}
std::ostream& operator<<(std::ostream& out, const GetFieldsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetFieldsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fields = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fields.clear();
            uint32_t _size1639;
            ::apache::thrift::protocol::TType _etype1642;
            xfer += iprot->readListBegin(_etype1642, _size1639);
            this->fields.resize(_size1639);
            uint32_t _i1643;
            for (_i1643 = 0; _i1643 < _size1639; ++_i1643)
            {
              xfer += this->fields[_i1643].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fields)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetFieldsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetFieldsResponse");

  xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fields.size()));
    std::vector<FieldSchema> ::const_iterator _iter1644;
    for (_iter1644 = this->fields.begin(); _iter1644 != this->fields.end(); ++_iter1644)
    {
      xfer += (*_iter1644).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetFieldsResponse &a, GetFieldsResponse &b) {
  using ::std::swap;
  swap(a.fields, b.fields);
}

GetFieldsResponse::GetFieldsResponse(const GetFieldsResponse& other1645) {
  fields = other1645.fields;
}
GetFieldsResponse& GetFieldsResponse::operator=(const GetFieldsResponse& other1646) {
  fields = other1646.fields;
  return *this;
}
void GetFieldsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetFieldsResponse(";
  out << "fields=" << to_string(fields);
  out << ")";
}


GetSchemaRequest::~GetSchemaRequest() noexcept {
}


void GetSchemaRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void GetSchemaRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void GetSchemaRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void GetSchemaRequest::__set_envContext(const EnvironmentContext& val) {
  this->envContext = val;
__isset.envContext = true;
}

void GetSchemaRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void GetSchemaRequest::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}
std::ostream& operator<<(std::ostream& out, const GetSchemaRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetSchemaRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->envContext.read(iprot);
          this->__isset.envContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetSchemaRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetSchemaRequest");

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.envContext) {
    xfer += oprot->writeFieldBegin("envContext", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->envContext.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetSchemaRequest &a, GetSchemaRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.envContext, b.envContext);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

GetSchemaRequest::GetSchemaRequest(const GetSchemaRequest& other1647) {
  catName = other1647.catName;
  dbName = other1647.dbName;
  tblName = other1647.tblName;
  envContext = other1647.envContext;
  validWriteIdList = other1647.validWriteIdList;
  id = other1647.id;
  __isset = other1647.__isset;
}
GetSchemaRequest& GetSchemaRequest::operator=(const GetSchemaRequest& other1648) {
  catName = other1648.catName;
  dbName = other1648.dbName;
  tblName = other1648.tblName;
  envContext = other1648.envContext;
  validWriteIdList = other1648.validWriteIdList;
  id = other1648.id;
  __isset = other1648.__isset;
  return *this;
}
void GetSchemaRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetSchemaRequest(";
  out << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "envContext="; (__isset.envContext ? (out << to_string(envContext)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


GetSchemaResponse::~GetSchemaResponse() noexcept {
}


void GetSchemaResponse::__set_fields(const std::vector<FieldSchema> & val) {
  this->fields = val;
}
std::ostream& operator<<(std::ostream& out, const GetSchemaResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetSchemaResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fields = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fields.clear();
            uint32_t _size1649;
            ::apache::thrift::protocol::TType _etype1652;
            xfer += iprot->readListBegin(_etype1652, _size1649);
            this->fields.resize(_size1649);
            uint32_t _i1653;
            for (_i1653 = 0; _i1653 < _size1649; ++_i1653)
            {
              xfer += this->fields[_i1653].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fields)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetSchemaResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetSchemaResponse");

  xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fields.size()));
    std::vector<FieldSchema> ::const_iterator _iter1654;
    for (_iter1654 = this->fields.begin(); _iter1654 != this->fields.end(); ++_iter1654)
    {
      xfer += (*_iter1654).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetSchemaResponse &a, GetSchemaResponse &b) {
  using ::std::swap;
  swap(a.fields, b.fields);
}

GetSchemaResponse::GetSchemaResponse(const GetSchemaResponse& other1655) {
  fields = other1655.fields;
}
GetSchemaResponse& GetSchemaResponse::operator=(const GetSchemaResponse& other1656) {
  fields = other1656.fields;
  return *this;
}
void GetSchemaResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetSchemaResponse(";
  out << "fields=" << to_string(fields);
  out << ")";
}


GetPartitionRequest::~GetPartitionRequest() noexcept {
}


void GetPartitionRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void GetPartitionRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void GetPartitionRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void GetPartitionRequest::__set_partVals(const std::vector<std::string> & val) {
  this->partVals = val;
}

void GetPartitionRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void GetPartitionRequest::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_partVals = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partVals.clear();
            uint32_t _size1657;
            ::apache::thrift::protocol::TType _etype1660;
            xfer += iprot->readListBegin(_etype1660, _size1657);
            this->partVals.resize(_size1657);
            uint32_t _i1661;
            for (_i1661 = 0; _i1661 < _size1657; ++_i1661)
            {
              xfer += iprot->readString(this->partVals[_i1661]);
            }
            xfer += iprot->readListEnd();
          }
          isset_partVals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partVals)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPartitionRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionRequest");

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partVals", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partVals.size()));
    std::vector<std::string> ::const_iterator _iter1662;
    for (_iter1662 = this->partVals.begin(); _iter1662 != this->partVals.end(); ++_iter1662)
    {
      xfer += oprot->writeString((*_iter1662));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionRequest &a, GetPartitionRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.partVals, b.partVals);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

GetPartitionRequest::GetPartitionRequest(const GetPartitionRequest& other1663) {
  catName = other1663.catName;
  dbName = other1663.dbName;
  tblName = other1663.tblName;
  partVals = other1663.partVals;
  validWriteIdList = other1663.validWriteIdList;
  id = other1663.id;
  __isset = other1663.__isset;
}
GetPartitionRequest& GetPartitionRequest::operator=(const GetPartitionRequest& other1664) {
  catName = other1664.catName;
  dbName = other1664.dbName;
  tblName = other1664.tblName;
  partVals = other1664.partVals;
  validWriteIdList = other1664.validWriteIdList;
  id = other1664.id;
  __isset = other1664.__isset;
  return *this;
}
void GetPartitionRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionRequest(";
  out << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "partVals=" << to_string(partVals);
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


GetPartitionResponse::~GetPartitionResponse() noexcept {
}


void GetPartitionResponse::__set_partition(const Partition& val) {
  this->partition = val;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partition = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->partition.read(iprot);
          isset_partition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partition)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPartitionResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionResponse");

  xfer += oprot->writeFieldBegin("partition", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->partition.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionResponse &a, GetPartitionResponse &b) {
  using ::std::swap;
  swap(a.partition, b.partition);
}

GetPartitionResponse::GetPartitionResponse(const GetPartitionResponse& other1665) {
  partition = other1665.partition;
}
GetPartitionResponse& GetPartitionResponse::operator=(const GetPartitionResponse& other1666) {
  partition = other1666.partition;
  return *this;
}
void GetPartitionResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionResponse(";
  out << "partition=" << to_string(partition);
  out << ")";
}


PartitionsRequest::~PartitionsRequest() noexcept {
}


void PartitionsRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void PartitionsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void PartitionsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void PartitionsRequest::__set_maxParts(const int16_t val) {
  this->maxParts = val;
__isset.maxParts = true;
}

void PartitionsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void PartitionsRequest::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}
std::ostream& operator<<(std::ostream& out, const PartitionsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->maxParts);
          this->__isset.maxParts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsRequest");

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.maxParts) {
    xfer += oprot->writeFieldBegin("maxParts", ::apache::thrift::protocol::T_I16, 4);
    xfer += oprot->writeI16(this->maxParts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsRequest &a, PartitionsRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.maxParts, b.maxParts);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

PartitionsRequest::PartitionsRequest(const PartitionsRequest& other1667) {
  catName = other1667.catName;
  dbName = other1667.dbName;
  tblName = other1667.tblName;
  maxParts = other1667.maxParts;
  validWriteIdList = other1667.validWriteIdList;
  id = other1667.id;
  __isset = other1667.__isset;
}
PartitionsRequest& PartitionsRequest::operator=(const PartitionsRequest& other1668) {
  catName = other1668.catName;
  dbName = other1668.dbName;
  tblName = other1668.tblName;
  maxParts = other1668.maxParts;
  validWriteIdList = other1668.validWriteIdList;
  id = other1668.id;
  __isset = other1668.__isset;
  return *this;
}
void PartitionsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsRequest(";
  out << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "maxParts="; (__isset.maxParts ? (out << to_string(maxParts)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


PartitionsResponse::~PartitionsResponse() noexcept {
}


void PartitionsResponse::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partitions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size1669;
            ::apache::thrift::protocol::TType _etype1672;
            xfer += iprot->readListBegin(_etype1672, _size1669);
            this->partitions.resize(_size1669);
            uint32_t _i1673;
            for (_i1673 = 0; _i1673 < _size1669; ++_i1673)
            {
              xfer += this->partitions[_i1673].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsResponse");

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<Partition> ::const_iterator _iter1674;
    for (_iter1674 = this->partitions.begin(); _iter1674 != this->partitions.end(); ++_iter1674)
    {
      xfer += (*_iter1674).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsResponse &a, PartitionsResponse &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
}

PartitionsResponse::PartitionsResponse(const PartitionsResponse& other1675) {
  partitions = other1675.partitions;
}
PartitionsResponse& PartitionsResponse::operator=(const PartitionsResponse& other1676) {
  partitions = other1676.partitions;
  return *this;
}
void PartitionsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsResponse(";
  out << "partitions=" << to_string(partitions);
  out << ")";
}


GetPartitionNamesPsRequest::~GetPartitionNamesPsRequest() noexcept {
}


void GetPartitionNamesPsRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void GetPartitionNamesPsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void GetPartitionNamesPsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void GetPartitionNamesPsRequest::__set_partValues(const std::vector<std::string> & val) {
  this->partValues = val;
__isset.partValues = true;
}

void GetPartitionNamesPsRequest::__set_maxParts(const int16_t val) {
  this->maxParts = val;
__isset.maxParts = true;
}

void GetPartitionNamesPsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void GetPartitionNamesPsRequest::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionNamesPsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionNamesPsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partValues.clear();
            uint32_t _size1677;
            ::apache::thrift::protocol::TType _etype1680;
            xfer += iprot->readListBegin(_etype1680, _size1677);
            this->partValues.resize(_size1677);
            uint32_t _i1681;
            for (_i1681 = 0; _i1681 < _size1677; ++_i1681)
            {
              xfer += iprot->readString(this->partValues[_i1681]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->maxParts);
          this->__isset.maxParts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPartitionNamesPsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionNamesPsRequest");

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partValues) {
    xfer += oprot->writeFieldBegin("partValues", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partValues.size()));
      std::vector<std::string> ::const_iterator _iter1682;
      for (_iter1682 = this->partValues.begin(); _iter1682 != this->partValues.end(); ++_iter1682)
      {
        xfer += oprot->writeString((*_iter1682));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxParts) {
    xfer += oprot->writeFieldBegin("maxParts", ::apache::thrift::protocol::T_I16, 5);
    xfer += oprot->writeI16(this->maxParts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionNamesPsRequest &a, GetPartitionNamesPsRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.partValues, b.partValues);
  swap(a.maxParts, b.maxParts);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

GetPartitionNamesPsRequest::GetPartitionNamesPsRequest(const GetPartitionNamesPsRequest& other1683) {
  catName = other1683.catName;
  dbName = other1683.dbName;
  tblName = other1683.tblName;
  partValues = other1683.partValues;
  maxParts = other1683.maxParts;
  validWriteIdList = other1683.validWriteIdList;
  id = other1683.id;
  __isset = other1683.__isset;
}
GetPartitionNamesPsRequest& GetPartitionNamesPsRequest::operator=(const GetPartitionNamesPsRequest& other1684) {
  catName = other1684.catName;
  dbName = other1684.dbName;
  tblName = other1684.tblName;
  partValues = other1684.partValues;
  maxParts = other1684.maxParts;
  validWriteIdList = other1684.validWriteIdList;
  id = other1684.id;
  __isset = other1684.__isset;
  return *this;
}
void GetPartitionNamesPsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionNamesPsRequest(";
  out << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "partValues="; (__isset.partValues ? (out << to_string(partValues)) : (out << "<null>"));
  out << ", " << "maxParts="; (__isset.maxParts ? (out << to_string(maxParts)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


GetPartitionNamesPsResponse::~GetPartitionNamesPsResponse() noexcept {
}


void GetPartitionNamesPsResponse::__set_names(const std::vector<std::string> & val) {
  this->names = val;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionNamesPsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionNamesPsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_names = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size1685;
            ::apache::thrift::protocol::TType _etype1688;
            xfer += iprot->readListBegin(_etype1688, _size1685);
            this->names.resize(_size1685);
            uint32_t _i1689;
            for (_i1689 = 0; _i1689 < _size1685; ++_i1689)
            {
              xfer += iprot->readString(this->names[_i1689]);
            }
            xfer += iprot->readListEnd();
          }
          isset_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_names)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPartitionNamesPsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionNamesPsResponse");

  xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->names.size()));
    std::vector<std::string> ::const_iterator _iter1690;
    for (_iter1690 = this->names.begin(); _iter1690 != this->names.end(); ++_iter1690)
    {
      xfer += oprot->writeString((*_iter1690));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionNamesPsResponse &a, GetPartitionNamesPsResponse &b) {
  using ::std::swap;
  swap(a.names, b.names);
}

GetPartitionNamesPsResponse::GetPartitionNamesPsResponse(const GetPartitionNamesPsResponse& other1691) {
  names = other1691.names;
}
GetPartitionNamesPsResponse& GetPartitionNamesPsResponse::operator=(const GetPartitionNamesPsResponse& other1692) {
  names = other1692.names;
  return *this;
}
void GetPartitionNamesPsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionNamesPsResponse(";
  out << "names=" << to_string(names);
  out << ")";
}


GetPartitionsPsWithAuthRequest::~GetPartitionsPsWithAuthRequest() noexcept {
}


void GetPartitionsPsWithAuthRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void GetPartitionsPsWithAuthRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void GetPartitionsPsWithAuthRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void GetPartitionsPsWithAuthRequest::__set_partVals(const std::vector<std::string> & val) {
  this->partVals = val;
__isset.partVals = true;
}

void GetPartitionsPsWithAuthRequest::__set_maxParts(const int16_t val) {
  this->maxParts = val;
__isset.maxParts = true;
}

void GetPartitionsPsWithAuthRequest::__set_userName(const std::string& val) {
  this->userName = val;
__isset.userName = true;
}

void GetPartitionsPsWithAuthRequest::__set_groupNames(const std::vector<std::string> & val) {
  this->groupNames = val;
__isset.groupNames = true;
}

void GetPartitionsPsWithAuthRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void GetPartitionsPsWithAuthRequest::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionsPsWithAuthRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionsPsWithAuthRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partVals.clear();
            uint32_t _size1693;
            ::apache::thrift::protocol::TType _etype1696;
            xfer += iprot->readListBegin(_etype1696, _size1693);
            this->partVals.resize(_size1693);
            uint32_t _i1697;
            for (_i1697 = 0; _i1697 < _size1693; ++_i1697)
            {
              xfer += iprot->readString(this->partVals[_i1697]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partVals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->maxParts);
          this->__isset.maxParts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userName);
          this->__isset.userName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->groupNames.clear();
            uint32_t _size1698;
            ::apache::thrift::protocol::TType _etype1701;
            xfer += iprot->readListBegin(_etype1701, _size1698);
            this->groupNames.resize(_size1698);
            uint32_t _i1702;
            for (_i1702 = 0; _i1702 < _size1698; ++_i1702)
            {
              xfer += iprot->readString(this->groupNames[_i1702]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.groupNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPartitionsPsWithAuthRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionsPsWithAuthRequest");

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partVals) {
    xfer += oprot->writeFieldBegin("partVals", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partVals.size()));
      std::vector<std::string> ::const_iterator _iter1703;
      for (_iter1703 = this->partVals.begin(); _iter1703 != this->partVals.end(); ++_iter1703)
      {
        xfer += oprot->writeString((*_iter1703));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxParts) {
    xfer += oprot->writeFieldBegin("maxParts", ::apache::thrift::protocol::T_I16, 5);
    xfer += oprot->writeI16(this->maxParts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.userName) {
    xfer += oprot->writeFieldBegin("userName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->userName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.groupNames) {
    xfer += oprot->writeFieldBegin("groupNames", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->groupNames.size()));
      std::vector<std::string> ::const_iterator _iter1704;
      for (_iter1704 = this->groupNames.begin(); _iter1704 != this->groupNames.end(); ++_iter1704)
      {
        xfer += oprot->writeString((*_iter1704));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionsPsWithAuthRequest &a, GetPartitionsPsWithAuthRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.partVals, b.partVals);
  swap(a.maxParts, b.maxParts);
  swap(a.userName, b.userName);
  swap(a.groupNames, b.groupNames);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

GetPartitionsPsWithAuthRequest::GetPartitionsPsWithAuthRequest(const GetPartitionsPsWithAuthRequest& other1705) {
  catName = other1705.catName;
  dbName = other1705.dbName;
  tblName = other1705.tblName;
  partVals = other1705.partVals;
  maxParts = other1705.maxParts;
  userName = other1705.userName;
  groupNames = other1705.groupNames;
  validWriteIdList = other1705.validWriteIdList;
  id = other1705.id;
  __isset = other1705.__isset;
}
GetPartitionsPsWithAuthRequest& GetPartitionsPsWithAuthRequest::operator=(const GetPartitionsPsWithAuthRequest& other1706) {
  catName = other1706.catName;
  dbName = other1706.dbName;
  tblName = other1706.tblName;
  partVals = other1706.partVals;
  maxParts = other1706.maxParts;
  userName = other1706.userName;
  groupNames = other1706.groupNames;
  validWriteIdList = other1706.validWriteIdList;
  id = other1706.id;
  __isset = other1706.__isset;
  return *this;
}
void GetPartitionsPsWithAuthRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionsPsWithAuthRequest(";
  out << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "partVals="; (__isset.partVals ? (out << to_string(partVals)) : (out << "<null>"));
  out << ", " << "maxParts="; (__isset.maxParts ? (out << to_string(maxParts)) : (out << "<null>"));
  out << ", " << "userName="; (__isset.userName ? (out << to_string(userName)) : (out << "<null>"));
  out << ", " << "groupNames="; (__isset.groupNames ? (out << to_string(groupNames)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


GetPartitionsPsWithAuthResponse::~GetPartitionsPsWithAuthResponse() noexcept {
}


void GetPartitionsPsWithAuthResponse::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionsPsWithAuthResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionsPsWithAuthResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partitions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size1707;
            ::apache::thrift::protocol::TType _etype1710;
            xfer += iprot->readListBegin(_etype1710, _size1707);
            this->partitions.resize(_size1707);
            uint32_t _i1711;
            for (_i1711 = 0; _i1711 < _size1707; ++_i1711)
            {
              xfer += this->partitions[_i1711].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPartitionsPsWithAuthResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionsPsWithAuthResponse");

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<Partition> ::const_iterator _iter1712;
    for (_iter1712 = this->partitions.begin(); _iter1712 != this->partitions.end(); ++_iter1712)
    {
      xfer += (*_iter1712).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionsPsWithAuthResponse &a, GetPartitionsPsWithAuthResponse &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
}

GetPartitionsPsWithAuthResponse::GetPartitionsPsWithAuthResponse(const GetPartitionsPsWithAuthResponse& other1713) {
  partitions = other1713.partitions;
}
GetPartitionsPsWithAuthResponse& GetPartitionsPsWithAuthResponse::operator=(const GetPartitionsPsWithAuthResponse& other1714) {
  partitions = other1714.partitions;
  return *this;
}
void GetPartitionsPsWithAuthResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionsPsWithAuthResponse(";
  out << "partitions=" << to_string(partitions);
  out << ")";
}


ReplicationMetrics::~ReplicationMetrics() noexcept {
}


void ReplicationMetrics::__set_scheduledExecutionId(const int64_t val) {
  this->scheduledExecutionId = val;
}

void ReplicationMetrics::__set_policy(const std::string& val) {
  this->policy = val;
}

void ReplicationMetrics::__set_dumpExecutionId(const int64_t val) {
  this->dumpExecutionId = val;
}

void ReplicationMetrics::__set_metadata(const std::string& val) {
  this->metadata = val;
__isset.metadata = true;
}

void ReplicationMetrics::__set_progress(const std::string& val) {
  this->progress = val;
__isset.progress = true;
}

void ReplicationMetrics::__set_messageFormat(const std::string& val) {
  this->messageFormat = val;
__isset.messageFormat = true;
}
std::ostream& operator<<(std::ostream& out, const ReplicationMetrics& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ReplicationMetrics::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_scheduledExecutionId = false;
  bool isset_policy = false;
  bool isset_dumpExecutionId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->scheduledExecutionId);
          isset_scheduledExecutionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->policy);
          isset_policy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dumpExecutionId);
          isset_dumpExecutionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metadata);
          this->__isset.metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->progress);
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->messageFormat);
          this->__isset.messageFormat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_scheduledExecutionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_policy)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dumpExecutionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ReplicationMetrics::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ReplicationMetrics");

  xfer += oprot->writeFieldBegin("scheduledExecutionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->scheduledExecutionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("policy", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->policy);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dumpExecutionId", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->dumpExecutionId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.metadata) {
    xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->metadata);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.progress) {
    xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->progress);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.messageFormat) {
    xfer += oprot->writeFieldBegin("messageFormat", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->messageFormat);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReplicationMetrics &a, ReplicationMetrics &b) {
  using ::std::swap;
  swap(a.scheduledExecutionId, b.scheduledExecutionId);
  swap(a.policy, b.policy);
  swap(a.dumpExecutionId, b.dumpExecutionId);
  swap(a.metadata, b.metadata);
  swap(a.progress, b.progress);
  swap(a.messageFormat, b.messageFormat);
  swap(a.__isset, b.__isset);
}

ReplicationMetrics::ReplicationMetrics(const ReplicationMetrics& other1715) {
  scheduledExecutionId = other1715.scheduledExecutionId;
  policy = other1715.policy;
  dumpExecutionId = other1715.dumpExecutionId;
  metadata = other1715.metadata;
  progress = other1715.progress;
  messageFormat = other1715.messageFormat;
  __isset = other1715.__isset;
}
ReplicationMetrics& ReplicationMetrics::operator=(const ReplicationMetrics& other1716) {
  scheduledExecutionId = other1716.scheduledExecutionId;
  policy = other1716.policy;
  dumpExecutionId = other1716.dumpExecutionId;
  metadata = other1716.metadata;
  progress = other1716.progress;
  messageFormat = other1716.messageFormat;
  __isset = other1716.__isset;
  return *this;
}
void ReplicationMetrics::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ReplicationMetrics(";
  out << "scheduledExecutionId=" << to_string(scheduledExecutionId);
  out << ", " << "policy=" << to_string(policy);
  out << ", " << "dumpExecutionId=" << to_string(dumpExecutionId);
  out << ", " << "metadata="; (__isset.metadata ? (out << to_string(metadata)) : (out << "<null>"));
  out << ", " << "progress="; (__isset.progress ? (out << to_string(progress)) : (out << "<null>"));
  out << ", " << "messageFormat="; (__isset.messageFormat ? (out << to_string(messageFormat)) : (out << "<null>"));
  out << ")";
}


ReplicationMetricList::~ReplicationMetricList() noexcept {
}


void ReplicationMetricList::__set_replicationMetricList(const std::vector<ReplicationMetrics> & val) {
  this->replicationMetricList = val;
}
std::ostream& operator<<(std::ostream& out, const ReplicationMetricList& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ReplicationMetricList::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_replicationMetricList = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->replicationMetricList.clear();
            uint32_t _size1717;
            ::apache::thrift::protocol::TType _etype1720;
            xfer += iprot->readListBegin(_etype1720, _size1717);
            this->replicationMetricList.resize(_size1717);
            uint32_t _i1721;
            for (_i1721 = 0; _i1721 < _size1717; ++_i1721)
            {
              xfer += this->replicationMetricList[_i1721].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_replicationMetricList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_replicationMetricList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ReplicationMetricList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ReplicationMetricList");

  xfer += oprot->writeFieldBegin("replicationMetricList", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->replicationMetricList.size()));
    std::vector<ReplicationMetrics> ::const_iterator _iter1722;
    for (_iter1722 = this->replicationMetricList.begin(); _iter1722 != this->replicationMetricList.end(); ++_iter1722)
    {
      xfer += (*_iter1722).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReplicationMetricList &a, ReplicationMetricList &b) {
  using ::std::swap;
  swap(a.replicationMetricList, b.replicationMetricList);
}

ReplicationMetricList::ReplicationMetricList(const ReplicationMetricList& other1723) {
  replicationMetricList = other1723.replicationMetricList;
}
ReplicationMetricList& ReplicationMetricList::operator=(const ReplicationMetricList& other1724) {
  replicationMetricList = other1724.replicationMetricList;
  return *this;
}
void ReplicationMetricList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ReplicationMetricList(";
  out << "replicationMetricList=" << to_string(replicationMetricList);
  out << ")";
}


GetReplicationMetricsRequest::~GetReplicationMetricsRequest() noexcept {
}


void GetReplicationMetricsRequest::__set_scheduledExecutionId(const int64_t val) {
  this->scheduledExecutionId = val;
__isset.scheduledExecutionId = true;
}

void GetReplicationMetricsRequest::__set_policy(const std::string& val) {
  this->policy = val;
__isset.policy = true;
}

void GetReplicationMetricsRequest::__set_dumpExecutionId(const int64_t val) {
  this->dumpExecutionId = val;
__isset.dumpExecutionId = true;
}
std::ostream& operator<<(std::ostream& out, const GetReplicationMetricsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetReplicationMetricsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->scheduledExecutionId);
          this->__isset.scheduledExecutionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->policy);
          this->__isset.policy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dumpExecutionId);
          this->__isset.dumpExecutionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetReplicationMetricsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetReplicationMetricsRequest");

  if (this->__isset.scheduledExecutionId) {
    xfer += oprot->writeFieldBegin("scheduledExecutionId", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->scheduledExecutionId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.policy) {
    xfer += oprot->writeFieldBegin("policy", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->policy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dumpExecutionId) {
    xfer += oprot->writeFieldBegin("dumpExecutionId", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->dumpExecutionId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetReplicationMetricsRequest &a, GetReplicationMetricsRequest &b) {
  using ::std::swap;
  swap(a.scheduledExecutionId, b.scheduledExecutionId);
  swap(a.policy, b.policy);
  swap(a.dumpExecutionId, b.dumpExecutionId);
  swap(a.__isset, b.__isset);
}

GetReplicationMetricsRequest::GetReplicationMetricsRequest(const GetReplicationMetricsRequest& other1725) {
  scheduledExecutionId = other1725.scheduledExecutionId;
  policy = other1725.policy;
  dumpExecutionId = other1725.dumpExecutionId;
  __isset = other1725.__isset;
}
GetReplicationMetricsRequest& GetReplicationMetricsRequest::operator=(const GetReplicationMetricsRequest& other1726) {
  scheduledExecutionId = other1726.scheduledExecutionId;
  policy = other1726.policy;
  dumpExecutionId = other1726.dumpExecutionId;
  __isset = other1726.__isset;
  return *this;
}
void GetReplicationMetricsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetReplicationMetricsRequest(";
  out << "scheduledExecutionId="; (__isset.scheduledExecutionId ? (out << to_string(scheduledExecutionId)) : (out << "<null>"));
  out << ", " << "policy="; (__isset.policy ? (out << to_string(policy)) : (out << "<null>"));
  out << ", " << "dumpExecutionId="; (__isset.dumpExecutionId ? (out << to_string(dumpExecutionId)) : (out << "<null>"));
  out << ")";
}


GetOpenTxnsRequest::~GetOpenTxnsRequest() noexcept {
}


void GetOpenTxnsRequest::__set_excludeTxnTypes(const std::vector<TxnType::type> & val) {
  this->excludeTxnTypes = val;
__isset.excludeTxnTypes = true;
}
std::ostream& operator<<(std::ostream& out, const GetOpenTxnsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetOpenTxnsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->excludeTxnTypes.clear();
            uint32_t _size1727;
            ::apache::thrift::protocol::TType _etype1730;
            xfer += iprot->readListBegin(_etype1730, _size1727);
            this->excludeTxnTypes.resize(_size1727);
            uint32_t _i1731;
            for (_i1731 = 0; _i1731 < _size1727; ++_i1731)
            {
              int32_t ecast1732;
              xfer += iprot->readI32(ecast1732);
              this->excludeTxnTypes[_i1731] = static_cast<TxnType::type>(ecast1732);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.excludeTxnTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetOpenTxnsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetOpenTxnsRequest");

  if (this->__isset.excludeTxnTypes) {
    xfer += oprot->writeFieldBegin("excludeTxnTypes", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->excludeTxnTypes.size()));
      std::vector<TxnType::type> ::const_iterator _iter1733;
      for (_iter1733 = this->excludeTxnTypes.begin(); _iter1733 != this->excludeTxnTypes.end(); ++_iter1733)
      {
        xfer += oprot->writeI32(static_cast<int32_t>((*_iter1733)));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetOpenTxnsRequest &a, GetOpenTxnsRequest &b) {
  using ::std::swap;
  swap(a.excludeTxnTypes, b.excludeTxnTypes);
  swap(a.__isset, b.__isset);
}

GetOpenTxnsRequest::GetOpenTxnsRequest(const GetOpenTxnsRequest& other1734) {
  excludeTxnTypes = other1734.excludeTxnTypes;
  __isset = other1734.__isset;
}
GetOpenTxnsRequest& GetOpenTxnsRequest::operator=(const GetOpenTxnsRequest& other1735) {
  excludeTxnTypes = other1735.excludeTxnTypes;
  __isset = other1735.__isset;
  return *this;
}
void GetOpenTxnsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetOpenTxnsRequest(";
  out << "excludeTxnTypes="; (__isset.excludeTxnTypes ? (out << to_string(excludeTxnTypes)) : (out << "<null>"));
  out << ")";
}


StoredProcedureRequest::~StoredProcedureRequest() noexcept {
}


void StoredProcedureRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void StoredProcedureRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void StoredProcedureRequest::__set_procName(const std::string& val) {
  this->procName = val;
}
std::ostream& operator<<(std::ostream& out, const StoredProcedureRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StoredProcedureRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catName = false;
  bool isset_dbName = false;
  bool isset_procName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->procName);
          isset_procName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_procName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t StoredProcedureRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StoredProcedureRequest");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("procName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->procName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StoredProcedureRequest &a, StoredProcedureRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.procName, b.procName);
}

StoredProcedureRequest::StoredProcedureRequest(const StoredProcedureRequest& other1736) {
  catName = other1736.catName;
  dbName = other1736.dbName;
  procName = other1736.procName;
}
StoredProcedureRequest& StoredProcedureRequest::operator=(const StoredProcedureRequest& other1737) {
  catName = other1737.catName;
  dbName = other1737.dbName;
  procName = other1737.procName;
  return *this;
}
void StoredProcedureRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StoredProcedureRequest(";
  out << "catName=" << to_string(catName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "procName=" << to_string(procName);
  out << ")";
}


ListStoredProcedureRequest::~ListStoredProcedureRequest() noexcept {
}


void ListStoredProcedureRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void ListStoredProcedureRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
__isset.dbName = true;
}
std::ostream& operator<<(std::ostream& out, const ListStoredProcedureRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ListStoredProcedureRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ListStoredProcedureRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListStoredProcedureRequest");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dbName) {
    xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->dbName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListStoredProcedureRequest &a, ListStoredProcedureRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.__isset, b.__isset);
}

ListStoredProcedureRequest::ListStoredProcedureRequest(const ListStoredProcedureRequest& other1738) {
  catName = other1738.catName;
  dbName = other1738.dbName;
  __isset = other1738.__isset;
}
ListStoredProcedureRequest& ListStoredProcedureRequest::operator=(const ListStoredProcedureRequest& other1739) {
  catName = other1739.catName;
  dbName = other1739.dbName;
  __isset = other1739.__isset;
  return *this;
}
void ListStoredProcedureRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListStoredProcedureRequest(";
  out << "catName=" << to_string(catName);
  out << ", " << "dbName="; (__isset.dbName ? (out << to_string(dbName)) : (out << "<null>"));
  out << ")";
}


StoredProcedure::~StoredProcedure() noexcept {
}


void StoredProcedure::__set_name(const std::string& val) {
  this->name = val;
}

void StoredProcedure::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void StoredProcedure::__set_catName(const std::string& val) {
  this->catName = val;
}

void StoredProcedure::__set_ownerName(const std::string& val) {
  this->ownerName = val;
}

void StoredProcedure::__set_source(const std::string& val) {
  this->source = val;
}
std::ostream& operator<<(std::ostream& out, const StoredProcedure& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StoredProcedure::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->source);
          this->__isset.source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StoredProcedure::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StoredProcedure");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->ownerName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("source", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->source);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StoredProcedure &a, StoredProcedure &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.dbName, b.dbName);
  swap(a.catName, b.catName);
  swap(a.ownerName, b.ownerName);
  swap(a.source, b.source);
  swap(a.__isset, b.__isset);
}

StoredProcedure::StoredProcedure(const StoredProcedure& other1740) {
  name = other1740.name;
  dbName = other1740.dbName;
  catName = other1740.catName;
  ownerName = other1740.ownerName;
  source = other1740.source;
  __isset = other1740.__isset;
}
StoredProcedure& StoredProcedure::operator=(const StoredProcedure& other1741) {
  name = other1741.name;
  dbName = other1741.dbName;
  catName = other1741.catName;
  ownerName = other1741.ownerName;
  source = other1741.source;
  __isset = other1741.__isset;
  return *this;
}
void StoredProcedure::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StoredProcedure(";
  out << "name=" << to_string(name);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "catName=" << to_string(catName);
  out << ", " << "ownerName=" << to_string(ownerName);
  out << ", " << "source=" << to_string(source);
  out << ")";
}


AddPackageRequest::~AddPackageRequest() noexcept {
}


void AddPackageRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void AddPackageRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void AddPackageRequest::__set_packageName(const std::string& val) {
  this->packageName = val;
}

void AddPackageRequest::__set_ownerName(const std::string& val) {
  this->ownerName = val;
}

void AddPackageRequest::__set_header(const std::string& val) {
  this->header = val;
}

void AddPackageRequest::__set_body(const std::string& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const AddPackageRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddPackageRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->packageName);
          this->__isset.packageName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->header);
          this->__isset.header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->body);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AddPackageRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddPackageRequest");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("packageName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->packageName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->ownerName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("header", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->header);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->body);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddPackageRequest &a, AddPackageRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.packageName, b.packageName);
  swap(a.ownerName, b.ownerName);
  swap(a.header, b.header);
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

AddPackageRequest::AddPackageRequest(const AddPackageRequest& other1742) {
  catName = other1742.catName;
  dbName = other1742.dbName;
  packageName = other1742.packageName;
  ownerName = other1742.ownerName;
  header = other1742.header;
  body = other1742.body;
  __isset = other1742.__isset;
}
AddPackageRequest& AddPackageRequest::operator=(const AddPackageRequest& other1743) {
  catName = other1743.catName;
  dbName = other1743.dbName;
  packageName = other1743.packageName;
  ownerName = other1743.ownerName;
  header = other1743.header;
  body = other1743.body;
  __isset = other1743.__isset;
  return *this;
}
void AddPackageRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddPackageRequest(";
  out << "catName=" << to_string(catName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "packageName=" << to_string(packageName);
  out << ", " << "ownerName=" << to_string(ownerName);
  out << ", " << "header=" << to_string(header);
  out << ", " << "body=" << to_string(body);
  out << ")";
}


GetPackageRequest::~GetPackageRequest() noexcept {
}


void GetPackageRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void GetPackageRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void GetPackageRequest::__set_packageName(const std::string& val) {
  this->packageName = val;
}
std::ostream& operator<<(std::ostream& out, const GetPackageRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPackageRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catName = false;
  bool isset_dbName = false;
  bool isset_packageName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->packageName);
          isset_packageName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_packageName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPackageRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPackageRequest");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("packageName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->packageName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPackageRequest &a, GetPackageRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.packageName, b.packageName);
}

GetPackageRequest::GetPackageRequest(const GetPackageRequest& other1744) {
  catName = other1744.catName;
  dbName = other1744.dbName;
  packageName = other1744.packageName;
}
GetPackageRequest& GetPackageRequest::operator=(const GetPackageRequest& other1745) {
  catName = other1745.catName;
  dbName = other1745.dbName;
  packageName = other1745.packageName;
  return *this;
}
void GetPackageRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPackageRequest(";
  out << "catName=" << to_string(catName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "packageName=" << to_string(packageName);
  out << ")";
}


DropPackageRequest::~DropPackageRequest() noexcept {
}


void DropPackageRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void DropPackageRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void DropPackageRequest::__set_packageName(const std::string& val) {
  this->packageName = val;
}
std::ostream& operator<<(std::ostream& out, const DropPackageRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropPackageRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catName = false;
  bool isset_dbName = false;
  bool isset_packageName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->packageName);
          isset_packageName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_packageName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DropPackageRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropPackageRequest");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("packageName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->packageName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropPackageRequest &a, DropPackageRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.packageName, b.packageName);
}

DropPackageRequest::DropPackageRequest(const DropPackageRequest& other1746) {
  catName = other1746.catName;
  dbName = other1746.dbName;
  packageName = other1746.packageName;
}
DropPackageRequest& DropPackageRequest::operator=(const DropPackageRequest& other1747) {
  catName = other1747.catName;
  dbName = other1747.dbName;
  packageName = other1747.packageName;
  return *this;
}
void DropPackageRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropPackageRequest(";
  out << "catName=" << to_string(catName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "packageName=" << to_string(packageName);
  out << ")";
}


ListPackageRequest::~ListPackageRequest() noexcept {
}


void ListPackageRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void ListPackageRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
__isset.dbName = true;
}
std::ostream& operator<<(std::ostream& out, const ListPackageRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ListPackageRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ListPackageRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListPackageRequest");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dbName) {
    xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->dbName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListPackageRequest &a, ListPackageRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.__isset, b.__isset);
}

ListPackageRequest::ListPackageRequest(const ListPackageRequest& other1748) {
  catName = other1748.catName;
  dbName = other1748.dbName;
  __isset = other1748.__isset;
}
ListPackageRequest& ListPackageRequest::operator=(const ListPackageRequest& other1749) {
  catName = other1749.catName;
  dbName = other1749.dbName;
  __isset = other1749.__isset;
  return *this;
}
void ListPackageRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListPackageRequest(";
  out << "catName=" << to_string(catName);
  out << ", " << "dbName="; (__isset.dbName ? (out << to_string(dbName)) : (out << "<null>"));
  out << ")";
}


Package::~Package() noexcept {
}


void Package::__set_catName(const std::string& val) {
  this->catName = val;
}

void Package::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void Package::__set_packageName(const std::string& val) {
  this->packageName = val;
}

void Package::__set_ownerName(const std::string& val) {
  this->ownerName = val;
}

void Package::__set_header(const std::string& val) {
  this->header = val;
}

void Package::__set_body(const std::string& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const Package& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Package::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->packageName);
          this->__isset.packageName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->header);
          this->__isset.header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->body);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Package::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Package");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("packageName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->packageName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->ownerName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("header", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->header);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->body);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Package &a, Package &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.packageName, b.packageName);
  swap(a.ownerName, b.ownerName);
  swap(a.header, b.header);
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

Package::Package(const Package& other1750) {
  catName = other1750.catName;
  dbName = other1750.dbName;
  packageName = other1750.packageName;
  ownerName = other1750.ownerName;
  header = other1750.header;
  body = other1750.body;
  __isset = other1750.__isset;
}
Package& Package::operator=(const Package& other1751) {
  catName = other1751.catName;
  dbName = other1751.dbName;
  packageName = other1751.packageName;
  ownerName = other1751.ownerName;
  header = other1751.header;
  body = other1751.body;
  __isset = other1751.__isset;
  return *this;
}
void Package::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Package(";
  out << "catName=" << to_string(catName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "packageName=" << to_string(packageName);
  out << ", " << "ownerName=" << to_string(ownerName);
  out << ", " << "header=" << to_string(header);
  out << ", " << "body=" << to_string(body);
  out << ")";
}


GetAllWriteEventInfoRequest::~GetAllWriteEventInfoRequest() noexcept {
}


void GetAllWriteEventInfoRequest::__set_txnId(const int64_t val) {
  this->txnId = val;
}

void GetAllWriteEventInfoRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
__isset.dbName = true;
}

void GetAllWriteEventInfoRequest::__set_tableName(const std::string& val) {
  this->tableName = val;
__isset.tableName = true;
}
std::ostream& operator<<(std::ostream& out, const GetAllWriteEventInfoRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetAllWriteEventInfoRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txnId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnId);
          isset_txnId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txnId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetAllWriteEventInfoRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetAllWriteEventInfoRequest");

  xfer += oprot->writeFieldBegin("txnId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txnId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dbName) {
    xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->dbName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableName) {
    xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->tableName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetAllWriteEventInfoRequest &a, GetAllWriteEventInfoRequest &b) {
  using ::std::swap;
  swap(a.txnId, b.txnId);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.__isset, b.__isset);
}

GetAllWriteEventInfoRequest::GetAllWriteEventInfoRequest(const GetAllWriteEventInfoRequest& other1752) {
  txnId = other1752.txnId;
  dbName = other1752.dbName;
  tableName = other1752.tableName;
  __isset = other1752.__isset;
}
GetAllWriteEventInfoRequest& GetAllWriteEventInfoRequest::operator=(const GetAllWriteEventInfoRequest& other1753) {
  txnId = other1753.txnId;
  dbName = other1753.dbName;
  tableName = other1753.tableName;
  __isset = other1753.__isset;
  return *this;
}
void GetAllWriteEventInfoRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetAllWriteEventInfoRequest(";
  out << "txnId=" << to_string(txnId);
  out << ", " << "dbName="; (__isset.dbName ? (out << to_string(dbName)) : (out << "<null>"));
  out << ", " << "tableName="; (__isset.tableName ? (out << to_string(tableName)) : (out << "<null>"));
  out << ")";
}


MetaException::~MetaException() noexcept {
}


void MetaException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const MetaException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MetaException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MetaException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MetaException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MetaException &a, MetaException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

MetaException::MetaException(const MetaException& other1754) : TException() {
  message = other1754.message;
  __isset = other1754.__isset;
}
MetaException& MetaException::operator=(const MetaException& other1755) {
  message = other1755.message;
  __isset = other1755.__isset;
  return *this;
}
void MetaException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MetaException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* MetaException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: MetaException";
  }
}


UnknownTableException::~UnknownTableException() noexcept {
}


void UnknownTableException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const UnknownTableException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UnknownTableException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnknownTableException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnknownTableException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnknownTableException &a, UnknownTableException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

UnknownTableException::UnknownTableException(const UnknownTableException& other1756) : TException() {
  message = other1756.message;
  __isset = other1756.__isset;
}
UnknownTableException& UnknownTableException::operator=(const UnknownTableException& other1757) {
  message = other1757.message;
  __isset = other1757.__isset;
  return *this;
}
void UnknownTableException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnknownTableException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* UnknownTableException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UnknownTableException";
  }
}


UnknownDBException::~UnknownDBException() noexcept {
}


void UnknownDBException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const UnknownDBException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UnknownDBException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnknownDBException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnknownDBException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnknownDBException &a, UnknownDBException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

UnknownDBException::UnknownDBException(const UnknownDBException& other1758) : TException() {
  message = other1758.message;
  __isset = other1758.__isset;
}
UnknownDBException& UnknownDBException::operator=(const UnknownDBException& other1759) {
  message = other1759.message;
  __isset = other1759.__isset;
  return *this;
}
void UnknownDBException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnknownDBException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* UnknownDBException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UnknownDBException";
  }
}


AlreadyExistsException::~AlreadyExistsException() noexcept {
}


void AlreadyExistsException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const AlreadyExistsException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AlreadyExistsException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlreadyExistsException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AlreadyExistsException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlreadyExistsException &a, AlreadyExistsException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

AlreadyExistsException::AlreadyExistsException(const AlreadyExistsException& other1760) : TException() {
  message = other1760.message;
  __isset = other1760.__isset;
}
AlreadyExistsException& AlreadyExistsException::operator=(const AlreadyExistsException& other1761) {
  message = other1761.message;
  __isset = other1761.__isset;
  return *this;
}
void AlreadyExistsException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AlreadyExistsException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* AlreadyExistsException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: AlreadyExistsException";
  }
}


InvalidPartitionException::~InvalidPartitionException() noexcept {
}


void InvalidPartitionException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidPartitionException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidPartitionException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidPartitionException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidPartitionException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidPartitionException &a, InvalidPartitionException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

InvalidPartitionException::InvalidPartitionException(const InvalidPartitionException& other1762) : TException() {
  message = other1762.message;
  __isset = other1762.__isset;
}
InvalidPartitionException& InvalidPartitionException::operator=(const InvalidPartitionException& other1763) {
  message = other1763.message;
  __isset = other1763.__isset;
  return *this;
}
void InvalidPartitionException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidPartitionException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* InvalidPartitionException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidPartitionException";
  }
}


UnknownPartitionException::~UnknownPartitionException() noexcept {
}


void UnknownPartitionException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const UnknownPartitionException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UnknownPartitionException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnknownPartitionException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnknownPartitionException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnknownPartitionException &a, UnknownPartitionException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

UnknownPartitionException::UnknownPartitionException(const UnknownPartitionException& other1764) : TException() {
  message = other1764.message;
  __isset = other1764.__isset;
}
UnknownPartitionException& UnknownPartitionException::operator=(const UnknownPartitionException& other1765) {
  message = other1765.message;
  __isset = other1765.__isset;
  return *this;
}
void UnknownPartitionException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnknownPartitionException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* UnknownPartitionException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UnknownPartitionException";
  }
}


InvalidObjectException::~InvalidObjectException() noexcept {
}


void InvalidObjectException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidObjectException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidObjectException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidObjectException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidObjectException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidObjectException &a, InvalidObjectException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

InvalidObjectException::InvalidObjectException(const InvalidObjectException& other1766) : TException() {
  message = other1766.message;
  __isset = other1766.__isset;
}
InvalidObjectException& InvalidObjectException::operator=(const InvalidObjectException& other1767) {
  message = other1767.message;
  __isset = other1767.__isset;
  return *this;
}
void InvalidObjectException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidObjectException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* InvalidObjectException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidObjectException";
  }
}


NoSuchObjectException::~NoSuchObjectException() noexcept {
}


void NoSuchObjectException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const NoSuchObjectException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NoSuchObjectException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchObjectException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchObjectException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchObjectException &a, NoSuchObjectException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoSuchObjectException::NoSuchObjectException(const NoSuchObjectException& other1768) : TException() {
  message = other1768.message;
  __isset = other1768.__isset;
}
NoSuchObjectException& NoSuchObjectException::operator=(const NoSuchObjectException& other1769) {
  message = other1769.message;
  __isset = other1769.__isset;
  return *this;
}
void NoSuchObjectException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchObjectException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* NoSuchObjectException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchObjectException";
  }
}


InvalidOperationException::~InvalidOperationException() noexcept {
}


void InvalidOperationException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidOperationException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidOperationException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidOperationException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidOperationException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidOperationException &a, InvalidOperationException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

InvalidOperationException::InvalidOperationException(const InvalidOperationException& other1770) : TException() {
  message = other1770.message;
  __isset = other1770.__isset;
}
InvalidOperationException& InvalidOperationException::operator=(const InvalidOperationException& other1771) {
  message = other1771.message;
  __isset = other1771.__isset;
  return *this;
}
void InvalidOperationException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidOperationException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* InvalidOperationException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidOperationException";
  }
}


ConfigValSecurityException::~ConfigValSecurityException() noexcept {
}


void ConfigValSecurityException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const ConfigValSecurityException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ConfigValSecurityException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConfigValSecurityException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ConfigValSecurityException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ConfigValSecurityException &a, ConfigValSecurityException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

ConfigValSecurityException::ConfigValSecurityException(const ConfigValSecurityException& other1772) : TException() {
  message = other1772.message;
  __isset = other1772.__isset;
}
ConfigValSecurityException& ConfigValSecurityException::operator=(const ConfigValSecurityException& other1773) {
  message = other1773.message;
  __isset = other1773.__isset;
  return *this;
}
void ConfigValSecurityException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ConfigValSecurityException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* ConfigValSecurityException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: ConfigValSecurityException";
  }
}


InvalidInputException::~InvalidInputException() noexcept {
}


void InvalidInputException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidInputException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidInputException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidInputException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidInputException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidInputException &a, InvalidInputException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

InvalidInputException::InvalidInputException(const InvalidInputException& other1774) : TException() {
  message = other1774.message;
  __isset = other1774.__isset;
}
InvalidInputException& InvalidInputException::operator=(const InvalidInputException& other1775) {
  message = other1775.message;
  __isset = other1775.__isset;
  return *this;
}
void InvalidInputException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidInputException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* InvalidInputException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidInputException";
  }
}


NoSuchTxnException::~NoSuchTxnException() noexcept {
}


void NoSuchTxnException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const NoSuchTxnException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NoSuchTxnException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchTxnException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchTxnException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchTxnException &a, NoSuchTxnException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoSuchTxnException::NoSuchTxnException(const NoSuchTxnException& other1776) : TException() {
  message = other1776.message;
  __isset = other1776.__isset;
}
NoSuchTxnException& NoSuchTxnException::operator=(const NoSuchTxnException& other1777) {
  message = other1777.message;
  __isset = other1777.__isset;
  return *this;
}
void NoSuchTxnException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchTxnException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* NoSuchTxnException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchTxnException";
  }
}


TxnAbortedException::~TxnAbortedException() noexcept {
}


void TxnAbortedException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const TxnAbortedException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TxnAbortedException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TxnAbortedException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TxnAbortedException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TxnAbortedException &a, TxnAbortedException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

TxnAbortedException::TxnAbortedException(const TxnAbortedException& other1778) : TException() {
  message = other1778.message;
  __isset = other1778.__isset;
}
TxnAbortedException& TxnAbortedException::operator=(const TxnAbortedException& other1779) {
  message = other1779.message;
  __isset = other1779.__isset;
  return *this;
}
void TxnAbortedException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TxnAbortedException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* TxnAbortedException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TxnAbortedException";
  }
}


TxnOpenException::~TxnOpenException() noexcept {
}


void TxnOpenException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const TxnOpenException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TxnOpenException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TxnOpenException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TxnOpenException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TxnOpenException &a, TxnOpenException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

TxnOpenException::TxnOpenException(const TxnOpenException& other1780) : TException() {
  message = other1780.message;
  __isset = other1780.__isset;
}
TxnOpenException& TxnOpenException::operator=(const TxnOpenException& other1781) {
  message = other1781.message;
  __isset = other1781.__isset;
  return *this;
}
void TxnOpenException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TxnOpenException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* TxnOpenException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TxnOpenException";
  }
}


NoSuchLockException::~NoSuchLockException() noexcept {
}


void NoSuchLockException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const NoSuchLockException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NoSuchLockException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchLockException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchLockException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchLockException &a, NoSuchLockException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoSuchLockException::NoSuchLockException(const NoSuchLockException& other1782) : TException() {
  message = other1782.message;
  __isset = other1782.__isset;
}
NoSuchLockException& NoSuchLockException::operator=(const NoSuchLockException& other1783) {
  message = other1783.message;
  __isset = other1783.__isset;
  return *this;
}
void NoSuchLockException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchLockException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* NoSuchLockException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchLockException";
  }
}


CompactionAbortedException::~CompactionAbortedException() noexcept {
}


void CompactionAbortedException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const CompactionAbortedException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CompactionAbortedException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CompactionAbortedException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactionAbortedException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactionAbortedException &a, CompactionAbortedException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

CompactionAbortedException::CompactionAbortedException(const CompactionAbortedException& other1784) : TException() {
  message = other1784.message;
  __isset = other1784.__isset;
}
CompactionAbortedException& CompactionAbortedException::operator=(const CompactionAbortedException& other1785) {
  message = other1785.message;
  __isset = other1785.__isset;
  return *this;
}
void CompactionAbortedException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactionAbortedException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* CompactionAbortedException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: CompactionAbortedException";
  }
}


NoSuchCompactionException::~NoSuchCompactionException() noexcept {
}


void NoSuchCompactionException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const NoSuchCompactionException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NoSuchCompactionException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchCompactionException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchCompactionException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchCompactionException &a, NoSuchCompactionException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoSuchCompactionException::NoSuchCompactionException(const NoSuchCompactionException& other1786) : TException() {
  message = other1786.message;
  __isset = other1786.__isset;
}
NoSuchCompactionException& NoSuchCompactionException::operator=(const NoSuchCompactionException& other1787) {
  message = other1787.message;
  __isset = other1787.__isset;
  return *this;
}
void NoSuchCompactionException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchCompactionException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* NoSuchCompactionException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchCompactionException";
  }
}

}}} // namespace
