/**
 * Autogenerated by Thrift Compiler (0.14.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "hive_metastore_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace Apache { namespace Hadoop { namespace Hive {

int _kHiveObjectTypeValues[] = {
  HiveObjectType::GLOBAL,
  HiveObjectType::DATABASE,
  HiveObjectType::TABLE,
  HiveObjectType::PARTITION,
  HiveObjectType::COLUMN
};
const char* _kHiveObjectTypeNames[] = {
  "GLOBAL",
  "DATABASE",
  "TABLE",
  "PARTITION",
  "COLUMN"
};
const std::map<int, const char*> _HiveObjectType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kHiveObjectTypeValues, _kHiveObjectTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const HiveObjectType::type& val) {
  std::map<int, const char*>::const_iterator it = _HiveObjectType_VALUES_TO_NAMES.find(val);
  if (it != _HiveObjectType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const HiveObjectType::type& val) {
  std::map<int, const char*>::const_iterator it = _HiveObjectType_VALUES_TO_NAMES.find(val);
  if (it != _HiveObjectType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kPrincipalTypeValues[] = {
  PrincipalType::USER,
  PrincipalType::ROLE,
  PrincipalType::GROUP
};
const char* _kPrincipalTypeNames[] = {
  "USER",
  "ROLE",
  "GROUP"
};
const std::map<int, const char*> _PrincipalType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kPrincipalTypeValues, _kPrincipalTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const PrincipalType::type& val) {
  std::map<int, const char*>::const_iterator it = _PrincipalType_VALUES_TO_NAMES.find(val);
  if (it != _PrincipalType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PrincipalType::type& val) {
  std::map<int, const char*>::const_iterator it = _PrincipalType_VALUES_TO_NAMES.find(val);
  if (it != _PrincipalType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kPartitionEventTypeValues[] = {
  PartitionEventType::LOAD_DONE
};
const char* _kPartitionEventTypeNames[] = {
  "LOAD_DONE"
};
const std::map<int, const char*> _PartitionEventType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kPartitionEventTypeValues, _kPartitionEventTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const PartitionEventType::type& val) {
  std::map<int, const char*>::const_iterator it = _PartitionEventType_VALUES_TO_NAMES.find(val);
  if (it != _PartitionEventType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PartitionEventType::type& val) {
  std::map<int, const char*>::const_iterator it = _PartitionEventType_VALUES_TO_NAMES.find(val);
  if (it != _PartitionEventType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTxnStateValues[] = {
  TxnState::COMMITTED,
  TxnState::ABORTED,
  TxnState::OPEN
};
const char* _kTxnStateNames[] = {
  "COMMITTED",
  "ABORTED",
  "OPEN"
};
const std::map<int, const char*> _TxnState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTxnStateValues, _kTxnStateNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TxnState::type& val) {
  std::map<int, const char*>::const_iterator it = _TxnState_VALUES_TO_NAMES.find(val);
  if (it != _TxnState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TxnState::type& val) {
  std::map<int, const char*>::const_iterator it = _TxnState_VALUES_TO_NAMES.find(val);
  if (it != _TxnState_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kLockLevelValues[] = {
  LockLevel::DB,
  LockLevel::TABLE,
  LockLevel::PARTITION
};
const char* _kLockLevelNames[] = {
  "DB",
  "TABLE",
  "PARTITION"
};
const std::map<int, const char*> _LockLevel_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kLockLevelValues, _kLockLevelNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const LockLevel::type& val) {
  std::map<int, const char*>::const_iterator it = _LockLevel_VALUES_TO_NAMES.find(val);
  if (it != _LockLevel_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const LockLevel::type& val) {
  std::map<int, const char*>::const_iterator it = _LockLevel_VALUES_TO_NAMES.find(val);
  if (it != _LockLevel_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kLockStateValues[] = {
  LockState::ACQUIRED,
  LockState::WAITING,
  LockState::ABORT,
  LockState::NOT_ACQUIRED
};
const char* _kLockStateNames[] = {
  "ACQUIRED",
  "WAITING",
  "ABORT",
  "NOT_ACQUIRED"
};
const std::map<int, const char*> _LockState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kLockStateValues, _kLockStateNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const LockState::type& val) {
  std::map<int, const char*>::const_iterator it = _LockState_VALUES_TO_NAMES.find(val);
  if (it != _LockState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const LockState::type& val) {
  std::map<int, const char*>::const_iterator it = _LockState_VALUES_TO_NAMES.find(val);
  if (it != _LockState_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kLockTypeValues[] = {
  LockType::SHARED_READ,
  LockType::SHARED_WRITE,
  LockType::EXCLUSIVE,
  LockType::EXCL_WRITE
};
const char* _kLockTypeNames[] = {
  "SHARED_READ",
  "SHARED_WRITE",
  "EXCLUSIVE",
  "EXCL_WRITE"
};
const std::map<int, const char*> _LockType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kLockTypeValues, _kLockTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const LockType::type& val) {
  std::map<int, const char*>::const_iterator it = _LockType_VALUES_TO_NAMES.find(val);
  if (it != _LockType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const LockType::type& val) {
  std::map<int, const char*>::const_iterator it = _LockType_VALUES_TO_NAMES.find(val);
  if (it != _LockType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCompactionTypeValues[] = {
  CompactionType::MINOR,
  CompactionType::MAJOR
};
const char* _kCompactionTypeNames[] = {
  "MINOR",
  "MAJOR"
};
const std::map<int, const char*> _CompactionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kCompactionTypeValues, _kCompactionTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const CompactionType::type& val) {
  std::map<int, const char*>::const_iterator it = _CompactionType_VALUES_TO_NAMES.find(val);
  if (it != _CompactionType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const CompactionType::type& val) {
  std::map<int, const char*>::const_iterator it = _CompactionType_VALUES_TO_NAMES.find(val);
  if (it != _CompactionType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kGrantRevokeTypeValues[] = {
  GrantRevokeType::GRANT,
  GrantRevokeType::REVOKE
};
const char* _kGrantRevokeTypeNames[] = {
  "GRANT",
  "REVOKE"
};
const std::map<int, const char*> _GrantRevokeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kGrantRevokeTypeValues, _kGrantRevokeTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const GrantRevokeType::type& val) {
  std::map<int, const char*>::const_iterator it = _GrantRevokeType_VALUES_TO_NAMES.find(val);
  if (it != _GrantRevokeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const GrantRevokeType::type& val) {
  std::map<int, const char*>::const_iterator it = _GrantRevokeType_VALUES_TO_NAMES.find(val);
  if (it != _GrantRevokeType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kDataOperationTypeValues[] = {
  DataOperationType::SELECT,
  DataOperationType::INSERT,
  DataOperationType::UPDATE,
  DataOperationType::DELETE,
  DataOperationType::UNSET,
  DataOperationType::NO_TXN
};
const char* _kDataOperationTypeNames[] = {
  "SELECT",
  "INSERT",
  "UPDATE",
  "DELETE",
  "UNSET",
  "NO_TXN"
};
const std::map<int, const char*> _DataOperationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kDataOperationTypeValues, _kDataOperationTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const DataOperationType::type& val) {
  std::map<int, const char*>::const_iterator it = _DataOperationType_VALUES_TO_NAMES.find(val);
  if (it != _DataOperationType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const DataOperationType::type& val) {
  std::map<int, const char*>::const_iterator it = _DataOperationType_VALUES_TO_NAMES.find(val);
  if (it != _DataOperationType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kEventRequestTypeValues[] = {
  EventRequestType::INSERT,
  EventRequestType::UPDATE,
  EventRequestType::DELETE
};
const char* _kEventRequestTypeNames[] = {
  "INSERT",
  "UPDATE",
  "DELETE"
};
const std::map<int, const char*> _EventRequestType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kEventRequestTypeValues, _kEventRequestTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const EventRequestType::type& val) {
  std::map<int, const char*>::const_iterator it = _EventRequestType_VALUES_TO_NAMES.find(val);
  if (it != _EventRequestType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const EventRequestType::type& val) {
  std::map<int, const char*>::const_iterator it = _EventRequestType_VALUES_TO_NAMES.find(val);
  if (it != _EventRequestType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSerdeTypeValues[] = {
  SerdeType::HIVE,
  SerdeType::SCHEMA_REGISTRY
};
const char* _kSerdeTypeNames[] = {
  "HIVE",
  "SCHEMA_REGISTRY"
};
const std::map<int, const char*> _SerdeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kSerdeTypeValues, _kSerdeTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SerdeType::type& val) {
  std::map<int, const char*>::const_iterator it = _SerdeType_VALUES_TO_NAMES.find(val);
  if (it != _SerdeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SerdeType::type& val) {
  std::map<int, const char*>::const_iterator it = _SerdeType_VALUES_TO_NAMES.find(val);
  if (it != _SerdeType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSchemaTypeValues[] = {
  SchemaType::HIVE,
  SchemaType::AVRO
};
const char* _kSchemaTypeNames[] = {
  "HIVE",
  "AVRO"
};
const std::map<int, const char*> _SchemaType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kSchemaTypeValues, _kSchemaTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SchemaType::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaType_VALUES_TO_NAMES.find(val);
  if (it != _SchemaType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SchemaType::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaType_VALUES_TO_NAMES.find(val);
  if (it != _SchemaType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSchemaCompatibilityValues[] = {
  SchemaCompatibility::NONE,
  SchemaCompatibility::BACKWARD,
  SchemaCompatibility::FORWARD,
  SchemaCompatibility::BOTH
};
const char* _kSchemaCompatibilityNames[] = {
  "NONE",
  "BACKWARD",
  "FORWARD",
  "BOTH"
};
const std::map<int, const char*> _SchemaCompatibility_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kSchemaCompatibilityValues, _kSchemaCompatibilityNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SchemaCompatibility::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaCompatibility_VALUES_TO_NAMES.find(val);
  if (it != _SchemaCompatibility_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SchemaCompatibility::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaCompatibility_VALUES_TO_NAMES.find(val);
  if (it != _SchemaCompatibility_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSchemaValidationValues[] = {
  SchemaValidation::LATEST,
  SchemaValidation::ALL
};
const char* _kSchemaValidationNames[] = {
  "LATEST",
  "ALL"
};
const std::map<int, const char*> _SchemaValidation_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kSchemaValidationValues, _kSchemaValidationNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SchemaValidation::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaValidation_VALUES_TO_NAMES.find(val);
  if (it != _SchemaValidation_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SchemaValidation::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaValidation_VALUES_TO_NAMES.find(val);
  if (it != _SchemaValidation_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSchemaVersionStateValues[] = {
  SchemaVersionState::INITIATED,
  SchemaVersionState::START_REVIEW,
  SchemaVersionState::CHANGES_REQUIRED,
  SchemaVersionState::REVIEWED,
  SchemaVersionState::ENABLED,
  SchemaVersionState::DISABLED,
  SchemaVersionState::ARCHIVED,
  SchemaVersionState::DELETED
};
const char* _kSchemaVersionStateNames[] = {
  "INITIATED",
  "START_REVIEW",
  "CHANGES_REQUIRED",
  "REVIEWED",
  "ENABLED",
  "DISABLED",
  "ARCHIVED",
  "DELETED"
};
const std::map<int, const char*> _SchemaVersionState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kSchemaVersionStateValues, _kSchemaVersionStateNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SchemaVersionState::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaVersionState_VALUES_TO_NAMES.find(val);
  if (it != _SchemaVersionState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SchemaVersionState::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaVersionState_VALUES_TO_NAMES.find(val);
  if (it != _SchemaVersionState_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kDatabaseTypeValues[] = {
  DatabaseType::NATIVE,
  DatabaseType::REMOTE
};
const char* _kDatabaseTypeNames[] = {
  "NATIVE",
  "REMOTE"
};
const std::map<int, const char*> _DatabaseType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kDatabaseTypeValues, _kDatabaseTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const DatabaseType::type& val) {
  std::map<int, const char*>::const_iterator it = _DatabaseType_VALUES_TO_NAMES.find(val);
  if (it != _DatabaseType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const DatabaseType::type& val) {
  std::map<int, const char*>::const_iterator it = _DatabaseType_VALUES_TO_NAMES.find(val);
  if (it != _DatabaseType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kFunctionTypeValues[] = {
  FunctionType::JAVA
};
const char* _kFunctionTypeNames[] = {
  "JAVA"
};
const std::map<int, const char*> _FunctionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kFunctionTypeValues, _kFunctionTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const FunctionType::type& val) {
  std::map<int, const char*>::const_iterator it = _FunctionType_VALUES_TO_NAMES.find(val);
  if (it != _FunctionType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const FunctionType::type& val) {
  std::map<int, const char*>::const_iterator it = _FunctionType_VALUES_TO_NAMES.find(val);
  if (it != _FunctionType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kResourceTypeValues[] = {
  ResourceType::JAR,
  ResourceType::FILE,
  ResourceType::ARCHIVE
};
const char* _kResourceTypeNames[] = {
  "JAR",
  "FILE",
  "ARCHIVE"
};
const std::map<int, const char*> _ResourceType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kResourceTypeValues, _kResourceTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ResourceType::type& val) {
  std::map<int, const char*>::const_iterator it = _ResourceType_VALUES_TO_NAMES.find(val);
  if (it != _ResourceType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ResourceType::type& val) {
  std::map<int, const char*>::const_iterator it = _ResourceType_VALUES_TO_NAMES.find(val);
  if (it != _ResourceType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTxnTypeValues[] = {
  TxnType::DEFAULT,
  TxnType::REPL_CREATED,
  TxnType::READ_ONLY,
  TxnType::COMPACTION,
  TxnType::MATER_VIEW_REBUILD
};
const char* _kTxnTypeNames[] = {
  "DEFAULT",
  "REPL_CREATED",
  "READ_ONLY",
  "COMPACTION",
  "MATER_VIEW_REBUILD"
};
const std::map<int, const char*> _TxnType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTxnTypeValues, _kTxnTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TxnType::type& val) {
  std::map<int, const char*>::const_iterator it = _TxnType_VALUES_TO_NAMES.find(val);
  if (it != _TxnType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TxnType::type& val) {
  std::map<int, const char*>::const_iterator it = _TxnType_VALUES_TO_NAMES.find(val);
  if (it != _TxnType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kGetTablesExtRequestFieldsValues[] = {
  GetTablesExtRequestFields::ACCESS_TYPE,
  GetTablesExtRequestFields::PROCESSOR_CAPABILITIES,
  GetTablesExtRequestFields::ALL
};
const char* _kGetTablesExtRequestFieldsNames[] = {
  "ACCESS_TYPE",
  "PROCESSOR_CAPABILITIES",
  "ALL"
};
const std::map<int, const char*> _GetTablesExtRequestFields_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kGetTablesExtRequestFieldsValues, _kGetTablesExtRequestFieldsNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const GetTablesExtRequestFields::type& val) {
  std::map<int, const char*>::const_iterator it = _GetTablesExtRequestFields_VALUES_TO_NAMES.find(val);
  if (it != _GetTablesExtRequestFields_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const GetTablesExtRequestFields::type& val) {
  std::map<int, const char*>::const_iterator it = _GetTablesExtRequestFields_VALUES_TO_NAMES.find(val);
  if (it != _GetTablesExtRequestFields_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kFileMetadataExprTypeValues[] = {
  FileMetadataExprType::ORC_SARG
};
const char* _kFileMetadataExprTypeNames[] = {
  "ORC_SARG"
};
const std::map<int, const char*> _FileMetadataExprType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kFileMetadataExprTypeValues, _kFileMetadataExprTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const FileMetadataExprType::type& val) {
  std::map<int, const char*>::const_iterator it = _FileMetadataExprType_VALUES_TO_NAMES.find(val);
  if (it != _FileMetadataExprType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const FileMetadataExprType::type& val) {
  std::map<int, const char*>::const_iterator it = _FileMetadataExprType_VALUES_TO_NAMES.find(val);
  if (it != _FileMetadataExprType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kClientCapabilityValues[] = {
  ClientCapability::TEST_CAPABILITY,
  ClientCapability::INSERT_ONLY_TABLES
};
const char* _kClientCapabilityNames[] = {
  "TEST_CAPABILITY",
  "INSERT_ONLY_TABLES"
};
const std::map<int, const char*> _ClientCapability_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kClientCapabilityValues, _kClientCapabilityNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ClientCapability::type& val) {
  std::map<int, const char*>::const_iterator it = _ClientCapability_VALUES_TO_NAMES.find(val);
  if (it != _ClientCapability_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ClientCapability::type& val) {
  std::map<int, const char*>::const_iterator it = _ClientCapability_VALUES_TO_NAMES.find(val);
  if (it != _ClientCapability_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kWMResourcePlanStatusValues[] = {
  WMResourcePlanStatus::ACTIVE,
  WMResourcePlanStatus::ENABLED,
  WMResourcePlanStatus::DISABLED
};
const char* _kWMResourcePlanStatusNames[] = {
  "ACTIVE",
  "ENABLED",
  "DISABLED"
};
const std::map<int, const char*> _WMResourcePlanStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kWMResourcePlanStatusValues, _kWMResourcePlanStatusNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const WMResourcePlanStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _WMResourcePlanStatus_VALUES_TO_NAMES.find(val);
  if (it != _WMResourcePlanStatus_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const WMResourcePlanStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _WMResourcePlanStatus_VALUES_TO_NAMES.find(val);
  if (it != _WMResourcePlanStatus_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kWMPoolSchedulingPolicyValues[] = {
  WMPoolSchedulingPolicy::FAIR,
  WMPoolSchedulingPolicy::FIFO
};
const char* _kWMPoolSchedulingPolicyNames[] = {
  "FAIR",
  "FIFO"
};
const std::map<int, const char*> _WMPoolSchedulingPolicy_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kWMPoolSchedulingPolicyValues, _kWMPoolSchedulingPolicyNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const WMPoolSchedulingPolicy::type& val) {
  std::map<int, const char*>::const_iterator it = _WMPoolSchedulingPolicy_VALUES_TO_NAMES.find(val);
  if (it != _WMPoolSchedulingPolicy_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const WMPoolSchedulingPolicy::type& val) {
  std::map<int, const char*>::const_iterator it = _WMPoolSchedulingPolicy_VALUES_TO_NAMES.find(val);
  if (it != _WMPoolSchedulingPolicy_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kScheduledQueryMaintenanceRequestTypeValues[] = {
  ScheduledQueryMaintenanceRequestType::CREATE,
  ScheduledQueryMaintenanceRequestType::ALTER,
  ScheduledQueryMaintenanceRequestType::DROP
};
const char* _kScheduledQueryMaintenanceRequestTypeNames[] = {
  "CREATE",
  "ALTER",
  "DROP"
};
const std::map<int, const char*> _ScheduledQueryMaintenanceRequestType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kScheduledQueryMaintenanceRequestTypeValues, _kScheduledQueryMaintenanceRequestTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ScheduledQueryMaintenanceRequestType::type& val) {
  std::map<int, const char*>::const_iterator it = _ScheduledQueryMaintenanceRequestType_VALUES_TO_NAMES.find(val);
  if (it != _ScheduledQueryMaintenanceRequestType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ScheduledQueryMaintenanceRequestType::type& val) {
  std::map<int, const char*>::const_iterator it = _ScheduledQueryMaintenanceRequestType_VALUES_TO_NAMES.find(val);
  if (it != _ScheduledQueryMaintenanceRequestType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kQueryStateValues[] = {
  QueryState::INITED,
  QueryState::EXECUTING,
  QueryState::FAILED,
  QueryState::FINISHED,
  QueryState::TIMED_OUT,
  QueryState::AUTO_DISABLED
};
const char* _kQueryStateNames[] = {
  "INITED",
  "EXECUTING",
  "FAILED",
  "FINISHED",
  "TIMED_OUT",
  "AUTO_DISABLED"
};
const std::map<int, const char*> _QueryState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kQueryStateValues, _kQueryStateNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const QueryState::type& val) {
  std::map<int, const char*>::const_iterator it = _QueryState_VALUES_TO_NAMES.find(val);
  if (it != _QueryState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const QueryState::type& val) {
  std::map<int, const char*>::const_iterator it = _QueryState_VALUES_TO_NAMES.find(val);
  if (it != _QueryState_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kPartitionFilterModeValues[] = {
  PartitionFilterMode::BY_NAMES,
  PartitionFilterMode::BY_VALUES,
  PartitionFilterMode::BY_EXPR
};
const char* _kPartitionFilterModeNames[] = {
  "BY_NAMES",
  "BY_VALUES",
  "BY_EXPR"
};
const std::map<int, const char*> _PartitionFilterMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kPartitionFilterModeValues, _kPartitionFilterModeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const PartitionFilterMode::type& val) {
  std::map<int, const char*>::const_iterator it = _PartitionFilterMode_VALUES_TO_NAMES.find(val);
  if (it != _PartitionFilterMode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PartitionFilterMode::type& val) {
  std::map<int, const char*>::const_iterator it = _PartitionFilterMode_VALUES_TO_NAMES.find(val);
  if (it != _PartitionFilterMode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


Version::~Version() noexcept {
}


void Version::__set_version(const std::string& val) {
  this->version = val;
}

void Version::__set_comments(const std::string& val) {
  this->comments = val;
}
std::ostream& operator<<(std::ostream& out, const Version& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Version::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comments);
          this->__isset.comments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Version::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Version");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comments", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->comments);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Version &a, Version &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.comments, b.comments);
  swap(a.__isset, b.__isset);
}

Version::Version(const Version& other0) {
  version = other0.version;
  comments = other0.comments;
  __isset = other0.__isset;
}
Version& Version::operator=(const Version& other1) {
  version = other1.version;
  comments = other1.comments;
  __isset = other1.__isset;
  return *this;
}
void Version::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Version(";
  out << "version=" << to_string(version);
  out << ", " << "comments=" << to_string(comments);
  out << ")";
}


FieldSchema::~FieldSchema() noexcept {
}


void FieldSchema::__set_name(const std::string& val) {
  this->name = val;
}

void FieldSchema::__set_type(const std::string& val) {
  this->type = val;
}

void FieldSchema::__set_comment(const std::string& val) {
  this->comment = val;
}
std::ostream& operator<<(std::ostream& out, const FieldSchema& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FieldSchema::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FieldSchema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FieldSchema");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->comment);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FieldSchema &a, FieldSchema &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

FieldSchema::FieldSchema(const FieldSchema& other2) {
  name = other2.name;
  type = other2.type;
  comment = other2.comment;
  __isset = other2.__isset;
}
FieldSchema& FieldSchema::operator=(const FieldSchema& other3) {
  name = other3.name;
  type = other3.type;
  comment = other3.comment;
  __isset = other3.__isset;
  return *this;
}
void FieldSchema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FieldSchema(";
  out << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "comment=" << to_string(comment);
  out << ")";
}


SQLPrimaryKey::~SQLPrimaryKey() noexcept {
}


void SQLPrimaryKey::__set_table_db(const std::string& val) {
  this->table_db = val;
}

void SQLPrimaryKey::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void SQLPrimaryKey::__set_column_name(const std::string& val) {
  this->column_name = val;
}

void SQLPrimaryKey::__set_key_seq(const int32_t val) {
  this->key_seq = val;
}

void SQLPrimaryKey::__set_pk_name(const std::string& val) {
  this->pk_name = val;
}

void SQLPrimaryKey::__set_enable_cstr(const bool val) {
  this->enable_cstr = val;
}

void SQLPrimaryKey::__set_validate_cstr(const bool val) {
  this->validate_cstr = val;
}

void SQLPrimaryKey::__set_rely_cstr(const bool val) {
  this->rely_cstr = val;
}

void SQLPrimaryKey::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}
std::ostream& operator<<(std::ostream& out, const SQLPrimaryKey& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SQLPrimaryKey::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_db);
          this->__isset.table_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->key_seq);
          this->__isset.key_seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pk_name);
          this->__isset.pk_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable_cstr);
          this->__isset.enable_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->validate_cstr);
          this->__isset.validate_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rely_cstr);
          this->__isset.rely_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SQLPrimaryKey::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SQLPrimaryKey");

  xfer += oprot->writeFieldBegin("table_db", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->table_db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_seq", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->key_seq);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pk_name", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->pk_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable_cstr", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->enable_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validate_cstr", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->validate_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rely_cstr", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->rely_cstr);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SQLPrimaryKey &a, SQLPrimaryKey &b) {
  using ::std::swap;
  swap(a.table_db, b.table_db);
  swap(a.table_name, b.table_name);
  swap(a.column_name, b.column_name);
  swap(a.key_seq, b.key_seq);
  swap(a.pk_name, b.pk_name);
  swap(a.enable_cstr, b.enable_cstr);
  swap(a.validate_cstr, b.validate_cstr);
  swap(a.rely_cstr, b.rely_cstr);
  swap(a.catName, b.catName);
  swap(a.__isset, b.__isset);
}

SQLPrimaryKey::SQLPrimaryKey(const SQLPrimaryKey& other4) {
  table_db = other4.table_db;
  table_name = other4.table_name;
  column_name = other4.column_name;
  key_seq = other4.key_seq;
  pk_name = other4.pk_name;
  enable_cstr = other4.enable_cstr;
  validate_cstr = other4.validate_cstr;
  rely_cstr = other4.rely_cstr;
  catName = other4.catName;
  __isset = other4.__isset;
}
SQLPrimaryKey& SQLPrimaryKey::operator=(const SQLPrimaryKey& other5) {
  table_db = other5.table_db;
  table_name = other5.table_name;
  column_name = other5.column_name;
  key_seq = other5.key_seq;
  pk_name = other5.pk_name;
  enable_cstr = other5.enable_cstr;
  validate_cstr = other5.validate_cstr;
  rely_cstr = other5.rely_cstr;
  catName = other5.catName;
  __isset = other5.__isset;
  return *this;
}
void SQLPrimaryKey::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SQLPrimaryKey(";
  out << "table_db=" << to_string(table_db);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "column_name=" << to_string(column_name);
  out << ", " << "key_seq=" << to_string(key_seq);
  out << ", " << "pk_name=" << to_string(pk_name);
  out << ", " << "enable_cstr=" << to_string(enable_cstr);
  out << ", " << "validate_cstr=" << to_string(validate_cstr);
  out << ", " << "rely_cstr=" << to_string(rely_cstr);
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ")";
}


SQLForeignKey::~SQLForeignKey() noexcept {
}


void SQLForeignKey::__set_pktable_db(const std::string& val) {
  this->pktable_db = val;
}

void SQLForeignKey::__set_pktable_name(const std::string& val) {
  this->pktable_name = val;
}

void SQLForeignKey::__set_pkcolumn_name(const std::string& val) {
  this->pkcolumn_name = val;
}

void SQLForeignKey::__set_fktable_db(const std::string& val) {
  this->fktable_db = val;
}

void SQLForeignKey::__set_fktable_name(const std::string& val) {
  this->fktable_name = val;
}

void SQLForeignKey::__set_fkcolumn_name(const std::string& val) {
  this->fkcolumn_name = val;
}

void SQLForeignKey::__set_key_seq(const int32_t val) {
  this->key_seq = val;
}

void SQLForeignKey::__set_update_rule(const int32_t val) {
  this->update_rule = val;
}

void SQLForeignKey::__set_delete_rule(const int32_t val) {
  this->delete_rule = val;
}

void SQLForeignKey::__set_fk_name(const std::string& val) {
  this->fk_name = val;
}

void SQLForeignKey::__set_pk_name(const std::string& val) {
  this->pk_name = val;
}

void SQLForeignKey::__set_enable_cstr(const bool val) {
  this->enable_cstr = val;
}

void SQLForeignKey::__set_validate_cstr(const bool val) {
  this->validate_cstr = val;
}

void SQLForeignKey::__set_rely_cstr(const bool val) {
  this->rely_cstr = val;
}

void SQLForeignKey::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}
std::ostream& operator<<(std::ostream& out, const SQLForeignKey& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SQLForeignKey::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pktable_db);
          this->__isset.pktable_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pktable_name);
          this->__isset.pktable_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pkcolumn_name);
          this->__isset.pkcolumn_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fktable_db);
          this->__isset.fktable_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fktable_name);
          this->__isset.fktable_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fkcolumn_name);
          this->__isset.fkcolumn_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->key_seq);
          this->__isset.key_seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->update_rule);
          this->__isset.update_rule = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->delete_rule);
          this->__isset.delete_rule = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fk_name);
          this->__isset.fk_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pk_name);
          this->__isset.pk_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable_cstr);
          this->__isset.enable_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->validate_cstr);
          this->__isset.validate_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rely_cstr);
          this->__isset.rely_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SQLForeignKey::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SQLForeignKey");

  xfer += oprot->writeFieldBegin("pktable_db", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->pktable_db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pktable_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->pktable_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pkcolumn_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->pkcolumn_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fktable_db", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->fktable_db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fktable_name", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->fktable_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fkcolumn_name", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->fkcolumn_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_seq", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->key_seq);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_rule", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->update_rule);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_rule", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->delete_rule);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fk_name", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->fk_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pk_name", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->pk_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable_cstr", ::apache::thrift::protocol::T_BOOL, 12);
  xfer += oprot->writeBool(this->enable_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validate_cstr", ::apache::thrift::protocol::T_BOOL, 13);
  xfer += oprot->writeBool(this->validate_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rely_cstr", ::apache::thrift::protocol::T_BOOL, 14);
  xfer += oprot->writeBool(this->rely_cstr);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SQLForeignKey &a, SQLForeignKey &b) {
  using ::std::swap;
  swap(a.pktable_db, b.pktable_db);
  swap(a.pktable_name, b.pktable_name);
  swap(a.pkcolumn_name, b.pkcolumn_name);
  swap(a.fktable_db, b.fktable_db);
  swap(a.fktable_name, b.fktable_name);
  swap(a.fkcolumn_name, b.fkcolumn_name);
  swap(a.key_seq, b.key_seq);
  swap(a.update_rule, b.update_rule);
  swap(a.delete_rule, b.delete_rule);
  swap(a.fk_name, b.fk_name);
  swap(a.pk_name, b.pk_name);
  swap(a.enable_cstr, b.enable_cstr);
  swap(a.validate_cstr, b.validate_cstr);
  swap(a.rely_cstr, b.rely_cstr);
  swap(a.catName, b.catName);
  swap(a.__isset, b.__isset);
}

SQLForeignKey::SQLForeignKey(const SQLForeignKey& other6) {
  pktable_db = other6.pktable_db;
  pktable_name = other6.pktable_name;
  pkcolumn_name = other6.pkcolumn_name;
  fktable_db = other6.fktable_db;
  fktable_name = other6.fktable_name;
  fkcolumn_name = other6.fkcolumn_name;
  key_seq = other6.key_seq;
  update_rule = other6.update_rule;
  delete_rule = other6.delete_rule;
  fk_name = other6.fk_name;
  pk_name = other6.pk_name;
  enable_cstr = other6.enable_cstr;
  validate_cstr = other6.validate_cstr;
  rely_cstr = other6.rely_cstr;
  catName = other6.catName;
  __isset = other6.__isset;
}
SQLForeignKey& SQLForeignKey::operator=(const SQLForeignKey& other7) {
  pktable_db = other7.pktable_db;
  pktable_name = other7.pktable_name;
  pkcolumn_name = other7.pkcolumn_name;
  fktable_db = other7.fktable_db;
  fktable_name = other7.fktable_name;
  fkcolumn_name = other7.fkcolumn_name;
  key_seq = other7.key_seq;
  update_rule = other7.update_rule;
  delete_rule = other7.delete_rule;
  fk_name = other7.fk_name;
  pk_name = other7.pk_name;
  enable_cstr = other7.enable_cstr;
  validate_cstr = other7.validate_cstr;
  rely_cstr = other7.rely_cstr;
  catName = other7.catName;
  __isset = other7.__isset;
  return *this;
}
void SQLForeignKey::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SQLForeignKey(";
  out << "pktable_db=" << to_string(pktable_db);
  out << ", " << "pktable_name=" << to_string(pktable_name);
  out << ", " << "pkcolumn_name=" << to_string(pkcolumn_name);
  out << ", " << "fktable_db=" << to_string(fktable_db);
  out << ", " << "fktable_name=" << to_string(fktable_name);
  out << ", " << "fkcolumn_name=" << to_string(fkcolumn_name);
  out << ", " << "key_seq=" << to_string(key_seq);
  out << ", " << "update_rule=" << to_string(update_rule);
  out << ", " << "delete_rule=" << to_string(delete_rule);
  out << ", " << "fk_name=" << to_string(fk_name);
  out << ", " << "pk_name=" << to_string(pk_name);
  out << ", " << "enable_cstr=" << to_string(enable_cstr);
  out << ", " << "validate_cstr=" << to_string(validate_cstr);
  out << ", " << "rely_cstr=" << to_string(rely_cstr);
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ")";
}


SQLUniqueConstraint::~SQLUniqueConstraint() noexcept {
}


void SQLUniqueConstraint::__set_catName(const std::string& val) {
  this->catName = val;
}

void SQLUniqueConstraint::__set_table_db(const std::string& val) {
  this->table_db = val;
}

void SQLUniqueConstraint::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void SQLUniqueConstraint::__set_column_name(const std::string& val) {
  this->column_name = val;
}

void SQLUniqueConstraint::__set_key_seq(const int32_t val) {
  this->key_seq = val;
}

void SQLUniqueConstraint::__set_uk_name(const std::string& val) {
  this->uk_name = val;
}

void SQLUniqueConstraint::__set_enable_cstr(const bool val) {
  this->enable_cstr = val;
}

void SQLUniqueConstraint::__set_validate_cstr(const bool val) {
  this->validate_cstr = val;
}

void SQLUniqueConstraint::__set_rely_cstr(const bool val) {
  this->rely_cstr = val;
}
std::ostream& operator<<(std::ostream& out, const SQLUniqueConstraint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SQLUniqueConstraint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_db);
          this->__isset.table_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->key_seq);
          this->__isset.key_seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uk_name);
          this->__isset.uk_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable_cstr);
          this->__isset.enable_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->validate_cstr);
          this->__isset.validate_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rely_cstr);
          this->__isset.rely_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SQLUniqueConstraint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SQLUniqueConstraint");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_db", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_seq", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->key_seq);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uk_name", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->uk_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable_cstr", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->enable_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validate_cstr", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->validate_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rely_cstr", ::apache::thrift::protocol::T_BOOL, 9);
  xfer += oprot->writeBool(this->rely_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SQLUniqueConstraint &a, SQLUniqueConstraint &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.table_db, b.table_db);
  swap(a.table_name, b.table_name);
  swap(a.column_name, b.column_name);
  swap(a.key_seq, b.key_seq);
  swap(a.uk_name, b.uk_name);
  swap(a.enable_cstr, b.enable_cstr);
  swap(a.validate_cstr, b.validate_cstr);
  swap(a.rely_cstr, b.rely_cstr);
  swap(a.__isset, b.__isset);
}

SQLUniqueConstraint::SQLUniqueConstraint(const SQLUniqueConstraint& other8) {
  catName = other8.catName;
  table_db = other8.table_db;
  table_name = other8.table_name;
  column_name = other8.column_name;
  key_seq = other8.key_seq;
  uk_name = other8.uk_name;
  enable_cstr = other8.enable_cstr;
  validate_cstr = other8.validate_cstr;
  rely_cstr = other8.rely_cstr;
  __isset = other8.__isset;
}
SQLUniqueConstraint& SQLUniqueConstraint::operator=(const SQLUniqueConstraint& other9) {
  catName = other9.catName;
  table_db = other9.table_db;
  table_name = other9.table_name;
  column_name = other9.column_name;
  key_seq = other9.key_seq;
  uk_name = other9.uk_name;
  enable_cstr = other9.enable_cstr;
  validate_cstr = other9.validate_cstr;
  rely_cstr = other9.rely_cstr;
  __isset = other9.__isset;
  return *this;
}
void SQLUniqueConstraint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SQLUniqueConstraint(";
  out << "catName=" << to_string(catName);
  out << ", " << "table_db=" << to_string(table_db);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "column_name=" << to_string(column_name);
  out << ", " << "key_seq=" << to_string(key_seq);
  out << ", " << "uk_name=" << to_string(uk_name);
  out << ", " << "enable_cstr=" << to_string(enable_cstr);
  out << ", " << "validate_cstr=" << to_string(validate_cstr);
  out << ", " << "rely_cstr=" << to_string(rely_cstr);
  out << ")";
}


SQLNotNullConstraint::~SQLNotNullConstraint() noexcept {
}


void SQLNotNullConstraint::__set_catName(const std::string& val) {
  this->catName = val;
}

void SQLNotNullConstraint::__set_table_db(const std::string& val) {
  this->table_db = val;
}

void SQLNotNullConstraint::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void SQLNotNullConstraint::__set_column_name(const std::string& val) {
  this->column_name = val;
}

void SQLNotNullConstraint::__set_nn_name(const std::string& val) {
  this->nn_name = val;
}

void SQLNotNullConstraint::__set_enable_cstr(const bool val) {
  this->enable_cstr = val;
}

void SQLNotNullConstraint::__set_validate_cstr(const bool val) {
  this->validate_cstr = val;
}

void SQLNotNullConstraint::__set_rely_cstr(const bool val) {
  this->rely_cstr = val;
}
std::ostream& operator<<(std::ostream& out, const SQLNotNullConstraint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SQLNotNullConstraint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_db);
          this->__isset.table_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nn_name);
          this->__isset.nn_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable_cstr);
          this->__isset.enable_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->validate_cstr);
          this->__isset.validate_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rely_cstr);
          this->__isset.rely_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SQLNotNullConstraint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SQLNotNullConstraint");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_db", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nn_name", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->nn_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable_cstr", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->enable_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validate_cstr", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->validate_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rely_cstr", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->rely_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SQLNotNullConstraint &a, SQLNotNullConstraint &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.table_db, b.table_db);
  swap(a.table_name, b.table_name);
  swap(a.column_name, b.column_name);
  swap(a.nn_name, b.nn_name);
  swap(a.enable_cstr, b.enable_cstr);
  swap(a.validate_cstr, b.validate_cstr);
  swap(a.rely_cstr, b.rely_cstr);
  swap(a.__isset, b.__isset);
}

SQLNotNullConstraint::SQLNotNullConstraint(const SQLNotNullConstraint& other10) {
  catName = other10.catName;
  table_db = other10.table_db;
  table_name = other10.table_name;
  column_name = other10.column_name;
  nn_name = other10.nn_name;
  enable_cstr = other10.enable_cstr;
  validate_cstr = other10.validate_cstr;
  rely_cstr = other10.rely_cstr;
  __isset = other10.__isset;
}
SQLNotNullConstraint& SQLNotNullConstraint::operator=(const SQLNotNullConstraint& other11) {
  catName = other11.catName;
  table_db = other11.table_db;
  table_name = other11.table_name;
  column_name = other11.column_name;
  nn_name = other11.nn_name;
  enable_cstr = other11.enable_cstr;
  validate_cstr = other11.validate_cstr;
  rely_cstr = other11.rely_cstr;
  __isset = other11.__isset;
  return *this;
}
void SQLNotNullConstraint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SQLNotNullConstraint(";
  out << "catName=" << to_string(catName);
  out << ", " << "table_db=" << to_string(table_db);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "column_name=" << to_string(column_name);
  out << ", " << "nn_name=" << to_string(nn_name);
  out << ", " << "enable_cstr=" << to_string(enable_cstr);
  out << ", " << "validate_cstr=" << to_string(validate_cstr);
  out << ", " << "rely_cstr=" << to_string(rely_cstr);
  out << ")";
}


SQLDefaultConstraint::~SQLDefaultConstraint() noexcept {
}


void SQLDefaultConstraint::__set_catName(const std::string& val) {
  this->catName = val;
}

void SQLDefaultConstraint::__set_table_db(const std::string& val) {
  this->table_db = val;
}

void SQLDefaultConstraint::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void SQLDefaultConstraint::__set_column_name(const std::string& val) {
  this->column_name = val;
}

void SQLDefaultConstraint::__set_default_value(const std::string& val) {
  this->default_value = val;
}

void SQLDefaultConstraint::__set_dc_name(const std::string& val) {
  this->dc_name = val;
}

void SQLDefaultConstraint::__set_enable_cstr(const bool val) {
  this->enable_cstr = val;
}

void SQLDefaultConstraint::__set_validate_cstr(const bool val) {
  this->validate_cstr = val;
}

void SQLDefaultConstraint::__set_rely_cstr(const bool val) {
  this->rely_cstr = val;
}
std::ostream& operator<<(std::ostream& out, const SQLDefaultConstraint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SQLDefaultConstraint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_db);
          this->__isset.table_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->default_value);
          this->__isset.default_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dc_name);
          this->__isset.dc_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable_cstr);
          this->__isset.enable_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->validate_cstr);
          this->__isset.validate_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rely_cstr);
          this->__isset.rely_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SQLDefaultConstraint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SQLDefaultConstraint");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_db", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("default_value", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->default_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dc_name", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->dc_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable_cstr", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->enable_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validate_cstr", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->validate_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rely_cstr", ::apache::thrift::protocol::T_BOOL, 9);
  xfer += oprot->writeBool(this->rely_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SQLDefaultConstraint &a, SQLDefaultConstraint &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.table_db, b.table_db);
  swap(a.table_name, b.table_name);
  swap(a.column_name, b.column_name);
  swap(a.default_value, b.default_value);
  swap(a.dc_name, b.dc_name);
  swap(a.enable_cstr, b.enable_cstr);
  swap(a.validate_cstr, b.validate_cstr);
  swap(a.rely_cstr, b.rely_cstr);
  swap(a.__isset, b.__isset);
}

SQLDefaultConstraint::SQLDefaultConstraint(const SQLDefaultConstraint& other12) {
  catName = other12.catName;
  table_db = other12.table_db;
  table_name = other12.table_name;
  column_name = other12.column_name;
  default_value = other12.default_value;
  dc_name = other12.dc_name;
  enable_cstr = other12.enable_cstr;
  validate_cstr = other12.validate_cstr;
  rely_cstr = other12.rely_cstr;
  __isset = other12.__isset;
}
SQLDefaultConstraint& SQLDefaultConstraint::operator=(const SQLDefaultConstraint& other13) {
  catName = other13.catName;
  table_db = other13.table_db;
  table_name = other13.table_name;
  column_name = other13.column_name;
  default_value = other13.default_value;
  dc_name = other13.dc_name;
  enable_cstr = other13.enable_cstr;
  validate_cstr = other13.validate_cstr;
  rely_cstr = other13.rely_cstr;
  __isset = other13.__isset;
  return *this;
}
void SQLDefaultConstraint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SQLDefaultConstraint(";
  out << "catName=" << to_string(catName);
  out << ", " << "table_db=" << to_string(table_db);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "column_name=" << to_string(column_name);
  out << ", " << "default_value=" << to_string(default_value);
  out << ", " << "dc_name=" << to_string(dc_name);
  out << ", " << "enable_cstr=" << to_string(enable_cstr);
  out << ", " << "validate_cstr=" << to_string(validate_cstr);
  out << ", " << "rely_cstr=" << to_string(rely_cstr);
  out << ")";
}


SQLCheckConstraint::~SQLCheckConstraint() noexcept {
}


void SQLCheckConstraint::__set_catName(const std::string& val) {
  this->catName = val;
}

void SQLCheckConstraint::__set_table_db(const std::string& val) {
  this->table_db = val;
}

void SQLCheckConstraint::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void SQLCheckConstraint::__set_column_name(const std::string& val) {
  this->column_name = val;
}

void SQLCheckConstraint::__set_check_expression(const std::string& val) {
  this->check_expression = val;
}

void SQLCheckConstraint::__set_dc_name(const std::string& val) {
  this->dc_name = val;
}

void SQLCheckConstraint::__set_enable_cstr(const bool val) {
  this->enable_cstr = val;
}

void SQLCheckConstraint::__set_validate_cstr(const bool val) {
  this->validate_cstr = val;
}

void SQLCheckConstraint::__set_rely_cstr(const bool val) {
  this->rely_cstr = val;
}
std::ostream& operator<<(std::ostream& out, const SQLCheckConstraint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SQLCheckConstraint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_db);
          this->__isset.table_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->check_expression);
          this->__isset.check_expression = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dc_name);
          this->__isset.dc_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable_cstr);
          this->__isset.enable_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->validate_cstr);
          this->__isset.validate_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rely_cstr);
          this->__isset.rely_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SQLCheckConstraint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SQLCheckConstraint");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_db", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("check_expression", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->check_expression);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dc_name", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->dc_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable_cstr", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->enable_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validate_cstr", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->validate_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rely_cstr", ::apache::thrift::protocol::T_BOOL, 9);
  xfer += oprot->writeBool(this->rely_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SQLCheckConstraint &a, SQLCheckConstraint &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.table_db, b.table_db);
  swap(a.table_name, b.table_name);
  swap(a.column_name, b.column_name);
  swap(a.check_expression, b.check_expression);
  swap(a.dc_name, b.dc_name);
  swap(a.enable_cstr, b.enable_cstr);
  swap(a.validate_cstr, b.validate_cstr);
  swap(a.rely_cstr, b.rely_cstr);
  swap(a.__isset, b.__isset);
}

SQLCheckConstraint::SQLCheckConstraint(const SQLCheckConstraint& other14) {
  catName = other14.catName;
  table_db = other14.table_db;
  table_name = other14.table_name;
  column_name = other14.column_name;
  check_expression = other14.check_expression;
  dc_name = other14.dc_name;
  enable_cstr = other14.enable_cstr;
  validate_cstr = other14.validate_cstr;
  rely_cstr = other14.rely_cstr;
  __isset = other14.__isset;
}
SQLCheckConstraint& SQLCheckConstraint::operator=(const SQLCheckConstraint& other15) {
  catName = other15.catName;
  table_db = other15.table_db;
  table_name = other15.table_name;
  column_name = other15.column_name;
  check_expression = other15.check_expression;
  dc_name = other15.dc_name;
  enable_cstr = other15.enable_cstr;
  validate_cstr = other15.validate_cstr;
  rely_cstr = other15.rely_cstr;
  __isset = other15.__isset;
  return *this;
}
void SQLCheckConstraint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SQLCheckConstraint(";
  out << "catName=" << to_string(catName);
  out << ", " << "table_db=" << to_string(table_db);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "column_name=" << to_string(column_name);
  out << ", " << "check_expression=" << to_string(check_expression);
  out << ", " << "dc_name=" << to_string(dc_name);
  out << ", " << "enable_cstr=" << to_string(enable_cstr);
  out << ", " << "validate_cstr=" << to_string(validate_cstr);
  out << ", " << "rely_cstr=" << to_string(rely_cstr);
  out << ")";
}


SQLAllTableConstraints::~SQLAllTableConstraints() noexcept {
}


void SQLAllTableConstraints::__set_primaryKeys(const std::vector<SQLPrimaryKey> & val) {
  this->primaryKeys = val;
__isset.primaryKeys = true;
}

void SQLAllTableConstraints::__set_foreignKeys(const std::vector<SQLForeignKey> & val) {
  this->foreignKeys = val;
__isset.foreignKeys = true;
}

void SQLAllTableConstraints::__set_uniqueConstraints(const std::vector<SQLUniqueConstraint> & val) {
  this->uniqueConstraints = val;
__isset.uniqueConstraints = true;
}

void SQLAllTableConstraints::__set_notNullConstraints(const std::vector<SQLNotNullConstraint> & val) {
  this->notNullConstraints = val;
__isset.notNullConstraints = true;
}

void SQLAllTableConstraints::__set_defaultConstraints(const std::vector<SQLDefaultConstraint> & val) {
  this->defaultConstraints = val;
__isset.defaultConstraints = true;
}

void SQLAllTableConstraints::__set_checkConstraints(const std::vector<SQLCheckConstraint> & val) {
  this->checkConstraints = val;
__isset.checkConstraints = true;
}
std::ostream& operator<<(std::ostream& out, const SQLAllTableConstraints& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SQLAllTableConstraints::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->primaryKeys.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->primaryKeys.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += this->primaryKeys[_i20].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.primaryKeys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->foreignKeys.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _etype24;
            xfer += iprot->readListBegin(_etype24, _size21);
            this->foreignKeys.resize(_size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
              xfer += this->foreignKeys[_i25].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.foreignKeys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->uniqueConstraints.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->uniqueConstraints.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += this->uniqueConstraints[_i30].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.uniqueConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->notNullConstraints.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->notNullConstraints.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              xfer += this->notNullConstraints[_i35].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.notNullConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->defaultConstraints.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->defaultConstraints.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += this->defaultConstraints[_i40].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.defaultConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->checkConstraints.clear();
            uint32_t _size41;
            ::apache::thrift::protocol::TType _etype44;
            xfer += iprot->readListBegin(_etype44, _size41);
            this->checkConstraints.resize(_size41);
            uint32_t _i45;
            for (_i45 = 0; _i45 < _size41; ++_i45)
            {
              xfer += this->checkConstraints[_i45].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.checkConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SQLAllTableConstraints::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SQLAllTableConstraints");

  if (this->__isset.primaryKeys) {
    xfer += oprot->writeFieldBegin("primaryKeys", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->primaryKeys.size()));
      std::vector<SQLPrimaryKey> ::const_iterator _iter46;
      for (_iter46 = this->primaryKeys.begin(); _iter46 != this->primaryKeys.end(); ++_iter46)
      {
        xfer += (*_iter46).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.foreignKeys) {
    xfer += oprot->writeFieldBegin("foreignKeys", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->foreignKeys.size()));
      std::vector<SQLForeignKey> ::const_iterator _iter47;
      for (_iter47 = this->foreignKeys.begin(); _iter47 != this->foreignKeys.end(); ++_iter47)
      {
        xfer += (*_iter47).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.uniqueConstraints) {
    xfer += oprot->writeFieldBegin("uniqueConstraints", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->uniqueConstraints.size()));
      std::vector<SQLUniqueConstraint> ::const_iterator _iter48;
      for (_iter48 = this->uniqueConstraints.begin(); _iter48 != this->uniqueConstraints.end(); ++_iter48)
      {
        xfer += (*_iter48).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.notNullConstraints) {
    xfer += oprot->writeFieldBegin("notNullConstraints", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->notNullConstraints.size()));
      std::vector<SQLNotNullConstraint> ::const_iterator _iter49;
      for (_iter49 = this->notNullConstraints.begin(); _iter49 != this->notNullConstraints.end(); ++_iter49)
      {
        xfer += (*_iter49).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.defaultConstraints) {
    xfer += oprot->writeFieldBegin("defaultConstraints", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->defaultConstraints.size()));
      std::vector<SQLDefaultConstraint> ::const_iterator _iter50;
      for (_iter50 = this->defaultConstraints.begin(); _iter50 != this->defaultConstraints.end(); ++_iter50)
      {
        xfer += (*_iter50).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.checkConstraints) {
    xfer += oprot->writeFieldBegin("checkConstraints", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->checkConstraints.size()));
      std::vector<SQLCheckConstraint> ::const_iterator _iter51;
      for (_iter51 = this->checkConstraints.begin(); _iter51 != this->checkConstraints.end(); ++_iter51)
      {
        xfer += (*_iter51).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SQLAllTableConstraints &a, SQLAllTableConstraints &b) {
  using ::std::swap;
  swap(a.primaryKeys, b.primaryKeys);
  swap(a.foreignKeys, b.foreignKeys);
  swap(a.uniqueConstraints, b.uniqueConstraints);
  swap(a.notNullConstraints, b.notNullConstraints);
  swap(a.defaultConstraints, b.defaultConstraints);
  swap(a.checkConstraints, b.checkConstraints);
  swap(a.__isset, b.__isset);
}

SQLAllTableConstraints::SQLAllTableConstraints(const SQLAllTableConstraints& other52) {
  primaryKeys = other52.primaryKeys;
  foreignKeys = other52.foreignKeys;
  uniqueConstraints = other52.uniqueConstraints;
  notNullConstraints = other52.notNullConstraints;
  defaultConstraints = other52.defaultConstraints;
  checkConstraints = other52.checkConstraints;
  __isset = other52.__isset;
}
SQLAllTableConstraints& SQLAllTableConstraints::operator=(const SQLAllTableConstraints& other53) {
  primaryKeys = other53.primaryKeys;
  foreignKeys = other53.foreignKeys;
  uniqueConstraints = other53.uniqueConstraints;
  notNullConstraints = other53.notNullConstraints;
  defaultConstraints = other53.defaultConstraints;
  checkConstraints = other53.checkConstraints;
  __isset = other53.__isset;
  return *this;
}
void SQLAllTableConstraints::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SQLAllTableConstraints(";
  out << "primaryKeys="; (__isset.primaryKeys ? (out << to_string(primaryKeys)) : (out << "<null>"));
  out << ", " << "foreignKeys="; (__isset.foreignKeys ? (out << to_string(foreignKeys)) : (out << "<null>"));
  out << ", " << "uniqueConstraints="; (__isset.uniqueConstraints ? (out << to_string(uniqueConstraints)) : (out << "<null>"));
  out << ", " << "notNullConstraints="; (__isset.notNullConstraints ? (out << to_string(notNullConstraints)) : (out << "<null>"));
  out << ", " << "defaultConstraints="; (__isset.defaultConstraints ? (out << to_string(defaultConstraints)) : (out << "<null>"));
  out << ", " << "checkConstraints="; (__isset.checkConstraints ? (out << to_string(checkConstraints)) : (out << "<null>"));
  out << ")";
}


Type::~Type() noexcept {
}


void Type::__set_name(const std::string& val) {
  this->name = val;
}

void Type::__set_type1(const std::string& val) {
  this->type1 = val;
__isset.type1 = true;
}

void Type::__set_type2(const std::string& val) {
  this->type2 = val;
__isset.type2 = true;
}

void Type::__set_fields(const std::vector<FieldSchema> & val) {
  this->fields = val;
__isset.fields = true;
}
std::ostream& operator<<(std::ostream& out, const Type& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Type::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type1);
          this->__isset.type1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type2);
          this->__isset.type2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fields.clear();
            uint32_t _size54;
            ::apache::thrift::protocol::TType _etype57;
            xfer += iprot->readListBegin(_etype57, _size54);
            this->fields.resize(_size54);
            uint32_t _i58;
            for (_i58 = 0; _i58 < _size54; ++_i58)
            {
              xfer += this->fields[_i58].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Type::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Type");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.type1) {
    xfer += oprot->writeFieldBegin("type1", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->type1);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type2) {
    xfer += oprot->writeFieldBegin("type2", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->type2);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fields) {
    xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fields.size()));
      std::vector<FieldSchema> ::const_iterator _iter59;
      for (_iter59 = this->fields.begin(); _iter59 != this->fields.end(); ++_iter59)
      {
        xfer += (*_iter59).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Type &a, Type &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.type1, b.type1);
  swap(a.type2, b.type2);
  swap(a.fields, b.fields);
  swap(a.__isset, b.__isset);
}

Type::Type(const Type& other60) {
  name = other60.name;
  type1 = other60.type1;
  type2 = other60.type2;
  fields = other60.fields;
  __isset = other60.__isset;
}
Type& Type::operator=(const Type& other61) {
  name = other61.name;
  type1 = other61.type1;
  type2 = other61.type2;
  fields = other61.fields;
  __isset = other61.__isset;
  return *this;
}
void Type::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Type(";
  out << "name=" << to_string(name);
  out << ", " << "type1="; (__isset.type1 ? (out << to_string(type1)) : (out << "<null>"));
  out << ", " << "type2="; (__isset.type2 ? (out << to_string(type2)) : (out << "<null>"));
  out << ", " << "fields="; (__isset.fields ? (out << to_string(fields)) : (out << "<null>"));
  out << ")";
}


HiveObjectRef::~HiveObjectRef() noexcept {
}


void HiveObjectRef::__set_objectType(const HiveObjectType::type val) {
  this->objectType = val;
}

void HiveObjectRef::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void HiveObjectRef::__set_objectName(const std::string& val) {
  this->objectName = val;
}

void HiveObjectRef::__set_partValues(const std::vector<std::string> & val) {
  this->partValues = val;
}

void HiveObjectRef::__set_columnName(const std::string& val) {
  this->columnName = val;
}

void HiveObjectRef::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}
std::ostream& operator<<(std::ostream& out, const HiveObjectRef& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HiveObjectRef::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast62;
          xfer += iprot->readI32(ecast62);
          this->objectType = (HiveObjectType::type)ecast62;
          this->__isset.objectType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->objectName);
          this->__isset.objectName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partValues.clear();
            uint32_t _size63;
            ::apache::thrift::protocol::TType _etype66;
            xfer += iprot->readListBegin(_etype66, _size63);
            this->partValues.resize(_size63);
            uint32_t _i67;
            for (_i67 = 0; _i67 < _size63; ++_i67)
            {
              xfer += iprot->readString(this->partValues[_i67]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnName);
          this->__isset.columnName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HiveObjectRef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HiveObjectRef");

  xfer += oprot->writeFieldBegin("objectType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->objectType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("objectName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->objectName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partValues", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partValues.size()));
    std::vector<std::string> ::const_iterator _iter68;
    for (_iter68 = this->partValues.begin(); _iter68 != this->partValues.end(); ++_iter68)
    {
      xfer += oprot->writeString((*_iter68));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columnName", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->columnName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HiveObjectRef &a, HiveObjectRef &b) {
  using ::std::swap;
  swap(a.objectType, b.objectType);
  swap(a.dbName, b.dbName);
  swap(a.objectName, b.objectName);
  swap(a.partValues, b.partValues);
  swap(a.columnName, b.columnName);
  swap(a.catName, b.catName);
  swap(a.__isset, b.__isset);
}

HiveObjectRef::HiveObjectRef(const HiveObjectRef& other69) {
  objectType = other69.objectType;
  dbName = other69.dbName;
  objectName = other69.objectName;
  partValues = other69.partValues;
  columnName = other69.columnName;
  catName = other69.catName;
  __isset = other69.__isset;
}
HiveObjectRef& HiveObjectRef::operator=(const HiveObjectRef& other70) {
  objectType = other70.objectType;
  dbName = other70.dbName;
  objectName = other70.objectName;
  partValues = other70.partValues;
  columnName = other70.columnName;
  catName = other70.catName;
  __isset = other70.__isset;
  return *this;
}
void HiveObjectRef::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HiveObjectRef(";
  out << "objectType=" << to_string(objectType);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "objectName=" << to_string(objectName);
  out << ", " << "partValues=" << to_string(partValues);
  out << ", " << "columnName=" << to_string(columnName);
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ")";
}


PrivilegeGrantInfo::~PrivilegeGrantInfo() noexcept {
}


void PrivilegeGrantInfo::__set_privilege(const std::string& val) {
  this->privilege = val;
}

void PrivilegeGrantInfo::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void PrivilegeGrantInfo::__set_grantor(const std::string& val) {
  this->grantor = val;
}

void PrivilegeGrantInfo::__set_grantorType(const PrincipalType::type val) {
  this->grantorType = val;
}

void PrivilegeGrantInfo::__set_grantOption(const bool val) {
  this->grantOption = val;
}
std::ostream& operator<<(std::ostream& out, const PrivilegeGrantInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PrivilegeGrantInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->privilege);
          this->__isset.privilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->grantor);
          this->__isset.grantor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast71;
          xfer += iprot->readI32(ecast71);
          this->grantorType = (PrincipalType::type)ecast71;
          this->__isset.grantorType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->grantOption);
          this->__isset.grantOption = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PrivilegeGrantInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PrivilegeGrantInfo");

  xfer += oprot->writeFieldBegin("privilege", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->privilege);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantor", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->grantor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantorType", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->grantorType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantOption", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->grantOption);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PrivilegeGrantInfo &a, PrivilegeGrantInfo &b) {
  using ::std::swap;
  swap(a.privilege, b.privilege);
  swap(a.createTime, b.createTime);
  swap(a.grantor, b.grantor);
  swap(a.grantorType, b.grantorType);
  swap(a.grantOption, b.grantOption);
  swap(a.__isset, b.__isset);
}

PrivilegeGrantInfo::PrivilegeGrantInfo(const PrivilegeGrantInfo& other72) {
  privilege = other72.privilege;
  createTime = other72.createTime;
  grantor = other72.grantor;
  grantorType = other72.grantorType;
  grantOption = other72.grantOption;
  __isset = other72.__isset;
}
PrivilegeGrantInfo& PrivilegeGrantInfo::operator=(const PrivilegeGrantInfo& other73) {
  privilege = other73.privilege;
  createTime = other73.createTime;
  grantor = other73.grantor;
  grantorType = other73.grantorType;
  grantOption = other73.grantOption;
  __isset = other73.__isset;
  return *this;
}
void PrivilegeGrantInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PrivilegeGrantInfo(";
  out << "privilege=" << to_string(privilege);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "grantor=" << to_string(grantor);
  out << ", " << "grantorType=" << to_string(grantorType);
  out << ", " << "grantOption=" << to_string(grantOption);
  out << ")";
}


HiveObjectPrivilege::~HiveObjectPrivilege() noexcept {
}


void HiveObjectPrivilege::__set_hiveObject(const HiveObjectRef& val) {
  this->hiveObject = val;
}

void HiveObjectPrivilege::__set_principalName(const std::string& val) {
  this->principalName = val;
}

void HiveObjectPrivilege::__set_principalType(const PrincipalType::type val) {
  this->principalType = val;
}

void HiveObjectPrivilege::__set_grantInfo(const PrivilegeGrantInfo& val) {
  this->grantInfo = val;
}

void HiveObjectPrivilege::__set_authorizer(const std::string& val) {
  this->authorizer = val;
}
std::ostream& operator<<(std::ostream& out, const HiveObjectPrivilege& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HiveObjectPrivilege::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hiveObject.read(iprot);
          this->__isset.hiveObject = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principalName);
          this->__isset.principalName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast74;
          xfer += iprot->readI32(ecast74);
          this->principalType = (PrincipalType::type)ecast74;
          this->__isset.principalType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->grantInfo.read(iprot);
          this->__isset.grantInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authorizer);
          this->__isset.authorizer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HiveObjectPrivilege::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HiveObjectPrivilege");

  xfer += oprot->writeFieldBegin("hiveObject", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->hiveObject.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->principalName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->principalType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantInfo", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->grantInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authorizer", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->authorizer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HiveObjectPrivilege &a, HiveObjectPrivilege &b) {
  using ::std::swap;
  swap(a.hiveObject, b.hiveObject);
  swap(a.principalName, b.principalName);
  swap(a.principalType, b.principalType);
  swap(a.grantInfo, b.grantInfo);
  swap(a.authorizer, b.authorizer);
  swap(a.__isset, b.__isset);
}

HiveObjectPrivilege::HiveObjectPrivilege(const HiveObjectPrivilege& other75) {
  hiveObject = other75.hiveObject;
  principalName = other75.principalName;
  principalType = other75.principalType;
  grantInfo = other75.grantInfo;
  authorizer = other75.authorizer;
  __isset = other75.__isset;
}
HiveObjectPrivilege& HiveObjectPrivilege::operator=(const HiveObjectPrivilege& other76) {
  hiveObject = other76.hiveObject;
  principalName = other76.principalName;
  principalType = other76.principalType;
  grantInfo = other76.grantInfo;
  authorizer = other76.authorizer;
  __isset = other76.__isset;
  return *this;
}
void HiveObjectPrivilege::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HiveObjectPrivilege(";
  out << "hiveObject=" << to_string(hiveObject);
  out << ", " << "principalName=" << to_string(principalName);
  out << ", " << "principalType=" << to_string(principalType);
  out << ", " << "grantInfo=" << to_string(grantInfo);
  out << ", " << "authorizer=" << to_string(authorizer);
  out << ")";
}


PrivilegeBag::~PrivilegeBag() noexcept {
}


void PrivilegeBag::__set_privileges(const std::vector<HiveObjectPrivilege> & val) {
  this->privileges = val;
}
std::ostream& operator<<(std::ostream& out, const PrivilegeBag& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PrivilegeBag::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->privileges.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _etype80;
            xfer += iprot->readListBegin(_etype80, _size77);
            this->privileges.resize(_size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              xfer += this->privileges[_i81].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PrivilegeBag::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PrivilegeBag");

  xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->privileges.size()));
    std::vector<HiveObjectPrivilege> ::const_iterator _iter82;
    for (_iter82 = this->privileges.begin(); _iter82 != this->privileges.end(); ++_iter82)
    {
      xfer += (*_iter82).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PrivilegeBag &a, PrivilegeBag &b) {
  using ::std::swap;
  swap(a.privileges, b.privileges);
  swap(a.__isset, b.__isset);
}

PrivilegeBag::PrivilegeBag(const PrivilegeBag& other83) {
  privileges = other83.privileges;
  __isset = other83.__isset;
}
PrivilegeBag& PrivilegeBag::operator=(const PrivilegeBag& other84) {
  privileges = other84.privileges;
  __isset = other84.__isset;
  return *this;
}
void PrivilegeBag::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PrivilegeBag(";
  out << "privileges=" << to_string(privileges);
  out << ")";
}


PrincipalPrivilegeSet::~PrincipalPrivilegeSet() noexcept {
}


void PrincipalPrivilegeSet::__set_userPrivileges(const std::map<std::string, std::vector<PrivilegeGrantInfo> > & val) {
  this->userPrivileges = val;
}

void PrincipalPrivilegeSet::__set_groupPrivileges(const std::map<std::string, std::vector<PrivilegeGrantInfo> > & val) {
  this->groupPrivileges = val;
}

void PrincipalPrivilegeSet::__set_rolePrivileges(const std::map<std::string, std::vector<PrivilegeGrantInfo> > & val) {
  this->rolePrivileges = val;
}
std::ostream& operator<<(std::ostream& out, const PrincipalPrivilegeSet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PrincipalPrivilegeSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->userPrivileges.clear();
            uint32_t _size85;
            ::apache::thrift::protocol::TType _ktype86;
            ::apache::thrift::protocol::TType _vtype87;
            xfer += iprot->readMapBegin(_ktype86, _vtype87, _size85);
            uint32_t _i89;
            for (_i89 = 0; _i89 < _size85; ++_i89)
            {
              std::string _key90;
              xfer += iprot->readString(_key90);
              std::vector<PrivilegeGrantInfo> & _val91 = this->userPrivileges[_key90];
              {
                _val91.clear();
                uint32_t _size92;
                ::apache::thrift::protocol::TType _etype95;
                xfer += iprot->readListBegin(_etype95, _size92);
                _val91.resize(_size92);
                uint32_t _i96;
                for (_i96 = 0; _i96 < _size92; ++_i96)
                {
                  xfer += _val91[_i96].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.userPrivileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->groupPrivileges.clear();
            uint32_t _size97;
            ::apache::thrift::protocol::TType _ktype98;
            ::apache::thrift::protocol::TType _vtype99;
            xfer += iprot->readMapBegin(_ktype98, _vtype99, _size97);
            uint32_t _i101;
            for (_i101 = 0; _i101 < _size97; ++_i101)
            {
              std::string _key102;
              xfer += iprot->readString(_key102);
              std::vector<PrivilegeGrantInfo> & _val103 = this->groupPrivileges[_key102];
              {
                _val103.clear();
                uint32_t _size104;
                ::apache::thrift::protocol::TType _etype107;
                xfer += iprot->readListBegin(_etype107, _size104);
                _val103.resize(_size104);
                uint32_t _i108;
                for (_i108 = 0; _i108 < _size104; ++_i108)
                {
                  xfer += _val103[_i108].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.groupPrivileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->rolePrivileges.clear();
            uint32_t _size109;
            ::apache::thrift::protocol::TType _ktype110;
            ::apache::thrift::protocol::TType _vtype111;
            xfer += iprot->readMapBegin(_ktype110, _vtype111, _size109);
            uint32_t _i113;
            for (_i113 = 0; _i113 < _size109; ++_i113)
            {
              std::string _key114;
              xfer += iprot->readString(_key114);
              std::vector<PrivilegeGrantInfo> & _val115 = this->rolePrivileges[_key114];
              {
                _val115.clear();
                uint32_t _size116;
                ::apache::thrift::protocol::TType _etype119;
                xfer += iprot->readListBegin(_etype119, _size116);
                _val115.resize(_size116);
                uint32_t _i120;
                for (_i120 = 0; _i120 < _size116; ++_i120)
                {
                  xfer += _val115[_i120].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.rolePrivileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PrincipalPrivilegeSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PrincipalPrivilegeSet");

  xfer += oprot->writeFieldBegin("userPrivileges", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->userPrivileges.size()));
    std::map<std::string, std::vector<PrivilegeGrantInfo> > ::const_iterator _iter121;
    for (_iter121 = this->userPrivileges.begin(); _iter121 != this->userPrivileges.end(); ++_iter121)
    {
      xfer += oprot->writeString(_iter121->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter121->second.size()));
        std::vector<PrivilegeGrantInfo> ::const_iterator _iter122;
        for (_iter122 = _iter121->second.begin(); _iter122 != _iter121->second.end(); ++_iter122)
        {
          xfer += (*_iter122).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groupPrivileges", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->groupPrivileges.size()));
    std::map<std::string, std::vector<PrivilegeGrantInfo> > ::const_iterator _iter123;
    for (_iter123 = this->groupPrivileges.begin(); _iter123 != this->groupPrivileges.end(); ++_iter123)
    {
      xfer += oprot->writeString(_iter123->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter123->second.size()));
        std::vector<PrivilegeGrantInfo> ::const_iterator _iter124;
        for (_iter124 = _iter123->second.begin(); _iter124 != _iter123->second.end(); ++_iter124)
        {
          xfer += (*_iter124).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rolePrivileges", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->rolePrivileges.size()));
    std::map<std::string, std::vector<PrivilegeGrantInfo> > ::const_iterator _iter125;
    for (_iter125 = this->rolePrivileges.begin(); _iter125 != this->rolePrivileges.end(); ++_iter125)
    {
      xfer += oprot->writeString(_iter125->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter125->second.size()));
        std::vector<PrivilegeGrantInfo> ::const_iterator _iter126;
        for (_iter126 = _iter125->second.begin(); _iter126 != _iter125->second.end(); ++_iter126)
        {
          xfer += (*_iter126).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PrincipalPrivilegeSet &a, PrincipalPrivilegeSet &b) {
  using ::std::swap;
  swap(a.userPrivileges, b.userPrivileges);
  swap(a.groupPrivileges, b.groupPrivileges);
  swap(a.rolePrivileges, b.rolePrivileges);
  swap(a.__isset, b.__isset);
}

PrincipalPrivilegeSet::PrincipalPrivilegeSet(const PrincipalPrivilegeSet& other127) {
  userPrivileges = other127.userPrivileges;
  groupPrivileges = other127.groupPrivileges;
  rolePrivileges = other127.rolePrivileges;
  __isset = other127.__isset;
}
PrincipalPrivilegeSet& PrincipalPrivilegeSet::operator=(const PrincipalPrivilegeSet& other128) {
  userPrivileges = other128.userPrivileges;
  groupPrivileges = other128.groupPrivileges;
  rolePrivileges = other128.rolePrivileges;
  __isset = other128.__isset;
  return *this;
}
void PrincipalPrivilegeSet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PrincipalPrivilegeSet(";
  out << "userPrivileges=" << to_string(userPrivileges);
  out << ", " << "groupPrivileges=" << to_string(groupPrivileges);
  out << ", " << "rolePrivileges=" << to_string(rolePrivileges);
  out << ")";
}


GrantRevokePrivilegeRequest::~GrantRevokePrivilegeRequest() noexcept {
}


void GrantRevokePrivilegeRequest::__set_requestType(const GrantRevokeType::type val) {
  this->requestType = val;
}

void GrantRevokePrivilegeRequest::__set_privileges(const PrivilegeBag& val) {
  this->privileges = val;
}

void GrantRevokePrivilegeRequest::__set_revokeGrantOption(const bool val) {
  this->revokeGrantOption = val;
__isset.revokeGrantOption = true;
}
std::ostream& operator<<(std::ostream& out, const GrantRevokePrivilegeRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GrantRevokePrivilegeRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast129;
          xfer += iprot->readI32(ecast129);
          this->requestType = (GrantRevokeType::type)ecast129;
          this->__isset.requestType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->revokeGrantOption);
          this->__isset.revokeGrantOption = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GrantRevokePrivilegeRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GrantRevokePrivilegeRequest");

  xfer += oprot->writeFieldBegin("requestType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->requestType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->privileges.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.revokeGrantOption) {
    xfer += oprot->writeFieldBegin("revokeGrantOption", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->revokeGrantOption);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GrantRevokePrivilegeRequest &a, GrantRevokePrivilegeRequest &b) {
  using ::std::swap;
  swap(a.requestType, b.requestType);
  swap(a.privileges, b.privileges);
  swap(a.revokeGrantOption, b.revokeGrantOption);
  swap(a.__isset, b.__isset);
}

GrantRevokePrivilegeRequest::GrantRevokePrivilegeRequest(const GrantRevokePrivilegeRequest& other130) {
  requestType = other130.requestType;
  privileges = other130.privileges;
  revokeGrantOption = other130.revokeGrantOption;
  __isset = other130.__isset;
}
GrantRevokePrivilegeRequest& GrantRevokePrivilegeRequest::operator=(const GrantRevokePrivilegeRequest& other131) {
  requestType = other131.requestType;
  privileges = other131.privileges;
  revokeGrantOption = other131.revokeGrantOption;
  __isset = other131.__isset;
  return *this;
}
void GrantRevokePrivilegeRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GrantRevokePrivilegeRequest(";
  out << "requestType=" << to_string(requestType);
  out << ", " << "privileges=" << to_string(privileges);
  out << ", " << "revokeGrantOption="; (__isset.revokeGrantOption ? (out << to_string(revokeGrantOption)) : (out << "<null>"));
  out << ")";
}


GrantRevokePrivilegeResponse::~GrantRevokePrivilegeResponse() noexcept {
}


void GrantRevokePrivilegeResponse::__set_success(const bool val) {
  this->success = val;
__isset.success = true;
}
std::ostream& operator<<(std::ostream& out, const GrantRevokePrivilegeResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GrantRevokePrivilegeResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GrantRevokePrivilegeResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GrantRevokePrivilegeResponse");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GrantRevokePrivilegeResponse &a, GrantRevokePrivilegeResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.__isset, b.__isset);
}

GrantRevokePrivilegeResponse::GrantRevokePrivilegeResponse(const GrantRevokePrivilegeResponse& other132) {
  success = other132.success;
  __isset = other132.__isset;
}
GrantRevokePrivilegeResponse& GrantRevokePrivilegeResponse::operator=(const GrantRevokePrivilegeResponse& other133) {
  success = other133.success;
  __isset = other133.__isset;
  return *this;
}
void GrantRevokePrivilegeResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GrantRevokePrivilegeResponse(";
  out << "success="; (__isset.success ? (out << to_string(success)) : (out << "<null>"));
  out << ")";
}


TruncateTableRequest::~TruncateTableRequest() noexcept {
}


void TruncateTableRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void TruncateTableRequest::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void TruncateTableRequest::__set_partNames(const std::vector<std::string> & val) {
  this->partNames = val;
__isset.partNames = true;
}

void TruncateTableRequest::__set_writeId(const int64_t val) {
  this->writeId = val;
__isset.writeId = true;
}

void TruncateTableRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}
std::ostream& operator<<(std::ostream& out, const TruncateTableRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TruncateTableRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tableName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partNames.clear();
            uint32_t _size134;
            ::apache::thrift::protocol::TType _etype137;
            xfer += iprot->readListBegin(_etype137, _size134);
            this->partNames.resize(_size134);
            uint32_t _i138;
            for (_i138 = 0; _i138 < _size134; ++_i138)
            {
              xfer += iprot->readString(this->partNames[_i138]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          this->__isset.writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TruncateTableRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TruncateTableRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partNames) {
    xfer += oprot->writeFieldBegin("partNames", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partNames.size()));
      std::vector<std::string> ::const_iterator _iter139;
      for (_iter139 = this->partNames.begin(); _iter139 != this->partNames.end(); ++_iter139)
      {
        xfer += oprot->writeString((*_iter139));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writeId) {
    xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->writeId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TruncateTableRequest &a, TruncateTableRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.partNames, b.partNames);
  swap(a.writeId, b.writeId);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.__isset, b.__isset);
}

TruncateTableRequest::TruncateTableRequest(const TruncateTableRequest& other140) {
  dbName = other140.dbName;
  tableName = other140.tableName;
  partNames = other140.partNames;
  writeId = other140.writeId;
  validWriteIdList = other140.validWriteIdList;
  __isset = other140.__isset;
}
TruncateTableRequest& TruncateTableRequest::operator=(const TruncateTableRequest& other141) {
  dbName = other141.dbName;
  tableName = other141.tableName;
  partNames = other141.partNames;
  writeId = other141.writeId;
  validWriteIdList = other141.validWriteIdList;
  __isset = other141.__isset;
  return *this;
}
void TruncateTableRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TruncateTableRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "partNames="; (__isset.partNames ? (out << to_string(partNames)) : (out << "<null>"));
  out << ", " << "writeId="; (__isset.writeId ? (out << to_string(writeId)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ")";
}


TruncateTableResponse::~TruncateTableResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const TruncateTableResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TruncateTableResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TruncateTableResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TruncateTableResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TruncateTableResponse &a, TruncateTableResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TruncateTableResponse::TruncateTableResponse(const TruncateTableResponse& other142) {
  (void) other142;
}
TruncateTableResponse& TruncateTableResponse::operator=(const TruncateTableResponse& other143) {
  (void) other143;
  return *this;
}
void TruncateTableResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TruncateTableResponse(";
  out << ")";
}


Role::~Role() noexcept {
}


void Role::__set_roleName(const std::string& val) {
  this->roleName = val;
}

void Role::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void Role::__set_ownerName(const std::string& val) {
  this->ownerName = val;
}
std::ostream& operator<<(std::ostream& out, const Role& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Role::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roleName);
          this->__isset.roleName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Role::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Role");

  xfer += oprot->writeFieldBegin("roleName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->roleName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ownerName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Role &a, Role &b) {
  using ::std::swap;
  swap(a.roleName, b.roleName);
  swap(a.createTime, b.createTime);
  swap(a.ownerName, b.ownerName);
  swap(a.__isset, b.__isset);
}

Role::Role(const Role& other144) {
  roleName = other144.roleName;
  createTime = other144.createTime;
  ownerName = other144.ownerName;
  __isset = other144.__isset;
}
Role& Role::operator=(const Role& other145) {
  roleName = other145.roleName;
  createTime = other145.createTime;
  ownerName = other145.ownerName;
  __isset = other145.__isset;
  return *this;
}
void Role::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Role(";
  out << "roleName=" << to_string(roleName);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "ownerName=" << to_string(ownerName);
  out << ")";
}


RolePrincipalGrant::~RolePrincipalGrant() noexcept {
}


void RolePrincipalGrant::__set_roleName(const std::string& val) {
  this->roleName = val;
}

void RolePrincipalGrant::__set_principalName(const std::string& val) {
  this->principalName = val;
}

void RolePrincipalGrant::__set_principalType(const PrincipalType::type val) {
  this->principalType = val;
}

void RolePrincipalGrant::__set_grantOption(const bool val) {
  this->grantOption = val;
}

void RolePrincipalGrant::__set_grantTime(const int32_t val) {
  this->grantTime = val;
}

void RolePrincipalGrant::__set_grantorName(const std::string& val) {
  this->grantorName = val;
}

void RolePrincipalGrant::__set_grantorPrincipalType(const PrincipalType::type val) {
  this->grantorPrincipalType = val;
}
std::ostream& operator<<(std::ostream& out, const RolePrincipalGrant& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RolePrincipalGrant::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roleName);
          this->__isset.roleName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principalName);
          this->__isset.principalName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast146;
          xfer += iprot->readI32(ecast146);
          this->principalType = (PrincipalType::type)ecast146;
          this->__isset.principalType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->grantOption);
          this->__isset.grantOption = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->grantTime);
          this->__isset.grantTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->grantorName);
          this->__isset.grantorName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast147;
          xfer += iprot->readI32(ecast147);
          this->grantorPrincipalType = (PrincipalType::type)ecast147;
          this->__isset.grantorPrincipalType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RolePrincipalGrant::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RolePrincipalGrant");

  xfer += oprot->writeFieldBegin("roleName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->roleName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->principalName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->principalType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantOption", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->grantOption);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantTime", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->grantTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantorName", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->grantorName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantorPrincipalType", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->grantorPrincipalType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RolePrincipalGrant &a, RolePrincipalGrant &b) {
  using ::std::swap;
  swap(a.roleName, b.roleName);
  swap(a.principalName, b.principalName);
  swap(a.principalType, b.principalType);
  swap(a.grantOption, b.grantOption);
  swap(a.grantTime, b.grantTime);
  swap(a.grantorName, b.grantorName);
  swap(a.grantorPrincipalType, b.grantorPrincipalType);
  swap(a.__isset, b.__isset);
}

RolePrincipalGrant::RolePrincipalGrant(const RolePrincipalGrant& other148) {
  roleName = other148.roleName;
  principalName = other148.principalName;
  principalType = other148.principalType;
  grantOption = other148.grantOption;
  grantTime = other148.grantTime;
  grantorName = other148.grantorName;
  grantorPrincipalType = other148.grantorPrincipalType;
  __isset = other148.__isset;
}
RolePrincipalGrant& RolePrincipalGrant::operator=(const RolePrincipalGrant& other149) {
  roleName = other149.roleName;
  principalName = other149.principalName;
  principalType = other149.principalType;
  grantOption = other149.grantOption;
  grantTime = other149.grantTime;
  grantorName = other149.grantorName;
  grantorPrincipalType = other149.grantorPrincipalType;
  __isset = other149.__isset;
  return *this;
}
void RolePrincipalGrant::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RolePrincipalGrant(";
  out << "roleName=" << to_string(roleName);
  out << ", " << "principalName=" << to_string(principalName);
  out << ", " << "principalType=" << to_string(principalType);
  out << ", " << "grantOption=" << to_string(grantOption);
  out << ", " << "grantTime=" << to_string(grantTime);
  out << ", " << "grantorName=" << to_string(grantorName);
  out << ", " << "grantorPrincipalType=" << to_string(grantorPrincipalType);
  out << ")";
}


GetRoleGrantsForPrincipalRequest::~GetRoleGrantsForPrincipalRequest() noexcept {
}


void GetRoleGrantsForPrincipalRequest::__set_principal_name(const std::string& val) {
  this->principal_name = val;
}

void GetRoleGrantsForPrincipalRequest::__set_principal_type(const PrincipalType::type val) {
  this->principal_type = val;
}
std::ostream& operator<<(std::ostream& out, const GetRoleGrantsForPrincipalRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetRoleGrantsForPrincipalRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_principal_name = false;
  bool isset_principal_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principal_name);
          isset_principal_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast150;
          xfer += iprot->readI32(ecast150);
          this->principal_type = (PrincipalType::type)ecast150;
          isset_principal_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_principal_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_principal_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetRoleGrantsForPrincipalRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetRoleGrantsForPrincipalRequest");

  xfer += oprot->writeFieldBegin("principal_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->principal_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principal_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->principal_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetRoleGrantsForPrincipalRequest &a, GetRoleGrantsForPrincipalRequest &b) {
  using ::std::swap;
  swap(a.principal_name, b.principal_name);
  swap(a.principal_type, b.principal_type);
}

GetRoleGrantsForPrincipalRequest::GetRoleGrantsForPrincipalRequest(const GetRoleGrantsForPrincipalRequest& other151) {
  principal_name = other151.principal_name;
  principal_type = other151.principal_type;
}
GetRoleGrantsForPrincipalRequest& GetRoleGrantsForPrincipalRequest::operator=(const GetRoleGrantsForPrincipalRequest& other152) {
  principal_name = other152.principal_name;
  principal_type = other152.principal_type;
  return *this;
}
void GetRoleGrantsForPrincipalRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetRoleGrantsForPrincipalRequest(";
  out << "principal_name=" << to_string(principal_name);
  out << ", " << "principal_type=" << to_string(principal_type);
  out << ")";
}


GetRoleGrantsForPrincipalResponse::~GetRoleGrantsForPrincipalResponse() noexcept {
}


void GetRoleGrantsForPrincipalResponse::__set_principalGrants(const std::vector<RolePrincipalGrant> & val) {
  this->principalGrants = val;
}
std::ostream& operator<<(std::ostream& out, const GetRoleGrantsForPrincipalResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetRoleGrantsForPrincipalResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_principalGrants = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->principalGrants.clear();
            uint32_t _size153;
            ::apache::thrift::protocol::TType _etype156;
            xfer += iprot->readListBegin(_etype156, _size153);
            this->principalGrants.resize(_size153);
            uint32_t _i157;
            for (_i157 = 0; _i157 < _size153; ++_i157)
            {
              xfer += this->principalGrants[_i157].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_principalGrants = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_principalGrants)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetRoleGrantsForPrincipalResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetRoleGrantsForPrincipalResponse");

  xfer += oprot->writeFieldBegin("principalGrants", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->principalGrants.size()));
    std::vector<RolePrincipalGrant> ::const_iterator _iter158;
    for (_iter158 = this->principalGrants.begin(); _iter158 != this->principalGrants.end(); ++_iter158)
    {
      xfer += (*_iter158).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetRoleGrantsForPrincipalResponse &a, GetRoleGrantsForPrincipalResponse &b) {
  using ::std::swap;
  swap(a.principalGrants, b.principalGrants);
}

GetRoleGrantsForPrincipalResponse::GetRoleGrantsForPrincipalResponse(const GetRoleGrantsForPrincipalResponse& other159) {
  principalGrants = other159.principalGrants;
}
GetRoleGrantsForPrincipalResponse& GetRoleGrantsForPrincipalResponse::operator=(const GetRoleGrantsForPrincipalResponse& other160) {
  principalGrants = other160.principalGrants;
  return *this;
}
void GetRoleGrantsForPrincipalResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetRoleGrantsForPrincipalResponse(";
  out << "principalGrants=" << to_string(principalGrants);
  out << ")";
}


GetPrincipalsInRoleRequest::~GetPrincipalsInRoleRequest() noexcept {
}


void GetPrincipalsInRoleRequest::__set_roleName(const std::string& val) {
  this->roleName = val;
}
std::ostream& operator<<(std::ostream& out, const GetPrincipalsInRoleRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPrincipalsInRoleRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_roleName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roleName);
          isset_roleName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_roleName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPrincipalsInRoleRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPrincipalsInRoleRequest");

  xfer += oprot->writeFieldBegin("roleName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->roleName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPrincipalsInRoleRequest &a, GetPrincipalsInRoleRequest &b) {
  using ::std::swap;
  swap(a.roleName, b.roleName);
}

GetPrincipalsInRoleRequest::GetPrincipalsInRoleRequest(const GetPrincipalsInRoleRequest& other161) {
  roleName = other161.roleName;
}
GetPrincipalsInRoleRequest& GetPrincipalsInRoleRequest::operator=(const GetPrincipalsInRoleRequest& other162) {
  roleName = other162.roleName;
  return *this;
}
void GetPrincipalsInRoleRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPrincipalsInRoleRequest(";
  out << "roleName=" << to_string(roleName);
  out << ")";
}


GetPrincipalsInRoleResponse::~GetPrincipalsInRoleResponse() noexcept {
}


void GetPrincipalsInRoleResponse::__set_principalGrants(const std::vector<RolePrincipalGrant> & val) {
  this->principalGrants = val;
}
std::ostream& operator<<(std::ostream& out, const GetPrincipalsInRoleResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPrincipalsInRoleResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_principalGrants = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->principalGrants.clear();
            uint32_t _size163;
            ::apache::thrift::protocol::TType _etype166;
            xfer += iprot->readListBegin(_etype166, _size163);
            this->principalGrants.resize(_size163);
            uint32_t _i167;
            for (_i167 = 0; _i167 < _size163; ++_i167)
            {
              xfer += this->principalGrants[_i167].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_principalGrants = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_principalGrants)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPrincipalsInRoleResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPrincipalsInRoleResponse");

  xfer += oprot->writeFieldBegin("principalGrants", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->principalGrants.size()));
    std::vector<RolePrincipalGrant> ::const_iterator _iter168;
    for (_iter168 = this->principalGrants.begin(); _iter168 != this->principalGrants.end(); ++_iter168)
    {
      xfer += (*_iter168).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPrincipalsInRoleResponse &a, GetPrincipalsInRoleResponse &b) {
  using ::std::swap;
  swap(a.principalGrants, b.principalGrants);
}

GetPrincipalsInRoleResponse::GetPrincipalsInRoleResponse(const GetPrincipalsInRoleResponse& other169) {
  principalGrants = other169.principalGrants;
}
GetPrincipalsInRoleResponse& GetPrincipalsInRoleResponse::operator=(const GetPrincipalsInRoleResponse& other170) {
  principalGrants = other170.principalGrants;
  return *this;
}
void GetPrincipalsInRoleResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPrincipalsInRoleResponse(";
  out << "principalGrants=" << to_string(principalGrants);
  out << ")";
}


GrantRevokeRoleRequest::~GrantRevokeRoleRequest() noexcept {
}


void GrantRevokeRoleRequest::__set_requestType(const GrantRevokeType::type val) {
  this->requestType = val;
}

void GrantRevokeRoleRequest::__set_roleName(const std::string& val) {
  this->roleName = val;
}

void GrantRevokeRoleRequest::__set_principalName(const std::string& val) {
  this->principalName = val;
}

void GrantRevokeRoleRequest::__set_principalType(const PrincipalType::type val) {
  this->principalType = val;
}

void GrantRevokeRoleRequest::__set_grantor(const std::string& val) {
  this->grantor = val;
__isset.grantor = true;
}

void GrantRevokeRoleRequest::__set_grantorType(const PrincipalType::type val) {
  this->grantorType = val;
__isset.grantorType = true;
}

void GrantRevokeRoleRequest::__set_grantOption(const bool val) {
  this->grantOption = val;
__isset.grantOption = true;
}
std::ostream& operator<<(std::ostream& out, const GrantRevokeRoleRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GrantRevokeRoleRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast171;
          xfer += iprot->readI32(ecast171);
          this->requestType = (GrantRevokeType::type)ecast171;
          this->__isset.requestType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roleName);
          this->__isset.roleName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principalName);
          this->__isset.principalName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast172;
          xfer += iprot->readI32(ecast172);
          this->principalType = (PrincipalType::type)ecast172;
          this->__isset.principalType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->grantor);
          this->__isset.grantor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast173;
          xfer += iprot->readI32(ecast173);
          this->grantorType = (PrincipalType::type)ecast173;
          this->__isset.grantorType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->grantOption);
          this->__isset.grantOption = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GrantRevokeRoleRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GrantRevokeRoleRequest");

  xfer += oprot->writeFieldBegin("requestType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->requestType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roleName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->roleName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->principalName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalType", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->principalType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.grantor) {
    xfer += oprot->writeFieldBegin("grantor", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->grantor);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.grantorType) {
    xfer += oprot->writeFieldBegin("grantorType", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->grantorType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.grantOption) {
    xfer += oprot->writeFieldBegin("grantOption", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->grantOption);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GrantRevokeRoleRequest &a, GrantRevokeRoleRequest &b) {
  using ::std::swap;
  swap(a.requestType, b.requestType);
  swap(a.roleName, b.roleName);
  swap(a.principalName, b.principalName);
  swap(a.principalType, b.principalType);
  swap(a.grantor, b.grantor);
  swap(a.grantorType, b.grantorType);
  swap(a.grantOption, b.grantOption);
  swap(a.__isset, b.__isset);
}

GrantRevokeRoleRequest::GrantRevokeRoleRequest(const GrantRevokeRoleRequest& other174) {
  requestType = other174.requestType;
  roleName = other174.roleName;
  principalName = other174.principalName;
  principalType = other174.principalType;
  grantor = other174.grantor;
  grantorType = other174.grantorType;
  grantOption = other174.grantOption;
  __isset = other174.__isset;
}
GrantRevokeRoleRequest& GrantRevokeRoleRequest::operator=(const GrantRevokeRoleRequest& other175) {
  requestType = other175.requestType;
  roleName = other175.roleName;
  principalName = other175.principalName;
  principalType = other175.principalType;
  grantor = other175.grantor;
  grantorType = other175.grantorType;
  grantOption = other175.grantOption;
  __isset = other175.__isset;
  return *this;
}
void GrantRevokeRoleRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GrantRevokeRoleRequest(";
  out << "requestType=" << to_string(requestType);
  out << ", " << "roleName=" << to_string(roleName);
  out << ", " << "principalName=" << to_string(principalName);
  out << ", " << "principalType=" << to_string(principalType);
  out << ", " << "grantor="; (__isset.grantor ? (out << to_string(grantor)) : (out << "<null>"));
  out << ", " << "grantorType="; (__isset.grantorType ? (out << to_string(grantorType)) : (out << "<null>"));
  out << ", " << "grantOption="; (__isset.grantOption ? (out << to_string(grantOption)) : (out << "<null>"));
  out << ")";
}


GrantRevokeRoleResponse::~GrantRevokeRoleResponse() noexcept {
}


void GrantRevokeRoleResponse::__set_success(const bool val) {
  this->success = val;
__isset.success = true;
}
std::ostream& operator<<(std::ostream& out, const GrantRevokeRoleResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GrantRevokeRoleResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GrantRevokeRoleResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GrantRevokeRoleResponse");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GrantRevokeRoleResponse &a, GrantRevokeRoleResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.__isset, b.__isset);
}

GrantRevokeRoleResponse::GrantRevokeRoleResponse(const GrantRevokeRoleResponse& other176) {
  success = other176.success;
  __isset = other176.__isset;
}
GrantRevokeRoleResponse& GrantRevokeRoleResponse::operator=(const GrantRevokeRoleResponse& other177) {
  success = other177.success;
  __isset = other177.__isset;
  return *this;
}
void GrantRevokeRoleResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GrantRevokeRoleResponse(";
  out << "success="; (__isset.success ? (out << to_string(success)) : (out << "<null>"));
  out << ")";
}


Catalog::~Catalog() noexcept {
}


void Catalog::__set_name(const std::string& val) {
  this->name = val;
}

void Catalog::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void Catalog::__set_locationUri(const std::string& val) {
  this->locationUri = val;
}

void Catalog::__set_createTime(const int32_t val) {
  this->createTime = val;
__isset.createTime = true;
}
std::ostream& operator<<(std::ostream& out, const Catalog& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Catalog::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->locationUri);
          this->__isset.locationUri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Catalog::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Catalog");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("locationUri", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->locationUri);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.createTime) {
    xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->createTime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Catalog &a, Catalog &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.description, b.description);
  swap(a.locationUri, b.locationUri);
  swap(a.createTime, b.createTime);
  swap(a.__isset, b.__isset);
}

Catalog::Catalog(const Catalog& other178) {
  name = other178.name;
  description = other178.description;
  locationUri = other178.locationUri;
  createTime = other178.createTime;
  __isset = other178.__isset;
}
Catalog& Catalog::operator=(const Catalog& other179) {
  name = other179.name;
  description = other179.description;
  locationUri = other179.locationUri;
  createTime = other179.createTime;
  __isset = other179.__isset;
  return *this;
}
void Catalog::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Catalog(";
  out << "name=" << to_string(name);
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "locationUri=" << to_string(locationUri);
  out << ", " << "createTime="; (__isset.createTime ? (out << to_string(createTime)) : (out << "<null>"));
  out << ")";
}


CreateCatalogRequest::~CreateCatalogRequest() noexcept {
}


void CreateCatalogRequest::__set_catalog(const Catalog& val) {
  this->catalog = val;
}
std::ostream& operator<<(std::ostream& out, const CreateCatalogRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateCatalogRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalog.read(iprot);
          this->__isset.catalog = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateCatalogRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateCatalogRequest");

  xfer += oprot->writeFieldBegin("catalog", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->catalog.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateCatalogRequest &a, CreateCatalogRequest &b) {
  using ::std::swap;
  swap(a.catalog, b.catalog);
  swap(a.__isset, b.__isset);
}

CreateCatalogRequest::CreateCatalogRequest(const CreateCatalogRequest& other180) {
  catalog = other180.catalog;
  __isset = other180.__isset;
}
CreateCatalogRequest& CreateCatalogRequest::operator=(const CreateCatalogRequest& other181) {
  catalog = other181.catalog;
  __isset = other181.__isset;
  return *this;
}
void CreateCatalogRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateCatalogRequest(";
  out << "catalog=" << to_string(catalog);
  out << ")";
}


AlterCatalogRequest::~AlterCatalogRequest() noexcept {
}


void AlterCatalogRequest::__set_name(const std::string& val) {
  this->name = val;
}

void AlterCatalogRequest::__set_newCat(const Catalog& val) {
  this->newCat = val;
}
std::ostream& operator<<(std::ostream& out, const AlterCatalogRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AlterCatalogRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->newCat.read(iprot);
          this->__isset.newCat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlterCatalogRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AlterCatalogRequest");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newCat", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->newCat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlterCatalogRequest &a, AlterCatalogRequest &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.newCat, b.newCat);
  swap(a.__isset, b.__isset);
}

AlterCatalogRequest::AlterCatalogRequest(const AlterCatalogRequest& other182) {
  name = other182.name;
  newCat = other182.newCat;
  __isset = other182.__isset;
}
AlterCatalogRequest& AlterCatalogRequest::operator=(const AlterCatalogRequest& other183) {
  name = other183.name;
  newCat = other183.newCat;
  __isset = other183.__isset;
  return *this;
}
void AlterCatalogRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AlterCatalogRequest(";
  out << "name=" << to_string(name);
  out << ", " << "newCat=" << to_string(newCat);
  out << ")";
}


GetCatalogRequest::~GetCatalogRequest() noexcept {
}


void GetCatalogRequest::__set_name(const std::string& val) {
  this->name = val;
}
std::ostream& operator<<(std::ostream& out, const GetCatalogRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetCatalogRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetCatalogRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetCatalogRequest");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetCatalogRequest &a, GetCatalogRequest &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

GetCatalogRequest::GetCatalogRequest(const GetCatalogRequest& other184) {
  name = other184.name;
  __isset = other184.__isset;
}
GetCatalogRequest& GetCatalogRequest::operator=(const GetCatalogRequest& other185) {
  name = other185.name;
  __isset = other185.__isset;
  return *this;
}
void GetCatalogRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetCatalogRequest(";
  out << "name=" << to_string(name);
  out << ")";
}


GetCatalogResponse::~GetCatalogResponse() noexcept {
}


void GetCatalogResponse::__set_catalog(const Catalog& val) {
  this->catalog = val;
}
std::ostream& operator<<(std::ostream& out, const GetCatalogResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetCatalogResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalog.read(iprot);
          this->__isset.catalog = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetCatalogResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetCatalogResponse");

  xfer += oprot->writeFieldBegin("catalog", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->catalog.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetCatalogResponse &a, GetCatalogResponse &b) {
  using ::std::swap;
  swap(a.catalog, b.catalog);
  swap(a.__isset, b.__isset);
}

GetCatalogResponse::GetCatalogResponse(const GetCatalogResponse& other186) {
  catalog = other186.catalog;
  __isset = other186.__isset;
}
GetCatalogResponse& GetCatalogResponse::operator=(const GetCatalogResponse& other187) {
  catalog = other187.catalog;
  __isset = other187.__isset;
  return *this;
}
void GetCatalogResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetCatalogResponse(";
  out << "catalog=" << to_string(catalog);
  out << ")";
}


GetCatalogsResponse::~GetCatalogsResponse() noexcept {
}


void GetCatalogsResponse::__set_names(const std::vector<std::string> & val) {
  this->names = val;
}
std::ostream& operator<<(std::ostream& out, const GetCatalogsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetCatalogsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size188;
            ::apache::thrift::protocol::TType _etype191;
            xfer += iprot->readListBegin(_etype191, _size188);
            this->names.resize(_size188);
            uint32_t _i192;
            for (_i192 = 0; _i192 < _size188; ++_i192)
            {
              xfer += iprot->readString(this->names[_i192]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetCatalogsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetCatalogsResponse");

  xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->names.size()));
    std::vector<std::string> ::const_iterator _iter193;
    for (_iter193 = this->names.begin(); _iter193 != this->names.end(); ++_iter193)
    {
      xfer += oprot->writeString((*_iter193));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetCatalogsResponse &a, GetCatalogsResponse &b) {
  using ::std::swap;
  swap(a.names, b.names);
  swap(a.__isset, b.__isset);
}

GetCatalogsResponse::GetCatalogsResponse(const GetCatalogsResponse& other194) {
  names = other194.names;
  __isset = other194.__isset;
}
GetCatalogsResponse& GetCatalogsResponse::operator=(const GetCatalogsResponse& other195) {
  names = other195.names;
  __isset = other195.__isset;
  return *this;
}
void GetCatalogsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetCatalogsResponse(";
  out << "names=" << to_string(names);
  out << ")";
}


DropCatalogRequest::~DropCatalogRequest() noexcept {
}


void DropCatalogRequest::__set_name(const std::string& val) {
  this->name = val;
}
std::ostream& operator<<(std::ostream& out, const DropCatalogRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropCatalogRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DropCatalogRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropCatalogRequest");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropCatalogRequest &a, DropCatalogRequest &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

DropCatalogRequest::DropCatalogRequest(const DropCatalogRequest& other196) {
  name = other196.name;
  __isset = other196.__isset;
}
DropCatalogRequest& DropCatalogRequest::operator=(const DropCatalogRequest& other197) {
  name = other197.name;
  __isset = other197.__isset;
  return *this;
}
void DropCatalogRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropCatalogRequest(";
  out << "name=" << to_string(name);
  out << ")";
}


Database::~Database() noexcept {
}


void Database::__set_name(const std::string& val) {
  this->name = val;
}

void Database::__set_description(const std::string& val) {
  this->description = val;
}

void Database::__set_locationUri(const std::string& val) {
  this->locationUri = val;
}

void Database::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void Database::__set_privileges(const PrincipalPrivilegeSet& val) {
  this->privileges = val;
__isset.privileges = true;
}

void Database::__set_ownerName(const std::string& val) {
  this->ownerName = val;
__isset.ownerName = true;
}

void Database::__set_ownerType(const PrincipalType::type val) {
  this->ownerType = val;
__isset.ownerType = true;
}

void Database::__set_catalogName(const std::string& val) {
  this->catalogName = val;
__isset.catalogName = true;
}

void Database::__set_createTime(const int32_t val) {
  this->createTime = val;
__isset.createTime = true;
}

void Database::__set_managedLocationUri(const std::string& val) {
  this->managedLocationUri = val;
__isset.managedLocationUri = true;
}

void Database::__set_type(const DatabaseType::type val) {
  this->type = val;
__isset.type = true;
}

void Database::__set_connector_name(const std::string& val) {
  this->connector_name = val;
__isset.connector_name = true;
}

void Database::__set_remote_dbname(const std::string& val) {
  this->remote_dbname = val;
__isset.remote_dbname = true;
}
std::ostream& operator<<(std::ostream& out, const Database& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Database::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->locationUri);
          this->__isset.locationUri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size198;
            ::apache::thrift::protocol::TType _ktype199;
            ::apache::thrift::protocol::TType _vtype200;
            xfer += iprot->readMapBegin(_ktype199, _vtype200, _size198);
            uint32_t _i202;
            for (_i202 = 0; _i202 < _size198; ++_i202)
            {
              std::string _key203;
              xfer += iprot->readString(_key203);
              std::string& _val204 = this->parameters[_key203];
              xfer += iprot->readString(_val204);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast205;
          xfer += iprot->readI32(ecast205);
          this->ownerType = (PrincipalType::type)ecast205;
          this->__isset.ownerType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogName);
          this->__isset.catalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->managedLocationUri);
          this->__isset.managedLocationUri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast206;
          xfer += iprot->readI32(ecast206);
          this->type = (DatabaseType::type)ecast206;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->connector_name);
          this->__isset.connector_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->remote_dbname);
          this->__isset.remote_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Database::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Database");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->description);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("locationUri", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->locationUri);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter207;
    for (_iter207 = this->parameters.begin(); _iter207 != this->parameters.end(); ++_iter207)
    {
      xfer += oprot->writeString(_iter207->first);
      xfer += oprot->writeString(_iter207->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.privileges) {
    xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->privileges.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ownerName) {
    xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->ownerName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ownerType) {
    xfer += oprot->writeFieldBegin("ownerType", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->ownerType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalogName) {
    xfer += oprot->writeFieldBegin("catalogName", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->catalogName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTime) {
    xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->createTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.managedLocationUri) {
    xfer += oprot->writeFieldBegin("managedLocationUri", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->managedLocationUri);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connector_name) {
    xfer += oprot->writeFieldBegin("connector_name", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->connector_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.remote_dbname) {
    xfer += oprot->writeFieldBegin("remote_dbname", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->remote_dbname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Database &a, Database &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.description, b.description);
  swap(a.locationUri, b.locationUri);
  swap(a.parameters, b.parameters);
  swap(a.privileges, b.privileges);
  swap(a.ownerName, b.ownerName);
  swap(a.ownerType, b.ownerType);
  swap(a.catalogName, b.catalogName);
  swap(a.createTime, b.createTime);
  swap(a.managedLocationUri, b.managedLocationUri);
  swap(a.type, b.type);
  swap(a.connector_name, b.connector_name);
  swap(a.remote_dbname, b.remote_dbname);
  swap(a.__isset, b.__isset);
}

Database::Database(const Database& other208) {
  name = other208.name;
  description = other208.description;
  locationUri = other208.locationUri;
  parameters = other208.parameters;
  privileges = other208.privileges;
  ownerName = other208.ownerName;
  ownerType = other208.ownerType;
  catalogName = other208.catalogName;
  createTime = other208.createTime;
  managedLocationUri = other208.managedLocationUri;
  type = other208.type;
  connector_name = other208.connector_name;
  remote_dbname = other208.remote_dbname;
  __isset = other208.__isset;
}
Database& Database::operator=(const Database& other209) {
  name = other209.name;
  description = other209.description;
  locationUri = other209.locationUri;
  parameters = other209.parameters;
  privileges = other209.privileges;
  ownerName = other209.ownerName;
  ownerType = other209.ownerType;
  catalogName = other209.catalogName;
  createTime = other209.createTime;
  managedLocationUri = other209.managedLocationUri;
  type = other209.type;
  connector_name = other209.connector_name;
  remote_dbname = other209.remote_dbname;
  __isset = other209.__isset;
  return *this;
}
void Database::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Database(";
  out << "name=" << to_string(name);
  out << ", " << "description=" << to_string(description);
  out << ", " << "locationUri=" << to_string(locationUri);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "privileges="; (__isset.privileges ? (out << to_string(privileges)) : (out << "<null>"));
  out << ", " << "ownerName="; (__isset.ownerName ? (out << to_string(ownerName)) : (out << "<null>"));
  out << ", " << "ownerType="; (__isset.ownerType ? (out << to_string(ownerType)) : (out << "<null>"));
  out << ", " << "catalogName="; (__isset.catalogName ? (out << to_string(catalogName)) : (out << "<null>"));
  out << ", " << "createTime="; (__isset.createTime ? (out << to_string(createTime)) : (out << "<null>"));
  out << ", " << "managedLocationUri="; (__isset.managedLocationUri ? (out << to_string(managedLocationUri)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "connector_name="; (__isset.connector_name ? (out << to_string(connector_name)) : (out << "<null>"));
  out << ", " << "remote_dbname="; (__isset.remote_dbname ? (out << to_string(remote_dbname)) : (out << "<null>"));
  out << ")";
}


SerDeInfo::~SerDeInfo() noexcept {
}


void SerDeInfo::__set_name(const std::string& val) {
  this->name = val;
}

void SerDeInfo::__set_serializationLib(const std::string& val) {
  this->serializationLib = val;
}

void SerDeInfo::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void SerDeInfo::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void SerDeInfo::__set_serializerClass(const std::string& val) {
  this->serializerClass = val;
__isset.serializerClass = true;
}

void SerDeInfo::__set_deserializerClass(const std::string& val) {
  this->deserializerClass = val;
__isset.deserializerClass = true;
}

void SerDeInfo::__set_serdeType(const SerdeType::type val) {
  this->serdeType = val;
__isset.serdeType = true;
}
std::ostream& operator<<(std::ostream& out, const SerDeInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SerDeInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serializationLib);
          this->__isset.serializationLib = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size210;
            ::apache::thrift::protocol::TType _ktype211;
            ::apache::thrift::protocol::TType _vtype212;
            xfer += iprot->readMapBegin(_ktype211, _vtype212, _size210);
            uint32_t _i214;
            for (_i214 = 0; _i214 < _size210; ++_i214)
            {
              std::string _key215;
              xfer += iprot->readString(_key215);
              std::string& _val216 = this->parameters[_key215];
              xfer += iprot->readString(_val216);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serializerClass);
          this->__isset.serializerClass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deserializerClass);
          this->__isset.deserializerClass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast217;
          xfer += iprot->readI32(ecast217);
          this->serdeType = (SerdeType::type)ecast217;
          this->__isset.serdeType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SerDeInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SerDeInfo");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serializationLib", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->serializationLib);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter218;
    for (_iter218 = this->parameters.begin(); _iter218 != this->parameters.end(); ++_iter218)
    {
      xfer += oprot->writeString(_iter218->first);
      xfer += oprot->writeString(_iter218->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.serializerClass) {
    xfer += oprot->writeFieldBegin("serializerClass", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->serializerClass);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deserializerClass) {
    xfer += oprot->writeFieldBegin("deserializerClass", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->deserializerClass);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.serdeType) {
    xfer += oprot->writeFieldBegin("serdeType", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->serdeType);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SerDeInfo &a, SerDeInfo &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.serializationLib, b.serializationLib);
  swap(a.parameters, b.parameters);
  swap(a.description, b.description);
  swap(a.serializerClass, b.serializerClass);
  swap(a.deserializerClass, b.deserializerClass);
  swap(a.serdeType, b.serdeType);
  swap(a.__isset, b.__isset);
}

SerDeInfo::SerDeInfo(const SerDeInfo& other219) {
  name = other219.name;
  serializationLib = other219.serializationLib;
  parameters = other219.parameters;
  description = other219.description;
  serializerClass = other219.serializerClass;
  deserializerClass = other219.deserializerClass;
  serdeType = other219.serdeType;
  __isset = other219.__isset;
}
SerDeInfo& SerDeInfo::operator=(const SerDeInfo& other220) {
  name = other220.name;
  serializationLib = other220.serializationLib;
  parameters = other220.parameters;
  description = other220.description;
  serializerClass = other220.serializerClass;
  deserializerClass = other220.deserializerClass;
  serdeType = other220.serdeType;
  __isset = other220.__isset;
  return *this;
}
void SerDeInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SerDeInfo(";
  out << "name=" << to_string(name);
  out << ", " << "serializationLib=" << to_string(serializationLib);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "serializerClass="; (__isset.serializerClass ? (out << to_string(serializerClass)) : (out << "<null>"));
  out << ", " << "deserializerClass="; (__isset.deserializerClass ? (out << to_string(deserializerClass)) : (out << "<null>"));
  out << ", " << "serdeType="; (__isset.serdeType ? (out << to_string(serdeType)) : (out << "<null>"));
  out << ")";
}


Order::~Order() noexcept {
}


void Order::__set_col(const std::string& val) {
  this->col = val;
}

void Order::__set_order(const int32_t val) {
  this->order = val;
}
std::ostream& operator<<(std::ostream& out, const Order& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Order::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->col);
          this->__isset.col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->order);
          this->__isset.order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Order::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Order");

  xfer += oprot->writeFieldBegin("col", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->col);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("order", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->order);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Order &a, Order &b) {
  using ::std::swap;
  swap(a.col, b.col);
  swap(a.order, b.order);
  swap(a.__isset, b.__isset);
}

Order::Order(const Order& other221) {
  col = other221.col;
  order = other221.order;
  __isset = other221.__isset;
}
Order& Order::operator=(const Order& other222) {
  col = other222.col;
  order = other222.order;
  __isset = other222.__isset;
  return *this;
}
void Order::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Order(";
  out << "col=" << to_string(col);
  out << ", " << "order=" << to_string(order);
  out << ")";
}


SkewedInfo::~SkewedInfo() noexcept {
}


void SkewedInfo::__set_skewedColNames(const std::vector<std::string> & val) {
  this->skewedColNames = val;
}

void SkewedInfo::__set_skewedColValues(const std::vector<std::vector<std::string> > & val) {
  this->skewedColValues = val;
}

void SkewedInfo::__set_skewedColValueLocationMaps(const std::map<std::vector<std::string> , std::string> & val) {
  this->skewedColValueLocationMaps = val;
}
std::ostream& operator<<(std::ostream& out, const SkewedInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SkewedInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->skewedColNames.clear();
            uint32_t _size223;
            ::apache::thrift::protocol::TType _etype226;
            xfer += iprot->readListBegin(_etype226, _size223);
            this->skewedColNames.resize(_size223);
            uint32_t _i227;
            for (_i227 = 0; _i227 < _size223; ++_i227)
            {
              xfer += iprot->readString(this->skewedColNames[_i227]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.skewedColNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->skewedColValues.clear();
            uint32_t _size228;
            ::apache::thrift::protocol::TType _etype231;
            xfer += iprot->readListBegin(_etype231, _size228);
            this->skewedColValues.resize(_size228);
            uint32_t _i232;
            for (_i232 = 0; _i232 < _size228; ++_i232)
            {
              {
                this->skewedColValues[_i232].clear();
                uint32_t _size233;
                ::apache::thrift::protocol::TType _etype236;
                xfer += iprot->readListBegin(_etype236, _size233);
                this->skewedColValues[_i232].resize(_size233);
                uint32_t _i237;
                for (_i237 = 0; _i237 < _size233; ++_i237)
                {
                  xfer += iprot->readString(this->skewedColValues[_i232][_i237]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.skewedColValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->skewedColValueLocationMaps.clear();
            uint32_t _size238;
            ::apache::thrift::protocol::TType _ktype239;
            ::apache::thrift::protocol::TType _vtype240;
            xfer += iprot->readMapBegin(_ktype239, _vtype240, _size238);
            uint32_t _i242;
            for (_i242 = 0; _i242 < _size238; ++_i242)
            {
              std::vector<std::string>  _key243;
              {
                _key243.clear();
                uint32_t _size245;
                ::apache::thrift::protocol::TType _etype248;
                xfer += iprot->readListBegin(_etype248, _size245);
                _key243.resize(_size245);
                uint32_t _i249;
                for (_i249 = 0; _i249 < _size245; ++_i249)
                {
                  xfer += iprot->readString(_key243[_i249]);
                }
                xfer += iprot->readListEnd();
              }
              std::string& _val244 = this->skewedColValueLocationMaps[_key243];
              xfer += iprot->readString(_val244);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.skewedColValueLocationMaps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SkewedInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SkewedInfo");

  xfer += oprot->writeFieldBegin("skewedColNames", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->skewedColNames.size()));
    std::vector<std::string> ::const_iterator _iter250;
    for (_iter250 = this->skewedColNames.begin(); _iter250 != this->skewedColNames.end(); ++_iter250)
    {
      xfer += oprot->writeString((*_iter250));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skewedColValues", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->skewedColValues.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter251;
    for (_iter251 = this->skewedColValues.begin(); _iter251 != this->skewedColValues.end(); ++_iter251)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter251).size()));
        std::vector<std::string> ::const_iterator _iter252;
        for (_iter252 = (*_iter251).begin(); _iter252 != (*_iter251).end(); ++_iter252)
        {
          xfer += oprot->writeString((*_iter252));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skewedColValueLocationMaps", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_LIST, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->skewedColValueLocationMaps.size()));
    std::map<std::vector<std::string> , std::string> ::const_iterator _iter253;
    for (_iter253 = this->skewedColValueLocationMaps.begin(); _iter253 != this->skewedColValueLocationMaps.end(); ++_iter253)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter253->first.size()));
        std::vector<std::string> ::const_iterator _iter254;
        for (_iter254 = _iter253->first.begin(); _iter254 != _iter253->first.end(); ++_iter254)
        {
          xfer += oprot->writeString((*_iter254));
        }
        xfer += oprot->writeListEnd();
      }
      xfer += oprot->writeString(_iter253->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SkewedInfo &a, SkewedInfo &b) {
  using ::std::swap;
  swap(a.skewedColNames, b.skewedColNames);
  swap(a.skewedColValues, b.skewedColValues);
  swap(a.skewedColValueLocationMaps, b.skewedColValueLocationMaps);
  swap(a.__isset, b.__isset);
}

SkewedInfo::SkewedInfo(const SkewedInfo& other255) {
  skewedColNames = other255.skewedColNames;
  skewedColValues = other255.skewedColValues;
  skewedColValueLocationMaps = other255.skewedColValueLocationMaps;
  __isset = other255.__isset;
}
SkewedInfo& SkewedInfo::operator=(const SkewedInfo& other256) {
  skewedColNames = other256.skewedColNames;
  skewedColValues = other256.skewedColValues;
  skewedColValueLocationMaps = other256.skewedColValueLocationMaps;
  __isset = other256.__isset;
  return *this;
}
void SkewedInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SkewedInfo(";
  out << "skewedColNames=" << to_string(skewedColNames);
  out << ", " << "skewedColValues=" << to_string(skewedColValues);
  out << ", " << "skewedColValueLocationMaps=" << to_string(skewedColValueLocationMaps);
  out << ")";
}


StorageDescriptor::~StorageDescriptor() noexcept {
}


void StorageDescriptor::__set_cols(const std::vector<FieldSchema> & val) {
  this->cols = val;
}

void StorageDescriptor::__set_location(const std::string& val) {
  this->location = val;
}

void StorageDescriptor::__set_inputFormat(const std::string& val) {
  this->inputFormat = val;
}

void StorageDescriptor::__set_outputFormat(const std::string& val) {
  this->outputFormat = val;
}

void StorageDescriptor::__set_compressed(const bool val) {
  this->compressed = val;
}

void StorageDescriptor::__set_numBuckets(const int32_t val) {
  this->numBuckets = val;
}

void StorageDescriptor::__set_serdeInfo(const SerDeInfo& val) {
  this->serdeInfo = val;
}

void StorageDescriptor::__set_bucketCols(const std::vector<std::string> & val) {
  this->bucketCols = val;
}

void StorageDescriptor::__set_sortCols(const std::vector<Order> & val) {
  this->sortCols = val;
}

void StorageDescriptor::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void StorageDescriptor::__set_skewedInfo(const SkewedInfo& val) {
  this->skewedInfo = val;
__isset.skewedInfo = true;
}

void StorageDescriptor::__set_storedAsSubDirectories(const bool val) {
  this->storedAsSubDirectories = val;
__isset.storedAsSubDirectories = true;
}
std::ostream& operator<<(std::ostream& out, const StorageDescriptor& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StorageDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cols.clear();
            uint32_t _size257;
            ::apache::thrift::protocol::TType _etype260;
            xfer += iprot->readListBegin(_etype260, _size257);
            this->cols.resize(_size257);
            uint32_t _i261;
            for (_i261 = 0; _i261 < _size257; ++_i261)
            {
              xfer += this->cols[_i261].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->inputFormat);
          this->__isset.inputFormat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->outputFormat);
          this->__isset.outputFormat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compressed);
          this->__isset.compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numBuckets);
          this->__isset.numBuckets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->serdeInfo.read(iprot);
          this->__isset.serdeInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bucketCols.clear();
            uint32_t _size262;
            ::apache::thrift::protocol::TType _etype265;
            xfer += iprot->readListBegin(_etype265, _size262);
            this->bucketCols.resize(_size262);
            uint32_t _i266;
            for (_i266 = 0; _i266 < _size262; ++_i266)
            {
              xfer += iprot->readString(this->bucketCols[_i266]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.bucketCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sortCols.clear();
            uint32_t _size267;
            ::apache::thrift::protocol::TType _etype270;
            xfer += iprot->readListBegin(_etype270, _size267);
            this->sortCols.resize(_size267);
            uint32_t _i271;
            for (_i271 = 0; _i271 < _size267; ++_i271)
            {
              xfer += this->sortCols[_i271].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sortCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size272;
            ::apache::thrift::protocol::TType _ktype273;
            ::apache::thrift::protocol::TType _vtype274;
            xfer += iprot->readMapBegin(_ktype273, _vtype274, _size272);
            uint32_t _i276;
            for (_i276 = 0; _i276 < _size272; ++_i276)
            {
              std::string _key277;
              xfer += iprot->readString(_key277);
              std::string& _val278 = this->parameters[_key277];
              xfer += iprot->readString(_val278);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->skewedInfo.read(iprot);
          this->__isset.skewedInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->storedAsSubDirectories);
          this->__isset.storedAsSubDirectories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StorageDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StorageDescriptor");

  xfer += oprot->writeFieldBegin("cols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cols.size()));
    std::vector<FieldSchema> ::const_iterator _iter279;
    for (_iter279 = this->cols.begin(); _iter279 != this->cols.end(); ++_iter279)
    {
      xfer += (*_iter279).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->location);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inputFormat", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->inputFormat);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputFormat", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->outputFormat);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compressed", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->compressed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numBuckets", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->numBuckets);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serdeInfo", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->serdeInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bucketCols", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->bucketCols.size()));
    std::vector<std::string> ::const_iterator _iter280;
    for (_iter280 = this->bucketCols.begin(); _iter280 != this->bucketCols.end(); ++_iter280)
    {
      xfer += oprot->writeString((*_iter280));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sortCols", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->sortCols.size()));
    std::vector<Order> ::const_iterator _iter281;
    for (_iter281 = this->sortCols.begin(); _iter281 != this->sortCols.end(); ++_iter281)
    {
      xfer += (*_iter281).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter282;
    for (_iter282 = this->parameters.begin(); _iter282 != this->parameters.end(); ++_iter282)
    {
      xfer += oprot->writeString(_iter282->first);
      xfer += oprot->writeString(_iter282->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.skewedInfo) {
    xfer += oprot->writeFieldBegin("skewedInfo", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->skewedInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storedAsSubDirectories) {
    xfer += oprot->writeFieldBegin("storedAsSubDirectories", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->storedAsSubDirectories);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StorageDescriptor &a, StorageDescriptor &b) {
  using ::std::swap;
  swap(a.cols, b.cols);
  swap(a.location, b.location);
  swap(a.inputFormat, b.inputFormat);
  swap(a.outputFormat, b.outputFormat);
  swap(a.compressed, b.compressed);
  swap(a.numBuckets, b.numBuckets);
  swap(a.serdeInfo, b.serdeInfo);
  swap(a.bucketCols, b.bucketCols);
  swap(a.sortCols, b.sortCols);
  swap(a.parameters, b.parameters);
  swap(a.skewedInfo, b.skewedInfo);
  swap(a.storedAsSubDirectories, b.storedAsSubDirectories);
  swap(a.__isset, b.__isset);
}

StorageDescriptor::StorageDescriptor(const StorageDescriptor& other283) {
  cols = other283.cols;
  location = other283.location;
  inputFormat = other283.inputFormat;
  outputFormat = other283.outputFormat;
  compressed = other283.compressed;
  numBuckets = other283.numBuckets;
  serdeInfo = other283.serdeInfo;
  bucketCols = other283.bucketCols;
  sortCols = other283.sortCols;
  parameters = other283.parameters;
  skewedInfo = other283.skewedInfo;
  storedAsSubDirectories = other283.storedAsSubDirectories;
  __isset = other283.__isset;
}
StorageDescriptor& StorageDescriptor::operator=(const StorageDescriptor& other284) {
  cols = other284.cols;
  location = other284.location;
  inputFormat = other284.inputFormat;
  outputFormat = other284.outputFormat;
  compressed = other284.compressed;
  numBuckets = other284.numBuckets;
  serdeInfo = other284.serdeInfo;
  bucketCols = other284.bucketCols;
  sortCols = other284.sortCols;
  parameters = other284.parameters;
  skewedInfo = other284.skewedInfo;
  storedAsSubDirectories = other284.storedAsSubDirectories;
  __isset = other284.__isset;
  return *this;
}
void StorageDescriptor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StorageDescriptor(";
  out << "cols=" << to_string(cols);
  out << ", " << "location=" << to_string(location);
  out << ", " << "inputFormat=" << to_string(inputFormat);
  out << ", " << "outputFormat=" << to_string(outputFormat);
  out << ", " << "compressed=" << to_string(compressed);
  out << ", " << "numBuckets=" << to_string(numBuckets);
  out << ", " << "serdeInfo=" << to_string(serdeInfo);
  out << ", " << "bucketCols=" << to_string(bucketCols);
  out << ", " << "sortCols=" << to_string(sortCols);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "skewedInfo="; (__isset.skewedInfo ? (out << to_string(skewedInfo)) : (out << "<null>"));
  out << ", " << "storedAsSubDirectories="; (__isset.storedAsSubDirectories ? (out << to_string(storedAsSubDirectories)) : (out << "<null>"));
  out << ")";
}


CreationMetadata::~CreationMetadata() noexcept {
}


void CreationMetadata::__set_catName(const std::string& val) {
  this->catName = val;
}

void CreationMetadata::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void CreationMetadata::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void CreationMetadata::__set_tablesUsed(const std::set<std::string> & val) {
  this->tablesUsed = val;
}

void CreationMetadata::__set_validTxnList(const std::string& val) {
  this->validTxnList = val;
__isset.validTxnList = true;
}

void CreationMetadata::__set_materializationTime(const int64_t val) {
  this->materializationTime = val;
__isset.materializationTime = true;
}
std::ostream& operator<<(std::ostream& out, const CreationMetadata& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreationMetadata::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catName = false;
  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_tablesUsed = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->tablesUsed.clear();
            uint32_t _size285;
            ::apache::thrift::protocol::TType _etype288;
            xfer += iprot->readSetBegin(_etype288, _size285);
            uint32_t _i289;
            for (_i289 = 0; _i289 < _size285; ++_i289)
            {
              std::string _elem290;
              xfer += iprot->readString(_elem290);
              this->tablesUsed.insert(_elem290);
            }
            xfer += iprot->readSetEnd();
          }
          isset_tablesUsed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validTxnList);
          this->__isset.validTxnList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->materializationTime);
          this->__isset.materializationTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablesUsed)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CreationMetadata::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreationMetadata");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablesUsed", ::apache::thrift::protocol::T_SET, 4);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tablesUsed.size()));
    std::set<std::string> ::const_iterator _iter291;
    for (_iter291 = this->tablesUsed.begin(); _iter291 != this->tablesUsed.end(); ++_iter291)
    {
      xfer += oprot->writeString((*_iter291));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.validTxnList) {
    xfer += oprot->writeFieldBegin("validTxnList", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->validTxnList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.materializationTime) {
    xfer += oprot->writeFieldBegin("materializationTime", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->materializationTime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreationMetadata &a, CreationMetadata &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.tablesUsed, b.tablesUsed);
  swap(a.validTxnList, b.validTxnList);
  swap(a.materializationTime, b.materializationTime);
  swap(a.__isset, b.__isset);
}

CreationMetadata::CreationMetadata(const CreationMetadata& other292) {
  catName = other292.catName;
  dbName = other292.dbName;
  tblName = other292.tblName;
  tablesUsed = other292.tablesUsed;
  validTxnList = other292.validTxnList;
  materializationTime = other292.materializationTime;
  __isset = other292.__isset;
}
CreationMetadata& CreationMetadata::operator=(const CreationMetadata& other293) {
  catName = other293.catName;
  dbName = other293.dbName;
  tblName = other293.tblName;
  tablesUsed = other293.tablesUsed;
  validTxnList = other293.validTxnList;
  materializationTime = other293.materializationTime;
  __isset = other293.__isset;
  return *this;
}
void CreationMetadata::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreationMetadata(";
  out << "catName=" << to_string(catName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "tablesUsed=" << to_string(tablesUsed);
  out << ", " << "validTxnList="; (__isset.validTxnList ? (out << to_string(validTxnList)) : (out << "<null>"));
  out << ", " << "materializationTime="; (__isset.materializationTime ? (out << to_string(materializationTime)) : (out << "<null>"));
  out << ")";
}


BooleanColumnStatsData::~BooleanColumnStatsData() noexcept {
}


void BooleanColumnStatsData::__set_numTrues(const int64_t val) {
  this->numTrues = val;
}

void BooleanColumnStatsData::__set_numFalses(const int64_t val) {
  this->numFalses = val;
}

void BooleanColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void BooleanColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}
std::ostream& operator<<(std::ostream& out, const BooleanColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BooleanColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numTrues = false;
  bool isset_numFalses = false;
  bool isset_numNulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numTrues);
          isset_numTrues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numFalses);
          isset_numFalses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numTrues)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numFalses)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t BooleanColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BooleanColumnStatsData");

  xfer += oprot->writeFieldBegin("numTrues", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->numTrues);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numFalses", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->numFalses);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BooleanColumnStatsData &a, BooleanColumnStatsData &b) {
  using ::std::swap;
  swap(a.numTrues, b.numTrues);
  swap(a.numFalses, b.numFalses);
  swap(a.numNulls, b.numNulls);
  swap(a.bitVectors, b.bitVectors);
  swap(a.__isset, b.__isset);
}

BooleanColumnStatsData::BooleanColumnStatsData(const BooleanColumnStatsData& other294) {
  numTrues = other294.numTrues;
  numFalses = other294.numFalses;
  numNulls = other294.numNulls;
  bitVectors = other294.bitVectors;
  __isset = other294.__isset;
}
BooleanColumnStatsData& BooleanColumnStatsData::operator=(const BooleanColumnStatsData& other295) {
  numTrues = other295.numTrues;
  numFalses = other295.numFalses;
  numNulls = other295.numNulls;
  bitVectors = other295.bitVectors;
  __isset = other295.__isset;
  return *this;
}
void BooleanColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BooleanColumnStatsData(";
  out << "numTrues=" << to_string(numTrues);
  out << ", " << "numFalses=" << to_string(numFalses);
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ")";
}


DoubleColumnStatsData::~DoubleColumnStatsData() noexcept {
}


void DoubleColumnStatsData::__set_lowValue(const double val) {
  this->lowValue = val;
__isset.lowValue = true;
}

void DoubleColumnStatsData::__set_highValue(const double val) {
  this->highValue = val;
__isset.highValue = true;
}

void DoubleColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void DoubleColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

void DoubleColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}
std::ostream& operator<<(std::ostream& out, const DoubleColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DoubleColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->lowValue);
          this->__isset.lowValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->highValue);
          this->__isset.highValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DoubleColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DoubleColumnStatsData");

  if (this->__isset.lowValue) {
    xfer += oprot->writeFieldBegin("lowValue", ::apache::thrift::protocol::T_DOUBLE, 1);
    xfer += oprot->writeDouble(this->lowValue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.highValue) {
    xfer += oprot->writeFieldBegin("highValue", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->highValue);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DoubleColumnStatsData &a, DoubleColumnStatsData &b) {
  using ::std::swap;
  swap(a.lowValue, b.lowValue);
  swap(a.highValue, b.highValue);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
  swap(a.bitVectors, b.bitVectors);
  swap(a.__isset, b.__isset);
}

DoubleColumnStatsData::DoubleColumnStatsData(const DoubleColumnStatsData& other296) {
  lowValue = other296.lowValue;
  highValue = other296.highValue;
  numNulls = other296.numNulls;
  numDVs = other296.numDVs;
  bitVectors = other296.bitVectors;
  __isset = other296.__isset;
}
DoubleColumnStatsData& DoubleColumnStatsData::operator=(const DoubleColumnStatsData& other297) {
  lowValue = other297.lowValue;
  highValue = other297.highValue;
  numNulls = other297.numNulls;
  numDVs = other297.numDVs;
  bitVectors = other297.bitVectors;
  __isset = other297.__isset;
  return *this;
}
void DoubleColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DoubleColumnStatsData(";
  out << "lowValue="; (__isset.lowValue ? (out << to_string(lowValue)) : (out << "<null>"));
  out << ", " << "highValue="; (__isset.highValue ? (out << to_string(highValue)) : (out << "<null>"));
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ")";
}


LongColumnStatsData::~LongColumnStatsData() noexcept {
}


void LongColumnStatsData::__set_lowValue(const int64_t val) {
  this->lowValue = val;
__isset.lowValue = true;
}

void LongColumnStatsData::__set_highValue(const int64_t val) {
  this->highValue = val;
__isset.highValue = true;
}

void LongColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void LongColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

void LongColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}
std::ostream& operator<<(std::ostream& out, const LongColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LongColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lowValue);
          this->__isset.lowValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->highValue);
          this->__isset.highValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LongColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LongColumnStatsData");

  if (this->__isset.lowValue) {
    xfer += oprot->writeFieldBegin("lowValue", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->lowValue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.highValue) {
    xfer += oprot->writeFieldBegin("highValue", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->highValue);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LongColumnStatsData &a, LongColumnStatsData &b) {
  using ::std::swap;
  swap(a.lowValue, b.lowValue);
  swap(a.highValue, b.highValue);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
  swap(a.bitVectors, b.bitVectors);
  swap(a.__isset, b.__isset);
}

LongColumnStatsData::LongColumnStatsData(const LongColumnStatsData& other298) {
  lowValue = other298.lowValue;
  highValue = other298.highValue;
  numNulls = other298.numNulls;
  numDVs = other298.numDVs;
  bitVectors = other298.bitVectors;
  __isset = other298.__isset;
}
LongColumnStatsData& LongColumnStatsData::operator=(const LongColumnStatsData& other299) {
  lowValue = other299.lowValue;
  highValue = other299.highValue;
  numNulls = other299.numNulls;
  numDVs = other299.numDVs;
  bitVectors = other299.bitVectors;
  __isset = other299.__isset;
  return *this;
}
void LongColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LongColumnStatsData(";
  out << "lowValue="; (__isset.lowValue ? (out << to_string(lowValue)) : (out << "<null>"));
  out << ", " << "highValue="; (__isset.highValue ? (out << to_string(highValue)) : (out << "<null>"));
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ")";
}


StringColumnStatsData::~StringColumnStatsData() noexcept {
}


void StringColumnStatsData::__set_maxColLen(const int64_t val) {
  this->maxColLen = val;
}

void StringColumnStatsData::__set_avgColLen(const double val) {
  this->avgColLen = val;
}

void StringColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void StringColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

void StringColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}
std::ostream& operator<<(std::ostream& out, const StringColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StringColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_maxColLen = false;
  bool isset_avgColLen = false;
  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxColLen);
          isset_maxColLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->avgColLen);
          isset_avgColLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_maxColLen)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_avgColLen)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t StringColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StringColumnStatsData");

  xfer += oprot->writeFieldBegin("maxColLen", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->maxColLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("avgColLen", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->avgColLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StringColumnStatsData &a, StringColumnStatsData &b) {
  using ::std::swap;
  swap(a.maxColLen, b.maxColLen);
  swap(a.avgColLen, b.avgColLen);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
  swap(a.bitVectors, b.bitVectors);
  swap(a.__isset, b.__isset);
}

StringColumnStatsData::StringColumnStatsData(const StringColumnStatsData& other300) {
  maxColLen = other300.maxColLen;
  avgColLen = other300.avgColLen;
  numNulls = other300.numNulls;
  numDVs = other300.numDVs;
  bitVectors = other300.bitVectors;
  __isset = other300.__isset;
}
StringColumnStatsData& StringColumnStatsData::operator=(const StringColumnStatsData& other301) {
  maxColLen = other301.maxColLen;
  avgColLen = other301.avgColLen;
  numNulls = other301.numNulls;
  numDVs = other301.numDVs;
  bitVectors = other301.bitVectors;
  __isset = other301.__isset;
  return *this;
}
void StringColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StringColumnStatsData(";
  out << "maxColLen=" << to_string(maxColLen);
  out << ", " << "avgColLen=" << to_string(avgColLen);
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ")";
}


BinaryColumnStatsData::~BinaryColumnStatsData() noexcept {
}


void BinaryColumnStatsData::__set_maxColLen(const int64_t val) {
  this->maxColLen = val;
}

void BinaryColumnStatsData::__set_avgColLen(const double val) {
  this->avgColLen = val;
}

void BinaryColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void BinaryColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}
std::ostream& operator<<(std::ostream& out, const BinaryColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BinaryColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_maxColLen = false;
  bool isset_avgColLen = false;
  bool isset_numNulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxColLen);
          isset_maxColLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->avgColLen);
          isset_avgColLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_maxColLen)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_avgColLen)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t BinaryColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BinaryColumnStatsData");

  xfer += oprot->writeFieldBegin("maxColLen", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->maxColLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("avgColLen", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->avgColLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BinaryColumnStatsData &a, BinaryColumnStatsData &b) {
  using ::std::swap;
  swap(a.maxColLen, b.maxColLen);
  swap(a.avgColLen, b.avgColLen);
  swap(a.numNulls, b.numNulls);
  swap(a.bitVectors, b.bitVectors);
  swap(a.__isset, b.__isset);
}

BinaryColumnStatsData::BinaryColumnStatsData(const BinaryColumnStatsData& other302) {
  maxColLen = other302.maxColLen;
  avgColLen = other302.avgColLen;
  numNulls = other302.numNulls;
  bitVectors = other302.bitVectors;
  __isset = other302.__isset;
}
BinaryColumnStatsData& BinaryColumnStatsData::operator=(const BinaryColumnStatsData& other303) {
  maxColLen = other303.maxColLen;
  avgColLen = other303.avgColLen;
  numNulls = other303.numNulls;
  bitVectors = other303.bitVectors;
  __isset = other303.__isset;
  return *this;
}
void BinaryColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BinaryColumnStatsData(";
  out << "maxColLen=" << to_string(maxColLen);
  out << ", " << "avgColLen=" << to_string(avgColLen);
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ")";
}


Decimal::~Decimal() noexcept {
}


void Decimal::__set_scale(const int16_t val) {
  this->scale = val;
}

void Decimal::__set_unscaled(const std::string& val) {
  this->unscaled = val;
}
std::ostream& operator<<(std::ostream& out, const Decimal& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Decimal::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_scale = false;
  bool isset_unscaled = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->scale);
          isset_scale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->unscaled);
          isset_unscaled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_scale)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_unscaled)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Decimal::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Decimal");

  xfer += oprot->writeFieldBegin("unscaled", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->unscaled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scale", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->scale);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Decimal &a, Decimal &b) {
  using ::std::swap;
  swap(a.scale, b.scale);
  swap(a.unscaled, b.unscaled);
}

Decimal::Decimal(const Decimal& other304) {
  scale = other304.scale;
  unscaled = other304.unscaled;
}
Decimal& Decimal::operator=(const Decimal& other305) {
  scale = other305.scale;
  unscaled = other305.unscaled;
  return *this;
}
void Decimal::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Decimal(";
  out << "scale=" << to_string(scale);
  out << ", " << "unscaled=" << to_string(unscaled);
  out << ")";
}


DecimalColumnStatsData::~DecimalColumnStatsData() noexcept {
}


void DecimalColumnStatsData::__set_lowValue(const Decimal& val) {
  this->lowValue = val;
__isset.lowValue = true;
}

void DecimalColumnStatsData::__set_highValue(const Decimal& val) {
  this->highValue = val;
__isset.highValue = true;
}

void DecimalColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void DecimalColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

void DecimalColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}
std::ostream& operator<<(std::ostream& out, const DecimalColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DecimalColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lowValue.read(iprot);
          this->__isset.lowValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->highValue.read(iprot);
          this->__isset.highValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DecimalColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DecimalColumnStatsData");

  if (this->__isset.lowValue) {
    xfer += oprot->writeFieldBegin("lowValue", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->lowValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.highValue) {
    xfer += oprot->writeFieldBegin("highValue", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->highValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DecimalColumnStatsData &a, DecimalColumnStatsData &b) {
  using ::std::swap;
  swap(a.lowValue, b.lowValue);
  swap(a.highValue, b.highValue);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
  swap(a.bitVectors, b.bitVectors);
  swap(a.__isset, b.__isset);
}

DecimalColumnStatsData::DecimalColumnStatsData(const DecimalColumnStatsData& other306) {
  lowValue = other306.lowValue;
  highValue = other306.highValue;
  numNulls = other306.numNulls;
  numDVs = other306.numDVs;
  bitVectors = other306.bitVectors;
  __isset = other306.__isset;
}
DecimalColumnStatsData& DecimalColumnStatsData::operator=(const DecimalColumnStatsData& other307) {
  lowValue = other307.lowValue;
  highValue = other307.highValue;
  numNulls = other307.numNulls;
  numDVs = other307.numDVs;
  bitVectors = other307.bitVectors;
  __isset = other307.__isset;
  return *this;
}
void DecimalColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DecimalColumnStatsData(";
  out << "lowValue="; (__isset.lowValue ? (out << to_string(lowValue)) : (out << "<null>"));
  out << ", " << "highValue="; (__isset.highValue ? (out << to_string(highValue)) : (out << "<null>"));
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ")";
}


Date::~Date() noexcept {
}


void Date::__set_daysSinceEpoch(const int64_t val) {
  this->daysSinceEpoch = val;
}
std::ostream& operator<<(std::ostream& out, const Date& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Date::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_daysSinceEpoch = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->daysSinceEpoch);
          isset_daysSinceEpoch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_daysSinceEpoch)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Date::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Date");

  xfer += oprot->writeFieldBegin("daysSinceEpoch", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->daysSinceEpoch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Date &a, Date &b) {
  using ::std::swap;
  swap(a.daysSinceEpoch, b.daysSinceEpoch);
}

Date::Date(const Date& other308) {
  daysSinceEpoch = other308.daysSinceEpoch;
}
Date& Date::operator=(const Date& other309) {
  daysSinceEpoch = other309.daysSinceEpoch;
  return *this;
}
void Date::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Date(";
  out << "daysSinceEpoch=" << to_string(daysSinceEpoch);
  out << ")";
}


DateColumnStatsData::~DateColumnStatsData() noexcept {
}


void DateColumnStatsData::__set_lowValue(const Date& val) {
  this->lowValue = val;
__isset.lowValue = true;
}

void DateColumnStatsData::__set_highValue(const Date& val) {
  this->highValue = val;
__isset.highValue = true;
}

void DateColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void DateColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

void DateColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}
std::ostream& operator<<(std::ostream& out, const DateColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DateColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lowValue.read(iprot);
          this->__isset.lowValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->highValue.read(iprot);
          this->__isset.highValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DateColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DateColumnStatsData");

  if (this->__isset.lowValue) {
    xfer += oprot->writeFieldBegin("lowValue", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->lowValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.highValue) {
    xfer += oprot->writeFieldBegin("highValue", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->highValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DateColumnStatsData &a, DateColumnStatsData &b) {
  using ::std::swap;
  swap(a.lowValue, b.lowValue);
  swap(a.highValue, b.highValue);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
  swap(a.bitVectors, b.bitVectors);
  swap(a.__isset, b.__isset);
}

DateColumnStatsData::DateColumnStatsData(const DateColumnStatsData& other310) {
  lowValue = other310.lowValue;
  highValue = other310.highValue;
  numNulls = other310.numNulls;
  numDVs = other310.numDVs;
  bitVectors = other310.bitVectors;
  __isset = other310.__isset;
}
DateColumnStatsData& DateColumnStatsData::operator=(const DateColumnStatsData& other311) {
  lowValue = other311.lowValue;
  highValue = other311.highValue;
  numNulls = other311.numNulls;
  numDVs = other311.numDVs;
  bitVectors = other311.bitVectors;
  __isset = other311.__isset;
  return *this;
}
void DateColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DateColumnStatsData(";
  out << "lowValue="; (__isset.lowValue ? (out << to_string(lowValue)) : (out << "<null>"));
  out << ", " << "highValue="; (__isset.highValue ? (out << to_string(highValue)) : (out << "<null>"));
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ")";
}


Timestamp::~Timestamp() noexcept {
}


void Timestamp::__set_secondsSinceEpoch(const int64_t val) {
  this->secondsSinceEpoch = val;
}
std::ostream& operator<<(std::ostream& out, const Timestamp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Timestamp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_secondsSinceEpoch = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->secondsSinceEpoch);
          isset_secondsSinceEpoch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_secondsSinceEpoch)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Timestamp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Timestamp");

  xfer += oprot->writeFieldBegin("secondsSinceEpoch", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->secondsSinceEpoch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Timestamp &a, Timestamp &b) {
  using ::std::swap;
  swap(a.secondsSinceEpoch, b.secondsSinceEpoch);
}

Timestamp::Timestamp(const Timestamp& other312) {
  secondsSinceEpoch = other312.secondsSinceEpoch;
}
Timestamp& Timestamp::operator=(const Timestamp& other313) {
  secondsSinceEpoch = other313.secondsSinceEpoch;
  return *this;
}
void Timestamp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Timestamp(";
  out << "secondsSinceEpoch=" << to_string(secondsSinceEpoch);
  out << ")";
}


TimestampColumnStatsData::~TimestampColumnStatsData() noexcept {
}


void TimestampColumnStatsData::__set_lowValue(const Timestamp& val) {
  this->lowValue = val;
__isset.lowValue = true;
}

void TimestampColumnStatsData::__set_highValue(const Timestamp& val) {
  this->highValue = val;
__isset.highValue = true;
}

void TimestampColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void TimestampColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

void TimestampColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}
std::ostream& operator<<(std::ostream& out, const TimestampColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimestampColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lowValue.read(iprot);
          this->__isset.lowValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->highValue.read(iprot);
          this->__isset.highValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TimestampColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimestampColumnStatsData");

  if (this->__isset.lowValue) {
    xfer += oprot->writeFieldBegin("lowValue", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->lowValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.highValue) {
    xfer += oprot->writeFieldBegin("highValue", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->highValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimestampColumnStatsData &a, TimestampColumnStatsData &b) {
  using ::std::swap;
  swap(a.lowValue, b.lowValue);
  swap(a.highValue, b.highValue);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
  swap(a.bitVectors, b.bitVectors);
  swap(a.__isset, b.__isset);
}

TimestampColumnStatsData::TimestampColumnStatsData(const TimestampColumnStatsData& other314) {
  lowValue = other314.lowValue;
  highValue = other314.highValue;
  numNulls = other314.numNulls;
  numDVs = other314.numDVs;
  bitVectors = other314.bitVectors;
  __isset = other314.__isset;
}
TimestampColumnStatsData& TimestampColumnStatsData::operator=(const TimestampColumnStatsData& other315) {
  lowValue = other315.lowValue;
  highValue = other315.highValue;
  numNulls = other315.numNulls;
  numDVs = other315.numDVs;
  bitVectors = other315.bitVectors;
  __isset = other315.__isset;
  return *this;
}
void TimestampColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimestampColumnStatsData(";
  out << "lowValue="; (__isset.lowValue ? (out << to_string(lowValue)) : (out << "<null>"));
  out << ", " << "highValue="; (__isset.highValue ? (out << to_string(highValue)) : (out << "<null>"));
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ")";
}


ColumnStatisticsData::~ColumnStatisticsData() noexcept {
}


void ColumnStatisticsData::__set_booleanStats(const BooleanColumnStatsData& val) {
  this->booleanStats = val;
__isset.booleanStats = true;
}

void ColumnStatisticsData::__set_longStats(const LongColumnStatsData& val) {
  this->longStats = val;
__isset.longStats = true;
}

void ColumnStatisticsData::__set_doubleStats(const DoubleColumnStatsData& val) {
  this->doubleStats = val;
__isset.doubleStats = true;
}

void ColumnStatisticsData::__set_stringStats(const StringColumnStatsData& val) {
  this->stringStats = val;
__isset.stringStats = true;
}

void ColumnStatisticsData::__set_binaryStats(const BinaryColumnStatsData& val) {
  this->binaryStats = val;
__isset.binaryStats = true;
}

void ColumnStatisticsData::__set_decimalStats(const DecimalColumnStatsData& val) {
  this->decimalStats = val;
__isset.decimalStats = true;
}

void ColumnStatisticsData::__set_dateStats(const DateColumnStatsData& val) {
  this->dateStats = val;
__isset.dateStats = true;
}

void ColumnStatisticsData::__set_timestampStats(const TimestampColumnStatsData& val) {
  this->timestampStats = val;
__isset.timestampStats = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnStatisticsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnStatisticsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->booleanStats.read(iprot);
          this->__isset.booleanStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->longStats.read(iprot);
          this->__isset.longStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->doubleStats.read(iprot);
          this->__isset.doubleStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stringStats.read(iprot);
          this->__isset.stringStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->binaryStats.read(iprot);
          this->__isset.binaryStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->decimalStats.read(iprot);
          this->__isset.decimalStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dateStats.read(iprot);
          this->__isset.dateStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->timestampStats.read(iprot);
          this->__isset.timestampStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnStatisticsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnStatisticsData");

  if (this->__isset.booleanStats) {
    xfer += oprot->writeFieldBegin("booleanStats", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->booleanStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.longStats) {
    xfer += oprot->writeFieldBegin("longStats", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->longStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.doubleStats) {
    xfer += oprot->writeFieldBegin("doubleStats", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->doubleStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stringStats) {
    xfer += oprot->writeFieldBegin("stringStats", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->stringStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.binaryStats) {
    xfer += oprot->writeFieldBegin("binaryStats", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->binaryStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.decimalStats) {
    xfer += oprot->writeFieldBegin("decimalStats", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->decimalStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dateStats) {
    xfer += oprot->writeFieldBegin("dateStats", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->dateStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestampStats) {
    xfer += oprot->writeFieldBegin("timestampStats", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->timestampStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnStatisticsData &a, ColumnStatisticsData &b) {
  using ::std::swap;
  swap(a.booleanStats, b.booleanStats);
  swap(a.longStats, b.longStats);
  swap(a.doubleStats, b.doubleStats);
  swap(a.stringStats, b.stringStats);
  swap(a.binaryStats, b.binaryStats);
  swap(a.decimalStats, b.decimalStats);
  swap(a.dateStats, b.dateStats);
  swap(a.timestampStats, b.timestampStats);
  swap(a.__isset, b.__isset);
}

ColumnStatisticsData::ColumnStatisticsData(const ColumnStatisticsData& other316) {
  booleanStats = other316.booleanStats;
  longStats = other316.longStats;
  doubleStats = other316.doubleStats;
  stringStats = other316.stringStats;
  binaryStats = other316.binaryStats;
  decimalStats = other316.decimalStats;
  dateStats = other316.dateStats;
  timestampStats = other316.timestampStats;
  __isset = other316.__isset;
}
ColumnStatisticsData& ColumnStatisticsData::operator=(const ColumnStatisticsData& other317) {
  booleanStats = other317.booleanStats;
  longStats = other317.longStats;
  doubleStats = other317.doubleStats;
  stringStats = other317.stringStats;
  binaryStats = other317.binaryStats;
  decimalStats = other317.decimalStats;
  dateStats = other317.dateStats;
  timestampStats = other317.timestampStats;
  __isset = other317.__isset;
  return *this;
}
void ColumnStatisticsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnStatisticsData(";
  out << "booleanStats="; (__isset.booleanStats ? (out << to_string(booleanStats)) : (out << "<null>"));
  out << ", " << "longStats="; (__isset.longStats ? (out << to_string(longStats)) : (out << "<null>"));
  out << ", " << "doubleStats="; (__isset.doubleStats ? (out << to_string(doubleStats)) : (out << "<null>"));
  out << ", " << "stringStats="; (__isset.stringStats ? (out << to_string(stringStats)) : (out << "<null>"));
  out << ", " << "binaryStats="; (__isset.binaryStats ? (out << to_string(binaryStats)) : (out << "<null>"));
  out << ", " << "decimalStats="; (__isset.decimalStats ? (out << to_string(decimalStats)) : (out << "<null>"));
  out << ", " << "dateStats="; (__isset.dateStats ? (out << to_string(dateStats)) : (out << "<null>"));
  out << ", " << "timestampStats="; (__isset.timestampStats ? (out << to_string(timestampStats)) : (out << "<null>"));
  out << ")";
}


ColumnStatisticsObj::~ColumnStatisticsObj() noexcept {
}


void ColumnStatisticsObj::__set_colName(const std::string& val) {
  this->colName = val;
}

void ColumnStatisticsObj::__set_colType(const std::string& val) {
  this->colType = val;
}

void ColumnStatisticsObj::__set_statsData(const ColumnStatisticsData& val) {
  this->statsData = val;
}
std::ostream& operator<<(std::ostream& out, const ColumnStatisticsObj& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnStatisticsObj::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_colName = false;
  bool isset_colType = false;
  bool isset_statsData = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->colName);
          isset_colName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->colType);
          isset_colType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->statsData.read(iprot);
          isset_statsData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_colName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_colType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statsData)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnStatisticsObj::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnStatisticsObj");

  xfer += oprot->writeFieldBegin("colName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->colName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colType", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->colType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statsData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->statsData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnStatisticsObj &a, ColumnStatisticsObj &b) {
  using ::std::swap;
  swap(a.colName, b.colName);
  swap(a.colType, b.colType);
  swap(a.statsData, b.statsData);
}

ColumnStatisticsObj::ColumnStatisticsObj(const ColumnStatisticsObj& other318) {
  colName = other318.colName;
  colType = other318.colType;
  statsData = other318.statsData;
}
ColumnStatisticsObj& ColumnStatisticsObj::operator=(const ColumnStatisticsObj& other319) {
  colName = other319.colName;
  colType = other319.colType;
  statsData = other319.statsData;
  return *this;
}
void ColumnStatisticsObj::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnStatisticsObj(";
  out << "colName=" << to_string(colName);
  out << ", " << "colType=" << to_string(colType);
  out << ", " << "statsData=" << to_string(statsData);
  out << ")";
}


ColumnStatisticsDesc::~ColumnStatisticsDesc() noexcept {
}


void ColumnStatisticsDesc::__set_isTblLevel(const bool val) {
  this->isTblLevel = val;
}

void ColumnStatisticsDesc::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void ColumnStatisticsDesc::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void ColumnStatisticsDesc::__set_partName(const std::string& val) {
  this->partName = val;
__isset.partName = true;
}

void ColumnStatisticsDesc::__set_lastAnalyzed(const int64_t val) {
  this->lastAnalyzed = val;
__isset.lastAnalyzed = true;
}

void ColumnStatisticsDesc::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnStatisticsDesc& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnStatisticsDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_isTblLevel = false;
  bool isset_dbName = false;
  bool isset_tableName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isTblLevel);
          isset_isTblLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partName);
          this->__isset.partName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastAnalyzed);
          this->__isset.lastAnalyzed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_isTblLevel)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnStatisticsDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnStatisticsDesc");

  xfer += oprot->writeFieldBegin("isTblLevel", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->isTblLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partName) {
    xfer += oprot->writeFieldBegin("partName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->partName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastAnalyzed) {
    xfer += oprot->writeFieldBegin("lastAnalyzed", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->lastAnalyzed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnStatisticsDesc &a, ColumnStatisticsDesc &b) {
  using ::std::swap;
  swap(a.isTblLevel, b.isTblLevel);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.partName, b.partName);
  swap(a.lastAnalyzed, b.lastAnalyzed);
  swap(a.catName, b.catName);
  swap(a.__isset, b.__isset);
}

ColumnStatisticsDesc::ColumnStatisticsDesc(const ColumnStatisticsDesc& other320) {
  isTblLevel = other320.isTblLevel;
  dbName = other320.dbName;
  tableName = other320.tableName;
  partName = other320.partName;
  lastAnalyzed = other320.lastAnalyzed;
  catName = other320.catName;
  __isset = other320.__isset;
}
ColumnStatisticsDesc& ColumnStatisticsDesc::operator=(const ColumnStatisticsDesc& other321) {
  isTblLevel = other321.isTblLevel;
  dbName = other321.dbName;
  tableName = other321.tableName;
  partName = other321.partName;
  lastAnalyzed = other321.lastAnalyzed;
  catName = other321.catName;
  __isset = other321.__isset;
  return *this;
}
void ColumnStatisticsDesc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnStatisticsDesc(";
  out << "isTblLevel=" << to_string(isTblLevel);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "partName="; (__isset.partName ? (out << to_string(partName)) : (out << "<null>"));
  out << ", " << "lastAnalyzed="; (__isset.lastAnalyzed ? (out << to_string(lastAnalyzed)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ")";
}


ColumnStatistics::~ColumnStatistics() noexcept {
}


void ColumnStatistics::__set_statsDesc(const ColumnStatisticsDesc& val) {
  this->statsDesc = val;
}

void ColumnStatistics::__set_statsObj(const std::vector<ColumnStatisticsObj> & val) {
  this->statsObj = val;
}

void ColumnStatistics::__set_isStatsCompliant(const bool val) {
  this->isStatsCompliant = val;
__isset.isStatsCompliant = true;
}

void ColumnStatistics::__set_engine(const std::string& val) {
  this->engine = val;
__isset.engine = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnStatistics& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnStatistics::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_statsDesc = false;
  bool isset_statsObj = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->statsDesc.read(iprot);
          isset_statsDesc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->statsObj.clear();
            uint32_t _size322;
            ::apache::thrift::protocol::TType _etype325;
            xfer += iprot->readListBegin(_etype325, _size322);
            this->statsObj.resize(_size322);
            uint32_t _i326;
            for (_i326 = 0; _i326 < _size322; ++_i326)
            {
              xfer += this->statsObj[_i326].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_statsObj = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isStatsCompliant);
          this->__isset.isStatsCompliant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->engine);
          this->__isset.engine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_statsDesc)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statsObj)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnStatistics::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnStatistics");

  xfer += oprot->writeFieldBegin("statsDesc", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->statsDesc.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statsObj", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->statsObj.size()));
    std::vector<ColumnStatisticsObj> ::const_iterator _iter327;
    for (_iter327 = this->statsObj.begin(); _iter327 != this->statsObj.end(); ++_iter327)
    {
      xfer += (*_iter327).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.isStatsCompliant) {
    xfer += oprot->writeFieldBegin("isStatsCompliant", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->isStatsCompliant);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.engine) {
    xfer += oprot->writeFieldBegin("engine", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->engine);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnStatistics &a, ColumnStatistics &b) {
  using ::std::swap;
  swap(a.statsDesc, b.statsDesc);
  swap(a.statsObj, b.statsObj);
  swap(a.isStatsCompliant, b.isStatsCompliant);
  swap(a.engine, b.engine);
  swap(a.__isset, b.__isset);
}

ColumnStatistics::ColumnStatistics(const ColumnStatistics& other328) {
  statsDesc = other328.statsDesc;
  statsObj = other328.statsObj;
  isStatsCompliant = other328.isStatsCompliant;
  engine = other328.engine;
  __isset = other328.__isset;
}
ColumnStatistics& ColumnStatistics::operator=(const ColumnStatistics& other329) {
  statsDesc = other329.statsDesc;
  statsObj = other329.statsObj;
  isStatsCompliant = other329.isStatsCompliant;
  engine = other329.engine;
  __isset = other329.__isset;
  return *this;
}
void ColumnStatistics::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnStatistics(";
  out << "statsDesc=" << to_string(statsDesc);
  out << ", " << "statsObj=" << to_string(statsObj);
  out << ", " << "isStatsCompliant="; (__isset.isStatsCompliant ? (out << to_string(isStatsCompliant)) : (out << "<null>"));
  out << ", " << "engine="; (__isset.engine ? (out << to_string(engine)) : (out << "<null>"));
  out << ")";
}


FileMetadata::~FileMetadata() noexcept {
}


void FileMetadata::__set_type(const int8_t val) {
  this->type = val;
}

void FileMetadata::__set_version(const int8_t val) {
  this->version = val;
}

void FileMetadata::__set_data(const std::vector<std::string> & val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const FileMetadata& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FileMetadata::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size330;
            ::apache::thrift::protocol::TType _etype333;
            xfer += iprot->readListBegin(_etype333, _size330);
            this->data.resize(_size330);
            uint32_t _i334;
            for (_i334 = 0; _i334 < _size330; ++_i334)
            {
              xfer += iprot->readBinary(this->data[_i334]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FileMetadata::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FileMetadata");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->data.size()));
    std::vector<std::string> ::const_iterator _iter335;
    for (_iter335 = this->data.begin(); _iter335 != this->data.end(); ++_iter335)
    {
      xfer += oprot->writeBinary((*_iter335));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FileMetadata &a, FileMetadata &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.version, b.version);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

FileMetadata::FileMetadata(const FileMetadata& other336) {
  type = other336.type;
  version = other336.version;
  data = other336.data;
  __isset = other336.__isset;
}
FileMetadata& FileMetadata::operator=(const FileMetadata& other337) {
  type = other337.type;
  version = other337.version;
  data = other337.data;
  __isset = other337.__isset;
  return *this;
}
void FileMetadata::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FileMetadata(";
  out << "type=" << to_string(type);
  out << ", " << "version=" << to_string(version);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


ObjectDictionary::~ObjectDictionary() noexcept {
}


void ObjectDictionary::__set_values(const std::map<std::string, std::vector<std::string> > & val) {
  this->values = val;
}
std::ostream& operator<<(std::ostream& out, const ObjectDictionary& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ObjectDictionary::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->values.clear();
            uint32_t _size338;
            ::apache::thrift::protocol::TType _ktype339;
            ::apache::thrift::protocol::TType _vtype340;
            xfer += iprot->readMapBegin(_ktype339, _vtype340, _size338);
            uint32_t _i342;
            for (_i342 = 0; _i342 < _size338; ++_i342)
            {
              std::string _key343;
              xfer += iprot->readString(_key343);
              std::vector<std::string> & _val344 = this->values[_key343];
              {
                _val344.clear();
                uint32_t _size345;
                ::apache::thrift::protocol::TType _etype348;
                xfer += iprot->readListBegin(_etype348, _size345);
                _val344.resize(_size345);
                uint32_t _i349;
                for (_i349 = 0; _i349 < _size345; ++_i349)
                {
                  xfer += iprot->readBinary(_val344[_i349]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ObjectDictionary::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ObjectDictionary");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->values.size()));
    std::map<std::string, std::vector<std::string> > ::const_iterator _iter350;
    for (_iter350 = this->values.begin(); _iter350 != this->values.end(); ++_iter350)
    {
      xfer += oprot->writeString(_iter350->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter350->second.size()));
        std::vector<std::string> ::const_iterator _iter351;
        for (_iter351 = _iter350->second.begin(); _iter351 != _iter350->second.end(); ++_iter351)
        {
          xfer += oprot->writeBinary((*_iter351));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ObjectDictionary &a, ObjectDictionary &b) {
  using ::std::swap;
  swap(a.values, b.values);
}

ObjectDictionary::ObjectDictionary(const ObjectDictionary& other352) {
  values = other352.values;
}
ObjectDictionary& ObjectDictionary::operator=(const ObjectDictionary& other353) {
  values = other353.values;
  return *this;
}
void ObjectDictionary::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ObjectDictionary(";
  out << "values=" << to_string(values);
  out << ")";
}


Table::~Table() noexcept {
}


void Table::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void Table::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void Table::__set_owner(const std::string& val) {
  this->owner = val;
}

void Table::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void Table::__set_lastAccessTime(const int32_t val) {
  this->lastAccessTime = val;
}

void Table::__set_retention(const int32_t val) {
  this->retention = val;
}

void Table::__set_sd(const StorageDescriptor& val) {
  this->sd = val;
}

void Table::__set_partitionKeys(const std::vector<FieldSchema> & val) {
  this->partitionKeys = val;
}

void Table::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void Table::__set_viewOriginalText(const std::string& val) {
  this->viewOriginalText = val;
}

void Table::__set_viewExpandedText(const std::string& val) {
  this->viewExpandedText = val;
}

void Table::__set_tableType(const std::string& val) {
  this->tableType = val;
}

void Table::__set_privileges(const PrincipalPrivilegeSet& val) {
  this->privileges = val;
__isset.privileges = true;
}

void Table::__set_temporary(const bool val) {
  this->temporary = val;
__isset.temporary = true;
}

void Table::__set_rewriteEnabled(const bool val) {
  this->rewriteEnabled = val;
__isset.rewriteEnabled = true;
}

void Table::__set_creationMetadata(const CreationMetadata& val) {
  this->creationMetadata = val;
__isset.creationMetadata = true;
}

void Table::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void Table::__set_ownerType(const PrincipalType::type val) {
  this->ownerType = val;
__isset.ownerType = true;
}

void Table::__set_writeId(const int64_t val) {
  this->writeId = val;
__isset.writeId = true;
}

void Table::__set_isStatsCompliant(const bool val) {
  this->isStatsCompliant = val;
__isset.isStatsCompliant = true;
}

void Table::__set_colStats(const ColumnStatistics& val) {
  this->colStats = val;
__isset.colStats = true;
}

void Table::__set_accessType(const int8_t val) {
  this->accessType = val;
__isset.accessType = true;
}

void Table::__set_requiredReadCapabilities(const std::vector<std::string> & val) {
  this->requiredReadCapabilities = val;
__isset.requiredReadCapabilities = true;
}

void Table::__set_requiredWriteCapabilities(const std::vector<std::string> & val) {
  this->requiredWriteCapabilities = val;
__isset.requiredWriteCapabilities = true;
}

void Table::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}

void Table::__set_fileMetadata(const FileMetadata& val) {
  this->fileMetadata = val;
__isset.fileMetadata = true;
}

void Table::__set_dictionary(const ObjectDictionary& val) {
  this->dictionary = val;
__isset.dictionary = true;
}
std::ostream& operator<<(std::ostream& out, const Table& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Table::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner);
          this->__isset.owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastAccessTime);
          this->__isset.lastAccessTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->retention);
          this->__isset.retention = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sd.read(iprot);
          this->__isset.sd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionKeys.clear();
            uint32_t _size354;
            ::apache::thrift::protocol::TType _etype357;
            xfer += iprot->readListBegin(_etype357, _size354);
            this->partitionKeys.resize(_size354);
            uint32_t _i358;
            for (_i358 = 0; _i358 < _size354; ++_i358)
            {
              xfer += this->partitionKeys[_i358].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionKeys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size359;
            ::apache::thrift::protocol::TType _ktype360;
            ::apache::thrift::protocol::TType _vtype361;
            xfer += iprot->readMapBegin(_ktype360, _vtype361, _size359);
            uint32_t _i363;
            for (_i363 = 0; _i363 < _size359; ++_i363)
            {
              std::string _key364;
              xfer += iprot->readString(_key364);
              std::string& _val365 = this->parameters[_key364];
              xfer += iprot->readString(_val365);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewOriginalText);
          this->__isset.viewOriginalText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewExpandedText);
          this->__isset.viewExpandedText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableType);
          this->__isset.tableType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->temporary);
          this->__isset.temporary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rewriteEnabled);
          this->__isset.rewriteEnabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->creationMetadata.read(iprot);
          this->__isset.creationMetadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast366;
          xfer += iprot->readI32(ecast366);
          this->ownerType = (PrincipalType::type)ecast366;
          this->__isset.ownerType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          this->__isset.writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isStatsCompliant);
          this->__isset.isStatsCompliant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->colStats.read(iprot);
          this->__isset.colStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->accessType);
          this->__isset.accessType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->requiredReadCapabilities.clear();
            uint32_t _size367;
            ::apache::thrift::protocol::TType _etype370;
            xfer += iprot->readListBegin(_etype370, _size367);
            this->requiredReadCapabilities.resize(_size367);
            uint32_t _i371;
            for (_i371 = 0; _i371 < _size367; ++_i371)
            {
              xfer += iprot->readString(this->requiredReadCapabilities[_i371]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.requiredReadCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->requiredWriteCapabilities.clear();
            uint32_t _size372;
            ::apache::thrift::protocol::TType _etype375;
            xfer += iprot->readListBegin(_etype375, _size372);
            this->requiredWriteCapabilities.resize(_size372);
            uint32_t _i376;
            for (_i376 = 0; _i376 < _size372; ++_i376)
            {
              xfer += iprot->readString(this->requiredWriteCapabilities[_i376]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.requiredWriteCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fileMetadata.read(iprot);
          this->__isset.fileMetadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dictionary.read(iprot);
          this->__isset.dictionary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Table::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Table");

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastAccessTime", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->lastAccessTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("retention", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->retention);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sd", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->sd.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitionKeys", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitionKeys.size()));
    std::vector<FieldSchema> ::const_iterator _iter377;
    for (_iter377 = this->partitionKeys.begin(); _iter377 != this->partitionKeys.end(); ++_iter377)
    {
      xfer += (*_iter377).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 9);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter378;
    for (_iter378 = this->parameters.begin(); _iter378 != this->parameters.end(); ++_iter378)
    {
      xfer += oprot->writeString(_iter378->first);
      xfer += oprot->writeString(_iter378->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("viewOriginalText", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->viewOriginalText);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("viewExpandedText", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->viewExpandedText);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableType", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->tableType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.privileges) {
    xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->privileges.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.temporary) {
    xfer += oprot->writeFieldBegin("temporary", ::apache::thrift::protocol::T_BOOL, 14);
    xfer += oprot->writeBool(this->temporary);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rewriteEnabled) {
    xfer += oprot->writeFieldBegin("rewriteEnabled", ::apache::thrift::protocol::T_BOOL, 15);
    xfer += oprot->writeBool(this->rewriteEnabled);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.creationMetadata) {
    xfer += oprot->writeFieldBegin("creationMetadata", ::apache::thrift::protocol::T_STRUCT, 16);
    xfer += this->creationMetadata.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ownerType) {
    xfer += oprot->writeFieldBegin("ownerType", ::apache::thrift::protocol::T_I32, 18);
    xfer += oprot->writeI32((int32_t)this->ownerType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writeId) {
    xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 19);
    xfer += oprot->writeI64(this->writeId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isStatsCompliant) {
    xfer += oprot->writeFieldBegin("isStatsCompliant", ::apache::thrift::protocol::T_BOOL, 20);
    xfer += oprot->writeBool(this->isStatsCompliant);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.colStats) {
    xfer += oprot->writeFieldBegin("colStats", ::apache::thrift::protocol::T_STRUCT, 21);
    xfer += this->colStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.accessType) {
    xfer += oprot->writeFieldBegin("accessType", ::apache::thrift::protocol::T_BYTE, 22);
    xfer += oprot->writeByte(this->accessType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.requiredReadCapabilities) {
    xfer += oprot->writeFieldBegin("requiredReadCapabilities", ::apache::thrift::protocol::T_LIST, 23);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->requiredReadCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter379;
      for (_iter379 = this->requiredReadCapabilities.begin(); _iter379 != this->requiredReadCapabilities.end(); ++_iter379)
      {
        xfer += oprot->writeString((*_iter379));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.requiredWriteCapabilities) {
    xfer += oprot->writeFieldBegin("requiredWriteCapabilities", ::apache::thrift::protocol::T_LIST, 24);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->requiredWriteCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter380;
      for (_iter380 = this->requiredWriteCapabilities.begin(); _iter380 != this->requiredWriteCapabilities.end(); ++_iter380)
      {
        xfer += oprot->writeString((*_iter380));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 25);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fileMetadata) {
    xfer += oprot->writeFieldBegin("fileMetadata", ::apache::thrift::protocol::T_STRUCT, 26);
    xfer += this->fileMetadata.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dictionary) {
    xfer += oprot->writeFieldBegin("dictionary", ::apache::thrift::protocol::T_STRUCT, 27);
    xfer += this->dictionary.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Table &a, Table &b) {
  using ::std::swap;
  swap(a.tableName, b.tableName);
  swap(a.dbName, b.dbName);
  swap(a.owner, b.owner);
  swap(a.createTime, b.createTime);
  swap(a.lastAccessTime, b.lastAccessTime);
  swap(a.retention, b.retention);
  swap(a.sd, b.sd);
  swap(a.partitionKeys, b.partitionKeys);
  swap(a.parameters, b.parameters);
  swap(a.viewOriginalText, b.viewOriginalText);
  swap(a.viewExpandedText, b.viewExpandedText);
  swap(a.tableType, b.tableType);
  swap(a.privileges, b.privileges);
  swap(a.temporary, b.temporary);
  swap(a.rewriteEnabled, b.rewriteEnabled);
  swap(a.creationMetadata, b.creationMetadata);
  swap(a.catName, b.catName);
  swap(a.ownerType, b.ownerType);
  swap(a.writeId, b.writeId);
  swap(a.isStatsCompliant, b.isStatsCompliant);
  swap(a.colStats, b.colStats);
  swap(a.accessType, b.accessType);
  swap(a.requiredReadCapabilities, b.requiredReadCapabilities);
  swap(a.requiredWriteCapabilities, b.requiredWriteCapabilities);
  swap(a.id, b.id);
  swap(a.fileMetadata, b.fileMetadata);
  swap(a.dictionary, b.dictionary);
  swap(a.__isset, b.__isset);
}

Table::Table(const Table& other381) {
  tableName = other381.tableName;
  dbName = other381.dbName;
  owner = other381.owner;
  createTime = other381.createTime;
  lastAccessTime = other381.lastAccessTime;
  retention = other381.retention;
  sd = other381.sd;
  partitionKeys = other381.partitionKeys;
  parameters = other381.parameters;
  viewOriginalText = other381.viewOriginalText;
  viewExpandedText = other381.viewExpandedText;
  tableType = other381.tableType;
  privileges = other381.privileges;
  temporary = other381.temporary;
  rewriteEnabled = other381.rewriteEnabled;
  creationMetadata = other381.creationMetadata;
  catName = other381.catName;
  ownerType = other381.ownerType;
  writeId = other381.writeId;
  isStatsCompliant = other381.isStatsCompliant;
  colStats = other381.colStats;
  accessType = other381.accessType;
  requiredReadCapabilities = other381.requiredReadCapabilities;
  requiredWriteCapabilities = other381.requiredWriteCapabilities;
  id = other381.id;
  fileMetadata = other381.fileMetadata;
  dictionary = other381.dictionary;
  __isset = other381.__isset;
}
Table& Table::operator=(const Table& other382) {
  tableName = other382.tableName;
  dbName = other382.dbName;
  owner = other382.owner;
  createTime = other382.createTime;
  lastAccessTime = other382.lastAccessTime;
  retention = other382.retention;
  sd = other382.sd;
  partitionKeys = other382.partitionKeys;
  parameters = other382.parameters;
  viewOriginalText = other382.viewOriginalText;
  viewExpandedText = other382.viewExpandedText;
  tableType = other382.tableType;
  privileges = other382.privileges;
  temporary = other382.temporary;
  rewriteEnabled = other382.rewriteEnabled;
  creationMetadata = other382.creationMetadata;
  catName = other382.catName;
  ownerType = other382.ownerType;
  writeId = other382.writeId;
  isStatsCompliant = other382.isStatsCompliant;
  colStats = other382.colStats;
  accessType = other382.accessType;
  requiredReadCapabilities = other382.requiredReadCapabilities;
  requiredWriteCapabilities = other382.requiredWriteCapabilities;
  id = other382.id;
  fileMetadata = other382.fileMetadata;
  dictionary = other382.dictionary;
  __isset = other382.__isset;
  return *this;
}
void Table::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Table(";
  out << "tableName=" << to_string(tableName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "owner=" << to_string(owner);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "lastAccessTime=" << to_string(lastAccessTime);
  out << ", " << "retention=" << to_string(retention);
  out << ", " << "sd=" << to_string(sd);
  out << ", " << "partitionKeys=" << to_string(partitionKeys);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "viewOriginalText=" << to_string(viewOriginalText);
  out << ", " << "viewExpandedText=" << to_string(viewExpandedText);
  out << ", " << "tableType=" << to_string(tableType);
  out << ", " << "privileges="; (__isset.privileges ? (out << to_string(privileges)) : (out << "<null>"));
  out << ", " << "temporary="; (__isset.temporary ? (out << to_string(temporary)) : (out << "<null>"));
  out << ", " << "rewriteEnabled="; (__isset.rewriteEnabled ? (out << to_string(rewriteEnabled)) : (out << "<null>"));
  out << ", " << "creationMetadata="; (__isset.creationMetadata ? (out << to_string(creationMetadata)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "ownerType="; (__isset.ownerType ? (out << to_string(ownerType)) : (out << "<null>"));
  out << ", " << "writeId="; (__isset.writeId ? (out << to_string(writeId)) : (out << "<null>"));
  out << ", " << "isStatsCompliant="; (__isset.isStatsCompliant ? (out << to_string(isStatsCompliant)) : (out << "<null>"));
  out << ", " << "colStats="; (__isset.colStats ? (out << to_string(colStats)) : (out << "<null>"));
  out << ", " << "accessType="; (__isset.accessType ? (out << to_string(accessType)) : (out << "<null>"));
  out << ", " << "requiredReadCapabilities="; (__isset.requiredReadCapabilities ? (out << to_string(requiredReadCapabilities)) : (out << "<null>"));
  out << ", " << "requiredWriteCapabilities="; (__isset.requiredWriteCapabilities ? (out << to_string(requiredWriteCapabilities)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "fileMetadata="; (__isset.fileMetadata ? (out << to_string(fileMetadata)) : (out << "<null>"));
  out << ", " << "dictionary="; (__isset.dictionary ? (out << to_string(dictionary)) : (out << "<null>"));
  out << ")";
}


Partition::~Partition() noexcept {
}


void Partition::__set_values(const std::vector<std::string> & val) {
  this->values = val;
}

void Partition::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void Partition::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void Partition::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void Partition::__set_lastAccessTime(const int32_t val) {
  this->lastAccessTime = val;
}

void Partition::__set_sd(const StorageDescriptor& val) {
  this->sd = val;
}

void Partition::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void Partition::__set_privileges(const PrincipalPrivilegeSet& val) {
  this->privileges = val;
__isset.privileges = true;
}

void Partition::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void Partition::__set_writeId(const int64_t val) {
  this->writeId = val;
__isset.writeId = true;
}

void Partition::__set_isStatsCompliant(const bool val) {
  this->isStatsCompliant = val;
__isset.isStatsCompliant = true;
}

void Partition::__set_colStats(const ColumnStatistics& val) {
  this->colStats = val;
__isset.colStats = true;
}

void Partition::__set_fileMetadata(const FileMetadata& val) {
  this->fileMetadata = val;
__isset.fileMetadata = true;
}
std::ostream& operator<<(std::ostream& out, const Partition& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Partition::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size383;
            ::apache::thrift::protocol::TType _etype386;
            xfer += iprot->readListBegin(_etype386, _size383);
            this->values.resize(_size383);
            uint32_t _i387;
            for (_i387 = 0; _i387 < _size383; ++_i387)
            {
              xfer += iprot->readString(this->values[_i387]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastAccessTime);
          this->__isset.lastAccessTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sd.read(iprot);
          this->__isset.sd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size388;
            ::apache::thrift::protocol::TType _ktype389;
            ::apache::thrift::protocol::TType _vtype390;
            xfer += iprot->readMapBegin(_ktype389, _vtype390, _size388);
            uint32_t _i392;
            for (_i392 = 0; _i392 < _size388; ++_i392)
            {
              std::string _key393;
              xfer += iprot->readString(_key393);
              std::string& _val394 = this->parameters[_key393];
              xfer += iprot->readString(_val394);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          this->__isset.writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isStatsCompliant);
          this->__isset.isStatsCompliant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->colStats.read(iprot);
          this->__isset.colStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fileMetadata.read(iprot);
          this->__isset.fileMetadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Partition::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Partition");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter395;
    for (_iter395 = this->values.begin(); _iter395 != this->values.end(); ++_iter395)
    {
      xfer += oprot->writeString((*_iter395));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastAccessTime", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->lastAccessTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sd", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->sd.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 7);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter396;
    for (_iter396 = this->parameters.begin(); _iter396 != this->parameters.end(); ++_iter396)
    {
      xfer += oprot->writeString(_iter396->first);
      xfer += oprot->writeString(_iter396->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.privileges) {
    xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->privileges.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writeId) {
    xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->writeId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isStatsCompliant) {
    xfer += oprot->writeFieldBegin("isStatsCompliant", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->isStatsCompliant);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.colStats) {
    xfer += oprot->writeFieldBegin("colStats", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->colStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fileMetadata) {
    xfer += oprot->writeFieldBegin("fileMetadata", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->fileMetadata.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Partition &a, Partition &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.createTime, b.createTime);
  swap(a.lastAccessTime, b.lastAccessTime);
  swap(a.sd, b.sd);
  swap(a.parameters, b.parameters);
  swap(a.privileges, b.privileges);
  swap(a.catName, b.catName);
  swap(a.writeId, b.writeId);
  swap(a.isStatsCompliant, b.isStatsCompliant);
  swap(a.colStats, b.colStats);
  swap(a.fileMetadata, b.fileMetadata);
  swap(a.__isset, b.__isset);
}

Partition::Partition(const Partition& other397) {
  values = other397.values;
  dbName = other397.dbName;
  tableName = other397.tableName;
  createTime = other397.createTime;
  lastAccessTime = other397.lastAccessTime;
  sd = other397.sd;
  parameters = other397.parameters;
  privileges = other397.privileges;
  catName = other397.catName;
  writeId = other397.writeId;
  isStatsCompliant = other397.isStatsCompliant;
  colStats = other397.colStats;
  fileMetadata = other397.fileMetadata;
  __isset = other397.__isset;
}
Partition& Partition::operator=(const Partition& other398) {
  values = other398.values;
  dbName = other398.dbName;
  tableName = other398.tableName;
  createTime = other398.createTime;
  lastAccessTime = other398.lastAccessTime;
  sd = other398.sd;
  parameters = other398.parameters;
  privileges = other398.privileges;
  catName = other398.catName;
  writeId = other398.writeId;
  isStatsCompliant = other398.isStatsCompliant;
  colStats = other398.colStats;
  fileMetadata = other398.fileMetadata;
  __isset = other398.__isset;
  return *this;
}
void Partition::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Partition(";
  out << "values=" << to_string(values);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "lastAccessTime=" << to_string(lastAccessTime);
  out << ", " << "sd=" << to_string(sd);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "privileges="; (__isset.privileges ? (out << to_string(privileges)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "writeId="; (__isset.writeId ? (out << to_string(writeId)) : (out << "<null>"));
  out << ", " << "isStatsCompliant="; (__isset.isStatsCompliant ? (out << to_string(isStatsCompliant)) : (out << "<null>"));
  out << ", " << "colStats="; (__isset.colStats ? (out << to_string(colStats)) : (out << "<null>"));
  out << ", " << "fileMetadata="; (__isset.fileMetadata ? (out << to_string(fileMetadata)) : (out << "<null>"));
  out << ")";
}


PartitionWithoutSD::~PartitionWithoutSD() noexcept {
}


void PartitionWithoutSD::__set_values(const std::vector<std::string> & val) {
  this->values = val;
}

void PartitionWithoutSD::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void PartitionWithoutSD::__set_lastAccessTime(const int32_t val) {
  this->lastAccessTime = val;
}

void PartitionWithoutSD::__set_relativePath(const std::string& val) {
  this->relativePath = val;
}

void PartitionWithoutSD::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void PartitionWithoutSD::__set_privileges(const PrincipalPrivilegeSet& val) {
  this->privileges = val;
__isset.privileges = true;
}
std::ostream& operator<<(std::ostream& out, const PartitionWithoutSD& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionWithoutSD::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size399;
            ::apache::thrift::protocol::TType _etype402;
            xfer += iprot->readListBegin(_etype402, _size399);
            this->values.resize(_size399);
            uint32_t _i403;
            for (_i403 = 0; _i403 < _size399; ++_i403)
            {
              xfer += iprot->readString(this->values[_i403]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastAccessTime);
          this->__isset.lastAccessTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->relativePath);
          this->__isset.relativePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size404;
            ::apache::thrift::protocol::TType _ktype405;
            ::apache::thrift::protocol::TType _vtype406;
            xfer += iprot->readMapBegin(_ktype405, _vtype406, _size404);
            uint32_t _i408;
            for (_i408 = 0; _i408 < _size404; ++_i408)
            {
              std::string _key409;
              xfer += iprot->readString(_key409);
              std::string& _val410 = this->parameters[_key409];
              xfer += iprot->readString(_val410);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PartitionWithoutSD::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionWithoutSD");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter411;
    for (_iter411 = this->values.begin(); _iter411 != this->values.end(); ++_iter411)
    {
      xfer += oprot->writeString((*_iter411));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastAccessTime", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->lastAccessTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("relativePath", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->relativePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter412;
    for (_iter412 = this->parameters.begin(); _iter412 != this->parameters.end(); ++_iter412)
    {
      xfer += oprot->writeString(_iter412->first);
      xfer += oprot->writeString(_iter412->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.privileges) {
    xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->privileges.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionWithoutSD &a, PartitionWithoutSD &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.createTime, b.createTime);
  swap(a.lastAccessTime, b.lastAccessTime);
  swap(a.relativePath, b.relativePath);
  swap(a.parameters, b.parameters);
  swap(a.privileges, b.privileges);
  swap(a.__isset, b.__isset);
}

PartitionWithoutSD::PartitionWithoutSD(const PartitionWithoutSD& other413) {
  values = other413.values;
  createTime = other413.createTime;
  lastAccessTime = other413.lastAccessTime;
  relativePath = other413.relativePath;
  parameters = other413.parameters;
  privileges = other413.privileges;
  __isset = other413.__isset;
}
PartitionWithoutSD& PartitionWithoutSD::operator=(const PartitionWithoutSD& other414) {
  values = other414.values;
  createTime = other414.createTime;
  lastAccessTime = other414.lastAccessTime;
  relativePath = other414.relativePath;
  parameters = other414.parameters;
  privileges = other414.privileges;
  __isset = other414.__isset;
  return *this;
}
void PartitionWithoutSD::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionWithoutSD(";
  out << "values=" << to_string(values);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "lastAccessTime=" << to_string(lastAccessTime);
  out << ", " << "relativePath=" << to_string(relativePath);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "privileges="; (__isset.privileges ? (out << to_string(privileges)) : (out << "<null>"));
  out << ")";
}


PartitionSpecWithSharedSD::~PartitionSpecWithSharedSD() noexcept {
}


void PartitionSpecWithSharedSD::__set_partitions(const std::vector<PartitionWithoutSD> & val) {
  this->partitions = val;
}

void PartitionSpecWithSharedSD::__set_sd(const StorageDescriptor& val) {
  this->sd = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionSpecWithSharedSD& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionSpecWithSharedSD::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size415;
            ::apache::thrift::protocol::TType _etype418;
            xfer += iprot->readListBegin(_etype418, _size415);
            this->partitions.resize(_size415);
            uint32_t _i419;
            for (_i419 = 0; _i419 < _size415; ++_i419)
            {
              xfer += this->partitions[_i419].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sd.read(iprot);
          this->__isset.sd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PartitionSpecWithSharedSD::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionSpecWithSharedSD");

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<PartitionWithoutSD> ::const_iterator _iter420;
    for (_iter420 = this->partitions.begin(); _iter420 != this->partitions.end(); ++_iter420)
    {
      xfer += (*_iter420).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sd", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->sd.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionSpecWithSharedSD &a, PartitionSpecWithSharedSD &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.sd, b.sd);
  swap(a.__isset, b.__isset);
}

PartitionSpecWithSharedSD::PartitionSpecWithSharedSD(const PartitionSpecWithSharedSD& other421) {
  partitions = other421.partitions;
  sd = other421.sd;
  __isset = other421.__isset;
}
PartitionSpecWithSharedSD& PartitionSpecWithSharedSD::operator=(const PartitionSpecWithSharedSD& other422) {
  partitions = other422.partitions;
  sd = other422.sd;
  __isset = other422.__isset;
  return *this;
}
void PartitionSpecWithSharedSD::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionSpecWithSharedSD(";
  out << "partitions=" << to_string(partitions);
  out << ", " << "sd=" << to_string(sd);
  out << ")";
}


PartitionListComposingSpec::~PartitionListComposingSpec() noexcept {
}


void PartitionListComposingSpec::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionListComposingSpec& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionListComposingSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size423;
            ::apache::thrift::protocol::TType _etype426;
            xfer += iprot->readListBegin(_etype426, _size423);
            this->partitions.resize(_size423);
            uint32_t _i427;
            for (_i427 = 0; _i427 < _size423; ++_i427)
            {
              xfer += this->partitions[_i427].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PartitionListComposingSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionListComposingSpec");

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<Partition> ::const_iterator _iter428;
    for (_iter428 = this->partitions.begin(); _iter428 != this->partitions.end(); ++_iter428)
    {
      xfer += (*_iter428).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionListComposingSpec &a, PartitionListComposingSpec &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.__isset, b.__isset);
}

PartitionListComposingSpec::PartitionListComposingSpec(const PartitionListComposingSpec& other429) {
  partitions = other429.partitions;
  __isset = other429.__isset;
}
PartitionListComposingSpec& PartitionListComposingSpec::operator=(const PartitionListComposingSpec& other430) {
  partitions = other430.partitions;
  __isset = other430.__isset;
  return *this;
}
void PartitionListComposingSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionListComposingSpec(";
  out << "partitions=" << to_string(partitions);
  out << ")";
}


PartitionSpec::~PartitionSpec() noexcept {
}


void PartitionSpec::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void PartitionSpec::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void PartitionSpec::__set_rootPath(const std::string& val) {
  this->rootPath = val;
}

void PartitionSpec::__set_sharedSDPartitionSpec(const PartitionSpecWithSharedSD& val) {
  this->sharedSDPartitionSpec = val;
__isset.sharedSDPartitionSpec = true;
}

void PartitionSpec::__set_partitionList(const PartitionListComposingSpec& val) {
  this->partitionList = val;
__isset.partitionList = true;
}

void PartitionSpec::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void PartitionSpec::__set_writeId(const int64_t val) {
  this->writeId = val;
__isset.writeId = true;
}

void PartitionSpec::__set_isStatsCompliant(const bool val) {
  this->isStatsCompliant = val;
__isset.isStatsCompliant = true;
}
std::ostream& operator<<(std::ostream& out, const PartitionSpec& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rootPath);
          this->__isset.rootPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sharedSDPartitionSpec.read(iprot);
          this->__isset.sharedSDPartitionSpec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->partitionList.read(iprot);
          this->__isset.partitionList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          this->__isset.writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isStatsCompliant);
          this->__isset.isStatsCompliant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PartitionSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionSpec");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rootPath", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->rootPath);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sharedSDPartitionSpec) {
    xfer += oprot->writeFieldBegin("sharedSDPartitionSpec", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->sharedSDPartitionSpec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionList) {
    xfer += oprot->writeFieldBegin("partitionList", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->partitionList.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writeId) {
    xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->writeId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isStatsCompliant) {
    xfer += oprot->writeFieldBegin("isStatsCompliant", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->isStatsCompliant);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionSpec &a, PartitionSpec &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.rootPath, b.rootPath);
  swap(a.sharedSDPartitionSpec, b.sharedSDPartitionSpec);
  swap(a.partitionList, b.partitionList);
  swap(a.catName, b.catName);
  swap(a.writeId, b.writeId);
  swap(a.isStatsCompliant, b.isStatsCompliant);
  swap(a.__isset, b.__isset);
}

PartitionSpec::PartitionSpec(const PartitionSpec& other431) {
  dbName = other431.dbName;
  tableName = other431.tableName;
  rootPath = other431.rootPath;
  sharedSDPartitionSpec = other431.sharedSDPartitionSpec;
  partitionList = other431.partitionList;
  catName = other431.catName;
  writeId = other431.writeId;
  isStatsCompliant = other431.isStatsCompliant;
  __isset = other431.__isset;
}
PartitionSpec& PartitionSpec::operator=(const PartitionSpec& other432) {
  dbName = other432.dbName;
  tableName = other432.tableName;
  rootPath = other432.rootPath;
  sharedSDPartitionSpec = other432.sharedSDPartitionSpec;
  partitionList = other432.partitionList;
  catName = other432.catName;
  writeId = other432.writeId;
  isStatsCompliant = other432.isStatsCompliant;
  __isset = other432.__isset;
  return *this;
}
void PartitionSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionSpec(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "rootPath=" << to_string(rootPath);
  out << ", " << "sharedSDPartitionSpec="; (__isset.sharedSDPartitionSpec ? (out << to_string(sharedSDPartitionSpec)) : (out << "<null>"));
  out << ", " << "partitionList="; (__isset.partitionList ? (out << to_string(partitionList)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "writeId="; (__isset.writeId ? (out << to_string(writeId)) : (out << "<null>"));
  out << ", " << "isStatsCompliant="; (__isset.isStatsCompliant ? (out << to_string(isStatsCompliant)) : (out << "<null>"));
  out << ")";
}


AggrStats::~AggrStats() noexcept {
}


void AggrStats::__set_colStats(const std::vector<ColumnStatisticsObj> & val) {
  this->colStats = val;
}

void AggrStats::__set_partsFound(const int64_t val) {
  this->partsFound = val;
}

void AggrStats::__set_isStatsCompliant(const bool val) {
  this->isStatsCompliant = val;
__isset.isStatsCompliant = true;
}
std::ostream& operator<<(std::ostream& out, const AggrStats& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AggrStats::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_colStats = false;
  bool isset_partsFound = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colStats.clear();
            uint32_t _size433;
            ::apache::thrift::protocol::TType _etype436;
            xfer += iprot->readListBegin(_etype436, _size433);
            this->colStats.resize(_size433);
            uint32_t _i437;
            for (_i437 = 0; _i437 < _size433; ++_i437)
            {
              xfer += this->colStats[_i437].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_colStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->partsFound);
          isset_partsFound = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isStatsCompliant);
          this->__isset.isStatsCompliant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_colStats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partsFound)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AggrStats::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AggrStats");

  xfer += oprot->writeFieldBegin("colStats", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->colStats.size()));
    std::vector<ColumnStatisticsObj> ::const_iterator _iter438;
    for (_iter438 = this->colStats.begin(); _iter438 != this->colStats.end(); ++_iter438)
    {
      xfer += (*_iter438).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partsFound", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->partsFound);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.isStatsCompliant) {
    xfer += oprot->writeFieldBegin("isStatsCompliant", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->isStatsCompliant);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AggrStats &a, AggrStats &b) {
  using ::std::swap;
  swap(a.colStats, b.colStats);
  swap(a.partsFound, b.partsFound);
  swap(a.isStatsCompliant, b.isStatsCompliant);
  swap(a.__isset, b.__isset);
}

AggrStats::AggrStats(const AggrStats& other439) {
  colStats = other439.colStats;
  partsFound = other439.partsFound;
  isStatsCompliant = other439.isStatsCompliant;
  __isset = other439.__isset;
}
AggrStats& AggrStats::operator=(const AggrStats& other440) {
  colStats = other440.colStats;
  partsFound = other440.partsFound;
  isStatsCompliant = other440.isStatsCompliant;
  __isset = other440.__isset;
  return *this;
}
void AggrStats::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AggrStats(";
  out << "colStats=" << to_string(colStats);
  out << ", " << "partsFound=" << to_string(partsFound);
  out << ", " << "isStatsCompliant="; (__isset.isStatsCompliant ? (out << to_string(isStatsCompliant)) : (out << "<null>"));
  out << ")";
}


SetPartitionsStatsRequest::~SetPartitionsStatsRequest() noexcept {
}


void SetPartitionsStatsRequest::__set_colStats(const std::vector<ColumnStatistics> & val) {
  this->colStats = val;
}

void SetPartitionsStatsRequest::__set_needMerge(const bool val) {
  this->needMerge = val;
__isset.needMerge = true;
}

void SetPartitionsStatsRequest::__set_writeId(const int64_t val) {
  this->writeId = val;
__isset.writeId = true;
}

void SetPartitionsStatsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void SetPartitionsStatsRequest::__set_engine(const std::string& val) {
  this->engine = val;
}
std::ostream& operator<<(std::ostream& out, const SetPartitionsStatsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SetPartitionsStatsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_colStats = false;
  bool isset_engine = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colStats.clear();
            uint32_t _size441;
            ::apache::thrift::protocol::TType _etype444;
            xfer += iprot->readListBegin(_etype444, _size441);
            this->colStats.resize(_size441);
            uint32_t _i445;
            for (_i445 = 0; _i445 < _size441; ++_i445)
            {
              xfer += this->colStats[_i445].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_colStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->needMerge);
          this->__isset.needMerge = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          this->__isset.writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->engine);
          isset_engine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_colStats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_engine)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SetPartitionsStatsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SetPartitionsStatsRequest");

  xfer += oprot->writeFieldBegin("colStats", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->colStats.size()));
    std::vector<ColumnStatistics> ::const_iterator _iter446;
    for (_iter446 = this->colStats.begin(); _iter446 != this->colStats.end(); ++_iter446)
    {
      xfer += (*_iter446).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.needMerge) {
    xfer += oprot->writeFieldBegin("needMerge", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->needMerge);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writeId) {
    xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->writeId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("engine", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->engine);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SetPartitionsStatsRequest &a, SetPartitionsStatsRequest &b) {
  using ::std::swap;
  swap(a.colStats, b.colStats);
  swap(a.needMerge, b.needMerge);
  swap(a.writeId, b.writeId);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.engine, b.engine);
  swap(a.__isset, b.__isset);
}

SetPartitionsStatsRequest::SetPartitionsStatsRequest(const SetPartitionsStatsRequest& other447) {
  colStats = other447.colStats;
  needMerge = other447.needMerge;
  writeId = other447.writeId;
  validWriteIdList = other447.validWriteIdList;
  engine = other447.engine;
  __isset = other447.__isset;
}
SetPartitionsStatsRequest& SetPartitionsStatsRequest::operator=(const SetPartitionsStatsRequest& other448) {
  colStats = other448.colStats;
  needMerge = other448.needMerge;
  writeId = other448.writeId;
  validWriteIdList = other448.validWriteIdList;
  engine = other448.engine;
  __isset = other448.__isset;
  return *this;
}
void SetPartitionsStatsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SetPartitionsStatsRequest(";
  out << "colStats=" << to_string(colStats);
  out << ", " << "needMerge="; (__isset.needMerge ? (out << to_string(needMerge)) : (out << "<null>"));
  out << ", " << "writeId="; (__isset.writeId ? (out << to_string(writeId)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "engine=" << to_string(engine);
  out << ")";
}


SetPartitionsStatsResponse::~SetPartitionsStatsResponse() noexcept {
}


void SetPartitionsStatsResponse::__set_result(const bool val) {
  this->result = val;
}
std::ostream& operator<<(std::ostream& out, const SetPartitionsStatsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SetPartitionsStatsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_result = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->result);
          isset_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_result)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SetPartitionsStatsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SetPartitionsStatsResponse");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SetPartitionsStatsResponse &a, SetPartitionsStatsResponse &b) {
  using ::std::swap;
  swap(a.result, b.result);
}

SetPartitionsStatsResponse::SetPartitionsStatsResponse(const SetPartitionsStatsResponse& other449) {
  result = other449.result;
}
SetPartitionsStatsResponse& SetPartitionsStatsResponse::operator=(const SetPartitionsStatsResponse& other450) {
  result = other450.result;
  return *this;
}
void SetPartitionsStatsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SetPartitionsStatsResponse(";
  out << "result=" << to_string(result);
  out << ")";
}


Schema::~Schema() noexcept {
}


void Schema::__set_fieldSchemas(const std::vector<FieldSchema> & val) {
  this->fieldSchemas = val;
}

void Schema::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
}
std::ostream& operator<<(std::ostream& out, const Schema& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Schema::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fieldSchemas.clear();
            uint32_t _size451;
            ::apache::thrift::protocol::TType _etype454;
            xfer += iprot->readListBegin(_etype454, _size451);
            this->fieldSchemas.resize(_size451);
            uint32_t _i455;
            for (_i455 = 0; _i455 < _size451; ++_i455)
            {
              xfer += this->fieldSchemas[_i455].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldSchemas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size456;
            ::apache::thrift::protocol::TType _ktype457;
            ::apache::thrift::protocol::TType _vtype458;
            xfer += iprot->readMapBegin(_ktype457, _vtype458, _size456);
            uint32_t _i460;
            for (_i460 = 0; _i460 < _size456; ++_i460)
            {
              std::string _key461;
              xfer += iprot->readString(_key461);
              std::string& _val462 = this->properties[_key461];
              xfer += iprot->readString(_val462);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Schema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Schema");

  xfer += oprot->writeFieldBegin("fieldSchemas", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fieldSchemas.size()));
    std::vector<FieldSchema> ::const_iterator _iter463;
    for (_iter463 = this->fieldSchemas.begin(); _iter463 != this->fieldSchemas.end(); ++_iter463)
    {
      xfer += (*_iter463).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter464;
    for (_iter464 = this->properties.begin(); _iter464 != this->properties.end(); ++_iter464)
    {
      xfer += oprot->writeString(_iter464->first);
      xfer += oprot->writeString(_iter464->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Schema &a, Schema &b) {
  using ::std::swap;
  swap(a.fieldSchemas, b.fieldSchemas);
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

Schema::Schema(const Schema& other465) {
  fieldSchemas = other465.fieldSchemas;
  properties = other465.properties;
  __isset = other465.__isset;
}
Schema& Schema::operator=(const Schema& other466) {
  fieldSchemas = other466.fieldSchemas;
  properties = other466.properties;
  __isset = other466.__isset;
  return *this;
}
void Schema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Schema(";
  out << "fieldSchemas=" << to_string(fieldSchemas);
  out << ", " << "properties=" << to_string(properties);
  out << ")";
}


EnvironmentContext::~EnvironmentContext() noexcept {
}


void EnvironmentContext::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
}
std::ostream& operator<<(std::ostream& out, const EnvironmentContext& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t EnvironmentContext::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size467;
            ::apache::thrift::protocol::TType _ktype468;
            ::apache::thrift::protocol::TType _vtype469;
            xfer += iprot->readMapBegin(_ktype468, _vtype469, _size467);
            uint32_t _i471;
            for (_i471 = 0; _i471 < _size467; ++_i471)
            {
              std::string _key472;
              xfer += iprot->readString(_key472);
              std::string& _val473 = this->properties[_key472];
              xfer += iprot->readString(_val473);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EnvironmentContext::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EnvironmentContext");

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter474;
    for (_iter474 = this->properties.begin(); _iter474 != this->properties.end(); ++_iter474)
    {
      xfer += oprot->writeString(_iter474->first);
      xfer += oprot->writeString(_iter474->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EnvironmentContext &a, EnvironmentContext &b) {
  using ::std::swap;
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

EnvironmentContext::EnvironmentContext(const EnvironmentContext& other475) {
  properties = other475.properties;
  __isset = other475.__isset;
}
EnvironmentContext& EnvironmentContext::operator=(const EnvironmentContext& other476) {
  properties = other476.properties;
  __isset = other476.__isset;
  return *this;
}
void EnvironmentContext::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EnvironmentContext(";
  out << "properties=" << to_string(properties);
  out << ")";
}


PrimaryKeysRequest::~PrimaryKeysRequest() noexcept {
}


void PrimaryKeysRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void PrimaryKeysRequest::__set_tbl_name(const std::string& val) {
  this->tbl_name = val;
}

void PrimaryKeysRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void PrimaryKeysRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void PrimaryKeysRequest::__set_tableId(const int64_t val) {
  this->tableId = val;
__isset.tableId = true;
}
std::ostream& operator<<(std::ostream& out, const PrimaryKeysRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PrimaryKeysRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db_name = false;
  bool isset_tbl_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbl_name);
          isset_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tbl_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PrimaryKeysRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PrimaryKeysRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tbl_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tbl_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableId) {
    xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->tableId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PrimaryKeysRequest &a, PrimaryKeysRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.tbl_name, b.tbl_name);
  swap(a.catName, b.catName);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.tableId, b.tableId);
  swap(a.__isset, b.__isset);
}

PrimaryKeysRequest::PrimaryKeysRequest(const PrimaryKeysRequest& other477) {
  db_name = other477.db_name;
  tbl_name = other477.tbl_name;
  catName = other477.catName;
  validWriteIdList = other477.validWriteIdList;
  tableId = other477.tableId;
  __isset = other477.__isset;
}
PrimaryKeysRequest& PrimaryKeysRequest::operator=(const PrimaryKeysRequest& other478) {
  db_name = other478.db_name;
  tbl_name = other478.tbl_name;
  catName = other478.catName;
  validWriteIdList = other478.validWriteIdList;
  tableId = other478.tableId;
  __isset = other478.__isset;
  return *this;
}
void PrimaryKeysRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PrimaryKeysRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "tbl_name=" << to_string(tbl_name);
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "tableId="; (__isset.tableId ? (out << to_string(tableId)) : (out << "<null>"));
  out << ")";
}


PrimaryKeysResponse::~PrimaryKeysResponse() noexcept {
}


void PrimaryKeysResponse::__set_primaryKeys(const std::vector<SQLPrimaryKey> & val) {
  this->primaryKeys = val;
}
std::ostream& operator<<(std::ostream& out, const PrimaryKeysResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PrimaryKeysResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_primaryKeys = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->primaryKeys.clear();
            uint32_t _size479;
            ::apache::thrift::protocol::TType _etype482;
            xfer += iprot->readListBegin(_etype482, _size479);
            this->primaryKeys.resize(_size479);
            uint32_t _i483;
            for (_i483 = 0; _i483 < _size479; ++_i483)
            {
              xfer += this->primaryKeys[_i483].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_primaryKeys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_primaryKeys)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PrimaryKeysResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PrimaryKeysResponse");

  xfer += oprot->writeFieldBegin("primaryKeys", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->primaryKeys.size()));
    std::vector<SQLPrimaryKey> ::const_iterator _iter484;
    for (_iter484 = this->primaryKeys.begin(); _iter484 != this->primaryKeys.end(); ++_iter484)
    {
      xfer += (*_iter484).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PrimaryKeysResponse &a, PrimaryKeysResponse &b) {
  using ::std::swap;
  swap(a.primaryKeys, b.primaryKeys);
}

PrimaryKeysResponse::PrimaryKeysResponse(const PrimaryKeysResponse& other485) {
  primaryKeys = other485.primaryKeys;
}
PrimaryKeysResponse& PrimaryKeysResponse::operator=(const PrimaryKeysResponse& other486) {
  primaryKeys = other486.primaryKeys;
  return *this;
}
void PrimaryKeysResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PrimaryKeysResponse(";
  out << "primaryKeys=" << to_string(primaryKeys);
  out << ")";
}


ForeignKeysRequest::~ForeignKeysRequest() noexcept {
}


void ForeignKeysRequest::__set_parent_db_name(const std::string& val) {
  this->parent_db_name = val;
}

void ForeignKeysRequest::__set_parent_tbl_name(const std::string& val) {
  this->parent_tbl_name = val;
}

void ForeignKeysRequest::__set_foreign_db_name(const std::string& val) {
  this->foreign_db_name = val;
}

void ForeignKeysRequest::__set_foreign_tbl_name(const std::string& val) {
  this->foreign_tbl_name = val;
}

void ForeignKeysRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void ForeignKeysRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void ForeignKeysRequest::__set_tableId(const int64_t val) {
  this->tableId = val;
__isset.tableId = true;
}
std::ostream& operator<<(std::ostream& out, const ForeignKeysRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ForeignKeysRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parent_db_name);
          this->__isset.parent_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parent_tbl_name);
          this->__isset.parent_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->foreign_db_name);
          this->__isset.foreign_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->foreign_tbl_name);
          this->__isset.foreign_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ForeignKeysRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ForeignKeysRequest");

  xfer += oprot->writeFieldBegin("parent_db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->parent_db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parent_tbl_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->parent_tbl_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("foreign_db_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->foreign_db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("foreign_tbl_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->foreign_tbl_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableId) {
    xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->tableId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ForeignKeysRequest &a, ForeignKeysRequest &b) {
  using ::std::swap;
  swap(a.parent_db_name, b.parent_db_name);
  swap(a.parent_tbl_name, b.parent_tbl_name);
  swap(a.foreign_db_name, b.foreign_db_name);
  swap(a.foreign_tbl_name, b.foreign_tbl_name);
  swap(a.catName, b.catName);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.tableId, b.tableId);
  swap(a.__isset, b.__isset);
}

ForeignKeysRequest::ForeignKeysRequest(const ForeignKeysRequest& other487) {
  parent_db_name = other487.parent_db_name;
  parent_tbl_name = other487.parent_tbl_name;
  foreign_db_name = other487.foreign_db_name;
  foreign_tbl_name = other487.foreign_tbl_name;
  catName = other487.catName;
  validWriteIdList = other487.validWriteIdList;
  tableId = other487.tableId;
  __isset = other487.__isset;
}
ForeignKeysRequest& ForeignKeysRequest::operator=(const ForeignKeysRequest& other488) {
  parent_db_name = other488.parent_db_name;
  parent_tbl_name = other488.parent_tbl_name;
  foreign_db_name = other488.foreign_db_name;
  foreign_tbl_name = other488.foreign_tbl_name;
  catName = other488.catName;
  validWriteIdList = other488.validWriteIdList;
  tableId = other488.tableId;
  __isset = other488.__isset;
  return *this;
}
void ForeignKeysRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ForeignKeysRequest(";
  out << "parent_db_name=" << to_string(parent_db_name);
  out << ", " << "parent_tbl_name=" << to_string(parent_tbl_name);
  out << ", " << "foreign_db_name=" << to_string(foreign_db_name);
  out << ", " << "foreign_tbl_name=" << to_string(foreign_tbl_name);
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "tableId="; (__isset.tableId ? (out << to_string(tableId)) : (out << "<null>"));
  out << ")";
}


ForeignKeysResponse::~ForeignKeysResponse() noexcept {
}


void ForeignKeysResponse::__set_foreignKeys(const std::vector<SQLForeignKey> & val) {
  this->foreignKeys = val;
}
std::ostream& operator<<(std::ostream& out, const ForeignKeysResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ForeignKeysResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_foreignKeys = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->foreignKeys.clear();
            uint32_t _size489;
            ::apache::thrift::protocol::TType _etype492;
            xfer += iprot->readListBegin(_etype492, _size489);
            this->foreignKeys.resize(_size489);
            uint32_t _i493;
            for (_i493 = 0; _i493 < _size489; ++_i493)
            {
              xfer += this->foreignKeys[_i493].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_foreignKeys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_foreignKeys)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ForeignKeysResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ForeignKeysResponse");

  xfer += oprot->writeFieldBegin("foreignKeys", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->foreignKeys.size()));
    std::vector<SQLForeignKey> ::const_iterator _iter494;
    for (_iter494 = this->foreignKeys.begin(); _iter494 != this->foreignKeys.end(); ++_iter494)
    {
      xfer += (*_iter494).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ForeignKeysResponse &a, ForeignKeysResponse &b) {
  using ::std::swap;
  swap(a.foreignKeys, b.foreignKeys);
}

ForeignKeysResponse::ForeignKeysResponse(const ForeignKeysResponse& other495) {
  foreignKeys = other495.foreignKeys;
}
ForeignKeysResponse& ForeignKeysResponse::operator=(const ForeignKeysResponse& other496) {
  foreignKeys = other496.foreignKeys;
  return *this;
}
void ForeignKeysResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ForeignKeysResponse(";
  out << "foreignKeys=" << to_string(foreignKeys);
  out << ")";
}


UniqueConstraintsRequest::~UniqueConstraintsRequest() noexcept {
}


void UniqueConstraintsRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void UniqueConstraintsRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void UniqueConstraintsRequest::__set_tbl_name(const std::string& val) {
  this->tbl_name = val;
}

void UniqueConstraintsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void UniqueConstraintsRequest::__set_tableId(const int64_t val) {
  this->tableId = val;
__isset.tableId = true;
}
std::ostream& operator<<(std::ostream& out, const UniqueConstraintsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UniqueConstraintsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catName = false;
  bool isset_db_name = false;
  bool isset_tbl_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbl_name);
          isset_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tbl_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UniqueConstraintsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UniqueConstraintsRequest");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tbl_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tbl_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableId) {
    xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->tableId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UniqueConstraintsRequest &a, UniqueConstraintsRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.db_name, b.db_name);
  swap(a.tbl_name, b.tbl_name);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.tableId, b.tableId);
  swap(a.__isset, b.__isset);
}

UniqueConstraintsRequest::UniqueConstraintsRequest(const UniqueConstraintsRequest& other497) {
  catName = other497.catName;
  db_name = other497.db_name;
  tbl_name = other497.tbl_name;
  validWriteIdList = other497.validWriteIdList;
  tableId = other497.tableId;
  __isset = other497.__isset;
}
UniqueConstraintsRequest& UniqueConstraintsRequest::operator=(const UniqueConstraintsRequest& other498) {
  catName = other498.catName;
  db_name = other498.db_name;
  tbl_name = other498.tbl_name;
  validWriteIdList = other498.validWriteIdList;
  tableId = other498.tableId;
  __isset = other498.__isset;
  return *this;
}
void UniqueConstraintsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UniqueConstraintsRequest(";
  out << "catName=" << to_string(catName);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "tbl_name=" << to_string(tbl_name);
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "tableId="; (__isset.tableId ? (out << to_string(tableId)) : (out << "<null>"));
  out << ")";
}


UniqueConstraintsResponse::~UniqueConstraintsResponse() noexcept {
}


void UniqueConstraintsResponse::__set_uniqueConstraints(const std::vector<SQLUniqueConstraint> & val) {
  this->uniqueConstraints = val;
}
std::ostream& operator<<(std::ostream& out, const UniqueConstraintsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UniqueConstraintsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_uniqueConstraints = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->uniqueConstraints.clear();
            uint32_t _size499;
            ::apache::thrift::protocol::TType _etype502;
            xfer += iprot->readListBegin(_etype502, _size499);
            this->uniqueConstraints.resize(_size499);
            uint32_t _i503;
            for (_i503 = 0; _i503 < _size499; ++_i503)
            {
              xfer += this->uniqueConstraints[_i503].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_uniqueConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_uniqueConstraints)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UniqueConstraintsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UniqueConstraintsResponse");

  xfer += oprot->writeFieldBegin("uniqueConstraints", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->uniqueConstraints.size()));
    std::vector<SQLUniqueConstraint> ::const_iterator _iter504;
    for (_iter504 = this->uniqueConstraints.begin(); _iter504 != this->uniqueConstraints.end(); ++_iter504)
    {
      xfer += (*_iter504).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UniqueConstraintsResponse &a, UniqueConstraintsResponse &b) {
  using ::std::swap;
  swap(a.uniqueConstraints, b.uniqueConstraints);
}

UniqueConstraintsResponse::UniqueConstraintsResponse(const UniqueConstraintsResponse& other505) {
  uniqueConstraints = other505.uniqueConstraints;
}
UniqueConstraintsResponse& UniqueConstraintsResponse::operator=(const UniqueConstraintsResponse& other506) {
  uniqueConstraints = other506.uniqueConstraints;
  return *this;
}
void UniqueConstraintsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UniqueConstraintsResponse(";
  out << "uniqueConstraints=" << to_string(uniqueConstraints);
  out << ")";
}


NotNullConstraintsRequest::~NotNullConstraintsRequest() noexcept {
}


void NotNullConstraintsRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void NotNullConstraintsRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void NotNullConstraintsRequest::__set_tbl_name(const std::string& val) {
  this->tbl_name = val;
}

void NotNullConstraintsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void NotNullConstraintsRequest::__set_tableId(const int64_t val) {
  this->tableId = val;
__isset.tableId = true;
}
std::ostream& operator<<(std::ostream& out, const NotNullConstraintsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotNullConstraintsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catName = false;
  bool isset_db_name = false;
  bool isset_tbl_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbl_name);
          isset_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tbl_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotNullConstraintsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotNullConstraintsRequest");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tbl_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tbl_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableId) {
    xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->tableId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotNullConstraintsRequest &a, NotNullConstraintsRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.db_name, b.db_name);
  swap(a.tbl_name, b.tbl_name);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.tableId, b.tableId);
  swap(a.__isset, b.__isset);
}

NotNullConstraintsRequest::NotNullConstraintsRequest(const NotNullConstraintsRequest& other507) {
  catName = other507.catName;
  db_name = other507.db_name;
  tbl_name = other507.tbl_name;
  validWriteIdList = other507.validWriteIdList;
  tableId = other507.tableId;
  __isset = other507.__isset;
}
NotNullConstraintsRequest& NotNullConstraintsRequest::operator=(const NotNullConstraintsRequest& other508) {
  catName = other508.catName;
  db_name = other508.db_name;
  tbl_name = other508.tbl_name;
  validWriteIdList = other508.validWriteIdList;
  tableId = other508.tableId;
  __isset = other508.__isset;
  return *this;
}
void NotNullConstraintsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotNullConstraintsRequest(";
  out << "catName=" << to_string(catName);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "tbl_name=" << to_string(tbl_name);
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "tableId="; (__isset.tableId ? (out << to_string(tableId)) : (out << "<null>"));
  out << ")";
}


NotNullConstraintsResponse::~NotNullConstraintsResponse() noexcept {
}


void NotNullConstraintsResponse::__set_notNullConstraints(const std::vector<SQLNotNullConstraint> & val) {
  this->notNullConstraints = val;
}
std::ostream& operator<<(std::ostream& out, const NotNullConstraintsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotNullConstraintsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_notNullConstraints = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->notNullConstraints.clear();
            uint32_t _size509;
            ::apache::thrift::protocol::TType _etype512;
            xfer += iprot->readListBegin(_etype512, _size509);
            this->notNullConstraints.resize(_size509);
            uint32_t _i513;
            for (_i513 = 0; _i513 < _size509; ++_i513)
            {
              xfer += this->notNullConstraints[_i513].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_notNullConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_notNullConstraints)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotNullConstraintsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotNullConstraintsResponse");

  xfer += oprot->writeFieldBegin("notNullConstraints", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->notNullConstraints.size()));
    std::vector<SQLNotNullConstraint> ::const_iterator _iter514;
    for (_iter514 = this->notNullConstraints.begin(); _iter514 != this->notNullConstraints.end(); ++_iter514)
    {
      xfer += (*_iter514).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotNullConstraintsResponse &a, NotNullConstraintsResponse &b) {
  using ::std::swap;
  swap(a.notNullConstraints, b.notNullConstraints);
}

NotNullConstraintsResponse::NotNullConstraintsResponse(const NotNullConstraintsResponse& other515) {
  notNullConstraints = other515.notNullConstraints;
}
NotNullConstraintsResponse& NotNullConstraintsResponse::operator=(const NotNullConstraintsResponse& other516) {
  notNullConstraints = other516.notNullConstraints;
  return *this;
}
void NotNullConstraintsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotNullConstraintsResponse(";
  out << "notNullConstraints=" << to_string(notNullConstraints);
  out << ")";
}


DefaultConstraintsRequest::~DefaultConstraintsRequest() noexcept {
}


void DefaultConstraintsRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void DefaultConstraintsRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void DefaultConstraintsRequest::__set_tbl_name(const std::string& val) {
  this->tbl_name = val;
}

void DefaultConstraintsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void DefaultConstraintsRequest::__set_tableId(const int64_t val) {
  this->tableId = val;
__isset.tableId = true;
}
std::ostream& operator<<(std::ostream& out, const DefaultConstraintsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DefaultConstraintsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catName = false;
  bool isset_db_name = false;
  bool isset_tbl_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbl_name);
          isset_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tbl_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DefaultConstraintsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DefaultConstraintsRequest");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tbl_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tbl_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableId) {
    xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->tableId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DefaultConstraintsRequest &a, DefaultConstraintsRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.db_name, b.db_name);
  swap(a.tbl_name, b.tbl_name);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.tableId, b.tableId);
  swap(a.__isset, b.__isset);
}

DefaultConstraintsRequest::DefaultConstraintsRequest(const DefaultConstraintsRequest& other517) {
  catName = other517.catName;
  db_name = other517.db_name;
  tbl_name = other517.tbl_name;
  validWriteIdList = other517.validWriteIdList;
  tableId = other517.tableId;
  __isset = other517.__isset;
}
DefaultConstraintsRequest& DefaultConstraintsRequest::operator=(const DefaultConstraintsRequest& other518) {
  catName = other518.catName;
  db_name = other518.db_name;
  tbl_name = other518.tbl_name;
  validWriteIdList = other518.validWriteIdList;
  tableId = other518.tableId;
  __isset = other518.__isset;
  return *this;
}
void DefaultConstraintsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DefaultConstraintsRequest(";
  out << "catName=" << to_string(catName);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "tbl_name=" << to_string(tbl_name);
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "tableId="; (__isset.tableId ? (out << to_string(tableId)) : (out << "<null>"));
  out << ")";
}


DefaultConstraintsResponse::~DefaultConstraintsResponse() noexcept {
}


void DefaultConstraintsResponse::__set_defaultConstraints(const std::vector<SQLDefaultConstraint> & val) {
  this->defaultConstraints = val;
}
std::ostream& operator<<(std::ostream& out, const DefaultConstraintsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DefaultConstraintsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_defaultConstraints = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->defaultConstraints.clear();
            uint32_t _size519;
            ::apache::thrift::protocol::TType _etype522;
            xfer += iprot->readListBegin(_etype522, _size519);
            this->defaultConstraints.resize(_size519);
            uint32_t _i523;
            for (_i523 = 0; _i523 < _size519; ++_i523)
            {
              xfer += this->defaultConstraints[_i523].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_defaultConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_defaultConstraints)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DefaultConstraintsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DefaultConstraintsResponse");

  xfer += oprot->writeFieldBegin("defaultConstraints", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->defaultConstraints.size()));
    std::vector<SQLDefaultConstraint> ::const_iterator _iter524;
    for (_iter524 = this->defaultConstraints.begin(); _iter524 != this->defaultConstraints.end(); ++_iter524)
    {
      xfer += (*_iter524).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DefaultConstraintsResponse &a, DefaultConstraintsResponse &b) {
  using ::std::swap;
  swap(a.defaultConstraints, b.defaultConstraints);
}

DefaultConstraintsResponse::DefaultConstraintsResponse(const DefaultConstraintsResponse& other525) {
  defaultConstraints = other525.defaultConstraints;
}
DefaultConstraintsResponse& DefaultConstraintsResponse::operator=(const DefaultConstraintsResponse& other526) {
  defaultConstraints = other526.defaultConstraints;
  return *this;
}
void DefaultConstraintsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DefaultConstraintsResponse(";
  out << "defaultConstraints=" << to_string(defaultConstraints);
  out << ")";
}


CheckConstraintsRequest::~CheckConstraintsRequest() noexcept {
}


void CheckConstraintsRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void CheckConstraintsRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void CheckConstraintsRequest::__set_tbl_name(const std::string& val) {
  this->tbl_name = val;
}

void CheckConstraintsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void CheckConstraintsRequest::__set_tableId(const int64_t val) {
  this->tableId = val;
__isset.tableId = true;
}
std::ostream& operator<<(std::ostream& out, const CheckConstraintsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CheckConstraintsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catName = false;
  bool isset_db_name = false;
  bool isset_tbl_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbl_name);
          isset_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tbl_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CheckConstraintsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CheckConstraintsRequest");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tbl_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tbl_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableId) {
    xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->tableId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CheckConstraintsRequest &a, CheckConstraintsRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.db_name, b.db_name);
  swap(a.tbl_name, b.tbl_name);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.tableId, b.tableId);
  swap(a.__isset, b.__isset);
}

CheckConstraintsRequest::CheckConstraintsRequest(const CheckConstraintsRequest& other527) {
  catName = other527.catName;
  db_name = other527.db_name;
  tbl_name = other527.tbl_name;
  validWriteIdList = other527.validWriteIdList;
  tableId = other527.tableId;
  __isset = other527.__isset;
}
CheckConstraintsRequest& CheckConstraintsRequest::operator=(const CheckConstraintsRequest& other528) {
  catName = other528.catName;
  db_name = other528.db_name;
  tbl_name = other528.tbl_name;
  validWriteIdList = other528.validWriteIdList;
  tableId = other528.tableId;
  __isset = other528.__isset;
  return *this;
}
void CheckConstraintsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CheckConstraintsRequest(";
  out << "catName=" << to_string(catName);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "tbl_name=" << to_string(tbl_name);
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "tableId="; (__isset.tableId ? (out << to_string(tableId)) : (out << "<null>"));
  out << ")";
}


CheckConstraintsResponse::~CheckConstraintsResponse() noexcept {
}


void CheckConstraintsResponse::__set_checkConstraints(const std::vector<SQLCheckConstraint> & val) {
  this->checkConstraints = val;
}
std::ostream& operator<<(std::ostream& out, const CheckConstraintsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CheckConstraintsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_checkConstraints = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->checkConstraints.clear();
            uint32_t _size529;
            ::apache::thrift::protocol::TType _etype532;
            xfer += iprot->readListBegin(_etype532, _size529);
            this->checkConstraints.resize(_size529);
            uint32_t _i533;
            for (_i533 = 0; _i533 < _size529; ++_i533)
            {
              xfer += this->checkConstraints[_i533].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_checkConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_checkConstraints)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CheckConstraintsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CheckConstraintsResponse");

  xfer += oprot->writeFieldBegin("checkConstraints", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->checkConstraints.size()));
    std::vector<SQLCheckConstraint> ::const_iterator _iter534;
    for (_iter534 = this->checkConstraints.begin(); _iter534 != this->checkConstraints.end(); ++_iter534)
    {
      xfer += (*_iter534).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CheckConstraintsResponse &a, CheckConstraintsResponse &b) {
  using ::std::swap;
  swap(a.checkConstraints, b.checkConstraints);
}

CheckConstraintsResponse::CheckConstraintsResponse(const CheckConstraintsResponse& other535) {
  checkConstraints = other535.checkConstraints;
}
CheckConstraintsResponse& CheckConstraintsResponse::operator=(const CheckConstraintsResponse& other536) {
  checkConstraints = other536.checkConstraints;
  return *this;
}
void CheckConstraintsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CheckConstraintsResponse(";
  out << "checkConstraints=" << to_string(checkConstraints);
  out << ")";
}


AllTableConstraintsRequest::~AllTableConstraintsRequest() noexcept {
}


void AllTableConstraintsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void AllTableConstraintsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void AllTableConstraintsRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void AllTableConstraintsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void AllTableConstraintsRequest::__set_tableId(const int64_t val) {
  this->tableId = val;
__isset.tableId = true;
}
std::ostream& operator<<(std::ostream& out, const AllTableConstraintsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AllTableConstraintsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_catName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AllTableConstraintsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AllTableConstraintsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableId) {
    xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->tableId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AllTableConstraintsRequest &a, AllTableConstraintsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.catName, b.catName);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.tableId, b.tableId);
  swap(a.__isset, b.__isset);
}

AllTableConstraintsRequest::AllTableConstraintsRequest(const AllTableConstraintsRequest& other537) {
  dbName = other537.dbName;
  tblName = other537.tblName;
  catName = other537.catName;
  validWriteIdList = other537.validWriteIdList;
  tableId = other537.tableId;
  __isset = other537.__isset;
}
AllTableConstraintsRequest& AllTableConstraintsRequest::operator=(const AllTableConstraintsRequest& other538) {
  dbName = other538.dbName;
  tblName = other538.tblName;
  catName = other538.catName;
  validWriteIdList = other538.validWriteIdList;
  tableId = other538.tableId;
  __isset = other538.__isset;
  return *this;
}
void AllTableConstraintsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AllTableConstraintsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "catName=" << to_string(catName);
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "tableId="; (__isset.tableId ? (out << to_string(tableId)) : (out << "<null>"));
  out << ")";
}


AllTableConstraintsResponse::~AllTableConstraintsResponse() noexcept {
}


void AllTableConstraintsResponse::__set_allTableConstraints(const SQLAllTableConstraints& val) {
  this->allTableConstraints = val;
}
std::ostream& operator<<(std::ostream& out, const AllTableConstraintsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AllTableConstraintsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_allTableConstraints = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->allTableConstraints.read(iprot);
          isset_allTableConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_allTableConstraints)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AllTableConstraintsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AllTableConstraintsResponse");

  xfer += oprot->writeFieldBegin("allTableConstraints", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->allTableConstraints.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AllTableConstraintsResponse &a, AllTableConstraintsResponse &b) {
  using ::std::swap;
  swap(a.allTableConstraints, b.allTableConstraints);
}

AllTableConstraintsResponse::AllTableConstraintsResponse(const AllTableConstraintsResponse& other539) {
  allTableConstraints = other539.allTableConstraints;
}
AllTableConstraintsResponse& AllTableConstraintsResponse::operator=(const AllTableConstraintsResponse& other540) {
  allTableConstraints = other540.allTableConstraints;
  return *this;
}
void AllTableConstraintsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AllTableConstraintsResponse(";
  out << "allTableConstraints=" << to_string(allTableConstraints);
  out << ")";
}


DropConstraintRequest::~DropConstraintRequest() noexcept {
}


void DropConstraintRequest::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void DropConstraintRequest::__set_tablename(const std::string& val) {
  this->tablename = val;
}

void DropConstraintRequest::__set_constraintname(const std::string& val) {
  this->constraintname = val;
}

void DropConstraintRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}
std::ostream& operator<<(std::ostream& out, const DropConstraintRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropConstraintRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbname = false;
  bool isset_tablename = false;
  bool isset_constraintname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          isset_tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->constraintname);
          isset_constraintname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_constraintname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DropConstraintRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropConstraintRequest");

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("constraintname", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->constraintname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropConstraintRequest &a, DropConstraintRequest &b) {
  using ::std::swap;
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.constraintname, b.constraintname);
  swap(a.catName, b.catName);
  swap(a.__isset, b.__isset);
}

DropConstraintRequest::DropConstraintRequest(const DropConstraintRequest& other541) {
  dbname = other541.dbname;
  tablename = other541.tablename;
  constraintname = other541.constraintname;
  catName = other541.catName;
  __isset = other541.__isset;
}
DropConstraintRequest& DropConstraintRequest::operator=(const DropConstraintRequest& other542) {
  dbname = other542.dbname;
  tablename = other542.tablename;
  constraintname = other542.constraintname;
  catName = other542.catName;
  __isset = other542.__isset;
  return *this;
}
void DropConstraintRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropConstraintRequest(";
  out << "dbname=" << to_string(dbname);
  out << ", " << "tablename=" << to_string(tablename);
  out << ", " << "constraintname=" << to_string(constraintname);
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ")";
}


AddPrimaryKeyRequest::~AddPrimaryKeyRequest() noexcept {
}


void AddPrimaryKeyRequest::__set_primaryKeyCols(const std::vector<SQLPrimaryKey> & val) {
  this->primaryKeyCols = val;
}
std::ostream& operator<<(std::ostream& out, const AddPrimaryKeyRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddPrimaryKeyRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_primaryKeyCols = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->primaryKeyCols.clear();
            uint32_t _size543;
            ::apache::thrift::protocol::TType _etype546;
            xfer += iprot->readListBegin(_etype546, _size543);
            this->primaryKeyCols.resize(_size543);
            uint32_t _i547;
            for (_i547 = 0; _i547 < _size543; ++_i547)
            {
              xfer += this->primaryKeyCols[_i547].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_primaryKeyCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_primaryKeyCols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddPrimaryKeyRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddPrimaryKeyRequest");

  xfer += oprot->writeFieldBegin("primaryKeyCols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->primaryKeyCols.size()));
    std::vector<SQLPrimaryKey> ::const_iterator _iter548;
    for (_iter548 = this->primaryKeyCols.begin(); _iter548 != this->primaryKeyCols.end(); ++_iter548)
    {
      xfer += (*_iter548).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddPrimaryKeyRequest &a, AddPrimaryKeyRequest &b) {
  using ::std::swap;
  swap(a.primaryKeyCols, b.primaryKeyCols);
}

AddPrimaryKeyRequest::AddPrimaryKeyRequest(const AddPrimaryKeyRequest& other549) {
  primaryKeyCols = other549.primaryKeyCols;
}
AddPrimaryKeyRequest& AddPrimaryKeyRequest::operator=(const AddPrimaryKeyRequest& other550) {
  primaryKeyCols = other550.primaryKeyCols;
  return *this;
}
void AddPrimaryKeyRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddPrimaryKeyRequest(";
  out << "primaryKeyCols=" << to_string(primaryKeyCols);
  out << ")";
}


AddForeignKeyRequest::~AddForeignKeyRequest() noexcept {
}


void AddForeignKeyRequest::__set_foreignKeyCols(const std::vector<SQLForeignKey> & val) {
  this->foreignKeyCols = val;
}
std::ostream& operator<<(std::ostream& out, const AddForeignKeyRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddForeignKeyRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_foreignKeyCols = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->foreignKeyCols.clear();
            uint32_t _size551;
            ::apache::thrift::protocol::TType _etype554;
            xfer += iprot->readListBegin(_etype554, _size551);
            this->foreignKeyCols.resize(_size551);
            uint32_t _i555;
            for (_i555 = 0; _i555 < _size551; ++_i555)
            {
              xfer += this->foreignKeyCols[_i555].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_foreignKeyCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_foreignKeyCols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddForeignKeyRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddForeignKeyRequest");

  xfer += oprot->writeFieldBegin("foreignKeyCols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->foreignKeyCols.size()));
    std::vector<SQLForeignKey> ::const_iterator _iter556;
    for (_iter556 = this->foreignKeyCols.begin(); _iter556 != this->foreignKeyCols.end(); ++_iter556)
    {
      xfer += (*_iter556).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddForeignKeyRequest &a, AddForeignKeyRequest &b) {
  using ::std::swap;
  swap(a.foreignKeyCols, b.foreignKeyCols);
}

AddForeignKeyRequest::AddForeignKeyRequest(const AddForeignKeyRequest& other557) {
  foreignKeyCols = other557.foreignKeyCols;
}
AddForeignKeyRequest& AddForeignKeyRequest::operator=(const AddForeignKeyRequest& other558) {
  foreignKeyCols = other558.foreignKeyCols;
  return *this;
}
void AddForeignKeyRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddForeignKeyRequest(";
  out << "foreignKeyCols=" << to_string(foreignKeyCols);
  out << ")";
}


AddUniqueConstraintRequest::~AddUniqueConstraintRequest() noexcept {
}


void AddUniqueConstraintRequest::__set_uniqueConstraintCols(const std::vector<SQLUniqueConstraint> & val) {
  this->uniqueConstraintCols = val;
}
std::ostream& operator<<(std::ostream& out, const AddUniqueConstraintRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddUniqueConstraintRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_uniqueConstraintCols = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->uniqueConstraintCols.clear();
            uint32_t _size559;
            ::apache::thrift::protocol::TType _etype562;
            xfer += iprot->readListBegin(_etype562, _size559);
            this->uniqueConstraintCols.resize(_size559);
            uint32_t _i563;
            for (_i563 = 0; _i563 < _size559; ++_i563)
            {
              xfer += this->uniqueConstraintCols[_i563].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_uniqueConstraintCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_uniqueConstraintCols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddUniqueConstraintRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddUniqueConstraintRequest");

  xfer += oprot->writeFieldBegin("uniqueConstraintCols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->uniqueConstraintCols.size()));
    std::vector<SQLUniqueConstraint> ::const_iterator _iter564;
    for (_iter564 = this->uniqueConstraintCols.begin(); _iter564 != this->uniqueConstraintCols.end(); ++_iter564)
    {
      xfer += (*_iter564).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddUniqueConstraintRequest &a, AddUniqueConstraintRequest &b) {
  using ::std::swap;
  swap(a.uniqueConstraintCols, b.uniqueConstraintCols);
}

AddUniqueConstraintRequest::AddUniqueConstraintRequest(const AddUniqueConstraintRequest& other565) {
  uniqueConstraintCols = other565.uniqueConstraintCols;
}
AddUniqueConstraintRequest& AddUniqueConstraintRequest::operator=(const AddUniqueConstraintRequest& other566) {
  uniqueConstraintCols = other566.uniqueConstraintCols;
  return *this;
}
void AddUniqueConstraintRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddUniqueConstraintRequest(";
  out << "uniqueConstraintCols=" << to_string(uniqueConstraintCols);
  out << ")";
}


AddNotNullConstraintRequest::~AddNotNullConstraintRequest() noexcept {
}


void AddNotNullConstraintRequest::__set_notNullConstraintCols(const std::vector<SQLNotNullConstraint> & val) {
  this->notNullConstraintCols = val;
}
std::ostream& operator<<(std::ostream& out, const AddNotNullConstraintRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddNotNullConstraintRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_notNullConstraintCols = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->notNullConstraintCols.clear();
            uint32_t _size567;
            ::apache::thrift::protocol::TType _etype570;
            xfer += iprot->readListBegin(_etype570, _size567);
            this->notNullConstraintCols.resize(_size567);
            uint32_t _i571;
            for (_i571 = 0; _i571 < _size567; ++_i571)
            {
              xfer += this->notNullConstraintCols[_i571].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_notNullConstraintCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_notNullConstraintCols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddNotNullConstraintRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddNotNullConstraintRequest");

  xfer += oprot->writeFieldBegin("notNullConstraintCols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->notNullConstraintCols.size()));
    std::vector<SQLNotNullConstraint> ::const_iterator _iter572;
    for (_iter572 = this->notNullConstraintCols.begin(); _iter572 != this->notNullConstraintCols.end(); ++_iter572)
    {
      xfer += (*_iter572).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddNotNullConstraintRequest &a, AddNotNullConstraintRequest &b) {
  using ::std::swap;
  swap(a.notNullConstraintCols, b.notNullConstraintCols);
}

AddNotNullConstraintRequest::AddNotNullConstraintRequest(const AddNotNullConstraintRequest& other573) {
  notNullConstraintCols = other573.notNullConstraintCols;
}
AddNotNullConstraintRequest& AddNotNullConstraintRequest::operator=(const AddNotNullConstraintRequest& other574) {
  notNullConstraintCols = other574.notNullConstraintCols;
  return *this;
}
void AddNotNullConstraintRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddNotNullConstraintRequest(";
  out << "notNullConstraintCols=" << to_string(notNullConstraintCols);
  out << ")";
}


AddDefaultConstraintRequest::~AddDefaultConstraintRequest() noexcept {
}


void AddDefaultConstraintRequest::__set_defaultConstraintCols(const std::vector<SQLDefaultConstraint> & val) {
  this->defaultConstraintCols = val;
}
std::ostream& operator<<(std::ostream& out, const AddDefaultConstraintRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddDefaultConstraintRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_defaultConstraintCols = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->defaultConstraintCols.clear();
            uint32_t _size575;
            ::apache::thrift::protocol::TType _etype578;
            xfer += iprot->readListBegin(_etype578, _size575);
            this->defaultConstraintCols.resize(_size575);
            uint32_t _i579;
            for (_i579 = 0; _i579 < _size575; ++_i579)
            {
              xfer += this->defaultConstraintCols[_i579].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_defaultConstraintCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_defaultConstraintCols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddDefaultConstraintRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddDefaultConstraintRequest");

  xfer += oprot->writeFieldBegin("defaultConstraintCols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->defaultConstraintCols.size()));
    std::vector<SQLDefaultConstraint> ::const_iterator _iter580;
    for (_iter580 = this->defaultConstraintCols.begin(); _iter580 != this->defaultConstraintCols.end(); ++_iter580)
    {
      xfer += (*_iter580).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddDefaultConstraintRequest &a, AddDefaultConstraintRequest &b) {
  using ::std::swap;
  swap(a.defaultConstraintCols, b.defaultConstraintCols);
}

AddDefaultConstraintRequest::AddDefaultConstraintRequest(const AddDefaultConstraintRequest& other581) {
  defaultConstraintCols = other581.defaultConstraintCols;
}
AddDefaultConstraintRequest& AddDefaultConstraintRequest::operator=(const AddDefaultConstraintRequest& other582) {
  defaultConstraintCols = other582.defaultConstraintCols;
  return *this;
}
void AddDefaultConstraintRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddDefaultConstraintRequest(";
  out << "defaultConstraintCols=" << to_string(defaultConstraintCols);
  out << ")";
}


AddCheckConstraintRequest::~AddCheckConstraintRequest() noexcept {
}


void AddCheckConstraintRequest::__set_checkConstraintCols(const std::vector<SQLCheckConstraint> & val) {
  this->checkConstraintCols = val;
}
std::ostream& operator<<(std::ostream& out, const AddCheckConstraintRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddCheckConstraintRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_checkConstraintCols = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->checkConstraintCols.clear();
            uint32_t _size583;
            ::apache::thrift::protocol::TType _etype586;
            xfer += iprot->readListBegin(_etype586, _size583);
            this->checkConstraintCols.resize(_size583);
            uint32_t _i587;
            for (_i587 = 0; _i587 < _size583; ++_i587)
            {
              xfer += this->checkConstraintCols[_i587].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_checkConstraintCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_checkConstraintCols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddCheckConstraintRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddCheckConstraintRequest");

  xfer += oprot->writeFieldBegin("checkConstraintCols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->checkConstraintCols.size()));
    std::vector<SQLCheckConstraint> ::const_iterator _iter588;
    for (_iter588 = this->checkConstraintCols.begin(); _iter588 != this->checkConstraintCols.end(); ++_iter588)
    {
      xfer += (*_iter588).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddCheckConstraintRequest &a, AddCheckConstraintRequest &b) {
  using ::std::swap;
  swap(a.checkConstraintCols, b.checkConstraintCols);
}

AddCheckConstraintRequest::AddCheckConstraintRequest(const AddCheckConstraintRequest& other589) {
  checkConstraintCols = other589.checkConstraintCols;
}
AddCheckConstraintRequest& AddCheckConstraintRequest::operator=(const AddCheckConstraintRequest& other590) {
  checkConstraintCols = other590.checkConstraintCols;
  return *this;
}
void AddCheckConstraintRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddCheckConstraintRequest(";
  out << "checkConstraintCols=" << to_string(checkConstraintCols);
  out << ")";
}


PartitionsByExprResult::~PartitionsByExprResult() noexcept {
}


void PartitionsByExprResult::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
}

void PartitionsByExprResult::__set_hasUnknownPartitions(const bool val) {
  this->hasUnknownPartitions = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionsByExprResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionsByExprResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partitions = false;
  bool isset_hasUnknownPartitions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size591;
            ::apache::thrift::protocol::TType _etype594;
            xfer += iprot->readListBegin(_etype594, _size591);
            this->partitions.resize(_size591);
            uint32_t _i595;
            for (_i595 = 0; _i595 < _size591; ++_i595)
            {
              xfer += this->partitions[_i595].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasUnknownPartitions);
          isset_hasUnknownPartitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hasUnknownPartitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsByExprResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsByExprResult");

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<Partition> ::const_iterator _iter596;
    for (_iter596 = this->partitions.begin(); _iter596 != this->partitions.end(); ++_iter596)
    {
      xfer += (*_iter596).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hasUnknownPartitions", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->hasUnknownPartitions);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsByExprResult &a, PartitionsByExprResult &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.hasUnknownPartitions, b.hasUnknownPartitions);
}

PartitionsByExprResult::PartitionsByExprResult(const PartitionsByExprResult& other597) {
  partitions = other597.partitions;
  hasUnknownPartitions = other597.hasUnknownPartitions;
}
PartitionsByExprResult& PartitionsByExprResult::operator=(const PartitionsByExprResult& other598) {
  partitions = other598.partitions;
  hasUnknownPartitions = other598.hasUnknownPartitions;
  return *this;
}
void PartitionsByExprResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsByExprResult(";
  out << "partitions=" << to_string(partitions);
  out << ", " << "hasUnknownPartitions=" << to_string(hasUnknownPartitions);
  out << ")";
}


PartitionsSpecByExprResult::~PartitionsSpecByExprResult() noexcept {
}


void PartitionsSpecByExprResult::__set_partitionsSpec(const std::vector<PartitionSpec> & val) {
  this->partitionsSpec = val;
}

void PartitionsSpecByExprResult::__set_hasUnknownPartitions(const bool val) {
  this->hasUnknownPartitions = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionsSpecByExprResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionsSpecByExprResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partitionsSpec = false;
  bool isset_hasUnknownPartitions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionsSpec.clear();
            uint32_t _size599;
            ::apache::thrift::protocol::TType _etype602;
            xfer += iprot->readListBegin(_etype602, _size599);
            this->partitionsSpec.resize(_size599);
            uint32_t _i603;
            for (_i603 = 0; _i603 < _size599; ++_i603)
            {
              xfer += this->partitionsSpec[_i603].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitionsSpec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasUnknownPartitions);
          isset_hasUnknownPartitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partitionsSpec)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hasUnknownPartitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsSpecByExprResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsSpecByExprResult");

  xfer += oprot->writeFieldBegin("partitionsSpec", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitionsSpec.size()));
    std::vector<PartitionSpec> ::const_iterator _iter604;
    for (_iter604 = this->partitionsSpec.begin(); _iter604 != this->partitionsSpec.end(); ++_iter604)
    {
      xfer += (*_iter604).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hasUnknownPartitions", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->hasUnknownPartitions);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsSpecByExprResult &a, PartitionsSpecByExprResult &b) {
  using ::std::swap;
  swap(a.partitionsSpec, b.partitionsSpec);
  swap(a.hasUnknownPartitions, b.hasUnknownPartitions);
}

PartitionsSpecByExprResult::PartitionsSpecByExprResult(const PartitionsSpecByExprResult& other605) {
  partitionsSpec = other605.partitionsSpec;
  hasUnknownPartitions = other605.hasUnknownPartitions;
}
PartitionsSpecByExprResult& PartitionsSpecByExprResult::operator=(const PartitionsSpecByExprResult& other606) {
  partitionsSpec = other606.partitionsSpec;
  hasUnknownPartitions = other606.hasUnknownPartitions;
  return *this;
}
void PartitionsSpecByExprResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsSpecByExprResult(";
  out << "partitionsSpec=" << to_string(partitionsSpec);
  out << ", " << "hasUnknownPartitions=" << to_string(hasUnknownPartitions);
  out << ")";
}


PartitionsByExprRequest::~PartitionsByExprRequest() noexcept {
}


void PartitionsByExprRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void PartitionsByExprRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void PartitionsByExprRequest::__set_expr(const std::string& val) {
  this->expr = val;
}

void PartitionsByExprRequest::__set_defaultPartitionName(const std::string& val) {
  this->defaultPartitionName = val;
__isset.defaultPartitionName = true;
}

void PartitionsByExprRequest::__set_maxParts(const int16_t val) {
  this->maxParts = val;
__isset.maxParts = true;
}

void PartitionsByExprRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void PartitionsByExprRequest::__set_order(const std::string& val) {
  this->order = val;
__isset.order = true;
}

void PartitionsByExprRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void PartitionsByExprRequest::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}
std::ostream& operator<<(std::ostream& out, const PartitionsByExprRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionsByExprRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_expr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->expr);
          isset_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->defaultPartitionName);
          this->__isset.defaultPartitionName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->maxParts);
          this->__isset.maxParts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->order);
          this->__isset.order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_expr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsByExprRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsByExprRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expr", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->expr);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.defaultPartitionName) {
    xfer += oprot->writeFieldBegin("defaultPartitionName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->defaultPartitionName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxParts) {
    xfer += oprot->writeFieldBegin("maxParts", ::apache::thrift::protocol::T_I16, 5);
    xfer += oprot->writeI16(this->maxParts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.order) {
    xfer += oprot->writeFieldBegin("order", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->order);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsByExprRequest &a, PartitionsByExprRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.expr, b.expr);
  swap(a.defaultPartitionName, b.defaultPartitionName);
  swap(a.maxParts, b.maxParts);
  swap(a.catName, b.catName);
  swap(a.order, b.order);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

PartitionsByExprRequest::PartitionsByExprRequest(const PartitionsByExprRequest& other607) {
  dbName = other607.dbName;
  tblName = other607.tblName;
  expr = other607.expr;
  defaultPartitionName = other607.defaultPartitionName;
  maxParts = other607.maxParts;
  catName = other607.catName;
  order = other607.order;
  validWriteIdList = other607.validWriteIdList;
  id = other607.id;
  __isset = other607.__isset;
}
PartitionsByExprRequest& PartitionsByExprRequest::operator=(const PartitionsByExprRequest& other608) {
  dbName = other608.dbName;
  tblName = other608.tblName;
  expr = other608.expr;
  defaultPartitionName = other608.defaultPartitionName;
  maxParts = other608.maxParts;
  catName = other608.catName;
  order = other608.order;
  validWriteIdList = other608.validWriteIdList;
  id = other608.id;
  __isset = other608.__isset;
  return *this;
}
void PartitionsByExprRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsByExprRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "expr=" << to_string(expr);
  out << ", " << "defaultPartitionName="; (__isset.defaultPartitionName ? (out << to_string(defaultPartitionName)) : (out << "<null>"));
  out << ", " << "maxParts="; (__isset.maxParts ? (out << to_string(maxParts)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "order="; (__isset.order ? (out << to_string(order)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


TableStatsResult::~TableStatsResult() noexcept {
}


void TableStatsResult::__set_tableStats(const std::vector<ColumnStatisticsObj> & val) {
  this->tableStats = val;
}

void TableStatsResult::__set_isStatsCompliant(const bool val) {
  this->isStatsCompliant = val;
__isset.isStatsCompliant = true;
}
std::ostream& operator<<(std::ostream& out, const TableStatsResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TableStatsResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tableStats = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tableStats.clear();
            uint32_t _size609;
            ::apache::thrift::protocol::TType _etype612;
            xfer += iprot->readListBegin(_etype612, _size609);
            this->tableStats.resize(_size609);
            uint32_t _i613;
            for (_i613 = 0; _i613 < _size609; ++_i613)
            {
              xfer += this->tableStats[_i613].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_tableStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isStatsCompliant);
          this->__isset.isStatsCompliant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tableStats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TableStatsResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TableStatsResult");

  xfer += oprot->writeFieldBegin("tableStats", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tableStats.size()));
    std::vector<ColumnStatisticsObj> ::const_iterator _iter614;
    for (_iter614 = this->tableStats.begin(); _iter614 != this->tableStats.end(); ++_iter614)
    {
      xfer += (*_iter614).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.isStatsCompliant) {
    xfer += oprot->writeFieldBegin("isStatsCompliant", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->isStatsCompliant);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableStatsResult &a, TableStatsResult &b) {
  using ::std::swap;
  swap(a.tableStats, b.tableStats);
  swap(a.isStatsCompliant, b.isStatsCompliant);
  swap(a.__isset, b.__isset);
}

TableStatsResult::TableStatsResult(const TableStatsResult& other615) {
  tableStats = other615.tableStats;
  isStatsCompliant = other615.isStatsCompliant;
  __isset = other615.__isset;
}
TableStatsResult& TableStatsResult::operator=(const TableStatsResult& other616) {
  tableStats = other616.tableStats;
  isStatsCompliant = other616.isStatsCompliant;
  __isset = other616.__isset;
  return *this;
}
void TableStatsResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TableStatsResult(";
  out << "tableStats=" << to_string(tableStats);
  out << ", " << "isStatsCompliant="; (__isset.isStatsCompliant ? (out << to_string(isStatsCompliant)) : (out << "<null>"));
  out << ")";
}


PartitionsStatsResult::~PartitionsStatsResult() noexcept {
}


void PartitionsStatsResult::__set_partStats(const std::map<std::string, std::vector<ColumnStatisticsObj> > & val) {
  this->partStats = val;
}

void PartitionsStatsResult::__set_isStatsCompliant(const bool val) {
  this->isStatsCompliant = val;
__isset.isStatsCompliant = true;
}
std::ostream& operator<<(std::ostream& out, const PartitionsStatsResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionsStatsResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partStats = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->partStats.clear();
            uint32_t _size617;
            ::apache::thrift::protocol::TType _ktype618;
            ::apache::thrift::protocol::TType _vtype619;
            xfer += iprot->readMapBegin(_ktype618, _vtype619, _size617);
            uint32_t _i621;
            for (_i621 = 0; _i621 < _size617; ++_i621)
            {
              std::string _key622;
              xfer += iprot->readString(_key622);
              std::vector<ColumnStatisticsObj> & _val623 = this->partStats[_key622];
              {
                _val623.clear();
                uint32_t _size624;
                ::apache::thrift::protocol::TType _etype627;
                xfer += iprot->readListBegin(_etype627, _size624);
                _val623.resize(_size624);
                uint32_t _i628;
                for (_i628 = 0; _i628 < _size624; ++_i628)
                {
                  xfer += _val623[_i628].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_partStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isStatsCompliant);
          this->__isset.isStatsCompliant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partStats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsStatsResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsStatsResult");

  xfer += oprot->writeFieldBegin("partStats", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->partStats.size()));
    std::map<std::string, std::vector<ColumnStatisticsObj> > ::const_iterator _iter629;
    for (_iter629 = this->partStats.begin(); _iter629 != this->partStats.end(); ++_iter629)
    {
      xfer += oprot->writeString(_iter629->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter629->second.size()));
        std::vector<ColumnStatisticsObj> ::const_iterator _iter630;
        for (_iter630 = _iter629->second.begin(); _iter630 != _iter629->second.end(); ++_iter630)
        {
          xfer += (*_iter630).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.isStatsCompliant) {
    xfer += oprot->writeFieldBegin("isStatsCompliant", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->isStatsCompliant);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsStatsResult &a, PartitionsStatsResult &b) {
  using ::std::swap;
  swap(a.partStats, b.partStats);
  swap(a.isStatsCompliant, b.isStatsCompliant);
  swap(a.__isset, b.__isset);
}

PartitionsStatsResult::PartitionsStatsResult(const PartitionsStatsResult& other631) {
  partStats = other631.partStats;
  isStatsCompliant = other631.isStatsCompliant;
  __isset = other631.__isset;
}
PartitionsStatsResult& PartitionsStatsResult::operator=(const PartitionsStatsResult& other632) {
  partStats = other632.partStats;
  isStatsCompliant = other632.isStatsCompliant;
  __isset = other632.__isset;
  return *this;
}
void PartitionsStatsResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsStatsResult(";
  out << "partStats=" << to_string(partStats);
  out << ", " << "isStatsCompliant="; (__isset.isStatsCompliant ? (out << to_string(isStatsCompliant)) : (out << "<null>"));
  out << ")";
}


TableStatsRequest::~TableStatsRequest() noexcept {
}


void TableStatsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void TableStatsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void TableStatsRequest::__set_colNames(const std::vector<std::string> & val) {
  this->colNames = val;
}

void TableStatsRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void TableStatsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void TableStatsRequest::__set_engine(const std::string& val) {
  this->engine = val;
}

void TableStatsRequest::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}
std::ostream& operator<<(std::ostream& out, const TableStatsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TableStatsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_colNames = false;
  bool isset_engine = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colNames.clear();
            uint32_t _size633;
            ::apache::thrift::protocol::TType _etype636;
            xfer += iprot->readListBegin(_etype636, _size633);
            this->colNames.resize(_size633);
            uint32_t _i637;
            for (_i637 = 0; _i637 < _size633; ++_i637)
            {
              xfer += iprot->readString(this->colNames[_i637]);
            }
            xfer += iprot->readListEnd();
          }
          isset_colNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->engine);
          isset_engine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_colNames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_engine)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TableStatsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TableStatsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colNames", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->colNames.size()));
    std::vector<std::string> ::const_iterator _iter638;
    for (_iter638 = this->colNames.begin(); _iter638 != this->colNames.end(); ++_iter638)
    {
      xfer += oprot->writeString((*_iter638));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("engine", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->engine);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableStatsRequest &a, TableStatsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.colNames, b.colNames);
  swap(a.catName, b.catName);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.engine, b.engine);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

TableStatsRequest::TableStatsRequest(const TableStatsRequest& other639) {
  dbName = other639.dbName;
  tblName = other639.tblName;
  colNames = other639.colNames;
  catName = other639.catName;
  validWriteIdList = other639.validWriteIdList;
  engine = other639.engine;
  id = other639.id;
  __isset = other639.__isset;
}
TableStatsRequest& TableStatsRequest::operator=(const TableStatsRequest& other640) {
  dbName = other640.dbName;
  tblName = other640.tblName;
  colNames = other640.colNames;
  catName = other640.catName;
  validWriteIdList = other640.validWriteIdList;
  engine = other640.engine;
  id = other640.id;
  __isset = other640.__isset;
  return *this;
}
void TableStatsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TableStatsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "colNames=" << to_string(colNames);
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "engine=" << to_string(engine);
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


PartitionsStatsRequest::~PartitionsStatsRequest() noexcept {
}


void PartitionsStatsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void PartitionsStatsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void PartitionsStatsRequest::__set_colNames(const std::vector<std::string> & val) {
  this->colNames = val;
}

void PartitionsStatsRequest::__set_partNames(const std::vector<std::string> & val) {
  this->partNames = val;
}

void PartitionsStatsRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void PartitionsStatsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void PartitionsStatsRequest::__set_engine(const std::string& val) {
  this->engine = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionsStatsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionsStatsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_colNames = false;
  bool isset_partNames = false;
  bool isset_engine = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colNames.clear();
            uint32_t _size641;
            ::apache::thrift::protocol::TType _etype644;
            xfer += iprot->readListBegin(_etype644, _size641);
            this->colNames.resize(_size641);
            uint32_t _i645;
            for (_i645 = 0; _i645 < _size641; ++_i645)
            {
              xfer += iprot->readString(this->colNames[_i645]);
            }
            xfer += iprot->readListEnd();
          }
          isset_colNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partNames.clear();
            uint32_t _size646;
            ::apache::thrift::protocol::TType _etype649;
            xfer += iprot->readListBegin(_etype649, _size646);
            this->partNames.resize(_size646);
            uint32_t _i650;
            for (_i650 = 0; _i650 < _size646; ++_i650)
            {
              xfer += iprot->readString(this->partNames[_i650]);
            }
            xfer += iprot->readListEnd();
          }
          isset_partNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->engine);
          isset_engine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_colNames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partNames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_engine)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsStatsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsStatsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colNames", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->colNames.size()));
    std::vector<std::string> ::const_iterator _iter651;
    for (_iter651 = this->colNames.begin(); _iter651 != this->colNames.end(); ++_iter651)
    {
      xfer += oprot->writeString((*_iter651));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partNames", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partNames.size()));
    std::vector<std::string> ::const_iterator _iter652;
    for (_iter652 = this->partNames.begin(); _iter652 != this->partNames.end(); ++_iter652)
    {
      xfer += oprot->writeString((*_iter652));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("engine", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->engine);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsStatsRequest &a, PartitionsStatsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.colNames, b.colNames);
  swap(a.partNames, b.partNames);
  swap(a.catName, b.catName);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.engine, b.engine);
  swap(a.__isset, b.__isset);
}

PartitionsStatsRequest::PartitionsStatsRequest(const PartitionsStatsRequest& other653) {
  dbName = other653.dbName;
  tblName = other653.tblName;
  colNames = other653.colNames;
  partNames = other653.partNames;
  catName = other653.catName;
  validWriteIdList = other653.validWriteIdList;
  engine = other653.engine;
  __isset = other653.__isset;
}
PartitionsStatsRequest& PartitionsStatsRequest::operator=(const PartitionsStatsRequest& other654) {
  dbName = other654.dbName;
  tblName = other654.tblName;
  colNames = other654.colNames;
  partNames = other654.partNames;
  catName = other654.catName;
  validWriteIdList = other654.validWriteIdList;
  engine = other654.engine;
  __isset = other654.__isset;
  return *this;
}
void PartitionsStatsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsStatsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "colNames=" << to_string(colNames);
  out << ", " << "partNames=" << to_string(partNames);
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "engine=" << to_string(engine);
  out << ")";
}


AddPartitionsResult::~AddPartitionsResult() noexcept {
}


void AddPartitionsResult::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
__isset.partitions = true;
}

void AddPartitionsResult::__set_isStatsCompliant(const bool val) {
  this->isStatsCompliant = val;
__isset.isStatsCompliant = true;
}
std::ostream& operator<<(std::ostream& out, const AddPartitionsResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddPartitionsResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size655;
            ::apache::thrift::protocol::TType _etype658;
            xfer += iprot->readListBegin(_etype658, _size655);
            this->partitions.resize(_size655);
            uint32_t _i659;
            for (_i659 = 0; _i659 < _size655; ++_i659)
            {
              xfer += this->partitions[_i659].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isStatsCompliant);
          this->__isset.isStatsCompliant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AddPartitionsResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddPartitionsResult");

  if (this->__isset.partitions) {
    xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
      std::vector<Partition> ::const_iterator _iter660;
      for (_iter660 = this->partitions.begin(); _iter660 != this->partitions.end(); ++_iter660)
      {
        xfer += (*_iter660).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isStatsCompliant) {
    xfer += oprot->writeFieldBegin("isStatsCompliant", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->isStatsCompliant);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddPartitionsResult &a, AddPartitionsResult &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.isStatsCompliant, b.isStatsCompliant);
  swap(a.__isset, b.__isset);
}

AddPartitionsResult::AddPartitionsResult(const AddPartitionsResult& other661) {
  partitions = other661.partitions;
  isStatsCompliant = other661.isStatsCompliant;
  __isset = other661.__isset;
}
AddPartitionsResult& AddPartitionsResult::operator=(const AddPartitionsResult& other662) {
  partitions = other662.partitions;
  isStatsCompliant = other662.isStatsCompliant;
  __isset = other662.__isset;
  return *this;
}
void AddPartitionsResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddPartitionsResult(";
  out << "partitions="; (__isset.partitions ? (out << to_string(partitions)) : (out << "<null>"));
  out << ", " << "isStatsCompliant="; (__isset.isStatsCompliant ? (out << to_string(isStatsCompliant)) : (out << "<null>"));
  out << ")";
}


AddPartitionsRequest::~AddPartitionsRequest() noexcept {
}


void AddPartitionsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void AddPartitionsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void AddPartitionsRequest::__set_parts(const std::vector<Partition> & val) {
  this->parts = val;
}

void AddPartitionsRequest::__set_ifNotExists(const bool val) {
  this->ifNotExists = val;
}

void AddPartitionsRequest::__set_needResult(const bool val) {
  this->needResult = val;
__isset.needResult = true;
}

void AddPartitionsRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void AddPartitionsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}
std::ostream& operator<<(std::ostream& out, const AddPartitionsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddPartitionsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_parts = false;
  bool isset_ifNotExists = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->parts.clear();
            uint32_t _size663;
            ::apache::thrift::protocol::TType _etype666;
            xfer += iprot->readListBegin(_etype666, _size663);
            this->parts.resize(_size663);
            uint32_t _i667;
            for (_i667 = 0; _i667 < _size663; ++_i667)
            {
              xfer += this->parts[_i667].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_parts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ifNotExists);
          isset_ifNotExists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->needResult);
          this->__isset.needResult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_parts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ifNotExists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddPartitionsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddPartitionsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parts", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->parts.size()));
    std::vector<Partition> ::const_iterator _iter668;
    for (_iter668 = this->parts.begin(); _iter668 != this->parts.end(); ++_iter668)
    {
      xfer += (*_iter668).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ifNotExists", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->ifNotExists);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.needResult) {
    xfer += oprot->writeFieldBegin("needResult", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->needResult);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddPartitionsRequest &a, AddPartitionsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.parts, b.parts);
  swap(a.ifNotExists, b.ifNotExists);
  swap(a.needResult, b.needResult);
  swap(a.catName, b.catName);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.__isset, b.__isset);
}

AddPartitionsRequest::AddPartitionsRequest(const AddPartitionsRequest& other669) {
  dbName = other669.dbName;
  tblName = other669.tblName;
  parts = other669.parts;
  ifNotExists = other669.ifNotExists;
  needResult = other669.needResult;
  catName = other669.catName;
  validWriteIdList = other669.validWriteIdList;
  __isset = other669.__isset;
}
AddPartitionsRequest& AddPartitionsRequest::operator=(const AddPartitionsRequest& other670) {
  dbName = other670.dbName;
  tblName = other670.tblName;
  parts = other670.parts;
  ifNotExists = other670.ifNotExists;
  needResult = other670.needResult;
  catName = other670.catName;
  validWriteIdList = other670.validWriteIdList;
  __isset = other670.__isset;
  return *this;
}
void AddPartitionsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddPartitionsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "parts=" << to_string(parts);
  out << ", " << "ifNotExists=" << to_string(ifNotExists);
  out << ", " << "needResult="; (__isset.needResult ? (out << to_string(needResult)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ")";
}


DropPartitionsResult::~DropPartitionsResult() noexcept {
}


void DropPartitionsResult::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
__isset.partitions = true;
}
std::ostream& operator<<(std::ostream& out, const DropPartitionsResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropPartitionsResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size671;
            ::apache::thrift::protocol::TType _etype674;
            xfer += iprot->readListBegin(_etype674, _size671);
            this->partitions.resize(_size671);
            uint32_t _i675;
            for (_i675 = 0; _i675 < _size671; ++_i675)
            {
              xfer += this->partitions[_i675].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DropPartitionsResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropPartitionsResult");

  if (this->__isset.partitions) {
    xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
      std::vector<Partition> ::const_iterator _iter676;
      for (_iter676 = this->partitions.begin(); _iter676 != this->partitions.end(); ++_iter676)
      {
        xfer += (*_iter676).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropPartitionsResult &a, DropPartitionsResult &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.__isset, b.__isset);
}

DropPartitionsResult::DropPartitionsResult(const DropPartitionsResult& other677) {
  partitions = other677.partitions;
  __isset = other677.__isset;
}
DropPartitionsResult& DropPartitionsResult::operator=(const DropPartitionsResult& other678) {
  partitions = other678.partitions;
  __isset = other678.__isset;
  return *this;
}
void DropPartitionsResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropPartitionsResult(";
  out << "partitions="; (__isset.partitions ? (out << to_string(partitions)) : (out << "<null>"));
  out << ")";
}


DropPartitionsExpr::~DropPartitionsExpr() noexcept {
}


void DropPartitionsExpr::__set_expr(const std::string& val) {
  this->expr = val;
}

void DropPartitionsExpr::__set_partArchiveLevel(const int32_t val) {
  this->partArchiveLevel = val;
__isset.partArchiveLevel = true;
}
std::ostream& operator<<(std::ostream& out, const DropPartitionsExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropPartitionsExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_expr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->expr);
          isset_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partArchiveLevel);
          this->__isset.partArchiveLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_expr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DropPartitionsExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropPartitionsExpr");

  xfer += oprot->writeFieldBegin("expr", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->expr);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partArchiveLevel) {
    xfer += oprot->writeFieldBegin("partArchiveLevel", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->partArchiveLevel);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropPartitionsExpr &a, DropPartitionsExpr &b) {
  using ::std::swap;
  swap(a.expr, b.expr);
  swap(a.partArchiveLevel, b.partArchiveLevel);
  swap(a.__isset, b.__isset);
}

DropPartitionsExpr::DropPartitionsExpr(const DropPartitionsExpr& other679) {
  expr = other679.expr;
  partArchiveLevel = other679.partArchiveLevel;
  __isset = other679.__isset;
}
DropPartitionsExpr& DropPartitionsExpr::operator=(const DropPartitionsExpr& other680) {
  expr = other680.expr;
  partArchiveLevel = other680.partArchiveLevel;
  __isset = other680.__isset;
  return *this;
}
void DropPartitionsExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropPartitionsExpr(";
  out << "expr=" << to_string(expr);
  out << ", " << "partArchiveLevel="; (__isset.partArchiveLevel ? (out << to_string(partArchiveLevel)) : (out << "<null>"));
  out << ")";
}


RequestPartsSpec::~RequestPartsSpec() noexcept {
}


void RequestPartsSpec::__set_names(const std::vector<std::string> & val) {
  this->names = val;
__isset.names = true;
}

void RequestPartsSpec::__set_exprs(const std::vector<DropPartitionsExpr> & val) {
  this->exprs = val;
__isset.exprs = true;
}
std::ostream& operator<<(std::ostream& out, const RequestPartsSpec& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RequestPartsSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size681;
            ::apache::thrift::protocol::TType _etype684;
            xfer += iprot->readListBegin(_etype684, _size681);
            this->names.resize(_size681);
            uint32_t _i685;
            for (_i685 = 0; _i685 < _size681; ++_i685)
            {
              xfer += iprot->readString(this->names[_i685]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->exprs.clear();
            uint32_t _size686;
            ::apache::thrift::protocol::TType _etype689;
            xfer += iprot->readListBegin(_etype689, _size686);
            this->exprs.resize(_size686);
            uint32_t _i690;
            for (_i690 = 0; _i690 < _size686; ++_i690)
            {
              xfer += this->exprs[_i690].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RequestPartsSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RequestPartsSpec");

  if (this->__isset.names) {
    xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->names.size()));
      std::vector<std::string> ::const_iterator _iter691;
      for (_iter691 = this->names.begin(); _iter691 != this->names.end(); ++_iter691)
      {
        xfer += oprot->writeString((*_iter691));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exprs) {
    xfer += oprot->writeFieldBegin("exprs", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->exprs.size()));
      std::vector<DropPartitionsExpr> ::const_iterator _iter692;
      for (_iter692 = this->exprs.begin(); _iter692 != this->exprs.end(); ++_iter692)
      {
        xfer += (*_iter692).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RequestPartsSpec &a, RequestPartsSpec &b) {
  using ::std::swap;
  swap(a.names, b.names);
  swap(a.exprs, b.exprs);
  swap(a.__isset, b.__isset);
}

RequestPartsSpec::RequestPartsSpec(const RequestPartsSpec& other693) {
  names = other693.names;
  exprs = other693.exprs;
  __isset = other693.__isset;
}
RequestPartsSpec& RequestPartsSpec::operator=(const RequestPartsSpec& other694) {
  names = other694.names;
  exprs = other694.exprs;
  __isset = other694.__isset;
  return *this;
}
void RequestPartsSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RequestPartsSpec(";
  out << "names="; (__isset.names ? (out << to_string(names)) : (out << "<null>"));
  out << ", " << "exprs="; (__isset.exprs ? (out << to_string(exprs)) : (out << "<null>"));
  out << ")";
}


DropPartitionsRequest::~DropPartitionsRequest() noexcept {
}


void DropPartitionsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void DropPartitionsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void DropPartitionsRequest::__set_parts(const RequestPartsSpec& val) {
  this->parts = val;
}

void DropPartitionsRequest::__set_deleteData(const bool val) {
  this->deleteData = val;
__isset.deleteData = true;
}

void DropPartitionsRequest::__set_ifExists(const bool val) {
  this->ifExists = val;
__isset.ifExists = true;
}

void DropPartitionsRequest::__set_ignoreProtection(const bool val) {
  this->ignoreProtection = val;
__isset.ignoreProtection = true;
}

void DropPartitionsRequest::__set_environmentContext(const EnvironmentContext& val) {
  this->environmentContext = val;
__isset.environmentContext = true;
}

void DropPartitionsRequest::__set_needResult(const bool val) {
  this->needResult = val;
__isset.needResult = true;
}

void DropPartitionsRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}
std::ostream& operator<<(std::ostream& out, const DropPartitionsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropPartitionsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_parts = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->parts.read(iprot);
          isset_parts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->deleteData);
          this->__isset.deleteData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ifExists);
          this->__isset.ifExists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ignoreProtection);
          this->__isset.ignoreProtection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->environmentContext.read(iprot);
          this->__isset.environmentContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->needResult);
          this->__isset.needResult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_parts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DropPartitionsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropPartitionsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parts", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->parts.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.deleteData) {
    xfer += oprot->writeFieldBegin("deleteData", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->deleteData);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ifExists) {
    xfer += oprot->writeFieldBegin("ifExists", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->ifExists);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ignoreProtection) {
    xfer += oprot->writeFieldBegin("ignoreProtection", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->ignoreProtection);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.environmentContext) {
    xfer += oprot->writeFieldBegin("environmentContext", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->environmentContext.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.needResult) {
    xfer += oprot->writeFieldBegin("needResult", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->needResult);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropPartitionsRequest &a, DropPartitionsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.parts, b.parts);
  swap(a.deleteData, b.deleteData);
  swap(a.ifExists, b.ifExists);
  swap(a.ignoreProtection, b.ignoreProtection);
  swap(a.environmentContext, b.environmentContext);
  swap(a.needResult, b.needResult);
  swap(a.catName, b.catName);
  swap(a.__isset, b.__isset);
}

DropPartitionsRequest::DropPartitionsRequest(const DropPartitionsRequest& other695) {
  dbName = other695.dbName;
  tblName = other695.tblName;
  parts = other695.parts;
  deleteData = other695.deleteData;
  ifExists = other695.ifExists;
  ignoreProtection = other695.ignoreProtection;
  environmentContext = other695.environmentContext;
  needResult = other695.needResult;
  catName = other695.catName;
  __isset = other695.__isset;
}
DropPartitionsRequest& DropPartitionsRequest::operator=(const DropPartitionsRequest& other696) {
  dbName = other696.dbName;
  tblName = other696.tblName;
  parts = other696.parts;
  deleteData = other696.deleteData;
  ifExists = other696.ifExists;
  ignoreProtection = other696.ignoreProtection;
  environmentContext = other696.environmentContext;
  needResult = other696.needResult;
  catName = other696.catName;
  __isset = other696.__isset;
  return *this;
}
void DropPartitionsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropPartitionsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "parts=" << to_string(parts);
  out << ", " << "deleteData="; (__isset.deleteData ? (out << to_string(deleteData)) : (out << "<null>"));
  out << ", " << "ifExists="; (__isset.ifExists ? (out << to_string(ifExists)) : (out << "<null>"));
  out << ", " << "ignoreProtection="; (__isset.ignoreProtection ? (out << to_string(ignoreProtection)) : (out << "<null>"));
  out << ", " << "environmentContext="; (__isset.environmentContext ? (out << to_string(environmentContext)) : (out << "<null>"));
  out << ", " << "needResult="; (__isset.needResult ? (out << to_string(needResult)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ")";
}


PartitionValuesRequest::~PartitionValuesRequest() noexcept {
}


void PartitionValuesRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void PartitionValuesRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void PartitionValuesRequest::__set_partitionKeys(const std::vector<FieldSchema> & val) {
  this->partitionKeys = val;
}

void PartitionValuesRequest::__set_applyDistinct(const bool val) {
  this->applyDistinct = val;
__isset.applyDistinct = true;
}

void PartitionValuesRequest::__set_filter(const std::string& val) {
  this->filter = val;
__isset.filter = true;
}

void PartitionValuesRequest::__set_partitionOrder(const std::vector<FieldSchema> & val) {
  this->partitionOrder = val;
__isset.partitionOrder = true;
}

void PartitionValuesRequest::__set_ascending(const bool val) {
  this->ascending = val;
__isset.ascending = true;
}

void PartitionValuesRequest::__set_maxParts(const int64_t val) {
  this->maxParts = val;
__isset.maxParts = true;
}

void PartitionValuesRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void PartitionValuesRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}
std::ostream& operator<<(std::ostream& out, const PartitionValuesRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionValuesRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_partitionKeys = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionKeys.clear();
            uint32_t _size697;
            ::apache::thrift::protocol::TType _etype700;
            xfer += iprot->readListBegin(_etype700, _size697);
            this->partitionKeys.resize(_size697);
            uint32_t _i701;
            for (_i701 = 0; _i701 < _size697; ++_i701)
            {
              xfer += this->partitionKeys[_i701].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitionKeys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->applyDistinct);
          this->__isset.applyDistinct = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->filter);
          this->__isset.filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionOrder.clear();
            uint32_t _size702;
            ::apache::thrift::protocol::TType _etype705;
            xfer += iprot->readListBegin(_etype705, _size702);
            this->partitionOrder.resize(_size702);
            uint32_t _i706;
            for (_i706 = 0; _i706 < _size702; ++_i706)
            {
              xfer += this->partitionOrder[_i706].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionOrder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ascending);
          this->__isset.ascending = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxParts);
          this->__isset.maxParts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partitionKeys)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionValuesRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionValuesRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitionKeys", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitionKeys.size()));
    std::vector<FieldSchema> ::const_iterator _iter707;
    for (_iter707 = this->partitionKeys.begin(); _iter707 != this->partitionKeys.end(); ++_iter707)
    {
      xfer += (*_iter707).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.applyDistinct) {
    xfer += oprot->writeFieldBegin("applyDistinct", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->applyDistinct);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filter) {
    xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->filter);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionOrder) {
    xfer += oprot->writeFieldBegin("partitionOrder", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitionOrder.size()));
      std::vector<FieldSchema> ::const_iterator _iter708;
      for (_iter708 = this->partitionOrder.begin(); _iter708 != this->partitionOrder.end(); ++_iter708)
      {
        xfer += (*_iter708).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ascending) {
    xfer += oprot->writeFieldBegin("ascending", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->ascending);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxParts) {
    xfer += oprot->writeFieldBegin("maxParts", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->maxParts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionValuesRequest &a, PartitionValuesRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.partitionKeys, b.partitionKeys);
  swap(a.applyDistinct, b.applyDistinct);
  swap(a.filter, b.filter);
  swap(a.partitionOrder, b.partitionOrder);
  swap(a.ascending, b.ascending);
  swap(a.maxParts, b.maxParts);
  swap(a.catName, b.catName);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.__isset, b.__isset);
}

PartitionValuesRequest::PartitionValuesRequest(const PartitionValuesRequest& other709) {
  dbName = other709.dbName;
  tblName = other709.tblName;
  partitionKeys = other709.partitionKeys;
  applyDistinct = other709.applyDistinct;
  filter = other709.filter;
  partitionOrder = other709.partitionOrder;
  ascending = other709.ascending;
  maxParts = other709.maxParts;
  catName = other709.catName;
  validWriteIdList = other709.validWriteIdList;
  __isset = other709.__isset;
}
PartitionValuesRequest& PartitionValuesRequest::operator=(const PartitionValuesRequest& other710) {
  dbName = other710.dbName;
  tblName = other710.tblName;
  partitionKeys = other710.partitionKeys;
  applyDistinct = other710.applyDistinct;
  filter = other710.filter;
  partitionOrder = other710.partitionOrder;
  ascending = other710.ascending;
  maxParts = other710.maxParts;
  catName = other710.catName;
  validWriteIdList = other710.validWriteIdList;
  __isset = other710.__isset;
  return *this;
}
void PartitionValuesRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionValuesRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "partitionKeys=" << to_string(partitionKeys);
  out << ", " << "applyDistinct="; (__isset.applyDistinct ? (out << to_string(applyDistinct)) : (out << "<null>"));
  out << ", " << "filter="; (__isset.filter ? (out << to_string(filter)) : (out << "<null>"));
  out << ", " << "partitionOrder="; (__isset.partitionOrder ? (out << to_string(partitionOrder)) : (out << "<null>"));
  out << ", " << "ascending="; (__isset.ascending ? (out << to_string(ascending)) : (out << "<null>"));
  out << ", " << "maxParts="; (__isset.maxParts ? (out << to_string(maxParts)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ")";
}


PartitionValuesRow::~PartitionValuesRow() noexcept {
}


void PartitionValuesRow::__set_row(const std::vector<std::string> & val) {
  this->row = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionValuesRow& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionValuesRow::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row.clear();
            uint32_t _size711;
            ::apache::thrift::protocol::TType _etype714;
            xfer += iprot->readListBegin(_etype714, _size711);
            this->row.resize(_size711);
            uint32_t _i715;
            for (_i715 = 0; _i715 < _size711; ++_i715)
            {
              xfer += iprot->readString(this->row[_i715]);
            }
            xfer += iprot->readListEnd();
          }
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionValuesRow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionValuesRow");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->row.size()));
    std::vector<std::string> ::const_iterator _iter716;
    for (_iter716 = this->row.begin(); _iter716 != this->row.end(); ++_iter716)
    {
      xfer += oprot->writeString((*_iter716));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionValuesRow &a, PartitionValuesRow &b) {
  using ::std::swap;
  swap(a.row, b.row);
}

PartitionValuesRow::PartitionValuesRow(const PartitionValuesRow& other717) {
  row = other717.row;
}
PartitionValuesRow& PartitionValuesRow::operator=(const PartitionValuesRow& other718) {
  row = other718.row;
  return *this;
}
void PartitionValuesRow::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionValuesRow(";
  out << "row=" << to_string(row);
  out << ")";
}


PartitionValuesResponse::~PartitionValuesResponse() noexcept {
}


void PartitionValuesResponse::__set_partitionValues(const std::vector<PartitionValuesRow> & val) {
  this->partitionValues = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionValuesResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionValuesResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partitionValues = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionValues.clear();
            uint32_t _size719;
            ::apache::thrift::protocol::TType _etype722;
            xfer += iprot->readListBegin(_etype722, _size719);
            this->partitionValues.resize(_size719);
            uint32_t _i723;
            for (_i723 = 0; _i723 < _size719; ++_i723)
            {
              xfer += this->partitionValues[_i723].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitionValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partitionValues)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionValuesResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionValuesResponse");

  xfer += oprot->writeFieldBegin("partitionValues", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitionValues.size()));
    std::vector<PartitionValuesRow> ::const_iterator _iter724;
    for (_iter724 = this->partitionValues.begin(); _iter724 != this->partitionValues.end(); ++_iter724)
    {
      xfer += (*_iter724).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionValuesResponse &a, PartitionValuesResponse &b) {
  using ::std::swap;
  swap(a.partitionValues, b.partitionValues);
}

PartitionValuesResponse::PartitionValuesResponse(const PartitionValuesResponse& other725) {
  partitionValues = other725.partitionValues;
}
PartitionValuesResponse& PartitionValuesResponse::operator=(const PartitionValuesResponse& other726) {
  partitionValues = other726.partitionValues;
  return *this;
}
void PartitionValuesResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionValuesResponse(";
  out << "partitionValues=" << to_string(partitionValues);
  out << ")";
}


GetPartitionsByNamesRequest::~GetPartitionsByNamesRequest() noexcept {
}


void GetPartitionsByNamesRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void GetPartitionsByNamesRequest::__set_tbl_name(const std::string& val) {
  this->tbl_name = val;
}

void GetPartitionsByNamesRequest::__set_names(const std::vector<std::string> & val) {
  this->names = val;
__isset.names = true;
}

void GetPartitionsByNamesRequest::__set_get_col_stats(const bool val) {
  this->get_col_stats = val;
__isset.get_col_stats = true;
}

void GetPartitionsByNamesRequest::__set_processorCapabilities(const std::vector<std::string> & val) {
  this->processorCapabilities = val;
__isset.processorCapabilities = true;
}

void GetPartitionsByNamesRequest::__set_processorIdentifier(const std::string& val) {
  this->processorIdentifier = val;
__isset.processorIdentifier = true;
}

void GetPartitionsByNamesRequest::__set_engine(const std::string& val) {
  this->engine = val;
__isset.engine = true;
}

void GetPartitionsByNamesRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void GetPartitionsByNamesRequest::__set_getFileMetadata(const bool val) {
  this->getFileMetadata = val;
__isset.getFileMetadata = true;
}

void GetPartitionsByNamesRequest::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionsByNamesRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionsByNamesRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db_name = false;
  bool isset_tbl_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbl_name);
          isset_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size727;
            ::apache::thrift::protocol::TType _etype730;
            xfer += iprot->readListBegin(_etype730, _size727);
            this->names.resize(_size727);
            uint32_t _i731;
            for (_i731 = 0; _i731 < _size727; ++_i731)
            {
              xfer += iprot->readString(this->names[_i731]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->get_col_stats);
          this->__isset.get_col_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->processorCapabilities.clear();
            uint32_t _size732;
            ::apache::thrift::protocol::TType _etype735;
            xfer += iprot->readListBegin(_etype735, _size732);
            this->processorCapabilities.resize(_size732);
            uint32_t _i736;
            for (_i736 = 0; _i736 < _size732; ++_i736)
            {
              xfer += iprot->readString(this->processorCapabilities[_i736]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.processorCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->processorIdentifier);
          this->__isset.processorIdentifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->engine);
          this->__isset.engine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->getFileMetadata);
          this->__isset.getFileMetadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tbl_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPartitionsByNamesRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionsByNamesRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tbl_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tbl_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.names) {
    xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->names.size()));
      std::vector<std::string> ::const_iterator _iter737;
      for (_iter737 = this->names.begin(); _iter737 != this->names.end(); ++_iter737)
      {
        xfer += oprot->writeString((*_iter737));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_col_stats) {
    xfer += oprot->writeFieldBegin("get_col_stats", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->get_col_stats);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorCapabilities) {
    xfer += oprot->writeFieldBegin("processorCapabilities", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->processorCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter738;
      for (_iter738 = this->processorCapabilities.begin(); _iter738 != this->processorCapabilities.end(); ++_iter738)
      {
        xfer += oprot->writeString((*_iter738));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorIdentifier) {
    xfer += oprot->writeFieldBegin("processorIdentifier", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->processorIdentifier);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.engine) {
    xfer += oprot->writeFieldBegin("engine", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->engine);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.getFileMetadata) {
    xfer += oprot->writeFieldBegin("getFileMetadata", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->getFileMetadata);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionsByNamesRequest &a, GetPartitionsByNamesRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.tbl_name, b.tbl_name);
  swap(a.names, b.names);
  swap(a.get_col_stats, b.get_col_stats);
  swap(a.processorCapabilities, b.processorCapabilities);
  swap(a.processorIdentifier, b.processorIdentifier);
  swap(a.engine, b.engine);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.getFileMetadata, b.getFileMetadata);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

GetPartitionsByNamesRequest::GetPartitionsByNamesRequest(const GetPartitionsByNamesRequest& other739) {
  db_name = other739.db_name;
  tbl_name = other739.tbl_name;
  names = other739.names;
  get_col_stats = other739.get_col_stats;
  processorCapabilities = other739.processorCapabilities;
  processorIdentifier = other739.processorIdentifier;
  engine = other739.engine;
  validWriteIdList = other739.validWriteIdList;
  getFileMetadata = other739.getFileMetadata;
  id = other739.id;
  __isset = other739.__isset;
}
GetPartitionsByNamesRequest& GetPartitionsByNamesRequest::operator=(const GetPartitionsByNamesRequest& other740) {
  db_name = other740.db_name;
  tbl_name = other740.tbl_name;
  names = other740.names;
  get_col_stats = other740.get_col_stats;
  processorCapabilities = other740.processorCapabilities;
  processorIdentifier = other740.processorIdentifier;
  engine = other740.engine;
  validWriteIdList = other740.validWriteIdList;
  getFileMetadata = other740.getFileMetadata;
  id = other740.id;
  __isset = other740.__isset;
  return *this;
}
void GetPartitionsByNamesRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionsByNamesRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "tbl_name=" << to_string(tbl_name);
  out << ", " << "names="; (__isset.names ? (out << to_string(names)) : (out << "<null>"));
  out << ", " << "get_col_stats="; (__isset.get_col_stats ? (out << to_string(get_col_stats)) : (out << "<null>"));
  out << ", " << "processorCapabilities="; (__isset.processorCapabilities ? (out << to_string(processorCapabilities)) : (out << "<null>"));
  out << ", " << "processorIdentifier="; (__isset.processorIdentifier ? (out << to_string(processorIdentifier)) : (out << "<null>"));
  out << ", " << "engine="; (__isset.engine ? (out << to_string(engine)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "getFileMetadata="; (__isset.getFileMetadata ? (out << to_string(getFileMetadata)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


GetPartitionsByNamesResult::~GetPartitionsByNamesResult() noexcept {
}


void GetPartitionsByNamesResult::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
}

void GetPartitionsByNamesResult::__set_dictionary(const ObjectDictionary& val) {
  this->dictionary = val;
__isset.dictionary = true;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionsByNamesResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionsByNamesResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partitions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size741;
            ::apache::thrift::protocol::TType _etype744;
            xfer += iprot->readListBegin(_etype744, _size741);
            this->partitions.resize(_size741);
            uint32_t _i745;
            for (_i745 = 0; _i745 < _size741; ++_i745)
            {
              xfer += this->partitions[_i745].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dictionary.read(iprot);
          this->__isset.dictionary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPartitionsByNamesResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionsByNamesResult");

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<Partition> ::const_iterator _iter746;
    for (_iter746 = this->partitions.begin(); _iter746 != this->partitions.end(); ++_iter746)
    {
      xfer += (*_iter746).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dictionary) {
    xfer += oprot->writeFieldBegin("dictionary", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->dictionary.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionsByNamesResult &a, GetPartitionsByNamesResult &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.dictionary, b.dictionary);
  swap(a.__isset, b.__isset);
}

GetPartitionsByNamesResult::GetPartitionsByNamesResult(const GetPartitionsByNamesResult& other747) {
  partitions = other747.partitions;
  dictionary = other747.dictionary;
  __isset = other747.__isset;
}
GetPartitionsByNamesResult& GetPartitionsByNamesResult::operator=(const GetPartitionsByNamesResult& other748) {
  partitions = other748.partitions;
  dictionary = other748.dictionary;
  __isset = other748.__isset;
  return *this;
}
void GetPartitionsByNamesResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionsByNamesResult(";
  out << "partitions=" << to_string(partitions);
  out << ", " << "dictionary="; (__isset.dictionary ? (out << to_string(dictionary)) : (out << "<null>"));
  out << ")";
}


DataConnector::~DataConnector() noexcept {
}


void DataConnector::__set_name(const std::string& val) {
  this->name = val;
}

void DataConnector::__set_type(const std::string& val) {
  this->type = val;
}

void DataConnector::__set_url(const std::string& val) {
  this->url = val;
}

void DataConnector::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void DataConnector::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
__isset.parameters = true;
}

void DataConnector::__set_ownerName(const std::string& val) {
  this->ownerName = val;
__isset.ownerName = true;
}

void DataConnector::__set_ownerType(const PrincipalType::type val) {
  this->ownerType = val;
__isset.ownerType = true;
}

void DataConnector::__set_createTime(const int32_t val) {
  this->createTime = val;
__isset.createTime = true;
}
std::ostream& operator<<(std::ostream& out, const DataConnector& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DataConnector::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size749;
            ::apache::thrift::protocol::TType _ktype750;
            ::apache::thrift::protocol::TType _vtype751;
            xfer += iprot->readMapBegin(_ktype750, _vtype751, _size749);
            uint32_t _i753;
            for (_i753 = 0; _i753 < _size749; ++_i753)
            {
              std::string _key754;
              xfer += iprot->readString(_key754);
              std::string& _val755 = this->parameters[_key754];
              xfer += iprot->readString(_val755);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast756;
          xfer += iprot->readI32(ecast756);
          this->ownerType = (PrincipalType::type)ecast756;
          this->__isset.ownerType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DataConnector::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DataConnector");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parameters) {
    xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
      std::map<std::string, std::string> ::const_iterator _iter757;
      for (_iter757 = this->parameters.begin(); _iter757 != this->parameters.end(); ++_iter757)
      {
        xfer += oprot->writeString(_iter757->first);
        xfer += oprot->writeString(_iter757->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ownerName) {
    xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->ownerName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ownerType) {
    xfer += oprot->writeFieldBegin("ownerType", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->ownerType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTime) {
    xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->createTime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DataConnector &a, DataConnector &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.url, b.url);
  swap(a.description, b.description);
  swap(a.parameters, b.parameters);
  swap(a.ownerName, b.ownerName);
  swap(a.ownerType, b.ownerType);
  swap(a.createTime, b.createTime);
  swap(a.__isset, b.__isset);
}

DataConnector::DataConnector(const DataConnector& other758) {
  name = other758.name;
  type = other758.type;
  url = other758.url;
  description = other758.description;
  parameters = other758.parameters;
  ownerName = other758.ownerName;
  ownerType = other758.ownerType;
  createTime = other758.createTime;
  __isset = other758.__isset;
}
DataConnector& DataConnector::operator=(const DataConnector& other759) {
  name = other759.name;
  type = other759.type;
  url = other759.url;
  description = other759.description;
  parameters = other759.parameters;
  ownerName = other759.ownerName;
  ownerType = other759.ownerType;
  createTime = other759.createTime;
  __isset = other759.__isset;
  return *this;
}
void DataConnector::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DataConnector(";
  out << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "url=" << to_string(url);
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "parameters="; (__isset.parameters ? (out << to_string(parameters)) : (out << "<null>"));
  out << ", " << "ownerName="; (__isset.ownerName ? (out << to_string(ownerName)) : (out << "<null>"));
  out << ", " << "ownerType="; (__isset.ownerType ? (out << to_string(ownerType)) : (out << "<null>"));
  out << ", " << "createTime="; (__isset.createTime ? (out << to_string(createTime)) : (out << "<null>"));
  out << ")";
}


ResourceUri::~ResourceUri() noexcept {
}


void ResourceUri::__set_resourceType(const ResourceType::type val) {
  this->resourceType = val;
}

void ResourceUri::__set_uri(const std::string& val) {
  this->uri = val;
}
std::ostream& operator<<(std::ostream& out, const ResourceUri& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResourceUri::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast760;
          xfer += iprot->readI32(ecast760);
          this->resourceType = (ResourceType::type)ecast760;
          this->__isset.resourceType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uri);
          this->__isset.uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ResourceUri::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResourceUri");

  xfer += oprot->writeFieldBegin("resourceType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->resourceType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uri", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->uri);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResourceUri &a, ResourceUri &b) {
  using ::std::swap;
  swap(a.resourceType, b.resourceType);
  swap(a.uri, b.uri);
  swap(a.__isset, b.__isset);
}

ResourceUri::ResourceUri(const ResourceUri& other761) {
  resourceType = other761.resourceType;
  uri = other761.uri;
  __isset = other761.__isset;
}
ResourceUri& ResourceUri::operator=(const ResourceUri& other762) {
  resourceType = other762.resourceType;
  uri = other762.uri;
  __isset = other762.__isset;
  return *this;
}
void ResourceUri::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResourceUri(";
  out << "resourceType=" << to_string(resourceType);
  out << ", " << "uri=" << to_string(uri);
  out << ")";
}


Function::~Function() noexcept {
}


void Function::__set_functionName(const std::string& val) {
  this->functionName = val;
}

void Function::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void Function::__set_className(const std::string& val) {
  this->className = val;
}

void Function::__set_ownerName(const std::string& val) {
  this->ownerName = val;
}

void Function::__set_ownerType(const PrincipalType::type val) {
  this->ownerType = val;
}

void Function::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void Function::__set_functionType(const FunctionType::type val) {
  this->functionType = val;
}

void Function::__set_resourceUris(const std::vector<ResourceUri> & val) {
  this->resourceUris = val;
}

void Function::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}
std::ostream& operator<<(std::ostream& out, const Function& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Function::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->functionName);
          this->__isset.functionName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->className);
          this->__isset.className = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast763;
          xfer += iprot->readI32(ecast763);
          this->ownerType = (PrincipalType::type)ecast763;
          this->__isset.ownerType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast764;
          xfer += iprot->readI32(ecast764);
          this->functionType = (FunctionType::type)ecast764;
          this->__isset.functionType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->resourceUris.clear();
            uint32_t _size765;
            ::apache::thrift::protocol::TType _etype768;
            xfer += iprot->readListBegin(_etype768, _size765);
            this->resourceUris.resize(_size765);
            uint32_t _i769;
            for (_i769 = 0; _i769 < _size765; ++_i769)
            {
              xfer += this->resourceUris[_i769].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.resourceUris = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Function::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Function");

  xfer += oprot->writeFieldBegin("functionName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->functionName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("className", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->className);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->ownerName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ownerType", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->ownerType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("functionType", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->functionType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resourceUris", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->resourceUris.size()));
    std::vector<ResourceUri> ::const_iterator _iter770;
    for (_iter770 = this->resourceUris.begin(); _iter770 != this->resourceUris.end(); ++_iter770)
    {
      xfer += (*_iter770).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Function &a, Function &b) {
  using ::std::swap;
  swap(a.functionName, b.functionName);
  swap(a.dbName, b.dbName);
  swap(a.className, b.className);
  swap(a.ownerName, b.ownerName);
  swap(a.ownerType, b.ownerType);
  swap(a.createTime, b.createTime);
  swap(a.functionType, b.functionType);
  swap(a.resourceUris, b.resourceUris);
  swap(a.catName, b.catName);
  swap(a.__isset, b.__isset);
}

Function::Function(const Function& other771) {
  functionName = other771.functionName;
  dbName = other771.dbName;
  className = other771.className;
  ownerName = other771.ownerName;
  ownerType = other771.ownerType;
  createTime = other771.createTime;
  functionType = other771.functionType;
  resourceUris = other771.resourceUris;
  catName = other771.catName;
  __isset = other771.__isset;
}
Function& Function::operator=(const Function& other772) {
  functionName = other772.functionName;
  dbName = other772.dbName;
  className = other772.className;
  ownerName = other772.ownerName;
  ownerType = other772.ownerType;
  createTime = other772.createTime;
  functionType = other772.functionType;
  resourceUris = other772.resourceUris;
  catName = other772.catName;
  __isset = other772.__isset;
  return *this;
}
void Function::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Function(";
  out << "functionName=" << to_string(functionName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "className=" << to_string(className);
  out << ", " << "ownerName=" << to_string(ownerName);
  out << ", " << "ownerType=" << to_string(ownerType);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "functionType=" << to_string(functionType);
  out << ", " << "resourceUris=" << to_string(resourceUris);
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ")";
}


TxnInfo::~TxnInfo() noexcept {
}


void TxnInfo::__set_id(const int64_t val) {
  this->id = val;
}

void TxnInfo::__set_state(const TxnState::type val) {
  this->state = val;
}

void TxnInfo::__set_user(const std::string& val) {
  this->user = val;
}

void TxnInfo::__set_hostname(const std::string& val) {
  this->hostname = val;
}

void TxnInfo::__set_agentInfo(const std::string& val) {
  this->agentInfo = val;
__isset.agentInfo = true;
}

void TxnInfo::__set_heartbeatCount(const int32_t val) {
  this->heartbeatCount = val;
__isset.heartbeatCount = true;
}

void TxnInfo::__set_metaInfo(const std::string& val) {
  this->metaInfo = val;
__isset.metaInfo = true;
}

void TxnInfo::__set_startedTime(const int64_t val) {
  this->startedTime = val;
__isset.startedTime = true;
}

void TxnInfo::__set_lastHeartbeatTime(const int64_t val) {
  this->lastHeartbeatTime = val;
__isset.lastHeartbeatTime = true;
}
std::ostream& operator<<(std::ostream& out, const TxnInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TxnInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_state = false;
  bool isset_user = false;
  bool isset_hostname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast773;
          xfer += iprot->readI32(ecast773);
          this->state = (TxnState::type)ecast773;
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          isset_hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agentInfo);
          this->__isset.agentInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->heartbeatCount);
          this->__isset.heartbeatCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metaInfo);
          this->__isset.metaInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startedTime);
          this->__isset.startedTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastHeartbeatTime);
          this->__isset.lastHeartbeatTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hostname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TxnInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TxnInfo");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.agentInfo) {
    xfer += oprot->writeFieldBegin("agentInfo", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->agentInfo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.heartbeatCount) {
    xfer += oprot->writeFieldBegin("heartbeatCount", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->heartbeatCount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.metaInfo) {
    xfer += oprot->writeFieldBegin("metaInfo", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->metaInfo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.startedTime) {
    xfer += oprot->writeFieldBegin("startedTime", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->startedTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastHeartbeatTime) {
    xfer += oprot->writeFieldBegin("lastHeartbeatTime", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->lastHeartbeatTime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TxnInfo &a, TxnInfo &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.state, b.state);
  swap(a.user, b.user);
  swap(a.hostname, b.hostname);
  swap(a.agentInfo, b.agentInfo);
  swap(a.heartbeatCount, b.heartbeatCount);
  swap(a.metaInfo, b.metaInfo);
  swap(a.startedTime, b.startedTime);
  swap(a.lastHeartbeatTime, b.lastHeartbeatTime);
  swap(a.__isset, b.__isset);
}

TxnInfo::TxnInfo(const TxnInfo& other774) {
  id = other774.id;
  state = other774.state;
  user = other774.user;
  hostname = other774.hostname;
  agentInfo = other774.agentInfo;
  heartbeatCount = other774.heartbeatCount;
  metaInfo = other774.metaInfo;
  startedTime = other774.startedTime;
  lastHeartbeatTime = other774.lastHeartbeatTime;
  __isset = other774.__isset;
}
TxnInfo& TxnInfo::operator=(const TxnInfo& other775) {
  id = other775.id;
  state = other775.state;
  user = other775.user;
  hostname = other775.hostname;
  agentInfo = other775.agentInfo;
  heartbeatCount = other775.heartbeatCount;
  metaInfo = other775.metaInfo;
  startedTime = other775.startedTime;
  lastHeartbeatTime = other775.lastHeartbeatTime;
  __isset = other775.__isset;
  return *this;
}
void TxnInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TxnInfo(";
  out << "id=" << to_string(id);
  out << ", " << "state=" << to_string(state);
  out << ", " << "user=" << to_string(user);
  out << ", " << "hostname=" << to_string(hostname);
  out << ", " << "agentInfo="; (__isset.agentInfo ? (out << to_string(agentInfo)) : (out << "<null>"));
  out << ", " << "heartbeatCount="; (__isset.heartbeatCount ? (out << to_string(heartbeatCount)) : (out << "<null>"));
  out << ", " << "metaInfo="; (__isset.metaInfo ? (out << to_string(metaInfo)) : (out << "<null>"));
  out << ", " << "startedTime="; (__isset.startedTime ? (out << to_string(startedTime)) : (out << "<null>"));
  out << ", " << "lastHeartbeatTime="; (__isset.lastHeartbeatTime ? (out << to_string(lastHeartbeatTime)) : (out << "<null>"));
  out << ")";
}


GetOpenTxnsInfoResponse::~GetOpenTxnsInfoResponse() noexcept {
}


void GetOpenTxnsInfoResponse::__set_txn_high_water_mark(const int64_t val) {
  this->txn_high_water_mark = val;
}

void GetOpenTxnsInfoResponse::__set_open_txns(const std::vector<TxnInfo> & val) {
  this->open_txns = val;
}
std::ostream& operator<<(std::ostream& out, const GetOpenTxnsInfoResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetOpenTxnsInfoResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txn_high_water_mark = false;
  bool isset_open_txns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txn_high_water_mark);
          isset_txn_high_water_mark = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->open_txns.clear();
            uint32_t _size776;
            ::apache::thrift::protocol::TType _etype779;
            xfer += iprot->readListBegin(_etype779, _size776);
            this->open_txns.resize(_size776);
            uint32_t _i780;
            for (_i780 = 0; _i780 < _size776; ++_i780)
            {
              xfer += this->open_txns[_i780].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_open_txns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txn_high_water_mark)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_open_txns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetOpenTxnsInfoResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetOpenTxnsInfoResponse");

  xfer += oprot->writeFieldBegin("txn_high_water_mark", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txn_high_water_mark);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("open_txns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->open_txns.size()));
    std::vector<TxnInfo> ::const_iterator _iter781;
    for (_iter781 = this->open_txns.begin(); _iter781 != this->open_txns.end(); ++_iter781)
    {
      xfer += (*_iter781).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetOpenTxnsInfoResponse &a, GetOpenTxnsInfoResponse &b) {
  using ::std::swap;
  swap(a.txn_high_water_mark, b.txn_high_water_mark);
  swap(a.open_txns, b.open_txns);
}

GetOpenTxnsInfoResponse::GetOpenTxnsInfoResponse(const GetOpenTxnsInfoResponse& other782) {
  txn_high_water_mark = other782.txn_high_water_mark;
  open_txns = other782.open_txns;
}
GetOpenTxnsInfoResponse& GetOpenTxnsInfoResponse::operator=(const GetOpenTxnsInfoResponse& other783) {
  txn_high_water_mark = other783.txn_high_water_mark;
  open_txns = other783.open_txns;
  return *this;
}
void GetOpenTxnsInfoResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetOpenTxnsInfoResponse(";
  out << "txn_high_water_mark=" << to_string(txn_high_water_mark);
  out << ", " << "open_txns=" << to_string(open_txns);
  out << ")";
}


GetOpenTxnsResponse::~GetOpenTxnsResponse() noexcept {
}


void GetOpenTxnsResponse::__set_txn_high_water_mark(const int64_t val) {
  this->txn_high_water_mark = val;
}

void GetOpenTxnsResponse::__set_open_txns(const std::vector<int64_t> & val) {
  this->open_txns = val;
}

void GetOpenTxnsResponse::__set_min_open_txn(const int64_t val) {
  this->min_open_txn = val;
__isset.min_open_txn = true;
}

void GetOpenTxnsResponse::__set_abortedBits(const std::string& val) {
  this->abortedBits = val;
}
std::ostream& operator<<(std::ostream& out, const GetOpenTxnsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetOpenTxnsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txn_high_water_mark = false;
  bool isset_open_txns = false;
  bool isset_abortedBits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txn_high_water_mark);
          isset_txn_high_water_mark = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->open_txns.clear();
            uint32_t _size784;
            ::apache::thrift::protocol::TType _etype787;
            xfer += iprot->readListBegin(_etype787, _size784);
            this->open_txns.resize(_size784);
            uint32_t _i788;
            for (_i788 = 0; _i788 < _size784; ++_i788)
            {
              xfer += iprot->readI64(this->open_txns[_i788]);
            }
            xfer += iprot->readListEnd();
          }
          isset_open_txns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->min_open_txn);
          this->__isset.min_open_txn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->abortedBits);
          isset_abortedBits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txn_high_water_mark)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_open_txns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_abortedBits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetOpenTxnsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetOpenTxnsResponse");

  xfer += oprot->writeFieldBegin("txn_high_water_mark", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txn_high_water_mark);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("open_txns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->open_txns.size()));
    std::vector<int64_t> ::const_iterator _iter789;
    for (_iter789 = this->open_txns.begin(); _iter789 != this->open_txns.end(); ++_iter789)
    {
      xfer += oprot->writeI64((*_iter789));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.min_open_txn) {
    xfer += oprot->writeFieldBegin("min_open_txn", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->min_open_txn);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("abortedBits", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->abortedBits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetOpenTxnsResponse &a, GetOpenTxnsResponse &b) {
  using ::std::swap;
  swap(a.txn_high_water_mark, b.txn_high_water_mark);
  swap(a.open_txns, b.open_txns);
  swap(a.min_open_txn, b.min_open_txn);
  swap(a.abortedBits, b.abortedBits);
  swap(a.__isset, b.__isset);
}

GetOpenTxnsResponse::GetOpenTxnsResponse(const GetOpenTxnsResponse& other790) {
  txn_high_water_mark = other790.txn_high_water_mark;
  open_txns = other790.open_txns;
  min_open_txn = other790.min_open_txn;
  abortedBits = other790.abortedBits;
  __isset = other790.__isset;
}
GetOpenTxnsResponse& GetOpenTxnsResponse::operator=(const GetOpenTxnsResponse& other791) {
  txn_high_water_mark = other791.txn_high_water_mark;
  open_txns = other791.open_txns;
  min_open_txn = other791.min_open_txn;
  abortedBits = other791.abortedBits;
  __isset = other791.__isset;
  return *this;
}
void GetOpenTxnsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetOpenTxnsResponse(";
  out << "txn_high_water_mark=" << to_string(txn_high_water_mark);
  out << ", " << "open_txns=" << to_string(open_txns);
  out << ", " << "min_open_txn="; (__isset.min_open_txn ? (out << to_string(min_open_txn)) : (out << "<null>"));
  out << ", " << "abortedBits=" << to_string(abortedBits);
  out << ")";
}


OpenTxnRequest::~OpenTxnRequest() noexcept {
}


void OpenTxnRequest::__set_num_txns(const int32_t val) {
  this->num_txns = val;
}

void OpenTxnRequest::__set_user(const std::string& val) {
  this->user = val;
}

void OpenTxnRequest::__set_hostname(const std::string& val) {
  this->hostname = val;
}

void OpenTxnRequest::__set_agentInfo(const std::string& val) {
  this->agentInfo = val;
__isset.agentInfo = true;
}

void OpenTxnRequest::__set_replPolicy(const std::string& val) {
  this->replPolicy = val;
__isset.replPolicy = true;
}

void OpenTxnRequest::__set_replSrcTxnIds(const std::vector<int64_t> & val) {
  this->replSrcTxnIds = val;
__isset.replSrcTxnIds = true;
}

void OpenTxnRequest::__set_txn_type(const TxnType::type val) {
  this->txn_type = val;
__isset.txn_type = true;
}
std::ostream& operator<<(std::ostream& out, const OpenTxnRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t OpenTxnRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_num_txns = false;
  bool isset_user = false;
  bool isset_hostname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_txns);
          isset_num_txns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          isset_hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agentInfo);
          this->__isset.agentInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replPolicy);
          this->__isset.replPolicy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->replSrcTxnIds.clear();
            uint32_t _size792;
            ::apache::thrift::protocol::TType _etype795;
            xfer += iprot->readListBegin(_etype795, _size792);
            this->replSrcTxnIds.resize(_size792);
            uint32_t _i796;
            for (_i796 = 0; _i796 < _size792; ++_i796)
            {
              xfer += iprot->readI64(this->replSrcTxnIds[_i796]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.replSrcTxnIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast797;
          xfer += iprot->readI32(ecast797);
          this->txn_type = (TxnType::type)ecast797;
          this->__isset.txn_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_num_txns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hostname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t OpenTxnRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OpenTxnRequest");

  xfer += oprot->writeFieldBegin("num_txns", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->num_txns);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.agentInfo) {
    xfer += oprot->writeFieldBegin("agentInfo", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->agentInfo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replPolicy) {
    xfer += oprot->writeFieldBegin("replPolicy", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->replPolicy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replSrcTxnIds) {
    xfer += oprot->writeFieldBegin("replSrcTxnIds", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->replSrcTxnIds.size()));
      std::vector<int64_t> ::const_iterator _iter798;
      for (_iter798 = this->replSrcTxnIds.begin(); _iter798 != this->replSrcTxnIds.end(); ++_iter798)
      {
        xfer += oprot->writeI64((*_iter798));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.txn_type) {
    xfer += oprot->writeFieldBegin("txn_type", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->txn_type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OpenTxnRequest &a, OpenTxnRequest &b) {
  using ::std::swap;
  swap(a.num_txns, b.num_txns);
  swap(a.user, b.user);
  swap(a.hostname, b.hostname);
  swap(a.agentInfo, b.agentInfo);
  swap(a.replPolicy, b.replPolicy);
  swap(a.replSrcTxnIds, b.replSrcTxnIds);
  swap(a.txn_type, b.txn_type);
  swap(a.__isset, b.__isset);
}

OpenTxnRequest::OpenTxnRequest(const OpenTxnRequest& other799) {
  num_txns = other799.num_txns;
  user = other799.user;
  hostname = other799.hostname;
  agentInfo = other799.agentInfo;
  replPolicy = other799.replPolicy;
  replSrcTxnIds = other799.replSrcTxnIds;
  txn_type = other799.txn_type;
  __isset = other799.__isset;
}
OpenTxnRequest& OpenTxnRequest::operator=(const OpenTxnRequest& other800) {
  num_txns = other800.num_txns;
  user = other800.user;
  hostname = other800.hostname;
  agentInfo = other800.agentInfo;
  replPolicy = other800.replPolicy;
  replSrcTxnIds = other800.replSrcTxnIds;
  txn_type = other800.txn_type;
  __isset = other800.__isset;
  return *this;
}
void OpenTxnRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OpenTxnRequest(";
  out << "num_txns=" << to_string(num_txns);
  out << ", " << "user=" << to_string(user);
  out << ", " << "hostname=" << to_string(hostname);
  out << ", " << "agentInfo="; (__isset.agentInfo ? (out << to_string(agentInfo)) : (out << "<null>"));
  out << ", " << "replPolicy="; (__isset.replPolicy ? (out << to_string(replPolicy)) : (out << "<null>"));
  out << ", " << "replSrcTxnIds="; (__isset.replSrcTxnIds ? (out << to_string(replSrcTxnIds)) : (out << "<null>"));
  out << ", " << "txn_type="; (__isset.txn_type ? (out << to_string(txn_type)) : (out << "<null>"));
  out << ")";
}


OpenTxnsResponse::~OpenTxnsResponse() noexcept {
}


void OpenTxnsResponse::__set_txn_ids(const std::vector<int64_t> & val) {
  this->txn_ids = val;
}
std::ostream& operator<<(std::ostream& out, const OpenTxnsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t OpenTxnsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txn_ids = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->txn_ids.clear();
            uint32_t _size801;
            ::apache::thrift::protocol::TType _etype804;
            xfer += iprot->readListBegin(_etype804, _size801);
            this->txn_ids.resize(_size801);
            uint32_t _i805;
            for (_i805 = 0; _i805 < _size801; ++_i805)
            {
              xfer += iprot->readI64(this->txn_ids[_i805]);
            }
            xfer += iprot->readListEnd();
          }
          isset_txn_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txn_ids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t OpenTxnsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OpenTxnsResponse");

  xfer += oprot->writeFieldBegin("txn_ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->txn_ids.size()));
    std::vector<int64_t> ::const_iterator _iter806;
    for (_iter806 = this->txn_ids.begin(); _iter806 != this->txn_ids.end(); ++_iter806)
    {
      xfer += oprot->writeI64((*_iter806));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OpenTxnsResponse &a, OpenTxnsResponse &b) {
  using ::std::swap;
  swap(a.txn_ids, b.txn_ids);
}

OpenTxnsResponse::OpenTxnsResponse(const OpenTxnsResponse& other807) {
  txn_ids = other807.txn_ids;
}
OpenTxnsResponse& OpenTxnsResponse::operator=(const OpenTxnsResponse& other808) {
  txn_ids = other808.txn_ids;
  return *this;
}
void OpenTxnsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OpenTxnsResponse(";
  out << "txn_ids=" << to_string(txn_ids);
  out << ")";
}


AbortTxnRequest::~AbortTxnRequest() noexcept {
}


void AbortTxnRequest::__set_txnid(const int64_t val) {
  this->txnid = val;
}

void AbortTxnRequest::__set_replPolicy(const std::string& val) {
  this->replPolicy = val;
__isset.replPolicy = true;
}

void AbortTxnRequest::__set_txn_type(const TxnType::type val) {
  this->txn_type = val;
__isset.txn_type = true;
}
std::ostream& operator<<(std::ostream& out, const AbortTxnRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AbortTxnRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txnid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          isset_txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replPolicy);
          this->__isset.replPolicy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast809;
          xfer += iprot->readI32(ecast809);
          this->txn_type = (TxnType::type)ecast809;
          this->__isset.txn_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txnid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AbortTxnRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AbortTxnRequest");

  xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txnid);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.replPolicy) {
    xfer += oprot->writeFieldBegin("replPolicy", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->replPolicy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.txn_type) {
    xfer += oprot->writeFieldBegin("txn_type", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->txn_type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AbortTxnRequest &a, AbortTxnRequest &b) {
  using ::std::swap;
  swap(a.txnid, b.txnid);
  swap(a.replPolicy, b.replPolicy);
  swap(a.txn_type, b.txn_type);
  swap(a.__isset, b.__isset);
}

AbortTxnRequest::AbortTxnRequest(const AbortTxnRequest& other810) {
  txnid = other810.txnid;
  replPolicy = other810.replPolicy;
  txn_type = other810.txn_type;
  __isset = other810.__isset;
}
AbortTxnRequest& AbortTxnRequest::operator=(const AbortTxnRequest& other811) {
  txnid = other811.txnid;
  replPolicy = other811.replPolicy;
  txn_type = other811.txn_type;
  __isset = other811.__isset;
  return *this;
}
void AbortTxnRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AbortTxnRequest(";
  out << "txnid=" << to_string(txnid);
  out << ", " << "replPolicy="; (__isset.replPolicy ? (out << to_string(replPolicy)) : (out << "<null>"));
  out << ", " << "txn_type="; (__isset.txn_type ? (out << to_string(txn_type)) : (out << "<null>"));
  out << ")";
}


AbortTxnsRequest::~AbortTxnsRequest() noexcept {
}


void AbortTxnsRequest::__set_txn_ids(const std::vector<int64_t> & val) {
  this->txn_ids = val;
}
std::ostream& operator<<(std::ostream& out, const AbortTxnsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AbortTxnsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txn_ids = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->txn_ids.clear();
            uint32_t _size812;
            ::apache::thrift::protocol::TType _etype815;
            xfer += iprot->readListBegin(_etype815, _size812);
            this->txn_ids.resize(_size812);
            uint32_t _i816;
            for (_i816 = 0; _i816 < _size812; ++_i816)
            {
              xfer += iprot->readI64(this->txn_ids[_i816]);
            }
            xfer += iprot->readListEnd();
          }
          isset_txn_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txn_ids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AbortTxnsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AbortTxnsRequest");

  xfer += oprot->writeFieldBegin("txn_ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->txn_ids.size()));
    std::vector<int64_t> ::const_iterator _iter817;
    for (_iter817 = this->txn_ids.begin(); _iter817 != this->txn_ids.end(); ++_iter817)
    {
      xfer += oprot->writeI64((*_iter817));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AbortTxnsRequest &a, AbortTxnsRequest &b) {
  using ::std::swap;
  swap(a.txn_ids, b.txn_ids);
}

AbortTxnsRequest::AbortTxnsRequest(const AbortTxnsRequest& other818) {
  txn_ids = other818.txn_ids;
}
AbortTxnsRequest& AbortTxnsRequest::operator=(const AbortTxnsRequest& other819) {
  txn_ids = other819.txn_ids;
  return *this;
}
void AbortTxnsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AbortTxnsRequest(";
  out << "txn_ids=" << to_string(txn_ids);
  out << ")";
}


CommitTxnKeyValue::~CommitTxnKeyValue() noexcept {
}


void CommitTxnKeyValue::__set_tableId(const int64_t val) {
  this->tableId = val;
}

void CommitTxnKeyValue::__set_key(const std::string& val) {
  this->key = val;
}

void CommitTxnKeyValue::__set_value(const std::string& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const CommitTxnKeyValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CommitTxnKeyValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tableId = false;
  bool isset_key = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tableId);
          isset_tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          isset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tableId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CommitTxnKeyValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CommitTxnKeyValue");

  xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tableId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CommitTxnKeyValue &a, CommitTxnKeyValue &b) {
  using ::std::swap;
  swap(a.tableId, b.tableId);
  swap(a.key, b.key);
  swap(a.value, b.value);
}

CommitTxnKeyValue::CommitTxnKeyValue(const CommitTxnKeyValue& other820) {
  tableId = other820.tableId;
  key = other820.key;
  value = other820.value;
}
CommitTxnKeyValue& CommitTxnKeyValue::operator=(const CommitTxnKeyValue& other821) {
  tableId = other821.tableId;
  key = other821.key;
  value = other821.value;
  return *this;
}
void CommitTxnKeyValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CommitTxnKeyValue(";
  out << "tableId=" << to_string(tableId);
  out << ", " << "key=" << to_string(key);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


WriteEventInfo::~WriteEventInfo() noexcept {
}


void WriteEventInfo::__set_writeId(const int64_t val) {
  this->writeId = val;
}

void WriteEventInfo::__set_database(const std::string& val) {
  this->database = val;
}

void WriteEventInfo::__set_table(const std::string& val) {
  this->table = val;
}

void WriteEventInfo::__set_files(const std::string& val) {
  this->files = val;
}

void WriteEventInfo::__set_partition(const std::string& val) {
  this->partition = val;
__isset.partition = true;
}

void WriteEventInfo::__set_tableObj(const std::string& val) {
  this->tableObj = val;
__isset.tableObj = true;
}

void WriteEventInfo::__set_partitionObj(const std::string& val) {
  this->partitionObj = val;
__isset.partitionObj = true;
}
std::ostream& operator<<(std::ostream& out, const WriteEventInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WriteEventInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_writeId = false;
  bool isset_database = false;
  bool isset_table = false;
  bool isset_files = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          isset_writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->database);
          isset_database = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table);
          isset_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->files);
          isset_files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partition);
          this->__isset.partition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableObj);
          this->__isset.tableObj = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partitionObj);
          this->__isset.partitionObj = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_writeId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_database)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_files)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WriteEventInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WriteEventInfo");

  xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->writeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("database", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->database);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("files", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->files);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition) {
    xfer += oprot->writeFieldBegin("partition", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->partition);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableObj) {
    xfer += oprot->writeFieldBegin("tableObj", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->tableObj);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionObj) {
    xfer += oprot->writeFieldBegin("partitionObj", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->partitionObj);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WriteEventInfo &a, WriteEventInfo &b) {
  using ::std::swap;
  swap(a.writeId, b.writeId);
  swap(a.database, b.database);
  swap(a.table, b.table);
  swap(a.files, b.files);
  swap(a.partition, b.partition);
  swap(a.tableObj, b.tableObj);
  swap(a.partitionObj, b.partitionObj);
  swap(a.__isset, b.__isset);
}

WriteEventInfo::WriteEventInfo(const WriteEventInfo& other822) {
  writeId = other822.writeId;
  database = other822.database;
  table = other822.table;
  files = other822.files;
  partition = other822.partition;
  tableObj = other822.tableObj;
  partitionObj = other822.partitionObj;
  __isset = other822.__isset;
}
WriteEventInfo& WriteEventInfo::operator=(const WriteEventInfo& other823) {
  writeId = other823.writeId;
  database = other823.database;
  table = other823.table;
  files = other823.files;
  partition = other823.partition;
  tableObj = other823.tableObj;
  partitionObj = other823.partitionObj;
  __isset = other823.__isset;
  return *this;
}
void WriteEventInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WriteEventInfo(";
  out << "writeId=" << to_string(writeId);
  out << ", " << "database=" << to_string(database);
  out << ", " << "table=" << to_string(table);
  out << ", " << "files=" << to_string(files);
  out << ", " << "partition="; (__isset.partition ? (out << to_string(partition)) : (out << "<null>"));
  out << ", " << "tableObj="; (__isset.tableObj ? (out << to_string(tableObj)) : (out << "<null>"));
  out << ", " << "partitionObj="; (__isset.partitionObj ? (out << to_string(partitionObj)) : (out << "<null>"));
  out << ")";
}


ReplLastIdInfo::~ReplLastIdInfo() noexcept {
}


void ReplLastIdInfo::__set_database(const std::string& val) {
  this->database = val;
}

void ReplLastIdInfo::__set_lastReplId(const int64_t val) {
  this->lastReplId = val;
}

void ReplLastIdInfo::__set_table(const std::string& val) {
  this->table = val;
__isset.table = true;
}

void ReplLastIdInfo::__set_catalog(const std::string& val) {
  this->catalog = val;
__isset.catalog = true;
}

void ReplLastIdInfo::__set_partitionList(const std::vector<std::string> & val) {
  this->partitionList = val;
__isset.partitionList = true;
}
std::ostream& operator<<(std::ostream& out, const ReplLastIdInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ReplLastIdInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_database = false;
  bool isset_lastReplId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->database);
          isset_database = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastReplId);
          isset_lastReplId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table);
          this->__isset.table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalog);
          this->__isset.catalog = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionList.clear();
            uint32_t _size824;
            ::apache::thrift::protocol::TType _etype827;
            xfer += iprot->readListBegin(_etype827, _size824);
            this->partitionList.resize(_size824);
            uint32_t _i828;
            for (_i828 = 0; _i828 < _size824; ++_i828)
            {
              xfer += iprot->readString(this->partitionList[_i828]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_database)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_lastReplId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ReplLastIdInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ReplLastIdInfo");

  xfer += oprot->writeFieldBegin("database", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->database);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastReplId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->lastReplId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.table) {
    xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->table);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalog) {
    xfer += oprot->writeFieldBegin("catalog", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->catalog);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionList) {
    xfer += oprot->writeFieldBegin("partitionList", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partitionList.size()));
      std::vector<std::string> ::const_iterator _iter829;
      for (_iter829 = this->partitionList.begin(); _iter829 != this->partitionList.end(); ++_iter829)
      {
        xfer += oprot->writeString((*_iter829));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReplLastIdInfo &a, ReplLastIdInfo &b) {
  using ::std::swap;
  swap(a.database, b.database);
  swap(a.lastReplId, b.lastReplId);
  swap(a.table, b.table);
  swap(a.catalog, b.catalog);
  swap(a.partitionList, b.partitionList);
  swap(a.__isset, b.__isset);
}

ReplLastIdInfo::ReplLastIdInfo(const ReplLastIdInfo& other830) {
  database = other830.database;
  lastReplId = other830.lastReplId;
  table = other830.table;
  catalog = other830.catalog;
  partitionList = other830.partitionList;
  __isset = other830.__isset;
}
ReplLastIdInfo& ReplLastIdInfo::operator=(const ReplLastIdInfo& other831) {
  database = other831.database;
  lastReplId = other831.lastReplId;
  table = other831.table;
  catalog = other831.catalog;
  partitionList = other831.partitionList;
  __isset = other831.__isset;
  return *this;
}
void ReplLastIdInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ReplLastIdInfo(";
  out << "database=" << to_string(database);
  out << ", " << "lastReplId=" << to_string(lastReplId);
  out << ", " << "table="; (__isset.table ? (out << to_string(table)) : (out << "<null>"));
  out << ", " << "catalog="; (__isset.catalog ? (out << to_string(catalog)) : (out << "<null>"));
  out << ", " << "partitionList="; (__isset.partitionList ? (out << to_string(partitionList)) : (out << "<null>"));
  out << ")";
}


CommitTxnRequest::~CommitTxnRequest() noexcept {
}


void CommitTxnRequest::__set_txnid(const int64_t val) {
  this->txnid = val;
}

void CommitTxnRequest::__set_replPolicy(const std::string& val) {
  this->replPolicy = val;
__isset.replPolicy = true;
}

void CommitTxnRequest::__set_writeEventInfos(const std::vector<WriteEventInfo> & val) {
  this->writeEventInfos = val;
__isset.writeEventInfos = true;
}

void CommitTxnRequest::__set_replLastIdInfo(const ReplLastIdInfo& val) {
  this->replLastIdInfo = val;
__isset.replLastIdInfo = true;
}

void CommitTxnRequest::__set_keyValue(const CommitTxnKeyValue& val) {
  this->keyValue = val;
__isset.keyValue = true;
}

void CommitTxnRequest::__set_exclWriteEnabled(const bool val) {
  this->exclWriteEnabled = val;
__isset.exclWriteEnabled = true;
}

void CommitTxnRequest::__set_txn_type(const TxnType::type val) {
  this->txn_type = val;
__isset.txn_type = true;
}
std::ostream& operator<<(std::ostream& out, const CommitTxnRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CommitTxnRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txnid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          isset_txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replPolicy);
          this->__isset.replPolicy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->writeEventInfos.clear();
            uint32_t _size832;
            ::apache::thrift::protocol::TType _etype835;
            xfer += iprot->readListBegin(_etype835, _size832);
            this->writeEventInfos.resize(_size832);
            uint32_t _i836;
            for (_i836 = 0; _i836 < _size832; ++_i836)
            {
              xfer += this->writeEventInfos[_i836].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.writeEventInfos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->replLastIdInfo.read(iprot);
          this->__isset.replLastIdInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->keyValue.read(iprot);
          this->__isset.keyValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->exclWriteEnabled);
          this->__isset.exclWriteEnabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast837;
          xfer += iprot->readI32(ecast837);
          this->txn_type = (TxnType::type)ecast837;
          this->__isset.txn_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txnid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CommitTxnRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CommitTxnRequest");

  xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txnid);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.replPolicy) {
    xfer += oprot->writeFieldBegin("replPolicy", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->replPolicy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writeEventInfos) {
    xfer += oprot->writeFieldBegin("writeEventInfos", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->writeEventInfos.size()));
      std::vector<WriteEventInfo> ::const_iterator _iter838;
      for (_iter838 = this->writeEventInfos.begin(); _iter838 != this->writeEventInfos.end(); ++_iter838)
      {
        xfer += (*_iter838).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replLastIdInfo) {
    xfer += oprot->writeFieldBegin("replLastIdInfo", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->replLastIdInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.keyValue) {
    xfer += oprot->writeFieldBegin("keyValue", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->keyValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exclWriteEnabled) {
    xfer += oprot->writeFieldBegin("exclWriteEnabled", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->exclWriteEnabled);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.txn_type) {
    xfer += oprot->writeFieldBegin("txn_type", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->txn_type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CommitTxnRequest &a, CommitTxnRequest &b) {
  using ::std::swap;
  swap(a.txnid, b.txnid);
  swap(a.replPolicy, b.replPolicy);
  swap(a.writeEventInfos, b.writeEventInfos);
  swap(a.replLastIdInfo, b.replLastIdInfo);
  swap(a.keyValue, b.keyValue);
  swap(a.exclWriteEnabled, b.exclWriteEnabled);
  swap(a.txn_type, b.txn_type);
  swap(a.__isset, b.__isset);
}

CommitTxnRequest::CommitTxnRequest(const CommitTxnRequest& other839) {
  txnid = other839.txnid;
  replPolicy = other839.replPolicy;
  writeEventInfos = other839.writeEventInfos;
  replLastIdInfo = other839.replLastIdInfo;
  keyValue = other839.keyValue;
  exclWriteEnabled = other839.exclWriteEnabled;
  txn_type = other839.txn_type;
  __isset = other839.__isset;
}
CommitTxnRequest& CommitTxnRequest::operator=(const CommitTxnRequest& other840) {
  txnid = other840.txnid;
  replPolicy = other840.replPolicy;
  writeEventInfos = other840.writeEventInfos;
  replLastIdInfo = other840.replLastIdInfo;
  keyValue = other840.keyValue;
  exclWriteEnabled = other840.exclWriteEnabled;
  txn_type = other840.txn_type;
  __isset = other840.__isset;
  return *this;
}
void CommitTxnRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CommitTxnRequest(";
  out << "txnid=" << to_string(txnid);
  out << ", " << "replPolicy="; (__isset.replPolicy ? (out << to_string(replPolicy)) : (out << "<null>"));
  out << ", " << "writeEventInfos="; (__isset.writeEventInfos ? (out << to_string(writeEventInfos)) : (out << "<null>"));
  out << ", " << "replLastIdInfo="; (__isset.replLastIdInfo ? (out << to_string(replLastIdInfo)) : (out << "<null>"));
  out << ", " << "keyValue="; (__isset.keyValue ? (out << to_string(keyValue)) : (out << "<null>"));
  out << ", " << "exclWriteEnabled="; (__isset.exclWriteEnabled ? (out << to_string(exclWriteEnabled)) : (out << "<null>"));
  out << ", " << "txn_type="; (__isset.txn_type ? (out << to_string(txn_type)) : (out << "<null>"));
  out << ")";
}


ReplTblWriteIdStateRequest::~ReplTblWriteIdStateRequest() noexcept {
}


void ReplTblWriteIdStateRequest::__set_validWriteIdlist(const std::string& val) {
  this->validWriteIdlist = val;
}

void ReplTblWriteIdStateRequest::__set_user(const std::string& val) {
  this->user = val;
}

void ReplTblWriteIdStateRequest::__set_hostName(const std::string& val) {
  this->hostName = val;
}

void ReplTblWriteIdStateRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void ReplTblWriteIdStateRequest::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void ReplTblWriteIdStateRequest::__set_partNames(const std::vector<std::string> & val) {
  this->partNames = val;
__isset.partNames = true;
}
std::ostream& operator<<(std::ostream& out, const ReplTblWriteIdStateRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ReplTblWriteIdStateRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_validWriteIdlist = false;
  bool isset_user = false;
  bool isset_hostName = false;
  bool isset_dbName = false;
  bool isset_tableName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdlist);
          isset_validWriteIdlist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostName);
          isset_hostName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partNames.clear();
            uint32_t _size841;
            ::apache::thrift::protocol::TType _etype844;
            xfer += iprot->readListBegin(_etype844, _size841);
            this->partNames.resize(_size841);
            uint32_t _i845;
            for (_i845 = 0; _i845 < _size841; ++_i845)
            {
              xfer += iprot->readString(this->partNames[_i845]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_validWriteIdlist)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hostName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ReplTblWriteIdStateRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ReplTblWriteIdStateRequest");

  xfer += oprot->writeFieldBegin("validWriteIdlist", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->validWriteIdlist);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->hostName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partNames) {
    xfer += oprot->writeFieldBegin("partNames", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partNames.size()));
      std::vector<std::string> ::const_iterator _iter846;
      for (_iter846 = this->partNames.begin(); _iter846 != this->partNames.end(); ++_iter846)
      {
        xfer += oprot->writeString((*_iter846));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReplTblWriteIdStateRequest &a, ReplTblWriteIdStateRequest &b) {
  using ::std::swap;
  swap(a.validWriteIdlist, b.validWriteIdlist);
  swap(a.user, b.user);
  swap(a.hostName, b.hostName);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.partNames, b.partNames);
  swap(a.__isset, b.__isset);
}

ReplTblWriteIdStateRequest::ReplTblWriteIdStateRequest(const ReplTblWriteIdStateRequest& other847) {
  validWriteIdlist = other847.validWriteIdlist;
  user = other847.user;
  hostName = other847.hostName;
  dbName = other847.dbName;
  tableName = other847.tableName;
  partNames = other847.partNames;
  __isset = other847.__isset;
}
ReplTblWriteIdStateRequest& ReplTblWriteIdStateRequest::operator=(const ReplTblWriteIdStateRequest& other848) {
  validWriteIdlist = other848.validWriteIdlist;
  user = other848.user;
  hostName = other848.hostName;
  dbName = other848.dbName;
  tableName = other848.tableName;
  partNames = other848.partNames;
  __isset = other848.__isset;
  return *this;
}
void ReplTblWriteIdStateRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ReplTblWriteIdStateRequest(";
  out << "validWriteIdlist=" << to_string(validWriteIdlist);
  out << ", " << "user=" << to_string(user);
  out << ", " << "hostName=" << to_string(hostName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "partNames="; (__isset.partNames ? (out << to_string(partNames)) : (out << "<null>"));
  out << ")";
}


GetValidWriteIdsRequest::~GetValidWriteIdsRequest() noexcept {
}


void GetValidWriteIdsRequest::__set_fullTableNames(const std::vector<std::string> & val) {
  this->fullTableNames = val;
}

void GetValidWriteIdsRequest::__set_validTxnList(const std::string& val) {
  this->validTxnList = val;
__isset.validTxnList = true;
}

void GetValidWriteIdsRequest::__set_writeId(const int64_t val) {
  this->writeId = val;
__isset.writeId = true;
}
std::ostream& operator<<(std::ostream& out, const GetValidWriteIdsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetValidWriteIdsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fullTableNames = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fullTableNames.clear();
            uint32_t _size849;
            ::apache::thrift::protocol::TType _etype852;
            xfer += iprot->readListBegin(_etype852, _size849);
            this->fullTableNames.resize(_size849);
            uint32_t _i853;
            for (_i853 = 0; _i853 < _size849; ++_i853)
            {
              xfer += iprot->readString(this->fullTableNames[_i853]);
            }
            xfer += iprot->readListEnd();
          }
          isset_fullTableNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validTxnList);
          this->__isset.validTxnList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          this->__isset.writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fullTableNames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetValidWriteIdsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetValidWriteIdsRequest");

  xfer += oprot->writeFieldBegin("fullTableNames", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fullTableNames.size()));
    std::vector<std::string> ::const_iterator _iter854;
    for (_iter854 = this->fullTableNames.begin(); _iter854 != this->fullTableNames.end(); ++_iter854)
    {
      xfer += oprot->writeString((*_iter854));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.validTxnList) {
    xfer += oprot->writeFieldBegin("validTxnList", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->validTxnList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writeId) {
    xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->writeId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetValidWriteIdsRequest &a, GetValidWriteIdsRequest &b) {
  using ::std::swap;
  swap(a.fullTableNames, b.fullTableNames);
  swap(a.validTxnList, b.validTxnList);
  swap(a.writeId, b.writeId);
  swap(a.__isset, b.__isset);
}

GetValidWriteIdsRequest::GetValidWriteIdsRequest(const GetValidWriteIdsRequest& other855) {
  fullTableNames = other855.fullTableNames;
  validTxnList = other855.validTxnList;
  writeId = other855.writeId;
  __isset = other855.__isset;
}
GetValidWriteIdsRequest& GetValidWriteIdsRequest::operator=(const GetValidWriteIdsRequest& other856) {
  fullTableNames = other856.fullTableNames;
  validTxnList = other856.validTxnList;
  writeId = other856.writeId;
  __isset = other856.__isset;
  return *this;
}
void GetValidWriteIdsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetValidWriteIdsRequest(";
  out << "fullTableNames=" << to_string(fullTableNames);
  out << ", " << "validTxnList="; (__isset.validTxnList ? (out << to_string(validTxnList)) : (out << "<null>"));
  out << ", " << "writeId="; (__isset.writeId ? (out << to_string(writeId)) : (out << "<null>"));
  out << ")";
}


TableValidWriteIds::~TableValidWriteIds() noexcept {
}


void TableValidWriteIds::__set_fullTableName(const std::string& val) {
  this->fullTableName = val;
}

void TableValidWriteIds::__set_writeIdHighWaterMark(const int64_t val) {
  this->writeIdHighWaterMark = val;
}

void TableValidWriteIds::__set_invalidWriteIds(const std::vector<int64_t> & val) {
  this->invalidWriteIds = val;
}

void TableValidWriteIds::__set_minOpenWriteId(const int64_t val) {
  this->minOpenWriteId = val;
__isset.minOpenWriteId = true;
}

void TableValidWriteIds::__set_abortedBits(const std::string& val) {
  this->abortedBits = val;
}
std::ostream& operator<<(std::ostream& out, const TableValidWriteIds& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TableValidWriteIds::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fullTableName = false;
  bool isset_writeIdHighWaterMark = false;
  bool isset_invalidWriteIds = false;
  bool isset_abortedBits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fullTableName);
          isset_fullTableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeIdHighWaterMark);
          isset_writeIdHighWaterMark = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->invalidWriteIds.clear();
            uint32_t _size857;
            ::apache::thrift::protocol::TType _etype860;
            xfer += iprot->readListBegin(_etype860, _size857);
            this->invalidWriteIds.resize(_size857);
            uint32_t _i861;
            for (_i861 = 0; _i861 < _size857; ++_i861)
            {
              xfer += iprot->readI64(this->invalidWriteIds[_i861]);
            }
            xfer += iprot->readListEnd();
          }
          isset_invalidWriteIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->minOpenWriteId);
          this->__isset.minOpenWriteId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->abortedBits);
          isset_abortedBits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fullTableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_writeIdHighWaterMark)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_invalidWriteIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_abortedBits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TableValidWriteIds::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TableValidWriteIds");

  xfer += oprot->writeFieldBegin("fullTableName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->fullTableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("writeIdHighWaterMark", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->writeIdHighWaterMark);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("invalidWriteIds", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->invalidWriteIds.size()));
    std::vector<int64_t> ::const_iterator _iter862;
    for (_iter862 = this->invalidWriteIds.begin(); _iter862 != this->invalidWriteIds.end(); ++_iter862)
    {
      xfer += oprot->writeI64((*_iter862));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.minOpenWriteId) {
    xfer += oprot->writeFieldBegin("minOpenWriteId", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->minOpenWriteId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("abortedBits", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->abortedBits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableValidWriteIds &a, TableValidWriteIds &b) {
  using ::std::swap;
  swap(a.fullTableName, b.fullTableName);
  swap(a.writeIdHighWaterMark, b.writeIdHighWaterMark);
  swap(a.invalidWriteIds, b.invalidWriteIds);
  swap(a.minOpenWriteId, b.minOpenWriteId);
  swap(a.abortedBits, b.abortedBits);
  swap(a.__isset, b.__isset);
}

TableValidWriteIds::TableValidWriteIds(const TableValidWriteIds& other863) {
  fullTableName = other863.fullTableName;
  writeIdHighWaterMark = other863.writeIdHighWaterMark;
  invalidWriteIds = other863.invalidWriteIds;
  minOpenWriteId = other863.minOpenWriteId;
  abortedBits = other863.abortedBits;
  __isset = other863.__isset;
}
TableValidWriteIds& TableValidWriteIds::operator=(const TableValidWriteIds& other864) {
  fullTableName = other864.fullTableName;
  writeIdHighWaterMark = other864.writeIdHighWaterMark;
  invalidWriteIds = other864.invalidWriteIds;
  minOpenWriteId = other864.minOpenWriteId;
  abortedBits = other864.abortedBits;
  __isset = other864.__isset;
  return *this;
}
void TableValidWriteIds::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TableValidWriteIds(";
  out << "fullTableName=" << to_string(fullTableName);
  out << ", " << "writeIdHighWaterMark=" << to_string(writeIdHighWaterMark);
  out << ", " << "invalidWriteIds=" << to_string(invalidWriteIds);
  out << ", " << "minOpenWriteId="; (__isset.minOpenWriteId ? (out << to_string(minOpenWriteId)) : (out << "<null>"));
  out << ", " << "abortedBits=" << to_string(abortedBits);
  out << ")";
}


GetValidWriteIdsResponse::~GetValidWriteIdsResponse() noexcept {
}


void GetValidWriteIdsResponse::__set_tblValidWriteIds(const std::vector<TableValidWriteIds> & val) {
  this->tblValidWriteIds = val;
}
std::ostream& operator<<(std::ostream& out, const GetValidWriteIdsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetValidWriteIdsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tblValidWriteIds = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tblValidWriteIds.clear();
            uint32_t _size865;
            ::apache::thrift::protocol::TType _etype868;
            xfer += iprot->readListBegin(_etype868, _size865);
            this->tblValidWriteIds.resize(_size865);
            uint32_t _i869;
            for (_i869 = 0; _i869 < _size865; ++_i869)
            {
              xfer += this->tblValidWriteIds[_i869].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_tblValidWriteIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tblValidWriteIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetValidWriteIdsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetValidWriteIdsResponse");

  xfer += oprot->writeFieldBegin("tblValidWriteIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tblValidWriteIds.size()));
    std::vector<TableValidWriteIds> ::const_iterator _iter870;
    for (_iter870 = this->tblValidWriteIds.begin(); _iter870 != this->tblValidWriteIds.end(); ++_iter870)
    {
      xfer += (*_iter870).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetValidWriteIdsResponse &a, GetValidWriteIdsResponse &b) {
  using ::std::swap;
  swap(a.tblValidWriteIds, b.tblValidWriteIds);
}

GetValidWriteIdsResponse::GetValidWriteIdsResponse(const GetValidWriteIdsResponse& other871) {
  tblValidWriteIds = other871.tblValidWriteIds;
}
GetValidWriteIdsResponse& GetValidWriteIdsResponse::operator=(const GetValidWriteIdsResponse& other872) {
  tblValidWriteIds = other872.tblValidWriteIds;
  return *this;
}
void GetValidWriteIdsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetValidWriteIdsResponse(";
  out << "tblValidWriteIds=" << to_string(tblValidWriteIds);
  out << ")";
}


TxnToWriteId::~TxnToWriteId() noexcept {
}


void TxnToWriteId::__set_txnId(const int64_t val) {
  this->txnId = val;
}

void TxnToWriteId::__set_writeId(const int64_t val) {
  this->writeId = val;
}
std::ostream& operator<<(std::ostream& out, const TxnToWriteId& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TxnToWriteId::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txnId = false;
  bool isset_writeId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnId);
          isset_txnId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          isset_writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txnId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_writeId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TxnToWriteId::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TxnToWriteId");

  xfer += oprot->writeFieldBegin("txnId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txnId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->writeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TxnToWriteId &a, TxnToWriteId &b) {
  using ::std::swap;
  swap(a.txnId, b.txnId);
  swap(a.writeId, b.writeId);
}

TxnToWriteId::TxnToWriteId(const TxnToWriteId& other873) {
  txnId = other873.txnId;
  writeId = other873.writeId;
}
TxnToWriteId& TxnToWriteId::operator=(const TxnToWriteId& other874) {
  txnId = other874.txnId;
  writeId = other874.writeId;
  return *this;
}
void TxnToWriteId::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TxnToWriteId(";
  out << "txnId=" << to_string(txnId);
  out << ", " << "writeId=" << to_string(writeId);
  out << ")";
}


AllocateTableWriteIdsRequest::~AllocateTableWriteIdsRequest() noexcept {
}


void AllocateTableWriteIdsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void AllocateTableWriteIdsRequest::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void AllocateTableWriteIdsRequest::__set_txnIds(const std::vector<int64_t> & val) {
  this->txnIds = val;
__isset.txnIds = true;
}

void AllocateTableWriteIdsRequest::__set_replPolicy(const std::string& val) {
  this->replPolicy = val;
__isset.replPolicy = true;
}

void AllocateTableWriteIdsRequest::__set_srcTxnToWriteIdList(const std::vector<TxnToWriteId> & val) {
  this->srcTxnToWriteIdList = val;
__isset.srcTxnToWriteIdList = true;
}
std::ostream& operator<<(std::ostream& out, const AllocateTableWriteIdsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AllocateTableWriteIdsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tableName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->txnIds.clear();
            uint32_t _size875;
            ::apache::thrift::protocol::TType _etype878;
            xfer += iprot->readListBegin(_etype878, _size875);
            this->txnIds.resize(_size875);
            uint32_t _i879;
            for (_i879 = 0; _i879 < _size875; ++_i879)
            {
              xfer += iprot->readI64(this->txnIds[_i879]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.txnIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replPolicy);
          this->__isset.replPolicy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->srcTxnToWriteIdList.clear();
            uint32_t _size880;
            ::apache::thrift::protocol::TType _etype883;
            xfer += iprot->readListBegin(_etype883, _size880);
            this->srcTxnToWriteIdList.resize(_size880);
            uint32_t _i884;
            for (_i884 = 0; _i884 < _size880; ++_i884)
            {
              xfer += this->srcTxnToWriteIdList[_i884].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.srcTxnToWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AllocateTableWriteIdsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AllocateTableWriteIdsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.txnIds) {
    xfer += oprot->writeFieldBegin("txnIds", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->txnIds.size()));
      std::vector<int64_t> ::const_iterator _iter885;
      for (_iter885 = this->txnIds.begin(); _iter885 != this->txnIds.end(); ++_iter885)
      {
        xfer += oprot->writeI64((*_iter885));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replPolicy) {
    xfer += oprot->writeFieldBegin("replPolicy", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->replPolicy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.srcTxnToWriteIdList) {
    xfer += oprot->writeFieldBegin("srcTxnToWriteIdList", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->srcTxnToWriteIdList.size()));
      std::vector<TxnToWriteId> ::const_iterator _iter886;
      for (_iter886 = this->srcTxnToWriteIdList.begin(); _iter886 != this->srcTxnToWriteIdList.end(); ++_iter886)
      {
        xfer += (*_iter886).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AllocateTableWriteIdsRequest &a, AllocateTableWriteIdsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.txnIds, b.txnIds);
  swap(a.replPolicy, b.replPolicy);
  swap(a.srcTxnToWriteIdList, b.srcTxnToWriteIdList);
  swap(a.__isset, b.__isset);
}

AllocateTableWriteIdsRequest::AllocateTableWriteIdsRequest(const AllocateTableWriteIdsRequest& other887) {
  dbName = other887.dbName;
  tableName = other887.tableName;
  txnIds = other887.txnIds;
  replPolicy = other887.replPolicy;
  srcTxnToWriteIdList = other887.srcTxnToWriteIdList;
  __isset = other887.__isset;
}
AllocateTableWriteIdsRequest& AllocateTableWriteIdsRequest::operator=(const AllocateTableWriteIdsRequest& other888) {
  dbName = other888.dbName;
  tableName = other888.tableName;
  txnIds = other888.txnIds;
  replPolicy = other888.replPolicy;
  srcTxnToWriteIdList = other888.srcTxnToWriteIdList;
  __isset = other888.__isset;
  return *this;
}
void AllocateTableWriteIdsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AllocateTableWriteIdsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "txnIds="; (__isset.txnIds ? (out << to_string(txnIds)) : (out << "<null>"));
  out << ", " << "replPolicy="; (__isset.replPolicy ? (out << to_string(replPolicy)) : (out << "<null>"));
  out << ", " << "srcTxnToWriteIdList="; (__isset.srcTxnToWriteIdList ? (out << to_string(srcTxnToWriteIdList)) : (out << "<null>"));
  out << ")";
}


AllocateTableWriteIdsResponse::~AllocateTableWriteIdsResponse() noexcept {
}


void AllocateTableWriteIdsResponse::__set_txnToWriteIds(const std::vector<TxnToWriteId> & val) {
  this->txnToWriteIds = val;
}
std::ostream& operator<<(std::ostream& out, const AllocateTableWriteIdsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AllocateTableWriteIdsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txnToWriteIds = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->txnToWriteIds.clear();
            uint32_t _size889;
            ::apache::thrift::protocol::TType _etype892;
            xfer += iprot->readListBegin(_etype892, _size889);
            this->txnToWriteIds.resize(_size889);
            uint32_t _i893;
            for (_i893 = 0; _i893 < _size889; ++_i893)
            {
              xfer += this->txnToWriteIds[_i893].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_txnToWriteIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txnToWriteIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AllocateTableWriteIdsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AllocateTableWriteIdsResponse");

  xfer += oprot->writeFieldBegin("txnToWriteIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->txnToWriteIds.size()));
    std::vector<TxnToWriteId> ::const_iterator _iter894;
    for (_iter894 = this->txnToWriteIds.begin(); _iter894 != this->txnToWriteIds.end(); ++_iter894)
    {
      xfer += (*_iter894).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AllocateTableWriteIdsResponse &a, AllocateTableWriteIdsResponse &b) {
  using ::std::swap;
  swap(a.txnToWriteIds, b.txnToWriteIds);
}

AllocateTableWriteIdsResponse::AllocateTableWriteIdsResponse(const AllocateTableWriteIdsResponse& other895) {
  txnToWriteIds = other895.txnToWriteIds;
}
AllocateTableWriteIdsResponse& AllocateTableWriteIdsResponse::operator=(const AllocateTableWriteIdsResponse& other896) {
  txnToWriteIds = other896.txnToWriteIds;
  return *this;
}
void AllocateTableWriteIdsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AllocateTableWriteIdsResponse(";
  out << "txnToWriteIds=" << to_string(txnToWriteIds);
  out << ")";
}


MaxAllocatedTableWriteIdRequest::~MaxAllocatedTableWriteIdRequest() noexcept {
}


void MaxAllocatedTableWriteIdRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void MaxAllocatedTableWriteIdRequest::__set_tableName(const std::string& val) {
  this->tableName = val;
}
std::ostream& operator<<(std::ostream& out, const MaxAllocatedTableWriteIdRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MaxAllocatedTableWriteIdRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tableName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MaxAllocatedTableWriteIdRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MaxAllocatedTableWriteIdRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MaxAllocatedTableWriteIdRequest &a, MaxAllocatedTableWriteIdRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
}

MaxAllocatedTableWriteIdRequest::MaxAllocatedTableWriteIdRequest(const MaxAllocatedTableWriteIdRequest& other897) {
  dbName = other897.dbName;
  tableName = other897.tableName;
}
MaxAllocatedTableWriteIdRequest& MaxAllocatedTableWriteIdRequest::operator=(const MaxAllocatedTableWriteIdRequest& other898) {
  dbName = other898.dbName;
  tableName = other898.tableName;
  return *this;
}
void MaxAllocatedTableWriteIdRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MaxAllocatedTableWriteIdRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ")";
}


MaxAllocatedTableWriteIdResponse::~MaxAllocatedTableWriteIdResponse() noexcept {
}


void MaxAllocatedTableWriteIdResponse::__set_maxWriteId(const int64_t val) {
  this->maxWriteId = val;
}
std::ostream& operator<<(std::ostream& out, const MaxAllocatedTableWriteIdResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MaxAllocatedTableWriteIdResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_maxWriteId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxWriteId);
          isset_maxWriteId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_maxWriteId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MaxAllocatedTableWriteIdResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MaxAllocatedTableWriteIdResponse");

  xfer += oprot->writeFieldBegin("maxWriteId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->maxWriteId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MaxAllocatedTableWriteIdResponse &a, MaxAllocatedTableWriteIdResponse &b) {
  using ::std::swap;
  swap(a.maxWriteId, b.maxWriteId);
}

MaxAllocatedTableWriteIdResponse::MaxAllocatedTableWriteIdResponse(const MaxAllocatedTableWriteIdResponse& other899) {
  maxWriteId = other899.maxWriteId;
}
MaxAllocatedTableWriteIdResponse& MaxAllocatedTableWriteIdResponse::operator=(const MaxAllocatedTableWriteIdResponse& other900) {
  maxWriteId = other900.maxWriteId;
  return *this;
}
void MaxAllocatedTableWriteIdResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MaxAllocatedTableWriteIdResponse(";
  out << "maxWriteId=" << to_string(maxWriteId);
  out << ")";
}


SeedTableWriteIdsRequest::~SeedTableWriteIdsRequest() noexcept {
}


void SeedTableWriteIdsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void SeedTableWriteIdsRequest::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void SeedTableWriteIdsRequest::__set_seedWriteId(const int64_t val) {
  this->seedWriteId = val;
}
std::ostream& operator<<(std::ostream& out, const SeedTableWriteIdsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SeedTableWriteIdsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tableName = false;
  bool isset_seedWriteId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->seedWriteId);
          isset_seedWriteId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_seedWriteId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SeedTableWriteIdsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SeedTableWriteIdsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("seedWriteId", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->seedWriteId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SeedTableWriteIdsRequest &a, SeedTableWriteIdsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.seedWriteId, b.seedWriteId);
}

SeedTableWriteIdsRequest::SeedTableWriteIdsRequest(const SeedTableWriteIdsRequest& other901) {
  dbName = other901.dbName;
  tableName = other901.tableName;
  seedWriteId = other901.seedWriteId;
}
SeedTableWriteIdsRequest& SeedTableWriteIdsRequest::operator=(const SeedTableWriteIdsRequest& other902) {
  dbName = other902.dbName;
  tableName = other902.tableName;
  seedWriteId = other902.seedWriteId;
  return *this;
}
void SeedTableWriteIdsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SeedTableWriteIdsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "seedWriteId=" << to_string(seedWriteId);
  out << ")";
}


SeedTxnIdRequest::~SeedTxnIdRequest() noexcept {
}


void SeedTxnIdRequest::__set_seedTxnId(const int64_t val) {
  this->seedTxnId = val;
}
std::ostream& operator<<(std::ostream& out, const SeedTxnIdRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SeedTxnIdRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_seedTxnId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->seedTxnId);
          isset_seedTxnId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_seedTxnId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SeedTxnIdRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SeedTxnIdRequest");

  xfer += oprot->writeFieldBegin("seedTxnId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->seedTxnId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SeedTxnIdRequest &a, SeedTxnIdRequest &b) {
  using ::std::swap;
  swap(a.seedTxnId, b.seedTxnId);
}

SeedTxnIdRequest::SeedTxnIdRequest(const SeedTxnIdRequest& other903) {
  seedTxnId = other903.seedTxnId;
}
SeedTxnIdRequest& SeedTxnIdRequest::operator=(const SeedTxnIdRequest& other904) {
  seedTxnId = other904.seedTxnId;
  return *this;
}
void SeedTxnIdRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SeedTxnIdRequest(";
  out << "seedTxnId=" << to_string(seedTxnId);
  out << ")";
}


LockComponent::~LockComponent() noexcept {
}


void LockComponent::__set_type(const LockType::type val) {
  this->type = val;
}

void LockComponent::__set_level(const LockLevel::type val) {
  this->level = val;
}

void LockComponent::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void LockComponent::__set_tablename(const std::string& val) {
  this->tablename = val;
__isset.tablename = true;
}

void LockComponent::__set_partitionname(const std::string& val) {
  this->partitionname = val;
__isset.partitionname = true;
}

void LockComponent::__set_operationType(const DataOperationType::type val) {
  this->operationType = val;
__isset.operationType = true;
}

void LockComponent::__set_isTransactional(const bool val) {
  this->isTransactional = val;
__isset.isTransactional = true;
}

void LockComponent::__set_isDynamicPartitionWrite(const bool val) {
  this->isDynamicPartitionWrite = val;
__isset.isDynamicPartitionWrite = true;
}
std::ostream& operator<<(std::ostream& out, const LockComponent& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LockComponent::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;
  bool isset_level = false;
  bool isset_dbname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast905;
          xfer += iprot->readI32(ecast905);
          this->type = (LockType::type)ecast905;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast906;
          xfer += iprot->readI32(ecast906);
          this->level = (LockLevel::type)ecast906;
          isset_level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          this->__isset.tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partitionname);
          this->__isset.partitionname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast907;
          xfer += iprot->readI32(ecast907);
          this->operationType = (DataOperationType::type)ecast907;
          this->__isset.operationType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isTransactional);
          this->__isset.isTransactional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isDynamicPartitionWrite);
          this->__isset.isDynamicPartitionWrite = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_level)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LockComponent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LockComponent");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tablename) {
    xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->tablename);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionname) {
    xfer += oprot->writeFieldBegin("partitionname", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->partitionname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.operationType) {
    xfer += oprot->writeFieldBegin("operationType", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->operationType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isTransactional) {
    xfer += oprot->writeFieldBegin("isTransactional", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->isTransactional);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isDynamicPartitionWrite) {
    xfer += oprot->writeFieldBegin("isDynamicPartitionWrite", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->isDynamicPartitionWrite);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LockComponent &a, LockComponent &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.level, b.level);
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionname, b.partitionname);
  swap(a.operationType, b.operationType);
  swap(a.isTransactional, b.isTransactional);
  swap(a.isDynamicPartitionWrite, b.isDynamicPartitionWrite);
  swap(a.__isset, b.__isset);
}

LockComponent::LockComponent(const LockComponent& other908) {
  type = other908.type;
  level = other908.level;
  dbname = other908.dbname;
  tablename = other908.tablename;
  partitionname = other908.partitionname;
  operationType = other908.operationType;
  isTransactional = other908.isTransactional;
  isDynamicPartitionWrite = other908.isDynamicPartitionWrite;
  __isset = other908.__isset;
}
LockComponent& LockComponent::operator=(const LockComponent& other909) {
  type = other909.type;
  level = other909.level;
  dbname = other909.dbname;
  tablename = other909.tablename;
  partitionname = other909.partitionname;
  operationType = other909.operationType;
  isTransactional = other909.isTransactional;
  isDynamicPartitionWrite = other909.isDynamicPartitionWrite;
  __isset = other909.__isset;
  return *this;
}
void LockComponent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LockComponent(";
  out << "type=" << to_string(type);
  out << ", " << "level=" << to_string(level);
  out << ", " << "dbname=" << to_string(dbname);
  out << ", " << "tablename="; (__isset.tablename ? (out << to_string(tablename)) : (out << "<null>"));
  out << ", " << "partitionname="; (__isset.partitionname ? (out << to_string(partitionname)) : (out << "<null>"));
  out << ", " << "operationType="; (__isset.operationType ? (out << to_string(operationType)) : (out << "<null>"));
  out << ", " << "isTransactional="; (__isset.isTransactional ? (out << to_string(isTransactional)) : (out << "<null>"));
  out << ", " << "isDynamicPartitionWrite="; (__isset.isDynamicPartitionWrite ? (out << to_string(isDynamicPartitionWrite)) : (out << "<null>"));
  out << ")";
}


LockRequest::~LockRequest() noexcept {
}


void LockRequest::__set_component(const std::vector<LockComponent> & val) {
  this->component = val;
}

void LockRequest::__set_txnid(const int64_t val) {
  this->txnid = val;
__isset.txnid = true;
}

void LockRequest::__set_user(const std::string& val) {
  this->user = val;
}

void LockRequest::__set_hostname(const std::string& val) {
  this->hostname = val;
}

void LockRequest::__set_agentInfo(const std::string& val) {
  this->agentInfo = val;
__isset.agentInfo = true;
}

void LockRequest::__set_zeroWaitReadEnabled(const bool val) {
  this->zeroWaitReadEnabled = val;
__isset.zeroWaitReadEnabled = true;
}
std::ostream& operator<<(std::ostream& out, const LockRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LockRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_component = false;
  bool isset_user = false;
  bool isset_hostname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->component.clear();
            uint32_t _size910;
            ::apache::thrift::protocol::TType _etype913;
            xfer += iprot->readListBegin(_etype913, _size910);
            this->component.resize(_size910);
            uint32_t _i914;
            for (_i914 = 0; _i914 < _size910; ++_i914)
            {
              xfer += this->component[_i914].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_component = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          this->__isset.txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          isset_hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agentInfo);
          this->__isset.agentInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->zeroWaitReadEnabled);
          this->__isset.zeroWaitReadEnabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_component)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hostname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LockRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LockRequest");

  xfer += oprot->writeFieldBegin("component", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->component.size()));
    std::vector<LockComponent> ::const_iterator _iter915;
    for (_iter915 = this->component.begin(); _iter915 != this->component.end(); ++_iter915)
    {
      xfer += (*_iter915).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.txnid) {
    xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->txnid);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.agentInfo) {
    xfer += oprot->writeFieldBegin("agentInfo", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->agentInfo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.zeroWaitReadEnabled) {
    xfer += oprot->writeFieldBegin("zeroWaitReadEnabled", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->zeroWaitReadEnabled);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LockRequest &a, LockRequest &b) {
  using ::std::swap;
  swap(a.component, b.component);
  swap(a.txnid, b.txnid);
  swap(a.user, b.user);
  swap(a.hostname, b.hostname);
  swap(a.agentInfo, b.agentInfo);
  swap(a.zeroWaitReadEnabled, b.zeroWaitReadEnabled);
  swap(a.__isset, b.__isset);
}

LockRequest::LockRequest(const LockRequest& other916) {
  component = other916.component;
  txnid = other916.txnid;
  user = other916.user;
  hostname = other916.hostname;
  agentInfo = other916.agentInfo;
  zeroWaitReadEnabled = other916.zeroWaitReadEnabled;
  __isset = other916.__isset;
}
LockRequest& LockRequest::operator=(const LockRequest& other917) {
  component = other917.component;
  txnid = other917.txnid;
  user = other917.user;
  hostname = other917.hostname;
  agentInfo = other917.agentInfo;
  zeroWaitReadEnabled = other917.zeroWaitReadEnabled;
  __isset = other917.__isset;
  return *this;
}
void LockRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LockRequest(";
  out << "component=" << to_string(component);
  out << ", " << "txnid="; (__isset.txnid ? (out << to_string(txnid)) : (out << "<null>"));
  out << ", " << "user=" << to_string(user);
  out << ", " << "hostname=" << to_string(hostname);
  out << ", " << "agentInfo="; (__isset.agentInfo ? (out << to_string(agentInfo)) : (out << "<null>"));
  out << ", " << "zeroWaitReadEnabled="; (__isset.zeroWaitReadEnabled ? (out << to_string(zeroWaitReadEnabled)) : (out << "<null>"));
  out << ")";
}


LockResponse::~LockResponse() noexcept {
}


void LockResponse::__set_lockid(const int64_t val) {
  this->lockid = val;
}

void LockResponse::__set_state(const LockState::type val) {
  this->state = val;
}

void LockResponse::__set_errorMessage(const std::string& val) {
  this->errorMessage = val;
__isset.errorMessage = true;
}
std::ostream& operator<<(std::ostream& out, const LockResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LockResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lockid = false;
  bool isset_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockid);
          isset_lockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast918;
          xfer += iprot->readI32(ecast918);
          this->state = (LockState::type)ecast918;
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errorMessage);
          this->__isset.errorMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lockid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LockResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LockResponse");

  xfer += oprot->writeFieldBegin("lockid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lockid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.errorMessage) {
    xfer += oprot->writeFieldBegin("errorMessage", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->errorMessage);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LockResponse &a, LockResponse &b) {
  using ::std::swap;
  swap(a.lockid, b.lockid);
  swap(a.state, b.state);
  swap(a.errorMessage, b.errorMessage);
  swap(a.__isset, b.__isset);
}

LockResponse::LockResponse(const LockResponse& other919) {
  lockid = other919.lockid;
  state = other919.state;
  errorMessage = other919.errorMessage;
  __isset = other919.__isset;
}
LockResponse& LockResponse::operator=(const LockResponse& other920) {
  lockid = other920.lockid;
  state = other920.state;
  errorMessage = other920.errorMessage;
  __isset = other920.__isset;
  return *this;
}
void LockResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LockResponse(";
  out << "lockid=" << to_string(lockid);
  out << ", " << "state=" << to_string(state);
  out << ", " << "errorMessage="; (__isset.errorMessage ? (out << to_string(errorMessage)) : (out << "<null>"));
  out << ")";
}


CheckLockRequest::~CheckLockRequest() noexcept {
}


void CheckLockRequest::__set_lockid(const int64_t val) {
  this->lockid = val;
}

void CheckLockRequest::__set_txnid(const int64_t val) {
  this->txnid = val;
__isset.txnid = true;
}

void CheckLockRequest::__set_elapsed_ms(const int64_t val) {
  this->elapsed_ms = val;
__isset.elapsed_ms = true;
}
std::ostream& operator<<(std::ostream& out, const CheckLockRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CheckLockRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lockid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockid);
          isset_lockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          this->__isset.txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->elapsed_ms);
          this->__isset.elapsed_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lockid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CheckLockRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CheckLockRequest");

  xfer += oprot->writeFieldBegin("lockid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lockid);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.txnid) {
    xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->txnid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.elapsed_ms) {
    xfer += oprot->writeFieldBegin("elapsed_ms", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->elapsed_ms);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CheckLockRequest &a, CheckLockRequest &b) {
  using ::std::swap;
  swap(a.lockid, b.lockid);
  swap(a.txnid, b.txnid);
  swap(a.elapsed_ms, b.elapsed_ms);
  swap(a.__isset, b.__isset);
}

CheckLockRequest::CheckLockRequest(const CheckLockRequest& other921) {
  lockid = other921.lockid;
  txnid = other921.txnid;
  elapsed_ms = other921.elapsed_ms;
  __isset = other921.__isset;
}
CheckLockRequest& CheckLockRequest::operator=(const CheckLockRequest& other922) {
  lockid = other922.lockid;
  txnid = other922.txnid;
  elapsed_ms = other922.elapsed_ms;
  __isset = other922.__isset;
  return *this;
}
void CheckLockRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CheckLockRequest(";
  out << "lockid=" << to_string(lockid);
  out << ", " << "txnid="; (__isset.txnid ? (out << to_string(txnid)) : (out << "<null>"));
  out << ", " << "elapsed_ms="; (__isset.elapsed_ms ? (out << to_string(elapsed_ms)) : (out << "<null>"));
  out << ")";
}


UnlockRequest::~UnlockRequest() noexcept {
}


void UnlockRequest::__set_lockid(const int64_t val) {
  this->lockid = val;
}
std::ostream& operator<<(std::ostream& out, const UnlockRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UnlockRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lockid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockid);
          isset_lockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lockid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UnlockRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnlockRequest");

  xfer += oprot->writeFieldBegin("lockid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lockid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnlockRequest &a, UnlockRequest &b) {
  using ::std::swap;
  swap(a.lockid, b.lockid);
}

UnlockRequest::UnlockRequest(const UnlockRequest& other923) {
  lockid = other923.lockid;
}
UnlockRequest& UnlockRequest::operator=(const UnlockRequest& other924) {
  lockid = other924.lockid;
  return *this;
}
void UnlockRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnlockRequest(";
  out << "lockid=" << to_string(lockid);
  out << ")";
}


ShowLocksRequest::~ShowLocksRequest() noexcept {
}


void ShowLocksRequest::__set_dbname(const std::string& val) {
  this->dbname = val;
__isset.dbname = true;
}

void ShowLocksRequest::__set_tablename(const std::string& val) {
  this->tablename = val;
__isset.tablename = true;
}

void ShowLocksRequest::__set_partname(const std::string& val) {
  this->partname = val;
__isset.partname = true;
}

void ShowLocksRequest::__set_isExtended(const bool val) {
  this->isExtended = val;
__isset.isExtended = true;
}

void ShowLocksRequest::__set_txnid(const int64_t val) {
  this->txnid = val;
__isset.txnid = true;
}
std::ostream& operator<<(std::ostream& out, const ShowLocksRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowLocksRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          this->__isset.dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          this->__isset.tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partname);
          this->__isset.partname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isExtended);
          this->__isset.isExtended = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          this->__isset.txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowLocksRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowLocksRequest");

  if (this->__isset.dbname) {
    xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->dbname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tablename) {
    xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->tablename);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partname) {
    xfer += oprot->writeFieldBegin("partname", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->partname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isExtended) {
    xfer += oprot->writeFieldBegin("isExtended", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->isExtended);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.txnid) {
    xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->txnid);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowLocksRequest &a, ShowLocksRequest &b) {
  using ::std::swap;
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partname, b.partname);
  swap(a.isExtended, b.isExtended);
  swap(a.txnid, b.txnid);
  swap(a.__isset, b.__isset);
}

ShowLocksRequest::ShowLocksRequest(const ShowLocksRequest& other925) {
  dbname = other925.dbname;
  tablename = other925.tablename;
  partname = other925.partname;
  isExtended = other925.isExtended;
  txnid = other925.txnid;
  __isset = other925.__isset;
}
ShowLocksRequest& ShowLocksRequest::operator=(const ShowLocksRequest& other926) {
  dbname = other926.dbname;
  tablename = other926.tablename;
  partname = other926.partname;
  isExtended = other926.isExtended;
  txnid = other926.txnid;
  __isset = other926.__isset;
  return *this;
}
void ShowLocksRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowLocksRequest(";
  out << "dbname="; (__isset.dbname ? (out << to_string(dbname)) : (out << "<null>"));
  out << ", " << "tablename="; (__isset.tablename ? (out << to_string(tablename)) : (out << "<null>"));
  out << ", " << "partname="; (__isset.partname ? (out << to_string(partname)) : (out << "<null>"));
  out << ", " << "isExtended="; (__isset.isExtended ? (out << to_string(isExtended)) : (out << "<null>"));
  out << ", " << "txnid="; (__isset.txnid ? (out << to_string(txnid)) : (out << "<null>"));
  out << ")";
}


ShowLocksResponseElement::~ShowLocksResponseElement() noexcept {
}


void ShowLocksResponseElement::__set_lockid(const int64_t val) {
  this->lockid = val;
}

void ShowLocksResponseElement::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void ShowLocksResponseElement::__set_tablename(const std::string& val) {
  this->tablename = val;
__isset.tablename = true;
}

void ShowLocksResponseElement::__set_partname(const std::string& val) {
  this->partname = val;
__isset.partname = true;
}

void ShowLocksResponseElement::__set_state(const LockState::type val) {
  this->state = val;
}

void ShowLocksResponseElement::__set_type(const LockType::type val) {
  this->type = val;
}

void ShowLocksResponseElement::__set_txnid(const int64_t val) {
  this->txnid = val;
__isset.txnid = true;
}

void ShowLocksResponseElement::__set_lastheartbeat(const int64_t val) {
  this->lastheartbeat = val;
}

void ShowLocksResponseElement::__set_acquiredat(const int64_t val) {
  this->acquiredat = val;
__isset.acquiredat = true;
}

void ShowLocksResponseElement::__set_user(const std::string& val) {
  this->user = val;
}

void ShowLocksResponseElement::__set_hostname(const std::string& val) {
  this->hostname = val;
}

void ShowLocksResponseElement::__set_heartbeatCount(const int32_t val) {
  this->heartbeatCount = val;
__isset.heartbeatCount = true;
}

void ShowLocksResponseElement::__set_agentInfo(const std::string& val) {
  this->agentInfo = val;
__isset.agentInfo = true;
}

void ShowLocksResponseElement::__set_blockedByExtId(const int64_t val) {
  this->blockedByExtId = val;
__isset.blockedByExtId = true;
}

void ShowLocksResponseElement::__set_blockedByIntId(const int64_t val) {
  this->blockedByIntId = val;
__isset.blockedByIntId = true;
}

void ShowLocksResponseElement::__set_lockIdInternal(const int64_t val) {
  this->lockIdInternal = val;
__isset.lockIdInternal = true;
}
std::ostream& operator<<(std::ostream& out, const ShowLocksResponseElement& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowLocksResponseElement::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lockid = false;
  bool isset_dbname = false;
  bool isset_state = false;
  bool isset_type = false;
  bool isset_lastheartbeat = false;
  bool isset_user = false;
  bool isset_hostname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockid);
          isset_lockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          this->__isset.tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partname);
          this->__isset.partname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast927;
          xfer += iprot->readI32(ecast927);
          this->state = (LockState::type)ecast927;
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast928;
          xfer += iprot->readI32(ecast928);
          this->type = (LockType::type)ecast928;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          this->__isset.txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastheartbeat);
          isset_lastheartbeat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acquiredat);
          this->__isset.acquiredat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          isset_hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->heartbeatCount);
          this->__isset.heartbeatCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agentInfo);
          this->__isset.agentInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->blockedByExtId);
          this->__isset.blockedByExtId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->blockedByIntId);
          this->__isset.blockedByIntId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockIdInternal);
          this->__isset.lockIdInternal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lockid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_lastheartbeat)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hostname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ShowLocksResponseElement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowLocksResponseElement");

  xfer += oprot->writeFieldBegin("lockid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lockid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tablename) {
    xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->tablename);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partname) {
    xfer += oprot->writeFieldBegin("partname", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->partname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.txnid) {
    xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->txnid);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("lastheartbeat", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->lastheartbeat);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.acquiredat) {
    xfer += oprot->writeFieldBegin("acquiredat", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->acquiredat);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.heartbeatCount) {
    xfer += oprot->writeFieldBegin("heartbeatCount", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->heartbeatCount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.agentInfo) {
    xfer += oprot->writeFieldBegin("agentInfo", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->agentInfo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blockedByExtId) {
    xfer += oprot->writeFieldBegin("blockedByExtId", ::apache::thrift::protocol::T_I64, 14);
    xfer += oprot->writeI64(this->blockedByExtId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blockedByIntId) {
    xfer += oprot->writeFieldBegin("blockedByIntId", ::apache::thrift::protocol::T_I64, 15);
    xfer += oprot->writeI64(this->blockedByIntId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lockIdInternal) {
    xfer += oprot->writeFieldBegin("lockIdInternal", ::apache::thrift::protocol::T_I64, 16);
    xfer += oprot->writeI64(this->lockIdInternal);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowLocksResponseElement &a, ShowLocksResponseElement &b) {
  using ::std::swap;
  swap(a.lockid, b.lockid);
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partname, b.partname);
  swap(a.state, b.state);
  swap(a.type, b.type);
  swap(a.txnid, b.txnid);
  swap(a.lastheartbeat, b.lastheartbeat);
  swap(a.acquiredat, b.acquiredat);
  swap(a.user, b.user);
  swap(a.hostname, b.hostname);
  swap(a.heartbeatCount, b.heartbeatCount);
  swap(a.agentInfo, b.agentInfo);
  swap(a.blockedByExtId, b.blockedByExtId);
  swap(a.blockedByIntId, b.blockedByIntId);
  swap(a.lockIdInternal, b.lockIdInternal);
  swap(a.__isset, b.__isset);
}

ShowLocksResponseElement::ShowLocksResponseElement(const ShowLocksResponseElement& other929) {
  lockid = other929.lockid;
  dbname = other929.dbname;
  tablename = other929.tablename;
  partname = other929.partname;
  state = other929.state;
  type = other929.type;
  txnid = other929.txnid;
  lastheartbeat = other929.lastheartbeat;
  acquiredat = other929.acquiredat;
  user = other929.user;
  hostname = other929.hostname;
  heartbeatCount = other929.heartbeatCount;
  agentInfo = other929.agentInfo;
  blockedByExtId = other929.blockedByExtId;
  blockedByIntId = other929.blockedByIntId;
  lockIdInternal = other929.lockIdInternal;
  __isset = other929.__isset;
}
ShowLocksResponseElement& ShowLocksResponseElement::operator=(const ShowLocksResponseElement& other930) {
  lockid = other930.lockid;
  dbname = other930.dbname;
  tablename = other930.tablename;
  partname = other930.partname;
  state = other930.state;
  type = other930.type;
  txnid = other930.txnid;
  lastheartbeat = other930.lastheartbeat;
  acquiredat = other930.acquiredat;
  user = other930.user;
  hostname = other930.hostname;
  heartbeatCount = other930.heartbeatCount;
  agentInfo = other930.agentInfo;
  blockedByExtId = other930.blockedByExtId;
  blockedByIntId = other930.blockedByIntId;
  lockIdInternal = other930.lockIdInternal;
  __isset = other930.__isset;
  return *this;
}
void ShowLocksResponseElement::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowLocksResponseElement(";
  out << "lockid=" << to_string(lockid);
  out << ", " << "dbname=" << to_string(dbname);
  out << ", " << "tablename="; (__isset.tablename ? (out << to_string(tablename)) : (out << "<null>"));
  out << ", " << "partname="; (__isset.partname ? (out << to_string(partname)) : (out << "<null>"));
  out << ", " << "state=" << to_string(state);
  out << ", " << "type=" << to_string(type);
  out << ", " << "txnid="; (__isset.txnid ? (out << to_string(txnid)) : (out << "<null>"));
  out << ", " << "lastheartbeat=" << to_string(lastheartbeat);
  out << ", " << "acquiredat="; (__isset.acquiredat ? (out << to_string(acquiredat)) : (out << "<null>"));
  out << ", " << "user=" << to_string(user);
  out << ", " << "hostname=" << to_string(hostname);
  out << ", " << "heartbeatCount="; (__isset.heartbeatCount ? (out << to_string(heartbeatCount)) : (out << "<null>"));
  out << ", " << "agentInfo="; (__isset.agentInfo ? (out << to_string(agentInfo)) : (out << "<null>"));
  out << ", " << "blockedByExtId="; (__isset.blockedByExtId ? (out << to_string(blockedByExtId)) : (out << "<null>"));
  out << ", " << "blockedByIntId="; (__isset.blockedByIntId ? (out << to_string(blockedByIntId)) : (out << "<null>"));
  out << ", " << "lockIdInternal="; (__isset.lockIdInternal ? (out << to_string(lockIdInternal)) : (out << "<null>"));
  out << ")";
}


ShowLocksResponse::~ShowLocksResponse() noexcept {
}


void ShowLocksResponse::__set_locks(const std::vector<ShowLocksResponseElement> & val) {
  this->locks = val;
}
std::ostream& operator<<(std::ostream& out, const ShowLocksResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowLocksResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->locks.clear();
            uint32_t _size931;
            ::apache::thrift::protocol::TType _etype934;
            xfer += iprot->readListBegin(_etype934, _size931);
            this->locks.resize(_size931);
            uint32_t _i935;
            for (_i935 = 0; _i935 < _size931; ++_i935)
            {
              xfer += this->locks[_i935].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.locks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowLocksResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowLocksResponse");

  xfer += oprot->writeFieldBegin("locks", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->locks.size()));
    std::vector<ShowLocksResponseElement> ::const_iterator _iter936;
    for (_iter936 = this->locks.begin(); _iter936 != this->locks.end(); ++_iter936)
    {
      xfer += (*_iter936).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowLocksResponse &a, ShowLocksResponse &b) {
  using ::std::swap;
  swap(a.locks, b.locks);
  swap(a.__isset, b.__isset);
}

ShowLocksResponse::ShowLocksResponse(const ShowLocksResponse& other937) {
  locks = other937.locks;
  __isset = other937.__isset;
}
ShowLocksResponse& ShowLocksResponse::operator=(const ShowLocksResponse& other938) {
  locks = other938.locks;
  __isset = other938.__isset;
  return *this;
}
void ShowLocksResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowLocksResponse(";
  out << "locks=" << to_string(locks);
  out << ")";
}


HeartbeatRequest::~HeartbeatRequest() noexcept {
}


void HeartbeatRequest::__set_lockid(const int64_t val) {
  this->lockid = val;
__isset.lockid = true;
}

void HeartbeatRequest::__set_txnid(const int64_t val) {
  this->txnid = val;
__isset.txnid = true;
}
std::ostream& operator<<(std::ostream& out, const HeartbeatRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HeartbeatRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockid);
          this->__isset.lockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          this->__isset.txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HeartbeatRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HeartbeatRequest");

  if (this->__isset.lockid) {
    xfer += oprot->writeFieldBegin("lockid", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->lockid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.txnid) {
    xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->txnid);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HeartbeatRequest &a, HeartbeatRequest &b) {
  using ::std::swap;
  swap(a.lockid, b.lockid);
  swap(a.txnid, b.txnid);
  swap(a.__isset, b.__isset);
}

HeartbeatRequest::HeartbeatRequest(const HeartbeatRequest& other939) {
  lockid = other939.lockid;
  txnid = other939.txnid;
  __isset = other939.__isset;
}
HeartbeatRequest& HeartbeatRequest::operator=(const HeartbeatRequest& other940) {
  lockid = other940.lockid;
  txnid = other940.txnid;
  __isset = other940.__isset;
  return *this;
}
void HeartbeatRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HeartbeatRequest(";
  out << "lockid="; (__isset.lockid ? (out << to_string(lockid)) : (out << "<null>"));
  out << ", " << "txnid="; (__isset.txnid ? (out << to_string(txnid)) : (out << "<null>"));
  out << ")";
}


HeartbeatTxnRangeRequest::~HeartbeatTxnRangeRequest() noexcept {
}


void HeartbeatTxnRangeRequest::__set_min(const int64_t val) {
  this->min = val;
}

void HeartbeatTxnRangeRequest::__set_max(const int64_t val) {
  this->max = val;
}
std::ostream& operator<<(std::ostream& out, const HeartbeatTxnRangeRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HeartbeatTxnRangeRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_min = false;
  bool isset_max = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->min);
          isset_min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max);
          isset_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_min)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_max)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HeartbeatTxnRangeRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HeartbeatTxnRangeRequest");

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HeartbeatTxnRangeRequest &a, HeartbeatTxnRangeRequest &b) {
  using ::std::swap;
  swap(a.min, b.min);
  swap(a.max, b.max);
}

HeartbeatTxnRangeRequest::HeartbeatTxnRangeRequest(const HeartbeatTxnRangeRequest& other941) {
  min = other941.min;
  max = other941.max;
}
HeartbeatTxnRangeRequest& HeartbeatTxnRangeRequest::operator=(const HeartbeatTxnRangeRequest& other942) {
  min = other942.min;
  max = other942.max;
  return *this;
}
void HeartbeatTxnRangeRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HeartbeatTxnRangeRequest(";
  out << "min=" << to_string(min);
  out << ", " << "max=" << to_string(max);
  out << ")";
}


HeartbeatTxnRangeResponse::~HeartbeatTxnRangeResponse() noexcept {
}


void HeartbeatTxnRangeResponse::__set_aborted(const std::set<int64_t> & val) {
  this->aborted = val;
}

void HeartbeatTxnRangeResponse::__set_nosuch(const std::set<int64_t> & val) {
  this->nosuch = val;
}
std::ostream& operator<<(std::ostream& out, const HeartbeatTxnRangeResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HeartbeatTxnRangeResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_aborted = false;
  bool isset_nosuch = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->aborted.clear();
            uint32_t _size943;
            ::apache::thrift::protocol::TType _etype946;
            xfer += iprot->readSetBegin(_etype946, _size943);
            uint32_t _i947;
            for (_i947 = 0; _i947 < _size943; ++_i947)
            {
              int64_t _elem948;
              xfer += iprot->readI64(_elem948);
              this->aborted.insert(_elem948);
            }
            xfer += iprot->readSetEnd();
          }
          isset_aborted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->nosuch.clear();
            uint32_t _size949;
            ::apache::thrift::protocol::TType _etype952;
            xfer += iprot->readSetBegin(_etype952, _size949);
            uint32_t _i953;
            for (_i953 = 0; _i953 < _size949; ++_i953)
            {
              int64_t _elem954;
              xfer += iprot->readI64(_elem954);
              this->nosuch.insert(_elem954);
            }
            xfer += iprot->readSetEnd();
          }
          isset_nosuch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_aborted)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nosuch)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HeartbeatTxnRangeResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HeartbeatTxnRangeResponse");

  xfer += oprot->writeFieldBegin("aborted", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->aborted.size()));
    std::set<int64_t> ::const_iterator _iter955;
    for (_iter955 = this->aborted.begin(); _iter955 != this->aborted.end(); ++_iter955)
    {
      xfer += oprot->writeI64((*_iter955));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nosuch", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->nosuch.size()));
    std::set<int64_t> ::const_iterator _iter956;
    for (_iter956 = this->nosuch.begin(); _iter956 != this->nosuch.end(); ++_iter956)
    {
      xfer += oprot->writeI64((*_iter956));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HeartbeatTxnRangeResponse &a, HeartbeatTxnRangeResponse &b) {
  using ::std::swap;
  swap(a.aborted, b.aborted);
  swap(a.nosuch, b.nosuch);
}

HeartbeatTxnRangeResponse::HeartbeatTxnRangeResponse(const HeartbeatTxnRangeResponse& other957) {
  aborted = other957.aborted;
  nosuch = other957.nosuch;
}
HeartbeatTxnRangeResponse& HeartbeatTxnRangeResponse::operator=(const HeartbeatTxnRangeResponse& other958) {
  aborted = other958.aborted;
  nosuch = other958.nosuch;
  return *this;
}
void HeartbeatTxnRangeResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HeartbeatTxnRangeResponse(";
  out << "aborted=" << to_string(aborted);
  out << ", " << "nosuch=" << to_string(nosuch);
  out << ")";
}


CompactionRequest::~CompactionRequest() noexcept {
}


void CompactionRequest::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void CompactionRequest::__set_tablename(const std::string& val) {
  this->tablename = val;
}

void CompactionRequest::__set_partitionname(const std::string& val) {
  this->partitionname = val;
__isset.partitionname = true;
}

void CompactionRequest::__set_type(const CompactionType::type val) {
  this->type = val;
}

void CompactionRequest::__set_runas(const std::string& val) {
  this->runas = val;
__isset.runas = true;
}

void CompactionRequest::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
__isset.properties = true;
}

void CompactionRequest::__set_initiatorId(const std::string& val) {
  this->initiatorId = val;
__isset.initiatorId = true;
}

void CompactionRequest::__set_initiatorVersion(const std::string& val) {
  this->initiatorVersion = val;
__isset.initiatorVersion = true;
}
std::ostream& operator<<(std::ostream& out, const CompactionRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CompactionRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbname = false;
  bool isset_tablename = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          isset_tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partitionname);
          this->__isset.partitionname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast959;
          xfer += iprot->readI32(ecast959);
          this->type = (CompactionType::type)ecast959;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->runas);
          this->__isset.runas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size960;
            ::apache::thrift::protocol::TType _ktype961;
            ::apache::thrift::protocol::TType _vtype962;
            xfer += iprot->readMapBegin(_ktype961, _vtype962, _size960);
            uint32_t _i964;
            for (_i964 = 0; _i964 < _size960; ++_i964)
            {
              std::string _key965;
              xfer += iprot->readString(_key965);
              std::string& _val966 = this->properties[_key965];
              xfer += iprot->readString(_val966);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->initiatorId);
          this->__isset.initiatorId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->initiatorVersion);
          this->__isset.initiatorVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CompactionRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactionRequest");

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partitionname) {
    xfer += oprot->writeFieldBegin("partitionname", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->partitionname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.runas) {
    xfer += oprot->writeFieldBegin("runas", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->runas);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.properties) {
    xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter967;
      for (_iter967 = this->properties.begin(); _iter967 != this->properties.end(); ++_iter967)
      {
        xfer += oprot->writeString(_iter967->first);
        xfer += oprot->writeString(_iter967->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.initiatorId) {
    xfer += oprot->writeFieldBegin("initiatorId", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->initiatorId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.initiatorVersion) {
    xfer += oprot->writeFieldBegin("initiatorVersion", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->initiatorVersion);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactionRequest &a, CompactionRequest &b) {
  using ::std::swap;
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionname, b.partitionname);
  swap(a.type, b.type);
  swap(a.runas, b.runas);
  swap(a.properties, b.properties);
  swap(a.initiatorId, b.initiatorId);
  swap(a.initiatorVersion, b.initiatorVersion);
  swap(a.__isset, b.__isset);
}

CompactionRequest::CompactionRequest(const CompactionRequest& other968) {
  dbname = other968.dbname;
  tablename = other968.tablename;
  partitionname = other968.partitionname;
  type = other968.type;
  runas = other968.runas;
  properties = other968.properties;
  initiatorId = other968.initiatorId;
  initiatorVersion = other968.initiatorVersion;
  __isset = other968.__isset;
}
CompactionRequest& CompactionRequest::operator=(const CompactionRequest& other969) {
  dbname = other969.dbname;
  tablename = other969.tablename;
  partitionname = other969.partitionname;
  type = other969.type;
  runas = other969.runas;
  properties = other969.properties;
  initiatorId = other969.initiatorId;
  initiatorVersion = other969.initiatorVersion;
  __isset = other969.__isset;
  return *this;
}
void CompactionRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactionRequest(";
  out << "dbname=" << to_string(dbname);
  out << ", " << "tablename=" << to_string(tablename);
  out << ", " << "partitionname="; (__isset.partitionname ? (out << to_string(partitionname)) : (out << "<null>"));
  out << ", " << "type=" << to_string(type);
  out << ", " << "runas="; (__isset.runas ? (out << to_string(runas)) : (out << "<null>"));
  out << ", " << "properties="; (__isset.properties ? (out << to_string(properties)) : (out << "<null>"));
  out << ", " << "initiatorId="; (__isset.initiatorId ? (out << to_string(initiatorId)) : (out << "<null>"));
  out << ", " << "initiatorVersion="; (__isset.initiatorVersion ? (out << to_string(initiatorVersion)) : (out << "<null>"));
  out << ")";
}


CompactionInfoStruct::~CompactionInfoStruct() noexcept {
}


void CompactionInfoStruct::__set_id(const int64_t val) {
  this->id = val;
}

void CompactionInfoStruct::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void CompactionInfoStruct::__set_tablename(const std::string& val) {
  this->tablename = val;
}

void CompactionInfoStruct::__set_partitionname(const std::string& val) {
  this->partitionname = val;
__isset.partitionname = true;
}

void CompactionInfoStruct::__set_type(const CompactionType::type val) {
  this->type = val;
}

void CompactionInfoStruct::__set_runas(const std::string& val) {
  this->runas = val;
__isset.runas = true;
}

void CompactionInfoStruct::__set_properties(const std::string& val) {
  this->properties = val;
__isset.properties = true;
}

void CompactionInfoStruct::__set_toomanyaborts(const bool val) {
  this->toomanyaborts = val;
__isset.toomanyaborts = true;
}

void CompactionInfoStruct::__set_state(const std::string& val) {
  this->state = val;
__isset.state = true;
}

void CompactionInfoStruct::__set_workerId(const std::string& val) {
  this->workerId = val;
__isset.workerId = true;
}

void CompactionInfoStruct::__set_start(const int64_t val) {
  this->start = val;
__isset.start = true;
}

void CompactionInfoStruct::__set_highestWriteId(const int64_t val) {
  this->highestWriteId = val;
__isset.highestWriteId = true;
}

void CompactionInfoStruct::__set_errorMessage(const std::string& val) {
  this->errorMessage = val;
__isset.errorMessage = true;
}

void CompactionInfoStruct::__set_hasoldabort(const bool val) {
  this->hasoldabort = val;
__isset.hasoldabort = true;
}

void CompactionInfoStruct::__set_enqueueTime(const int64_t val) {
  this->enqueueTime = val;
__isset.enqueueTime = true;
}
std::ostream& operator<<(std::ostream& out, const CompactionInfoStruct& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CompactionInfoStruct::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_dbname = false;
  bool isset_tablename = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          isset_tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partitionname);
          this->__isset.partitionname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast970;
          xfer += iprot->readI32(ecast970);
          this->type = (CompactionType::type)ecast970;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->runas);
          this->__isset.runas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->properties);
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->toomanyaborts);
          this->__isset.toomanyaborts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->state);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->workerId);
          this->__isset.workerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->highestWriteId);
          this->__isset.highestWriteId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errorMessage);
          this->__isset.errorMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasoldabort);
          this->__isset.hasoldabort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->enqueueTime);
          this->__isset.enqueueTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CompactionInfoStruct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactionInfoStruct");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partitionname) {
    xfer += oprot->writeFieldBegin("partitionname", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->partitionname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.runas) {
    xfer += oprot->writeFieldBegin("runas", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->runas);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.properties) {
    xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->properties);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.toomanyaborts) {
    xfer += oprot->writeFieldBegin("toomanyaborts", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->toomanyaborts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.workerId) {
    xfer += oprot->writeFieldBegin("workerId", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->workerId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.start) {
    xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->start);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.highestWriteId) {
    xfer += oprot->writeFieldBegin("highestWriteId", ::apache::thrift::protocol::T_I64, 12);
    xfer += oprot->writeI64(this->highestWriteId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.errorMessage) {
    xfer += oprot->writeFieldBegin("errorMessage", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->errorMessage);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hasoldabort) {
    xfer += oprot->writeFieldBegin("hasoldabort", ::apache::thrift::protocol::T_BOOL, 14);
    xfer += oprot->writeBool(this->hasoldabort);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.enqueueTime) {
    xfer += oprot->writeFieldBegin("enqueueTime", ::apache::thrift::protocol::T_I64, 15);
    xfer += oprot->writeI64(this->enqueueTime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactionInfoStruct &a, CompactionInfoStruct &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionname, b.partitionname);
  swap(a.type, b.type);
  swap(a.runas, b.runas);
  swap(a.properties, b.properties);
  swap(a.toomanyaborts, b.toomanyaborts);
  swap(a.state, b.state);
  swap(a.workerId, b.workerId);
  swap(a.start, b.start);
  swap(a.highestWriteId, b.highestWriteId);
  swap(a.errorMessage, b.errorMessage);
  swap(a.hasoldabort, b.hasoldabort);
  swap(a.enqueueTime, b.enqueueTime);
  swap(a.__isset, b.__isset);
}

CompactionInfoStruct::CompactionInfoStruct(const CompactionInfoStruct& other971) {
  id = other971.id;
  dbname = other971.dbname;
  tablename = other971.tablename;
  partitionname = other971.partitionname;
  type = other971.type;
  runas = other971.runas;
  properties = other971.properties;
  toomanyaborts = other971.toomanyaborts;
  state = other971.state;
  workerId = other971.workerId;
  start = other971.start;
  highestWriteId = other971.highestWriteId;
  errorMessage = other971.errorMessage;
  hasoldabort = other971.hasoldabort;
  enqueueTime = other971.enqueueTime;
  __isset = other971.__isset;
}
CompactionInfoStruct& CompactionInfoStruct::operator=(const CompactionInfoStruct& other972) {
  id = other972.id;
  dbname = other972.dbname;
  tablename = other972.tablename;
  partitionname = other972.partitionname;
  type = other972.type;
  runas = other972.runas;
  properties = other972.properties;
  toomanyaborts = other972.toomanyaborts;
  state = other972.state;
  workerId = other972.workerId;
  start = other972.start;
  highestWriteId = other972.highestWriteId;
  errorMessage = other972.errorMessage;
  hasoldabort = other972.hasoldabort;
  enqueueTime = other972.enqueueTime;
  __isset = other972.__isset;
  return *this;
}
void CompactionInfoStruct::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactionInfoStruct(";
  out << "id=" << to_string(id);
  out << ", " << "dbname=" << to_string(dbname);
  out << ", " << "tablename=" << to_string(tablename);
  out << ", " << "partitionname="; (__isset.partitionname ? (out << to_string(partitionname)) : (out << "<null>"));
  out << ", " << "type=" << to_string(type);
  out << ", " << "runas="; (__isset.runas ? (out << to_string(runas)) : (out << "<null>"));
  out << ", " << "properties="; (__isset.properties ? (out << to_string(properties)) : (out << "<null>"));
  out << ", " << "toomanyaborts="; (__isset.toomanyaborts ? (out << to_string(toomanyaborts)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "workerId="; (__isset.workerId ? (out << to_string(workerId)) : (out << "<null>"));
  out << ", " << "start="; (__isset.start ? (out << to_string(start)) : (out << "<null>"));
  out << ", " << "highestWriteId="; (__isset.highestWriteId ? (out << to_string(highestWriteId)) : (out << "<null>"));
  out << ", " << "errorMessage="; (__isset.errorMessage ? (out << to_string(errorMessage)) : (out << "<null>"));
  out << ", " << "hasoldabort="; (__isset.hasoldabort ? (out << to_string(hasoldabort)) : (out << "<null>"));
  out << ", " << "enqueueTime="; (__isset.enqueueTime ? (out << to_string(enqueueTime)) : (out << "<null>"));
  out << ")";
}


OptionalCompactionInfoStruct::~OptionalCompactionInfoStruct() noexcept {
}


void OptionalCompactionInfoStruct::__set_ci(const CompactionInfoStruct& val) {
  this->ci = val;
__isset.ci = true;
}
std::ostream& operator<<(std::ostream& out, const OptionalCompactionInfoStruct& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t OptionalCompactionInfoStruct::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ci.read(iprot);
          this->__isset.ci = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OptionalCompactionInfoStruct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OptionalCompactionInfoStruct");

  if (this->__isset.ci) {
    xfer += oprot->writeFieldBegin("ci", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ci.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OptionalCompactionInfoStruct &a, OptionalCompactionInfoStruct &b) {
  using ::std::swap;
  swap(a.ci, b.ci);
  swap(a.__isset, b.__isset);
}

OptionalCompactionInfoStruct::OptionalCompactionInfoStruct(const OptionalCompactionInfoStruct& other973) {
  ci = other973.ci;
  __isset = other973.__isset;
}
OptionalCompactionInfoStruct& OptionalCompactionInfoStruct::operator=(const OptionalCompactionInfoStruct& other974) {
  ci = other974.ci;
  __isset = other974.__isset;
  return *this;
}
void OptionalCompactionInfoStruct::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OptionalCompactionInfoStruct(";
  out << "ci="; (__isset.ci ? (out << to_string(ci)) : (out << "<null>"));
  out << ")";
}


CompactionResponse::~CompactionResponse() noexcept {
}


void CompactionResponse::__set_id(const int64_t val) {
  this->id = val;
}

void CompactionResponse::__set_state(const std::string& val) {
  this->state = val;
}

void CompactionResponse::__set_accepted(const bool val) {
  this->accepted = val;
}
std::ostream& operator<<(std::ostream& out, const CompactionResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CompactionResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_state = false;
  bool isset_accepted = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->state);
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->accepted);
          isset_accepted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_accepted)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CompactionResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactionResponse");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("accepted", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->accepted);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactionResponse &a, CompactionResponse &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.state, b.state);
  swap(a.accepted, b.accepted);
}

CompactionResponse::CompactionResponse(const CompactionResponse& other975) {
  id = other975.id;
  state = other975.state;
  accepted = other975.accepted;
}
CompactionResponse& CompactionResponse::operator=(const CompactionResponse& other976) {
  id = other976.id;
  state = other976.state;
  accepted = other976.accepted;
  return *this;
}
void CompactionResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactionResponse(";
  out << "id=" << to_string(id);
  out << ", " << "state=" << to_string(state);
  out << ", " << "accepted=" << to_string(accepted);
  out << ")";
}


ShowCompactRequest::~ShowCompactRequest() noexcept {
}

std::ostream& operator<<(std::ostream& out, const ShowCompactRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowCompactRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowCompactRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowCompactRequest");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowCompactRequest &a, ShowCompactRequest &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

ShowCompactRequest::ShowCompactRequest(const ShowCompactRequest& other977) {
  (void) other977;
}
ShowCompactRequest& ShowCompactRequest::operator=(const ShowCompactRequest& other978) {
  (void) other978;
  return *this;
}
void ShowCompactRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowCompactRequest(";
  out << ")";
}


ShowCompactResponseElement::~ShowCompactResponseElement() noexcept {
}


void ShowCompactResponseElement::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void ShowCompactResponseElement::__set_tablename(const std::string& val) {
  this->tablename = val;
}

void ShowCompactResponseElement::__set_partitionname(const std::string& val) {
  this->partitionname = val;
__isset.partitionname = true;
}

void ShowCompactResponseElement::__set_type(const CompactionType::type val) {
  this->type = val;
}

void ShowCompactResponseElement::__set_state(const std::string& val) {
  this->state = val;
}

void ShowCompactResponseElement::__set_workerid(const std::string& val) {
  this->workerid = val;
__isset.workerid = true;
}

void ShowCompactResponseElement::__set_start(const int64_t val) {
  this->start = val;
__isset.start = true;
}

void ShowCompactResponseElement::__set_runAs(const std::string& val) {
  this->runAs = val;
__isset.runAs = true;
}

void ShowCompactResponseElement::__set_hightestTxnId(const int64_t val) {
  this->hightestTxnId = val;
__isset.hightestTxnId = true;
}

void ShowCompactResponseElement::__set_metaInfo(const std::string& val) {
  this->metaInfo = val;
__isset.metaInfo = true;
}

void ShowCompactResponseElement::__set_endTime(const int64_t val) {
  this->endTime = val;
__isset.endTime = true;
}

void ShowCompactResponseElement::__set_hadoopJobId(const std::string& val) {
  this->hadoopJobId = val;
__isset.hadoopJobId = true;
}

void ShowCompactResponseElement::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}

void ShowCompactResponseElement::__set_errorMessage(const std::string& val) {
  this->errorMessage = val;
__isset.errorMessage = true;
}

void ShowCompactResponseElement::__set_enqueueTime(const int64_t val) {
  this->enqueueTime = val;
__isset.enqueueTime = true;
}

void ShowCompactResponseElement::__set_workerVersion(const std::string& val) {
  this->workerVersion = val;
__isset.workerVersion = true;
}

void ShowCompactResponseElement::__set_initiatorId(const std::string& val) {
  this->initiatorId = val;
__isset.initiatorId = true;
}

void ShowCompactResponseElement::__set_initiatorVersion(const std::string& val) {
  this->initiatorVersion = val;
__isset.initiatorVersion = true;
}
std::ostream& operator<<(std::ostream& out, const ShowCompactResponseElement& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowCompactResponseElement::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbname = false;
  bool isset_tablename = false;
  bool isset_type = false;
  bool isset_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          isset_tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partitionname);
          this->__isset.partitionname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast979;
          xfer += iprot->readI32(ecast979);
          this->type = (CompactionType::type)ecast979;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->state);
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->workerid);
          this->__isset.workerid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->runAs);
          this->__isset.runAs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->hightestTxnId);
          this->__isset.hightestTxnId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metaInfo);
          this->__isset.metaInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->endTime);
          this->__isset.endTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hadoopJobId);
          this->__isset.hadoopJobId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errorMessage);
          this->__isset.errorMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->enqueueTime);
          this->__isset.enqueueTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->workerVersion);
          this->__isset.workerVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->initiatorId);
          this->__isset.initiatorId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->initiatorVersion);
          this->__isset.initiatorVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ShowCompactResponseElement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowCompactResponseElement");

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partitionname) {
    xfer += oprot->writeFieldBegin("partitionname", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->partitionname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.workerid) {
    xfer += oprot->writeFieldBegin("workerid", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->workerid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.start) {
    xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->start);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.runAs) {
    xfer += oprot->writeFieldBegin("runAs", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->runAs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hightestTxnId) {
    xfer += oprot->writeFieldBegin("hightestTxnId", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->hightestTxnId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.metaInfo) {
    xfer += oprot->writeFieldBegin("metaInfo", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->metaInfo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.endTime) {
    xfer += oprot->writeFieldBegin("endTime", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->endTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hadoopJobId) {
    xfer += oprot->writeFieldBegin("hadoopJobId", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->hadoopJobId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 13);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.errorMessage) {
    xfer += oprot->writeFieldBegin("errorMessage", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->errorMessage);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.enqueueTime) {
    xfer += oprot->writeFieldBegin("enqueueTime", ::apache::thrift::protocol::T_I64, 15);
    xfer += oprot->writeI64(this->enqueueTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.workerVersion) {
    xfer += oprot->writeFieldBegin("workerVersion", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->workerVersion);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.initiatorId) {
    xfer += oprot->writeFieldBegin("initiatorId", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->initiatorId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.initiatorVersion) {
    xfer += oprot->writeFieldBegin("initiatorVersion", ::apache::thrift::protocol::T_STRING, 18);
    xfer += oprot->writeString(this->initiatorVersion);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowCompactResponseElement &a, ShowCompactResponseElement &b) {
  using ::std::swap;
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionname, b.partitionname);
  swap(a.type, b.type);
  swap(a.state, b.state);
  swap(a.workerid, b.workerid);
  swap(a.start, b.start);
  swap(a.runAs, b.runAs);
  swap(a.hightestTxnId, b.hightestTxnId);
  swap(a.metaInfo, b.metaInfo);
  swap(a.endTime, b.endTime);
  swap(a.hadoopJobId, b.hadoopJobId);
  swap(a.id, b.id);
  swap(a.errorMessage, b.errorMessage);
  swap(a.enqueueTime, b.enqueueTime);
  swap(a.workerVersion, b.workerVersion);
  swap(a.initiatorId, b.initiatorId);
  swap(a.initiatorVersion, b.initiatorVersion);
  swap(a.__isset, b.__isset);
}

ShowCompactResponseElement::ShowCompactResponseElement(const ShowCompactResponseElement& other980) {
  dbname = other980.dbname;
  tablename = other980.tablename;
  partitionname = other980.partitionname;
  type = other980.type;
  state = other980.state;
  workerid = other980.workerid;
  start = other980.start;
  runAs = other980.runAs;
  hightestTxnId = other980.hightestTxnId;
  metaInfo = other980.metaInfo;
  endTime = other980.endTime;
  hadoopJobId = other980.hadoopJobId;
  id = other980.id;
  errorMessage = other980.errorMessage;
  enqueueTime = other980.enqueueTime;
  workerVersion = other980.workerVersion;
  initiatorId = other980.initiatorId;
  initiatorVersion = other980.initiatorVersion;
  __isset = other980.__isset;
}
ShowCompactResponseElement& ShowCompactResponseElement::operator=(const ShowCompactResponseElement& other981) {
  dbname = other981.dbname;
  tablename = other981.tablename;
  partitionname = other981.partitionname;
  type = other981.type;
  state = other981.state;
  workerid = other981.workerid;
  start = other981.start;
  runAs = other981.runAs;
  hightestTxnId = other981.hightestTxnId;
  metaInfo = other981.metaInfo;
  endTime = other981.endTime;
  hadoopJobId = other981.hadoopJobId;
  id = other981.id;
  errorMessage = other981.errorMessage;
  enqueueTime = other981.enqueueTime;
  workerVersion = other981.workerVersion;
  initiatorId = other981.initiatorId;
  initiatorVersion = other981.initiatorVersion;
  __isset = other981.__isset;
  return *this;
}
void ShowCompactResponseElement::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowCompactResponseElement(";
  out << "dbname=" << to_string(dbname);
  out << ", " << "tablename=" << to_string(tablename);
  out << ", " << "partitionname="; (__isset.partitionname ? (out << to_string(partitionname)) : (out << "<null>"));
  out << ", " << "type=" << to_string(type);
  out << ", " << "state=" << to_string(state);
  out << ", " << "workerid="; (__isset.workerid ? (out << to_string(workerid)) : (out << "<null>"));
  out << ", " << "start="; (__isset.start ? (out << to_string(start)) : (out << "<null>"));
  out << ", " << "runAs="; (__isset.runAs ? (out << to_string(runAs)) : (out << "<null>"));
  out << ", " << "hightestTxnId="; (__isset.hightestTxnId ? (out << to_string(hightestTxnId)) : (out << "<null>"));
  out << ", " << "metaInfo="; (__isset.metaInfo ? (out << to_string(metaInfo)) : (out << "<null>"));
  out << ", " << "endTime="; (__isset.endTime ? (out << to_string(endTime)) : (out << "<null>"));
  out << ", " << "hadoopJobId="; (__isset.hadoopJobId ? (out << to_string(hadoopJobId)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "errorMessage="; (__isset.errorMessage ? (out << to_string(errorMessage)) : (out << "<null>"));
  out << ", " << "enqueueTime="; (__isset.enqueueTime ? (out << to_string(enqueueTime)) : (out << "<null>"));
  out << ", " << "workerVersion="; (__isset.workerVersion ? (out << to_string(workerVersion)) : (out << "<null>"));
  out << ", " << "initiatorId="; (__isset.initiatorId ? (out << to_string(initiatorId)) : (out << "<null>"));
  out << ", " << "initiatorVersion="; (__isset.initiatorVersion ? (out << to_string(initiatorVersion)) : (out << "<null>"));
  out << ")";
}


ShowCompactResponse::~ShowCompactResponse() noexcept {
}


void ShowCompactResponse::__set_compacts(const std::vector<ShowCompactResponseElement> & val) {
  this->compacts = val;
}
std::ostream& operator<<(std::ostream& out, const ShowCompactResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowCompactResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_compacts = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->compacts.clear();
            uint32_t _size982;
            ::apache::thrift::protocol::TType _etype985;
            xfer += iprot->readListBegin(_etype985, _size982);
            this->compacts.resize(_size982);
            uint32_t _i986;
            for (_i986 = 0; _i986 < _size982; ++_i986)
            {
              xfer += this->compacts[_i986].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_compacts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_compacts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ShowCompactResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowCompactResponse");

  xfer += oprot->writeFieldBegin("compacts", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->compacts.size()));
    std::vector<ShowCompactResponseElement> ::const_iterator _iter987;
    for (_iter987 = this->compacts.begin(); _iter987 != this->compacts.end(); ++_iter987)
    {
      xfer += (*_iter987).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowCompactResponse &a, ShowCompactResponse &b) {
  using ::std::swap;
  swap(a.compacts, b.compacts);
}

ShowCompactResponse::ShowCompactResponse(const ShowCompactResponse& other988) {
  compacts = other988.compacts;
}
ShowCompactResponse& ShowCompactResponse::operator=(const ShowCompactResponse& other989) {
  compacts = other989.compacts;
  return *this;
}
void ShowCompactResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowCompactResponse(";
  out << "compacts=" << to_string(compacts);
  out << ")";
}


GetLatestCommittedCompactionInfoRequest::~GetLatestCommittedCompactionInfoRequest() noexcept {
}


void GetLatestCommittedCompactionInfoRequest::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void GetLatestCommittedCompactionInfoRequest::__set_tablename(const std::string& val) {
  this->tablename = val;
}

void GetLatestCommittedCompactionInfoRequest::__set_partitionnames(const std::vector<std::string> & val) {
  this->partitionnames = val;
__isset.partitionnames = true;
}
std::ostream& operator<<(std::ostream& out, const GetLatestCommittedCompactionInfoRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetLatestCommittedCompactionInfoRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbname = false;
  bool isset_tablename = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          isset_tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionnames.clear();
            uint32_t _size990;
            ::apache::thrift::protocol::TType _etype993;
            xfer += iprot->readListBegin(_etype993, _size990);
            this->partitionnames.resize(_size990);
            uint32_t _i994;
            for (_i994 = 0; _i994 < _size990; ++_i994)
            {
              xfer += iprot->readString(this->partitionnames[_i994]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionnames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetLatestCommittedCompactionInfoRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetLatestCommittedCompactionInfoRequest");

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partitionnames) {
    xfer += oprot->writeFieldBegin("partitionnames", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partitionnames.size()));
      std::vector<std::string> ::const_iterator _iter995;
      for (_iter995 = this->partitionnames.begin(); _iter995 != this->partitionnames.end(); ++_iter995)
      {
        xfer += oprot->writeString((*_iter995));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetLatestCommittedCompactionInfoRequest &a, GetLatestCommittedCompactionInfoRequest &b) {
  using ::std::swap;
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionnames, b.partitionnames);
  swap(a.__isset, b.__isset);
}

GetLatestCommittedCompactionInfoRequest::GetLatestCommittedCompactionInfoRequest(const GetLatestCommittedCompactionInfoRequest& other996) {
  dbname = other996.dbname;
  tablename = other996.tablename;
  partitionnames = other996.partitionnames;
  __isset = other996.__isset;
}
GetLatestCommittedCompactionInfoRequest& GetLatestCommittedCompactionInfoRequest::operator=(const GetLatestCommittedCompactionInfoRequest& other997) {
  dbname = other997.dbname;
  tablename = other997.tablename;
  partitionnames = other997.partitionnames;
  __isset = other997.__isset;
  return *this;
}
void GetLatestCommittedCompactionInfoRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetLatestCommittedCompactionInfoRequest(";
  out << "dbname=" << to_string(dbname);
  out << ", " << "tablename=" << to_string(tablename);
  out << ", " << "partitionnames="; (__isset.partitionnames ? (out << to_string(partitionnames)) : (out << "<null>"));
  out << ")";
}


GetLatestCommittedCompactionInfoResponse::~GetLatestCommittedCompactionInfoResponse() noexcept {
}


void GetLatestCommittedCompactionInfoResponse::__set_compactions(const std::vector<CompactionInfoStruct> & val) {
  this->compactions = val;
}
std::ostream& operator<<(std::ostream& out, const GetLatestCommittedCompactionInfoResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetLatestCommittedCompactionInfoResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_compactions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->compactions.clear();
            uint32_t _size998;
            ::apache::thrift::protocol::TType _etype1001;
            xfer += iprot->readListBegin(_etype1001, _size998);
            this->compactions.resize(_size998);
            uint32_t _i1002;
            for (_i1002 = 0; _i1002 < _size998; ++_i1002)
            {
              xfer += this->compactions[_i1002].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_compactions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_compactions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetLatestCommittedCompactionInfoResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetLatestCommittedCompactionInfoResponse");

  xfer += oprot->writeFieldBegin("compactions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->compactions.size()));
    std::vector<CompactionInfoStruct> ::const_iterator _iter1003;
    for (_iter1003 = this->compactions.begin(); _iter1003 != this->compactions.end(); ++_iter1003)
    {
      xfer += (*_iter1003).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetLatestCommittedCompactionInfoResponse &a, GetLatestCommittedCompactionInfoResponse &b) {
  using ::std::swap;
  swap(a.compactions, b.compactions);
}

GetLatestCommittedCompactionInfoResponse::GetLatestCommittedCompactionInfoResponse(const GetLatestCommittedCompactionInfoResponse& other1004) {
  compactions = other1004.compactions;
}
GetLatestCommittedCompactionInfoResponse& GetLatestCommittedCompactionInfoResponse::operator=(const GetLatestCommittedCompactionInfoResponse& other1005) {
  compactions = other1005.compactions;
  return *this;
}
void GetLatestCommittedCompactionInfoResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetLatestCommittedCompactionInfoResponse(";
  out << "compactions=" << to_string(compactions);
  out << ")";
}


AddDynamicPartitions::~AddDynamicPartitions() noexcept {
}


void AddDynamicPartitions::__set_txnid(const int64_t val) {
  this->txnid = val;
}

void AddDynamicPartitions::__set_writeid(const int64_t val) {
  this->writeid = val;
}

void AddDynamicPartitions::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void AddDynamicPartitions::__set_tablename(const std::string& val) {
  this->tablename = val;
}

void AddDynamicPartitions::__set_partitionnames(const std::vector<std::string> & val) {
  this->partitionnames = val;
}

void AddDynamicPartitions::__set_operationType(const DataOperationType::type val) {
  this->operationType = val;
__isset.operationType = true;
}
std::ostream& operator<<(std::ostream& out, const AddDynamicPartitions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddDynamicPartitions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txnid = false;
  bool isset_writeid = false;
  bool isset_dbname = false;
  bool isset_tablename = false;
  bool isset_partitionnames = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          isset_txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeid);
          isset_writeid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          isset_tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionnames.clear();
            uint32_t _size1006;
            ::apache::thrift::protocol::TType _etype1009;
            xfer += iprot->readListBegin(_etype1009, _size1006);
            this->partitionnames.resize(_size1006);
            uint32_t _i1010;
            for (_i1010 = 0; _i1010 < _size1006; ++_i1010)
            {
              xfer += iprot->readString(this->partitionnames[_i1010]);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitionnames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1011;
          xfer += iprot->readI32(ecast1011);
          this->operationType = (DataOperationType::type)ecast1011;
          this->__isset.operationType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txnid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_writeid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partitionnames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddDynamicPartitions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddDynamicPartitions");

  xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txnid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("writeid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->writeid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitionnames", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partitionnames.size()));
    std::vector<std::string> ::const_iterator _iter1012;
    for (_iter1012 = this->partitionnames.begin(); _iter1012 != this->partitionnames.end(); ++_iter1012)
    {
      xfer += oprot->writeString((*_iter1012));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationType) {
    xfer += oprot->writeFieldBegin("operationType", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->operationType);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddDynamicPartitions &a, AddDynamicPartitions &b) {
  using ::std::swap;
  swap(a.txnid, b.txnid);
  swap(a.writeid, b.writeid);
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionnames, b.partitionnames);
  swap(a.operationType, b.operationType);
  swap(a.__isset, b.__isset);
}

AddDynamicPartitions::AddDynamicPartitions(const AddDynamicPartitions& other1013) {
  txnid = other1013.txnid;
  writeid = other1013.writeid;
  dbname = other1013.dbname;
  tablename = other1013.tablename;
  partitionnames = other1013.partitionnames;
  operationType = other1013.operationType;
  __isset = other1013.__isset;
}
AddDynamicPartitions& AddDynamicPartitions::operator=(const AddDynamicPartitions& other1014) {
  txnid = other1014.txnid;
  writeid = other1014.writeid;
  dbname = other1014.dbname;
  tablename = other1014.tablename;
  partitionnames = other1014.partitionnames;
  operationType = other1014.operationType;
  __isset = other1014.__isset;
  return *this;
}
void AddDynamicPartitions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddDynamicPartitions(";
  out << "txnid=" << to_string(txnid);
  out << ", " << "writeid=" << to_string(writeid);
  out << ", " << "dbname=" << to_string(dbname);
  out << ", " << "tablename=" << to_string(tablename);
  out << ", " << "partitionnames=" << to_string(partitionnames);
  out << ", " << "operationType="; (__isset.operationType ? (out << to_string(operationType)) : (out << "<null>"));
  out << ")";
}


BasicTxnInfo::~BasicTxnInfo() noexcept {
}


void BasicTxnInfo::__set_isnull(const bool val) {
  this->isnull = val;
}

void BasicTxnInfo::__set_time(const int64_t val) {
  this->time = val;
__isset.time = true;
}

void BasicTxnInfo::__set_txnid(const int64_t val) {
  this->txnid = val;
__isset.txnid = true;
}

void BasicTxnInfo::__set_dbname(const std::string& val) {
  this->dbname = val;
__isset.dbname = true;
}

void BasicTxnInfo::__set_tablename(const std::string& val) {
  this->tablename = val;
__isset.tablename = true;
}

void BasicTxnInfo::__set_partitionname(const std::string& val) {
  this->partitionname = val;
__isset.partitionname = true;
}
std::ostream& operator<<(std::ostream& out, const BasicTxnInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BasicTxnInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_isnull = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isnull);
          isset_isnull = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          this->__isset.txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          this->__isset.dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          this->__isset.tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partitionname);
          this->__isset.partitionname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_isnull)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t BasicTxnInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BasicTxnInfo");

  xfer += oprot->writeFieldBegin("isnull", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->isnull);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.time) {
    xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.txnid) {
    xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->txnid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dbname) {
    xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->dbname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tablename) {
    xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->tablename);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionname) {
    xfer += oprot->writeFieldBegin("partitionname", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->partitionname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BasicTxnInfo &a, BasicTxnInfo &b) {
  using ::std::swap;
  swap(a.isnull, b.isnull);
  swap(a.time, b.time);
  swap(a.txnid, b.txnid);
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionname, b.partitionname);
  swap(a.__isset, b.__isset);
}

BasicTxnInfo::BasicTxnInfo(const BasicTxnInfo& other1015) {
  isnull = other1015.isnull;
  time = other1015.time;
  txnid = other1015.txnid;
  dbname = other1015.dbname;
  tablename = other1015.tablename;
  partitionname = other1015.partitionname;
  __isset = other1015.__isset;
}
BasicTxnInfo& BasicTxnInfo::operator=(const BasicTxnInfo& other1016) {
  isnull = other1016.isnull;
  time = other1016.time;
  txnid = other1016.txnid;
  dbname = other1016.dbname;
  tablename = other1016.tablename;
  partitionname = other1016.partitionname;
  __isset = other1016.__isset;
  return *this;
}
void BasicTxnInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BasicTxnInfo(";
  out << "isnull=" << to_string(isnull);
  out << ", " << "time="; (__isset.time ? (out << to_string(time)) : (out << "<null>"));
  out << ", " << "txnid="; (__isset.txnid ? (out << to_string(txnid)) : (out << "<null>"));
  out << ", " << "dbname="; (__isset.dbname ? (out << to_string(dbname)) : (out << "<null>"));
  out << ", " << "tablename="; (__isset.tablename ? (out << to_string(tablename)) : (out << "<null>"));
  out << ", " << "partitionname="; (__isset.partitionname ? (out << to_string(partitionname)) : (out << "<null>"));
  out << ")";
}


NotificationEventRequest::~NotificationEventRequest() noexcept {
}


void NotificationEventRequest::__set_lastEvent(const int64_t val) {
  this->lastEvent = val;
}

void NotificationEventRequest::__set_maxEvents(const int32_t val) {
  this->maxEvents = val;
__isset.maxEvents = true;
}

void NotificationEventRequest::__set_eventTypeSkipList(const std::vector<std::string> & val) {
  this->eventTypeSkipList = val;
__isset.eventTypeSkipList = true;
}
std::ostream& operator<<(std::ostream& out, const NotificationEventRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotificationEventRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lastEvent = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastEvent);
          isset_lastEvent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxEvents);
          this->__isset.maxEvents = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->eventTypeSkipList.clear();
            uint32_t _size1017;
            ::apache::thrift::protocol::TType _etype1020;
            xfer += iprot->readListBegin(_etype1020, _size1017);
            this->eventTypeSkipList.resize(_size1017);
            uint32_t _i1021;
            for (_i1021 = 0; _i1021 < _size1017; ++_i1021)
            {
              xfer += iprot->readString(this->eventTypeSkipList[_i1021]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.eventTypeSkipList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lastEvent)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotificationEventRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotificationEventRequest");

  xfer += oprot->writeFieldBegin("lastEvent", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lastEvent);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.maxEvents) {
    xfer += oprot->writeFieldBegin("maxEvents", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->maxEvents);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.eventTypeSkipList) {
    xfer += oprot->writeFieldBegin("eventTypeSkipList", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->eventTypeSkipList.size()));
      std::vector<std::string> ::const_iterator _iter1022;
      for (_iter1022 = this->eventTypeSkipList.begin(); _iter1022 != this->eventTypeSkipList.end(); ++_iter1022)
      {
        xfer += oprot->writeString((*_iter1022));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotificationEventRequest &a, NotificationEventRequest &b) {
  using ::std::swap;
  swap(a.lastEvent, b.lastEvent);
  swap(a.maxEvents, b.maxEvents);
  swap(a.eventTypeSkipList, b.eventTypeSkipList);
  swap(a.__isset, b.__isset);
}

NotificationEventRequest::NotificationEventRequest(const NotificationEventRequest& other1023) {
  lastEvent = other1023.lastEvent;
  maxEvents = other1023.maxEvents;
  eventTypeSkipList = other1023.eventTypeSkipList;
  __isset = other1023.__isset;
}
NotificationEventRequest& NotificationEventRequest::operator=(const NotificationEventRequest& other1024) {
  lastEvent = other1024.lastEvent;
  maxEvents = other1024.maxEvents;
  eventTypeSkipList = other1024.eventTypeSkipList;
  __isset = other1024.__isset;
  return *this;
}
void NotificationEventRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotificationEventRequest(";
  out << "lastEvent=" << to_string(lastEvent);
  out << ", " << "maxEvents="; (__isset.maxEvents ? (out << to_string(maxEvents)) : (out << "<null>"));
  out << ", " << "eventTypeSkipList="; (__isset.eventTypeSkipList ? (out << to_string(eventTypeSkipList)) : (out << "<null>"));
  out << ")";
}


NotificationEvent::~NotificationEvent() noexcept {
}


void NotificationEvent::__set_eventId(const int64_t val) {
  this->eventId = val;
}

void NotificationEvent::__set_eventTime(const int32_t val) {
  this->eventTime = val;
}

void NotificationEvent::__set_eventType(const std::string& val) {
  this->eventType = val;
}

void NotificationEvent::__set_dbName(const std::string& val) {
  this->dbName = val;
__isset.dbName = true;
}

void NotificationEvent::__set_tableName(const std::string& val) {
  this->tableName = val;
__isset.tableName = true;
}

void NotificationEvent::__set_message(const std::string& val) {
  this->message = val;
}

void NotificationEvent::__set_messageFormat(const std::string& val) {
  this->messageFormat = val;
__isset.messageFormat = true;
}

void NotificationEvent::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}
std::ostream& operator<<(std::ostream& out, const NotificationEvent& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotificationEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_eventId = false;
  bool isset_eventTime = false;
  bool isset_eventType = false;
  bool isset_message = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->eventId);
          isset_eventId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->eventTime);
          isset_eventTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->eventType);
          isset_eventType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          isset_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->messageFormat);
          this->__isset.messageFormat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_eventId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_eventTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_eventType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_message)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotificationEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotificationEvent");

  xfer += oprot->writeFieldBegin("eventId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->eventId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eventTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->eventTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eventType", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->eventType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dbName) {
    xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->dbName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableName) {
    xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->tableName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.messageFormat) {
    xfer += oprot->writeFieldBegin("messageFormat", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->messageFormat);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotificationEvent &a, NotificationEvent &b) {
  using ::std::swap;
  swap(a.eventId, b.eventId);
  swap(a.eventTime, b.eventTime);
  swap(a.eventType, b.eventType);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.message, b.message);
  swap(a.messageFormat, b.messageFormat);
  swap(a.catName, b.catName);
  swap(a.__isset, b.__isset);
}

NotificationEvent::NotificationEvent(const NotificationEvent& other1025) {
  eventId = other1025.eventId;
  eventTime = other1025.eventTime;
  eventType = other1025.eventType;
  dbName = other1025.dbName;
  tableName = other1025.tableName;
  message = other1025.message;
  messageFormat = other1025.messageFormat;
  catName = other1025.catName;
  __isset = other1025.__isset;
}
NotificationEvent& NotificationEvent::operator=(const NotificationEvent& other1026) {
  eventId = other1026.eventId;
  eventTime = other1026.eventTime;
  eventType = other1026.eventType;
  dbName = other1026.dbName;
  tableName = other1026.tableName;
  message = other1026.message;
  messageFormat = other1026.messageFormat;
  catName = other1026.catName;
  __isset = other1026.__isset;
  return *this;
}
void NotificationEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotificationEvent(";
  out << "eventId=" << to_string(eventId);
  out << ", " << "eventTime=" << to_string(eventTime);
  out << ", " << "eventType=" << to_string(eventType);
  out << ", " << "dbName="; (__isset.dbName ? (out << to_string(dbName)) : (out << "<null>"));
  out << ", " << "tableName="; (__isset.tableName ? (out << to_string(tableName)) : (out << "<null>"));
  out << ", " << "message=" << to_string(message);
  out << ", " << "messageFormat="; (__isset.messageFormat ? (out << to_string(messageFormat)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ")";
}


NotificationEventResponse::~NotificationEventResponse() noexcept {
}


void NotificationEventResponse::__set_events(const std::vector<NotificationEvent> & val) {
  this->events = val;
}
std::ostream& operator<<(std::ostream& out, const NotificationEventResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotificationEventResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_events = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->events.clear();
            uint32_t _size1027;
            ::apache::thrift::protocol::TType _etype1030;
            xfer += iprot->readListBegin(_etype1030, _size1027);
            this->events.resize(_size1027);
            uint32_t _i1031;
            for (_i1031 = 0; _i1031 < _size1027; ++_i1031)
            {
              xfer += this->events[_i1031].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_events = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_events)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotificationEventResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotificationEventResponse");

  xfer += oprot->writeFieldBegin("events", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->events.size()));
    std::vector<NotificationEvent> ::const_iterator _iter1032;
    for (_iter1032 = this->events.begin(); _iter1032 != this->events.end(); ++_iter1032)
    {
      xfer += (*_iter1032).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotificationEventResponse &a, NotificationEventResponse &b) {
  using ::std::swap;
  swap(a.events, b.events);
}

NotificationEventResponse::NotificationEventResponse(const NotificationEventResponse& other1033) {
  events = other1033.events;
}
NotificationEventResponse& NotificationEventResponse::operator=(const NotificationEventResponse& other1034) {
  events = other1034.events;
  return *this;
}
void NotificationEventResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotificationEventResponse(";
  out << "events=" << to_string(events);
  out << ")";
}


CurrentNotificationEventId::~CurrentNotificationEventId() noexcept {
}


void CurrentNotificationEventId::__set_eventId(const int64_t val) {
  this->eventId = val;
}
std::ostream& operator<<(std::ostream& out, const CurrentNotificationEventId& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CurrentNotificationEventId::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_eventId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->eventId);
          isset_eventId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_eventId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CurrentNotificationEventId::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CurrentNotificationEventId");

  xfer += oprot->writeFieldBegin("eventId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->eventId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CurrentNotificationEventId &a, CurrentNotificationEventId &b) {
  using ::std::swap;
  swap(a.eventId, b.eventId);
}

CurrentNotificationEventId::CurrentNotificationEventId(const CurrentNotificationEventId& other1035) {
  eventId = other1035.eventId;
}
CurrentNotificationEventId& CurrentNotificationEventId::operator=(const CurrentNotificationEventId& other1036) {
  eventId = other1036.eventId;
  return *this;
}
void CurrentNotificationEventId::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CurrentNotificationEventId(";
  out << "eventId=" << to_string(eventId);
  out << ")";
}


NotificationEventsCountRequest::~NotificationEventsCountRequest() noexcept {
}


void NotificationEventsCountRequest::__set_fromEventId(const int64_t val) {
  this->fromEventId = val;
}

void NotificationEventsCountRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void NotificationEventsCountRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void NotificationEventsCountRequest::__set_toEventId(const int64_t val) {
  this->toEventId = val;
__isset.toEventId = true;
}

void NotificationEventsCountRequest::__set_limit(const int64_t val) {
  this->limit = val;
__isset.limit = true;
}
std::ostream& operator<<(std::ostream& out, const NotificationEventsCountRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotificationEventsCountRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fromEventId = false;
  bool isset_dbName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->fromEventId);
          isset_fromEventId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->toEventId);
          this->__isset.toEventId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fromEventId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotificationEventsCountRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotificationEventsCountRequest");

  xfer += oprot->writeFieldBegin("fromEventId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->fromEventId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.toEventId) {
    xfer += oprot->writeFieldBegin("toEventId", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->toEventId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.limit) {
    xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->limit);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotificationEventsCountRequest &a, NotificationEventsCountRequest &b) {
  using ::std::swap;
  swap(a.fromEventId, b.fromEventId);
  swap(a.dbName, b.dbName);
  swap(a.catName, b.catName);
  swap(a.toEventId, b.toEventId);
  swap(a.limit, b.limit);
  swap(a.__isset, b.__isset);
}

NotificationEventsCountRequest::NotificationEventsCountRequest(const NotificationEventsCountRequest& other1037) {
  fromEventId = other1037.fromEventId;
  dbName = other1037.dbName;
  catName = other1037.catName;
  toEventId = other1037.toEventId;
  limit = other1037.limit;
  __isset = other1037.__isset;
}
NotificationEventsCountRequest& NotificationEventsCountRequest::operator=(const NotificationEventsCountRequest& other1038) {
  fromEventId = other1038.fromEventId;
  dbName = other1038.dbName;
  catName = other1038.catName;
  toEventId = other1038.toEventId;
  limit = other1038.limit;
  __isset = other1038.__isset;
  return *this;
}
void NotificationEventsCountRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotificationEventsCountRequest(";
  out << "fromEventId=" << to_string(fromEventId);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "toEventId="; (__isset.toEventId ? (out << to_string(toEventId)) : (out << "<null>"));
  out << ", " << "limit="; (__isset.limit ? (out << to_string(limit)) : (out << "<null>"));
  out << ")";
}


NotificationEventsCountResponse::~NotificationEventsCountResponse() noexcept {
}


void NotificationEventsCountResponse::__set_eventsCount(const int64_t val) {
  this->eventsCount = val;
}
std::ostream& operator<<(std::ostream& out, const NotificationEventsCountResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotificationEventsCountResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_eventsCount = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->eventsCount);
          isset_eventsCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_eventsCount)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotificationEventsCountResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotificationEventsCountResponse");

  xfer += oprot->writeFieldBegin("eventsCount", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->eventsCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotificationEventsCountResponse &a, NotificationEventsCountResponse &b) {
  using ::std::swap;
  swap(a.eventsCount, b.eventsCount);
}

NotificationEventsCountResponse::NotificationEventsCountResponse(const NotificationEventsCountResponse& other1039) {
  eventsCount = other1039.eventsCount;
}
NotificationEventsCountResponse& NotificationEventsCountResponse::operator=(const NotificationEventsCountResponse& other1040) {
  eventsCount = other1040.eventsCount;
  return *this;
}
void NotificationEventsCountResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotificationEventsCountResponse(";
  out << "eventsCount=" << to_string(eventsCount);
  out << ")";
}


InsertEventRequestData::~InsertEventRequestData() noexcept {
}


void InsertEventRequestData::__set_replace(const bool val) {
  this->replace = val;
__isset.replace = true;
}

void InsertEventRequestData::__set_filesAdded(const std::vector<std::string> & val) {
  this->filesAdded = val;
}

void InsertEventRequestData::__set_filesAddedChecksum(const std::vector<std::string> & val) {
  this->filesAddedChecksum = val;
__isset.filesAddedChecksum = true;
}

void InsertEventRequestData::__set_subDirectoryList(const std::vector<std::string> & val) {
  this->subDirectoryList = val;
__isset.subDirectoryList = true;
}

void InsertEventRequestData::__set_partitionVal(const std::vector<std::string> & val) {
  this->partitionVal = val;
__isset.partitionVal = true;
}
std::ostream& operator<<(std::ostream& out, const InsertEventRequestData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InsertEventRequestData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_filesAdded = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->replace);
          this->__isset.replace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->filesAdded.clear();
            uint32_t _size1041;
            ::apache::thrift::protocol::TType _etype1044;
            xfer += iprot->readListBegin(_etype1044, _size1041);
            this->filesAdded.resize(_size1041);
            uint32_t _i1045;
            for (_i1045 = 0; _i1045 < _size1041; ++_i1045)
            {
              xfer += iprot->readString(this->filesAdded[_i1045]);
            }
            xfer += iprot->readListEnd();
          }
          isset_filesAdded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->filesAddedChecksum.clear();
            uint32_t _size1046;
            ::apache::thrift::protocol::TType _etype1049;
            xfer += iprot->readListBegin(_etype1049, _size1046);
            this->filesAddedChecksum.resize(_size1046);
            uint32_t _i1050;
            for (_i1050 = 0; _i1050 < _size1046; ++_i1050)
            {
              xfer += iprot->readString(this->filesAddedChecksum[_i1050]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.filesAddedChecksum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->subDirectoryList.clear();
            uint32_t _size1051;
            ::apache::thrift::protocol::TType _etype1054;
            xfer += iprot->readListBegin(_etype1054, _size1051);
            this->subDirectoryList.resize(_size1051);
            uint32_t _i1055;
            for (_i1055 = 0; _i1055 < _size1051; ++_i1055)
            {
              xfer += iprot->readString(this->subDirectoryList[_i1055]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.subDirectoryList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionVal.clear();
            uint32_t _size1056;
            ::apache::thrift::protocol::TType _etype1059;
            xfer += iprot->readListBegin(_etype1059, _size1056);
            this->partitionVal.resize(_size1056);
            uint32_t _i1060;
            for (_i1060 = 0; _i1060 < _size1056; ++_i1060)
            {
              xfer += iprot->readString(this->partitionVal[_i1060]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_filesAdded)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InsertEventRequestData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InsertEventRequestData");

  if (this->__isset.replace) {
    xfer += oprot->writeFieldBegin("replace", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->replace);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("filesAdded", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->filesAdded.size()));
    std::vector<std::string> ::const_iterator _iter1061;
    for (_iter1061 = this->filesAdded.begin(); _iter1061 != this->filesAdded.end(); ++_iter1061)
    {
      xfer += oprot->writeString((*_iter1061));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.filesAddedChecksum) {
    xfer += oprot->writeFieldBegin("filesAddedChecksum", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->filesAddedChecksum.size()));
      std::vector<std::string> ::const_iterator _iter1062;
      for (_iter1062 = this->filesAddedChecksum.begin(); _iter1062 != this->filesAddedChecksum.end(); ++_iter1062)
      {
        xfer += oprot->writeString((*_iter1062));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subDirectoryList) {
    xfer += oprot->writeFieldBegin("subDirectoryList", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->subDirectoryList.size()));
      std::vector<std::string> ::const_iterator _iter1063;
      for (_iter1063 = this->subDirectoryList.begin(); _iter1063 != this->subDirectoryList.end(); ++_iter1063)
      {
        xfer += oprot->writeString((*_iter1063));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionVal) {
    xfer += oprot->writeFieldBegin("partitionVal", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partitionVal.size()));
      std::vector<std::string> ::const_iterator _iter1064;
      for (_iter1064 = this->partitionVal.begin(); _iter1064 != this->partitionVal.end(); ++_iter1064)
      {
        xfer += oprot->writeString((*_iter1064));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InsertEventRequestData &a, InsertEventRequestData &b) {
  using ::std::swap;
  swap(a.replace, b.replace);
  swap(a.filesAdded, b.filesAdded);
  swap(a.filesAddedChecksum, b.filesAddedChecksum);
  swap(a.subDirectoryList, b.subDirectoryList);
  swap(a.partitionVal, b.partitionVal);
  swap(a.__isset, b.__isset);
}

InsertEventRequestData::InsertEventRequestData(const InsertEventRequestData& other1065) {
  replace = other1065.replace;
  filesAdded = other1065.filesAdded;
  filesAddedChecksum = other1065.filesAddedChecksum;
  subDirectoryList = other1065.subDirectoryList;
  partitionVal = other1065.partitionVal;
  __isset = other1065.__isset;
}
InsertEventRequestData& InsertEventRequestData::operator=(const InsertEventRequestData& other1066) {
  replace = other1066.replace;
  filesAdded = other1066.filesAdded;
  filesAddedChecksum = other1066.filesAddedChecksum;
  subDirectoryList = other1066.subDirectoryList;
  partitionVal = other1066.partitionVal;
  __isset = other1066.__isset;
  return *this;
}
void InsertEventRequestData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InsertEventRequestData(";
  out << "replace="; (__isset.replace ? (out << to_string(replace)) : (out << "<null>"));
  out << ", " << "filesAdded=" << to_string(filesAdded);
  out << ", " << "filesAddedChecksum="; (__isset.filesAddedChecksum ? (out << to_string(filesAddedChecksum)) : (out << "<null>"));
  out << ", " << "subDirectoryList="; (__isset.subDirectoryList ? (out << to_string(subDirectoryList)) : (out << "<null>"));
  out << ", " << "partitionVal="; (__isset.partitionVal ? (out << to_string(partitionVal)) : (out << "<null>"));
  out << ")";
}


FireEventRequestData::~FireEventRequestData() noexcept {
}


void FireEventRequestData::__set_insertData(const InsertEventRequestData& val) {
  this->insertData = val;
__isset.insertData = true;
}

void FireEventRequestData::__set_insertDatas(const std::vector<InsertEventRequestData> & val) {
  this->insertDatas = val;
__isset.insertDatas = true;
}
std::ostream& operator<<(std::ostream& out, const FireEventRequestData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FireEventRequestData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->insertData.read(iprot);
          this->__isset.insertData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->insertDatas.clear();
            uint32_t _size1067;
            ::apache::thrift::protocol::TType _etype1070;
            xfer += iprot->readListBegin(_etype1070, _size1067);
            this->insertDatas.resize(_size1067);
            uint32_t _i1071;
            for (_i1071 = 0; _i1071 < _size1067; ++_i1071)
            {
              xfer += this->insertDatas[_i1071].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.insertDatas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FireEventRequestData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FireEventRequestData");

  if (this->__isset.insertData) {
    xfer += oprot->writeFieldBegin("insertData", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->insertData.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.insertDatas) {
    xfer += oprot->writeFieldBegin("insertDatas", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->insertDatas.size()));
      std::vector<InsertEventRequestData> ::const_iterator _iter1072;
      for (_iter1072 = this->insertDatas.begin(); _iter1072 != this->insertDatas.end(); ++_iter1072)
      {
        xfer += (*_iter1072).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FireEventRequestData &a, FireEventRequestData &b) {
  using ::std::swap;
  swap(a.insertData, b.insertData);
  swap(a.insertDatas, b.insertDatas);
  swap(a.__isset, b.__isset);
}

FireEventRequestData::FireEventRequestData(const FireEventRequestData& other1073) {
  insertData = other1073.insertData;
  insertDatas = other1073.insertDatas;
  __isset = other1073.__isset;
}
FireEventRequestData& FireEventRequestData::operator=(const FireEventRequestData& other1074) {
  insertData = other1074.insertData;
  insertDatas = other1074.insertDatas;
  __isset = other1074.__isset;
  return *this;
}
void FireEventRequestData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FireEventRequestData(";
  out << "insertData="; (__isset.insertData ? (out << to_string(insertData)) : (out << "<null>"));
  out << ", " << "insertDatas="; (__isset.insertDatas ? (out << to_string(insertDatas)) : (out << "<null>"));
  out << ")";
}


FireEventRequest::~FireEventRequest() noexcept {
}


void FireEventRequest::__set_successful(const bool val) {
  this->successful = val;
}

void FireEventRequest::__set_data(const FireEventRequestData& val) {
  this->data = val;
}

void FireEventRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
__isset.dbName = true;
}

void FireEventRequest::__set_tableName(const std::string& val) {
  this->tableName = val;
__isset.tableName = true;
}

void FireEventRequest::__set_partitionVals(const std::vector<std::string> & val) {
  this->partitionVals = val;
__isset.partitionVals = true;
}

void FireEventRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}
std::ostream& operator<<(std::ostream& out, const FireEventRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FireEventRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_successful = false;
  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->successful);
          isset_successful = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionVals.clear();
            uint32_t _size1075;
            ::apache::thrift::protocol::TType _etype1078;
            xfer += iprot->readListBegin(_etype1078, _size1075);
            this->partitionVals.resize(_size1075);
            uint32_t _i1079;
            for (_i1079 = 0; _i1079 < _size1075; ++_i1079)
            {
              xfer += iprot->readString(this->partitionVals[_i1079]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionVals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_successful)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t FireEventRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FireEventRequest");

  xfer += oprot->writeFieldBegin("successful", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->successful);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dbName) {
    xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->dbName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableName) {
    xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->tableName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionVals) {
    xfer += oprot->writeFieldBegin("partitionVals", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partitionVals.size()));
      std::vector<std::string> ::const_iterator _iter1080;
      for (_iter1080 = this->partitionVals.begin(); _iter1080 != this->partitionVals.end(); ++_iter1080)
      {
        xfer += oprot->writeString((*_iter1080));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FireEventRequest &a, FireEventRequest &b) {
  using ::std::swap;
  swap(a.successful, b.successful);
  swap(a.data, b.data);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.partitionVals, b.partitionVals);
  swap(a.catName, b.catName);
  swap(a.__isset, b.__isset);
}

FireEventRequest::FireEventRequest(const FireEventRequest& other1081) {
  successful = other1081.successful;
  data = other1081.data;
  dbName = other1081.dbName;
  tableName = other1081.tableName;
  partitionVals = other1081.partitionVals;
  catName = other1081.catName;
  __isset = other1081.__isset;
}
FireEventRequest& FireEventRequest::operator=(const FireEventRequest& other1082) {
  successful = other1082.successful;
  data = other1082.data;
  dbName = other1082.dbName;
  tableName = other1082.tableName;
  partitionVals = other1082.partitionVals;
  catName = other1082.catName;
  __isset = other1082.__isset;
  return *this;
}
void FireEventRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FireEventRequest(";
  out << "successful=" << to_string(successful);
  out << ", " << "data=" << to_string(data);
  out << ", " << "dbName="; (__isset.dbName ? (out << to_string(dbName)) : (out << "<null>"));
  out << ", " << "tableName="; (__isset.tableName ? (out << to_string(tableName)) : (out << "<null>"));
  out << ", " << "partitionVals="; (__isset.partitionVals ? (out << to_string(partitionVals)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ")";
}


FireEventResponse::~FireEventResponse() noexcept {
}


void FireEventResponse::__set_eventIds(const std::vector<int64_t> & val) {
  this->eventIds = val;
}
std::ostream& operator<<(std::ostream& out, const FireEventResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FireEventResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->eventIds.clear();
            uint32_t _size1083;
            ::apache::thrift::protocol::TType _etype1086;
            xfer += iprot->readListBegin(_etype1086, _size1083);
            this->eventIds.resize(_size1083);
            uint32_t _i1087;
            for (_i1087 = 0; _i1087 < _size1083; ++_i1087)
            {
              xfer += iprot->readI64(this->eventIds[_i1087]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.eventIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FireEventResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FireEventResponse");

  xfer += oprot->writeFieldBegin("eventIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->eventIds.size()));
    std::vector<int64_t> ::const_iterator _iter1088;
    for (_iter1088 = this->eventIds.begin(); _iter1088 != this->eventIds.end(); ++_iter1088)
    {
      xfer += oprot->writeI64((*_iter1088));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FireEventResponse &a, FireEventResponse &b) {
  using ::std::swap;
  swap(a.eventIds, b.eventIds);
  swap(a.__isset, b.__isset);
}

FireEventResponse::FireEventResponse(const FireEventResponse& other1089) {
  eventIds = other1089.eventIds;
  __isset = other1089.__isset;
}
FireEventResponse& FireEventResponse::operator=(const FireEventResponse& other1090) {
  eventIds = other1090.eventIds;
  __isset = other1090.__isset;
  return *this;
}
void FireEventResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FireEventResponse(";
  out << "eventIds=" << to_string(eventIds);
  out << ")";
}


WriteNotificationLogRequest::~WriteNotificationLogRequest() noexcept {
}


void WriteNotificationLogRequest::__set_txnId(const int64_t val) {
  this->txnId = val;
}

void WriteNotificationLogRequest::__set_writeId(const int64_t val) {
  this->writeId = val;
}

void WriteNotificationLogRequest::__set_db(const std::string& val) {
  this->db = val;
}

void WriteNotificationLogRequest::__set_table(const std::string& val) {
  this->table = val;
}

void WriteNotificationLogRequest::__set_fileInfo(const InsertEventRequestData& val) {
  this->fileInfo = val;
}

void WriteNotificationLogRequest::__set_partitionVals(const std::vector<std::string> & val) {
  this->partitionVals = val;
__isset.partitionVals = true;
}
std::ostream& operator<<(std::ostream& out, const WriteNotificationLogRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WriteNotificationLogRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txnId = false;
  bool isset_writeId = false;
  bool isset_db = false;
  bool isset_table = false;
  bool isset_fileInfo = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnId);
          isset_txnId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          isset_writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          isset_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table);
          isset_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fileInfo.read(iprot);
          isset_fileInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionVals.clear();
            uint32_t _size1091;
            ::apache::thrift::protocol::TType _etype1094;
            xfer += iprot->readListBegin(_etype1094, _size1091);
            this->partitionVals.resize(_size1091);
            uint32_t _i1095;
            for (_i1095 = 0; _i1095 < _size1091; ++_i1095)
            {
              xfer += iprot->readString(this->partitionVals[_i1095]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionVals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txnId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_writeId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fileInfo)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WriteNotificationLogRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WriteNotificationLogRequest");

  xfer += oprot->writeFieldBegin("txnId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txnId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->writeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->table);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fileInfo", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->fileInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partitionVals) {
    xfer += oprot->writeFieldBegin("partitionVals", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partitionVals.size()));
      std::vector<std::string> ::const_iterator _iter1096;
      for (_iter1096 = this->partitionVals.begin(); _iter1096 != this->partitionVals.end(); ++_iter1096)
      {
        xfer += oprot->writeString((*_iter1096));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WriteNotificationLogRequest &a, WriteNotificationLogRequest &b) {
  using ::std::swap;
  swap(a.txnId, b.txnId);
  swap(a.writeId, b.writeId);
  swap(a.db, b.db);
  swap(a.table, b.table);
  swap(a.fileInfo, b.fileInfo);
  swap(a.partitionVals, b.partitionVals);
  swap(a.__isset, b.__isset);
}

WriteNotificationLogRequest::WriteNotificationLogRequest(const WriteNotificationLogRequest& other1097) {
  txnId = other1097.txnId;
  writeId = other1097.writeId;
  db = other1097.db;
  table = other1097.table;
  fileInfo = other1097.fileInfo;
  partitionVals = other1097.partitionVals;
  __isset = other1097.__isset;
}
WriteNotificationLogRequest& WriteNotificationLogRequest::operator=(const WriteNotificationLogRequest& other1098) {
  txnId = other1098.txnId;
  writeId = other1098.writeId;
  db = other1098.db;
  table = other1098.table;
  fileInfo = other1098.fileInfo;
  partitionVals = other1098.partitionVals;
  __isset = other1098.__isset;
  return *this;
}
void WriteNotificationLogRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WriteNotificationLogRequest(";
  out << "txnId=" << to_string(txnId);
  out << ", " << "writeId=" << to_string(writeId);
  out << ", " << "db=" << to_string(db);
  out << ", " << "table=" << to_string(table);
  out << ", " << "fileInfo=" << to_string(fileInfo);
  out << ", " << "partitionVals="; (__isset.partitionVals ? (out << to_string(partitionVals)) : (out << "<null>"));
  out << ")";
}


WriteNotificationLogResponse::~WriteNotificationLogResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WriteNotificationLogResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WriteNotificationLogResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WriteNotificationLogResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WriteNotificationLogResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WriteNotificationLogResponse &a, WriteNotificationLogResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WriteNotificationLogResponse::WriteNotificationLogResponse(const WriteNotificationLogResponse& other1099) {
  (void) other1099;
}
WriteNotificationLogResponse& WriteNotificationLogResponse::operator=(const WriteNotificationLogResponse& other1100) {
  (void) other1100;
  return *this;
}
void WriteNotificationLogResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WriteNotificationLogResponse(";
  out << ")";
}


MetadataPpdResult::~MetadataPpdResult() noexcept {
}


void MetadataPpdResult::__set_metadata(const std::string& val) {
  this->metadata = val;
__isset.metadata = true;
}

void MetadataPpdResult::__set_includeBitset(const std::string& val) {
  this->includeBitset = val;
__isset.includeBitset = true;
}
std::ostream& operator<<(std::ostream& out, const MetadataPpdResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MetadataPpdResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->metadata);
          this->__isset.metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->includeBitset);
          this->__isset.includeBitset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MetadataPpdResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MetadataPpdResult");

  if (this->__isset.metadata) {
    xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->metadata);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeBitset) {
    xfer += oprot->writeFieldBegin("includeBitset", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->includeBitset);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MetadataPpdResult &a, MetadataPpdResult &b) {
  using ::std::swap;
  swap(a.metadata, b.metadata);
  swap(a.includeBitset, b.includeBitset);
  swap(a.__isset, b.__isset);
}

MetadataPpdResult::MetadataPpdResult(const MetadataPpdResult& other1101) {
  metadata = other1101.metadata;
  includeBitset = other1101.includeBitset;
  __isset = other1101.__isset;
}
MetadataPpdResult& MetadataPpdResult::operator=(const MetadataPpdResult& other1102) {
  metadata = other1102.metadata;
  includeBitset = other1102.includeBitset;
  __isset = other1102.__isset;
  return *this;
}
void MetadataPpdResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MetadataPpdResult(";
  out << "metadata="; (__isset.metadata ? (out << to_string(metadata)) : (out << "<null>"));
  out << ", " << "includeBitset="; (__isset.includeBitset ? (out << to_string(includeBitset)) : (out << "<null>"));
  out << ")";
}


GetFileMetadataByExprResult::~GetFileMetadataByExprResult() noexcept {
}


void GetFileMetadataByExprResult::__set_metadata(const std::map<int64_t, MetadataPpdResult> & val) {
  this->metadata = val;
}

void GetFileMetadataByExprResult::__set_isSupported(const bool val) {
  this->isSupported = val;
}
std::ostream& operator<<(std::ostream& out, const GetFileMetadataByExprResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetFileMetadataByExprResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_metadata = false;
  bool isset_isSupported = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size1103;
            ::apache::thrift::protocol::TType _ktype1104;
            ::apache::thrift::protocol::TType _vtype1105;
            xfer += iprot->readMapBegin(_ktype1104, _vtype1105, _size1103);
            uint32_t _i1107;
            for (_i1107 = 0; _i1107 < _size1103; ++_i1107)
            {
              int64_t _key1108;
              xfer += iprot->readI64(_key1108);
              MetadataPpdResult& _val1109 = this->metadata[_key1108];
              xfer += _val1109.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isSupported);
          isset_isSupported = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isSupported)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetFileMetadataByExprResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetFileMetadataByExprResult");

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->metadata.size()));
    std::map<int64_t, MetadataPpdResult> ::const_iterator _iter1110;
    for (_iter1110 = this->metadata.begin(); _iter1110 != this->metadata.end(); ++_iter1110)
    {
      xfer += oprot->writeI64(_iter1110->first);
      xfer += _iter1110->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isSupported", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->isSupported);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetFileMetadataByExprResult &a, GetFileMetadataByExprResult &b) {
  using ::std::swap;
  swap(a.metadata, b.metadata);
  swap(a.isSupported, b.isSupported);
}

GetFileMetadataByExprResult::GetFileMetadataByExprResult(const GetFileMetadataByExprResult& other1111) {
  metadata = other1111.metadata;
  isSupported = other1111.isSupported;
}
GetFileMetadataByExprResult& GetFileMetadataByExprResult::operator=(const GetFileMetadataByExprResult& other1112) {
  metadata = other1112.metadata;
  isSupported = other1112.isSupported;
  return *this;
}
void GetFileMetadataByExprResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetFileMetadataByExprResult(";
  out << "metadata=" << to_string(metadata);
  out << ", " << "isSupported=" << to_string(isSupported);
  out << ")";
}


GetFileMetadataByExprRequest::~GetFileMetadataByExprRequest() noexcept {
}


void GetFileMetadataByExprRequest::__set_fileIds(const std::vector<int64_t> & val) {
  this->fileIds = val;
}

void GetFileMetadataByExprRequest::__set_expr(const std::string& val) {
  this->expr = val;
}

void GetFileMetadataByExprRequest::__set_doGetFooters(const bool val) {
  this->doGetFooters = val;
__isset.doGetFooters = true;
}

void GetFileMetadataByExprRequest::__set_type(const FileMetadataExprType::type val) {
  this->type = val;
__isset.type = true;
}
std::ostream& operator<<(std::ostream& out, const GetFileMetadataByExprRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetFileMetadataByExprRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fileIds = false;
  bool isset_expr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fileIds.clear();
            uint32_t _size1113;
            ::apache::thrift::protocol::TType _etype1116;
            xfer += iprot->readListBegin(_etype1116, _size1113);
            this->fileIds.resize(_size1113);
            uint32_t _i1117;
            for (_i1117 = 0; _i1117 < _size1113; ++_i1117)
            {
              xfer += iprot->readI64(this->fileIds[_i1117]);
            }
            xfer += iprot->readListEnd();
          }
          isset_fileIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->expr);
          isset_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->doGetFooters);
          this->__isset.doGetFooters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1118;
          xfer += iprot->readI32(ecast1118);
          this->type = (FileMetadataExprType::type)ecast1118;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fileIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_expr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetFileMetadataByExprRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetFileMetadataByExprRequest");

  xfer += oprot->writeFieldBegin("fileIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->fileIds.size()));
    std::vector<int64_t> ::const_iterator _iter1119;
    for (_iter1119 = this->fileIds.begin(); _iter1119 != this->fileIds.end(); ++_iter1119)
    {
      xfer += oprot->writeI64((*_iter1119));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->expr);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.doGetFooters) {
    xfer += oprot->writeFieldBegin("doGetFooters", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->doGetFooters);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetFileMetadataByExprRequest &a, GetFileMetadataByExprRequest &b) {
  using ::std::swap;
  swap(a.fileIds, b.fileIds);
  swap(a.expr, b.expr);
  swap(a.doGetFooters, b.doGetFooters);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

GetFileMetadataByExprRequest::GetFileMetadataByExprRequest(const GetFileMetadataByExprRequest& other1120) {
  fileIds = other1120.fileIds;
  expr = other1120.expr;
  doGetFooters = other1120.doGetFooters;
  type = other1120.type;
  __isset = other1120.__isset;
}
GetFileMetadataByExprRequest& GetFileMetadataByExprRequest::operator=(const GetFileMetadataByExprRequest& other1121) {
  fileIds = other1121.fileIds;
  expr = other1121.expr;
  doGetFooters = other1121.doGetFooters;
  type = other1121.type;
  __isset = other1121.__isset;
  return *this;
}
void GetFileMetadataByExprRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetFileMetadataByExprRequest(";
  out << "fileIds=" << to_string(fileIds);
  out << ", " << "expr=" << to_string(expr);
  out << ", " << "doGetFooters="; (__isset.doGetFooters ? (out << to_string(doGetFooters)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ")";
}


GetFileMetadataResult::~GetFileMetadataResult() noexcept {
}


void GetFileMetadataResult::__set_metadata(const std::map<int64_t, std::string> & val) {
  this->metadata = val;
}

void GetFileMetadataResult::__set_isSupported(const bool val) {
  this->isSupported = val;
}
std::ostream& operator<<(std::ostream& out, const GetFileMetadataResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetFileMetadataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_metadata = false;
  bool isset_isSupported = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size1122;
            ::apache::thrift::protocol::TType _ktype1123;
            ::apache::thrift::protocol::TType _vtype1124;
            xfer += iprot->readMapBegin(_ktype1123, _vtype1124, _size1122);
            uint32_t _i1126;
            for (_i1126 = 0; _i1126 < _size1122; ++_i1126)
            {
              int64_t _key1127;
              xfer += iprot->readI64(_key1127);
              std::string& _val1128 = this->metadata[_key1127];
              xfer += iprot->readBinary(_val1128);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isSupported);
          isset_isSupported = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isSupported)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetFileMetadataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetFileMetadataResult");

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::map<int64_t, std::string> ::const_iterator _iter1129;
    for (_iter1129 = this->metadata.begin(); _iter1129 != this->metadata.end(); ++_iter1129)
    {
      xfer += oprot->writeI64(_iter1129->first);
      xfer += oprot->writeBinary(_iter1129->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isSupported", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->isSupported);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetFileMetadataResult &a, GetFileMetadataResult &b) {
  using ::std::swap;
  swap(a.metadata, b.metadata);
  swap(a.isSupported, b.isSupported);
}

GetFileMetadataResult::GetFileMetadataResult(const GetFileMetadataResult& other1130) {
  metadata = other1130.metadata;
  isSupported = other1130.isSupported;
}
GetFileMetadataResult& GetFileMetadataResult::operator=(const GetFileMetadataResult& other1131) {
  metadata = other1131.metadata;
  isSupported = other1131.isSupported;
  return *this;
}
void GetFileMetadataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetFileMetadataResult(";
  out << "metadata=" << to_string(metadata);
  out << ", " << "isSupported=" << to_string(isSupported);
  out << ")";
}


GetFileMetadataRequest::~GetFileMetadataRequest() noexcept {
}


void GetFileMetadataRequest::__set_fileIds(const std::vector<int64_t> & val) {
  this->fileIds = val;
}
std::ostream& operator<<(std::ostream& out, const GetFileMetadataRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetFileMetadataRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fileIds = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fileIds.clear();
            uint32_t _size1132;
            ::apache::thrift::protocol::TType _etype1135;
            xfer += iprot->readListBegin(_etype1135, _size1132);
            this->fileIds.resize(_size1132);
            uint32_t _i1136;
            for (_i1136 = 0; _i1136 < _size1132; ++_i1136)
            {
              xfer += iprot->readI64(this->fileIds[_i1136]);
            }
            xfer += iprot->readListEnd();
          }
          isset_fileIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fileIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetFileMetadataRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetFileMetadataRequest");

  xfer += oprot->writeFieldBegin("fileIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->fileIds.size()));
    std::vector<int64_t> ::const_iterator _iter1137;
    for (_iter1137 = this->fileIds.begin(); _iter1137 != this->fileIds.end(); ++_iter1137)
    {
      xfer += oprot->writeI64((*_iter1137));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetFileMetadataRequest &a, GetFileMetadataRequest &b) {
  using ::std::swap;
  swap(a.fileIds, b.fileIds);
}

GetFileMetadataRequest::GetFileMetadataRequest(const GetFileMetadataRequest& other1138) {
  fileIds = other1138.fileIds;
}
GetFileMetadataRequest& GetFileMetadataRequest::operator=(const GetFileMetadataRequest& other1139) {
  fileIds = other1139.fileIds;
  return *this;
}
void GetFileMetadataRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetFileMetadataRequest(";
  out << "fileIds=" << to_string(fileIds);
  out << ")";
}


PutFileMetadataResult::~PutFileMetadataResult() noexcept {
}

std::ostream& operator<<(std::ostream& out, const PutFileMetadataResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PutFileMetadataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PutFileMetadataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PutFileMetadataResult");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PutFileMetadataResult &a, PutFileMetadataResult &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

PutFileMetadataResult::PutFileMetadataResult(const PutFileMetadataResult& other1140) {
  (void) other1140;
}
PutFileMetadataResult& PutFileMetadataResult::operator=(const PutFileMetadataResult& other1141) {
  (void) other1141;
  return *this;
}
void PutFileMetadataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PutFileMetadataResult(";
  out << ")";
}


PutFileMetadataRequest::~PutFileMetadataRequest() noexcept {
}


void PutFileMetadataRequest::__set_fileIds(const std::vector<int64_t> & val) {
  this->fileIds = val;
}

void PutFileMetadataRequest::__set_metadata(const std::vector<std::string> & val) {
  this->metadata = val;
}

void PutFileMetadataRequest::__set_type(const FileMetadataExprType::type val) {
  this->type = val;
__isset.type = true;
}
std::ostream& operator<<(std::ostream& out, const PutFileMetadataRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PutFileMetadataRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fileIds = false;
  bool isset_metadata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fileIds.clear();
            uint32_t _size1142;
            ::apache::thrift::protocol::TType _etype1145;
            xfer += iprot->readListBegin(_etype1145, _size1142);
            this->fileIds.resize(_size1142);
            uint32_t _i1146;
            for (_i1146 = 0; _i1146 < _size1142; ++_i1146)
            {
              xfer += iprot->readI64(this->fileIds[_i1146]);
            }
            xfer += iprot->readListEnd();
          }
          isset_fileIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->metadata.clear();
            uint32_t _size1147;
            ::apache::thrift::protocol::TType _etype1150;
            xfer += iprot->readListBegin(_etype1150, _size1147);
            this->metadata.resize(_size1147);
            uint32_t _i1151;
            for (_i1151 = 0; _i1151 < _size1147; ++_i1151)
            {
              xfer += iprot->readBinary(this->metadata[_i1151]);
            }
            xfer += iprot->readListEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1152;
          xfer += iprot->readI32(ecast1152);
          this->type = (FileMetadataExprType::type)ecast1152;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fileIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PutFileMetadataRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PutFileMetadataRequest");

  xfer += oprot->writeFieldBegin("fileIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->fileIds.size()));
    std::vector<int64_t> ::const_iterator _iter1153;
    for (_iter1153 = this->fileIds.begin(); _iter1153 != this->fileIds.end(); ++_iter1153)
    {
      xfer += oprot->writeI64((*_iter1153));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::vector<std::string> ::const_iterator _iter1154;
    for (_iter1154 = this->metadata.begin(); _iter1154 != this->metadata.end(); ++_iter1154)
    {
      xfer += oprot->writeBinary((*_iter1154));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PutFileMetadataRequest &a, PutFileMetadataRequest &b) {
  using ::std::swap;
  swap(a.fileIds, b.fileIds);
  swap(a.metadata, b.metadata);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

PutFileMetadataRequest::PutFileMetadataRequest(const PutFileMetadataRequest& other1155) {
  fileIds = other1155.fileIds;
  metadata = other1155.metadata;
  type = other1155.type;
  __isset = other1155.__isset;
}
PutFileMetadataRequest& PutFileMetadataRequest::operator=(const PutFileMetadataRequest& other1156) {
  fileIds = other1156.fileIds;
  metadata = other1156.metadata;
  type = other1156.type;
  __isset = other1156.__isset;
  return *this;
}
void PutFileMetadataRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PutFileMetadataRequest(";
  out << "fileIds=" << to_string(fileIds);
  out << ", " << "metadata=" << to_string(metadata);
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ")";
}


ClearFileMetadataResult::~ClearFileMetadataResult() noexcept {
}

std::ostream& operator<<(std::ostream& out, const ClearFileMetadataResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ClearFileMetadataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClearFileMetadataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClearFileMetadataResult");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ClearFileMetadataResult &a, ClearFileMetadataResult &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

ClearFileMetadataResult::ClearFileMetadataResult(const ClearFileMetadataResult& other1157) {
  (void) other1157;
}
ClearFileMetadataResult& ClearFileMetadataResult::operator=(const ClearFileMetadataResult& other1158) {
  (void) other1158;
  return *this;
}
void ClearFileMetadataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ClearFileMetadataResult(";
  out << ")";
}


ClearFileMetadataRequest::~ClearFileMetadataRequest() noexcept {
}


void ClearFileMetadataRequest::__set_fileIds(const std::vector<int64_t> & val) {
  this->fileIds = val;
}
std::ostream& operator<<(std::ostream& out, const ClearFileMetadataRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ClearFileMetadataRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fileIds = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fileIds.clear();
            uint32_t _size1159;
            ::apache::thrift::protocol::TType _etype1162;
            xfer += iprot->readListBegin(_etype1162, _size1159);
            this->fileIds.resize(_size1159);
            uint32_t _i1163;
            for (_i1163 = 0; _i1163 < _size1159; ++_i1163)
            {
              xfer += iprot->readI64(this->fileIds[_i1163]);
            }
            xfer += iprot->readListEnd();
          }
          isset_fileIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fileIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ClearFileMetadataRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClearFileMetadataRequest");

  xfer += oprot->writeFieldBegin("fileIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->fileIds.size()));
    std::vector<int64_t> ::const_iterator _iter1164;
    for (_iter1164 = this->fileIds.begin(); _iter1164 != this->fileIds.end(); ++_iter1164)
    {
      xfer += oprot->writeI64((*_iter1164));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ClearFileMetadataRequest &a, ClearFileMetadataRequest &b) {
  using ::std::swap;
  swap(a.fileIds, b.fileIds);
}

ClearFileMetadataRequest::ClearFileMetadataRequest(const ClearFileMetadataRequest& other1165) {
  fileIds = other1165.fileIds;
}
ClearFileMetadataRequest& ClearFileMetadataRequest::operator=(const ClearFileMetadataRequest& other1166) {
  fileIds = other1166.fileIds;
  return *this;
}
void ClearFileMetadataRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ClearFileMetadataRequest(";
  out << "fileIds=" << to_string(fileIds);
  out << ")";
}


CacheFileMetadataResult::~CacheFileMetadataResult() noexcept {
}


void CacheFileMetadataResult::__set_isSupported(const bool val) {
  this->isSupported = val;
}
std::ostream& operator<<(std::ostream& out, const CacheFileMetadataResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CacheFileMetadataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_isSupported = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isSupported);
          isset_isSupported = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_isSupported)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CacheFileMetadataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CacheFileMetadataResult");

  xfer += oprot->writeFieldBegin("isSupported", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->isSupported);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CacheFileMetadataResult &a, CacheFileMetadataResult &b) {
  using ::std::swap;
  swap(a.isSupported, b.isSupported);
}

CacheFileMetadataResult::CacheFileMetadataResult(const CacheFileMetadataResult& other1167) {
  isSupported = other1167.isSupported;
}
CacheFileMetadataResult& CacheFileMetadataResult::operator=(const CacheFileMetadataResult& other1168) {
  isSupported = other1168.isSupported;
  return *this;
}
void CacheFileMetadataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CacheFileMetadataResult(";
  out << "isSupported=" << to_string(isSupported);
  out << ")";
}


CacheFileMetadataRequest::~CacheFileMetadataRequest() noexcept {
}


void CacheFileMetadataRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void CacheFileMetadataRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void CacheFileMetadataRequest::__set_partName(const std::string& val) {
  this->partName = val;
__isset.partName = true;
}

void CacheFileMetadataRequest::__set_isAllParts(const bool val) {
  this->isAllParts = val;
__isset.isAllParts = true;
}
std::ostream& operator<<(std::ostream& out, const CacheFileMetadataRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CacheFileMetadataRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partName);
          this->__isset.partName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAllParts);
          this->__isset.isAllParts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CacheFileMetadataRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CacheFileMetadataRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partName) {
    xfer += oprot->writeFieldBegin("partName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->partName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isAllParts) {
    xfer += oprot->writeFieldBegin("isAllParts", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->isAllParts);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CacheFileMetadataRequest &a, CacheFileMetadataRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.partName, b.partName);
  swap(a.isAllParts, b.isAllParts);
  swap(a.__isset, b.__isset);
}

CacheFileMetadataRequest::CacheFileMetadataRequest(const CacheFileMetadataRequest& other1169) {
  dbName = other1169.dbName;
  tblName = other1169.tblName;
  partName = other1169.partName;
  isAllParts = other1169.isAllParts;
  __isset = other1169.__isset;
}
CacheFileMetadataRequest& CacheFileMetadataRequest::operator=(const CacheFileMetadataRequest& other1170) {
  dbName = other1170.dbName;
  tblName = other1170.tblName;
  partName = other1170.partName;
  isAllParts = other1170.isAllParts;
  __isset = other1170.__isset;
  return *this;
}
void CacheFileMetadataRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CacheFileMetadataRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "partName="; (__isset.partName ? (out << to_string(partName)) : (out << "<null>"));
  out << ", " << "isAllParts="; (__isset.isAllParts ? (out << to_string(isAllParts)) : (out << "<null>"));
  out << ")";
}


GetAllFunctionsResponse::~GetAllFunctionsResponse() noexcept {
}


void GetAllFunctionsResponse::__set_functions(const std::vector<Function> & val) {
  this->functions = val;
__isset.functions = true;
}
std::ostream& operator<<(std::ostream& out, const GetAllFunctionsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetAllFunctionsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->functions.clear();
            uint32_t _size1171;
            ::apache::thrift::protocol::TType _etype1174;
            xfer += iprot->readListBegin(_etype1174, _size1171);
            this->functions.resize(_size1171);
            uint32_t _i1175;
            for (_i1175 = 0; _i1175 < _size1171; ++_i1175)
            {
              xfer += this->functions[_i1175].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.functions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetAllFunctionsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetAllFunctionsResponse");

  if (this->__isset.functions) {
    xfer += oprot->writeFieldBegin("functions", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->functions.size()));
      std::vector<Function> ::const_iterator _iter1176;
      for (_iter1176 = this->functions.begin(); _iter1176 != this->functions.end(); ++_iter1176)
      {
        xfer += (*_iter1176).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetAllFunctionsResponse &a, GetAllFunctionsResponse &b) {
  using ::std::swap;
  swap(a.functions, b.functions);
  swap(a.__isset, b.__isset);
}

GetAllFunctionsResponse::GetAllFunctionsResponse(const GetAllFunctionsResponse& other1177) {
  functions = other1177.functions;
  __isset = other1177.__isset;
}
GetAllFunctionsResponse& GetAllFunctionsResponse::operator=(const GetAllFunctionsResponse& other1178) {
  functions = other1178.functions;
  __isset = other1178.__isset;
  return *this;
}
void GetAllFunctionsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetAllFunctionsResponse(";
  out << "functions="; (__isset.functions ? (out << to_string(functions)) : (out << "<null>"));
  out << ")";
}


ClientCapabilities::~ClientCapabilities() noexcept {
}


void ClientCapabilities::__set_values(const std::vector<ClientCapability::type> & val) {
  this->values = val;
}
std::ostream& operator<<(std::ostream& out, const ClientCapabilities& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ClientCapabilities::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size1179;
            ::apache::thrift::protocol::TType _etype1182;
            xfer += iprot->readListBegin(_etype1182, _size1179);
            this->values.resize(_size1179);
            uint32_t _i1183;
            for (_i1183 = 0; _i1183 < _size1179; ++_i1183)
            {
              int32_t ecast1184;
              xfer += iprot->readI32(ecast1184);
              this->values[_i1183] = (ClientCapability::type)ecast1184;
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ClientCapabilities::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientCapabilities");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->values.size()));
    std::vector<ClientCapability::type> ::const_iterator _iter1185;
    for (_iter1185 = this->values.begin(); _iter1185 != this->values.end(); ++_iter1185)
    {
      xfer += oprot->writeI32((int32_t)(*_iter1185));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ClientCapabilities &a, ClientCapabilities &b) {
  using ::std::swap;
  swap(a.values, b.values);
}

ClientCapabilities::ClientCapabilities(const ClientCapabilities& other1186) {
  values = other1186.values;
}
ClientCapabilities& ClientCapabilities::operator=(const ClientCapabilities& other1187) {
  values = other1187.values;
  return *this;
}
void ClientCapabilities::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ClientCapabilities(";
  out << "values=" << to_string(values);
  out << ")";
}


GetProjectionsSpec::~GetProjectionsSpec() noexcept {
}


void GetProjectionsSpec::__set_fieldList(const std::vector<std::string> & val) {
  this->fieldList = val;
}

void GetProjectionsSpec::__set_includeParamKeyPattern(const std::string& val) {
  this->includeParamKeyPattern = val;
}

void GetProjectionsSpec::__set_excludeParamKeyPattern(const std::string& val) {
  this->excludeParamKeyPattern = val;
}
std::ostream& operator<<(std::ostream& out, const GetProjectionsSpec& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProjectionsSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fieldList.clear();
            uint32_t _size1188;
            ::apache::thrift::protocol::TType _etype1191;
            xfer += iprot->readListBegin(_etype1191, _size1188);
            this->fieldList.resize(_size1188);
            uint32_t _i1192;
            for (_i1192 = 0; _i1192 < _size1188; ++_i1192)
            {
              xfer += iprot->readString(this->fieldList[_i1192]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->includeParamKeyPattern);
          this->__isset.includeParamKeyPattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->excludeParamKeyPattern);
          this->__isset.excludeParamKeyPattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetProjectionsSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProjectionsSpec");

  xfer += oprot->writeFieldBegin("fieldList", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fieldList.size()));
    std::vector<std::string> ::const_iterator _iter1193;
    for (_iter1193 = this->fieldList.begin(); _iter1193 != this->fieldList.end(); ++_iter1193)
    {
      xfer += oprot->writeString((*_iter1193));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("includeParamKeyPattern", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->includeParamKeyPattern);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("excludeParamKeyPattern", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->excludeParamKeyPattern);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProjectionsSpec &a, GetProjectionsSpec &b) {
  using ::std::swap;
  swap(a.fieldList, b.fieldList);
  swap(a.includeParamKeyPattern, b.includeParamKeyPattern);
  swap(a.excludeParamKeyPattern, b.excludeParamKeyPattern);
  swap(a.__isset, b.__isset);
}

GetProjectionsSpec::GetProjectionsSpec(const GetProjectionsSpec& other1194) {
  fieldList = other1194.fieldList;
  includeParamKeyPattern = other1194.includeParamKeyPattern;
  excludeParamKeyPattern = other1194.excludeParamKeyPattern;
  __isset = other1194.__isset;
}
GetProjectionsSpec& GetProjectionsSpec::operator=(const GetProjectionsSpec& other1195) {
  fieldList = other1195.fieldList;
  includeParamKeyPattern = other1195.includeParamKeyPattern;
  excludeParamKeyPattern = other1195.excludeParamKeyPattern;
  __isset = other1195.__isset;
  return *this;
}
void GetProjectionsSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProjectionsSpec(";
  out << "fieldList=" << to_string(fieldList);
  out << ", " << "includeParamKeyPattern=" << to_string(includeParamKeyPattern);
  out << ", " << "excludeParamKeyPattern=" << to_string(excludeParamKeyPattern);
  out << ")";
}


GetTableRequest::~GetTableRequest() noexcept {
}


void GetTableRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void GetTableRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void GetTableRequest::__set_capabilities(const ClientCapabilities& val) {
  this->capabilities = val;
__isset.capabilities = true;
}

void GetTableRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void GetTableRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void GetTableRequest::__set_getColumnStats(const bool val) {
  this->getColumnStats = val;
__isset.getColumnStats = true;
}

void GetTableRequest::__set_processorCapabilities(const std::vector<std::string> & val) {
  this->processorCapabilities = val;
__isset.processorCapabilities = true;
}

void GetTableRequest::__set_processorIdentifier(const std::string& val) {
  this->processorIdentifier = val;
__isset.processorIdentifier = true;
}

void GetTableRequest::__set_engine(const std::string& val) {
  this->engine = val;
__isset.engine = true;
}

void GetTableRequest::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}
std::ostream& operator<<(std::ostream& out, const GetTableRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTableRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->capabilities.read(iprot);
          this->__isset.capabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->getColumnStats);
          this->__isset.getColumnStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->processorCapabilities.clear();
            uint32_t _size1196;
            ::apache::thrift::protocol::TType _etype1199;
            xfer += iprot->readListBegin(_etype1199, _size1196);
            this->processorCapabilities.resize(_size1196);
            uint32_t _i1200;
            for (_i1200 = 0; _i1200 < _size1196; ++_i1200)
            {
              xfer += iprot->readString(this->processorCapabilities[_i1200]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.processorCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->processorIdentifier);
          this->__isset.processorIdentifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->engine);
          this->__isset.engine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetTableRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTableRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.capabilities) {
    xfer += oprot->writeFieldBegin("capabilities", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->capabilities.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.getColumnStats) {
    xfer += oprot->writeFieldBegin("getColumnStats", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->getColumnStats);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorCapabilities) {
    xfer += oprot->writeFieldBegin("processorCapabilities", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->processorCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter1201;
      for (_iter1201 = this->processorCapabilities.begin(); _iter1201 != this->processorCapabilities.end(); ++_iter1201)
      {
        xfer += oprot->writeString((*_iter1201));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorIdentifier) {
    xfer += oprot->writeFieldBegin("processorIdentifier", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->processorIdentifier);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.engine) {
    xfer += oprot->writeFieldBegin("engine", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->engine);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTableRequest &a, GetTableRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.capabilities, b.capabilities);
  swap(a.catName, b.catName);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.getColumnStats, b.getColumnStats);
  swap(a.processorCapabilities, b.processorCapabilities);
  swap(a.processorIdentifier, b.processorIdentifier);
  swap(a.engine, b.engine);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

GetTableRequest::GetTableRequest(const GetTableRequest& other1202) {
  dbName = other1202.dbName;
  tblName = other1202.tblName;
  capabilities = other1202.capabilities;
  catName = other1202.catName;
  validWriteIdList = other1202.validWriteIdList;
  getColumnStats = other1202.getColumnStats;
  processorCapabilities = other1202.processorCapabilities;
  processorIdentifier = other1202.processorIdentifier;
  engine = other1202.engine;
  id = other1202.id;
  __isset = other1202.__isset;
}
GetTableRequest& GetTableRequest::operator=(const GetTableRequest& other1203) {
  dbName = other1203.dbName;
  tblName = other1203.tblName;
  capabilities = other1203.capabilities;
  catName = other1203.catName;
  validWriteIdList = other1203.validWriteIdList;
  getColumnStats = other1203.getColumnStats;
  processorCapabilities = other1203.processorCapabilities;
  processorIdentifier = other1203.processorIdentifier;
  engine = other1203.engine;
  id = other1203.id;
  __isset = other1203.__isset;
  return *this;
}
void GetTableRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTableRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "capabilities="; (__isset.capabilities ? (out << to_string(capabilities)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "getColumnStats="; (__isset.getColumnStats ? (out << to_string(getColumnStats)) : (out << "<null>"));
  out << ", " << "processorCapabilities="; (__isset.processorCapabilities ? (out << to_string(processorCapabilities)) : (out << "<null>"));
  out << ", " << "processorIdentifier="; (__isset.processorIdentifier ? (out << to_string(processorIdentifier)) : (out << "<null>"));
  out << ", " << "engine="; (__isset.engine ? (out << to_string(engine)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


GetTableResult::~GetTableResult() noexcept {
}


void GetTableResult::__set_table(const Table& val) {
  this->table = val;
}

void GetTableResult::__set_isStatsCompliant(const bool val) {
  this->isStatsCompliant = val;
__isset.isStatsCompliant = true;
}
std::ostream& operator<<(std::ostream& out, const GetTableResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTableResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table.read(iprot);
          isset_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isStatsCompliant);
          this->__isset.isStatsCompliant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetTableResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTableResult");

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.isStatsCompliant) {
    xfer += oprot->writeFieldBegin("isStatsCompliant", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->isStatsCompliant);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTableResult &a, GetTableResult &b) {
  using ::std::swap;
  swap(a.table, b.table);
  swap(a.isStatsCompliant, b.isStatsCompliant);
  swap(a.__isset, b.__isset);
}

GetTableResult::GetTableResult(const GetTableResult& other1204) {
  table = other1204.table;
  isStatsCompliant = other1204.isStatsCompliant;
  __isset = other1204.__isset;
}
GetTableResult& GetTableResult::operator=(const GetTableResult& other1205) {
  table = other1205.table;
  isStatsCompliant = other1205.isStatsCompliant;
  __isset = other1205.__isset;
  return *this;
}
void GetTableResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTableResult(";
  out << "table=" << to_string(table);
  out << ", " << "isStatsCompliant="; (__isset.isStatsCompliant ? (out << to_string(isStatsCompliant)) : (out << "<null>"));
  out << ")";
}


GetTablesRequest::~GetTablesRequest() noexcept {
}


void GetTablesRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void GetTablesRequest::__set_tblNames(const std::vector<std::string> & val) {
  this->tblNames = val;
__isset.tblNames = true;
}

void GetTablesRequest::__set_capabilities(const ClientCapabilities& val) {
  this->capabilities = val;
__isset.capabilities = true;
}

void GetTablesRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void GetTablesRequest::__set_processorCapabilities(const std::vector<std::string> & val) {
  this->processorCapabilities = val;
__isset.processorCapabilities = true;
}

void GetTablesRequest::__set_processorIdentifier(const std::string& val) {
  this->processorIdentifier = val;
__isset.processorIdentifier = true;
}

void GetTablesRequest::__set_projectionSpec(const GetProjectionsSpec& val) {
  this->projectionSpec = val;
__isset.projectionSpec = true;
}

void GetTablesRequest::__set_tablesPattern(const std::string& val) {
  this->tablesPattern = val;
__isset.tablesPattern = true;
}
std::ostream& operator<<(std::ostream& out, const GetTablesRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTablesRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tblNames.clear();
            uint32_t _size1206;
            ::apache::thrift::protocol::TType _etype1209;
            xfer += iprot->readListBegin(_etype1209, _size1206);
            this->tblNames.resize(_size1206);
            uint32_t _i1210;
            for (_i1210 = 0; _i1210 < _size1206; ++_i1210)
            {
              xfer += iprot->readString(this->tblNames[_i1210]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tblNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->capabilities.read(iprot);
          this->__isset.capabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->processorCapabilities.clear();
            uint32_t _size1211;
            ::apache::thrift::protocol::TType _etype1214;
            xfer += iprot->readListBegin(_etype1214, _size1211);
            this->processorCapabilities.resize(_size1211);
            uint32_t _i1215;
            for (_i1215 = 0; _i1215 < _size1211; ++_i1215)
            {
              xfer += iprot->readString(this->processorCapabilities[_i1215]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.processorCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->processorIdentifier);
          this->__isset.processorIdentifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->projectionSpec.read(iprot);
          this->__isset.projectionSpec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablesPattern);
          this->__isset.tablesPattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetTablesRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTablesRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tblNames) {
    xfer += oprot->writeFieldBegin("tblNames", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tblNames.size()));
      std::vector<std::string> ::const_iterator _iter1216;
      for (_iter1216 = this->tblNames.begin(); _iter1216 != this->tblNames.end(); ++_iter1216)
      {
        xfer += oprot->writeString((*_iter1216));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.capabilities) {
    xfer += oprot->writeFieldBegin("capabilities", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->capabilities.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorCapabilities) {
    xfer += oprot->writeFieldBegin("processorCapabilities", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->processorCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter1217;
      for (_iter1217 = this->processorCapabilities.begin(); _iter1217 != this->processorCapabilities.end(); ++_iter1217)
      {
        xfer += oprot->writeString((*_iter1217));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorIdentifier) {
    xfer += oprot->writeFieldBegin("processorIdentifier", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->processorIdentifier);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.projectionSpec) {
    xfer += oprot->writeFieldBegin("projectionSpec", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->projectionSpec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tablesPattern) {
    xfer += oprot->writeFieldBegin("tablesPattern", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->tablesPattern);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTablesRequest &a, GetTablesRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblNames, b.tblNames);
  swap(a.capabilities, b.capabilities);
  swap(a.catName, b.catName);
  swap(a.processorCapabilities, b.processorCapabilities);
  swap(a.processorIdentifier, b.processorIdentifier);
  swap(a.projectionSpec, b.projectionSpec);
  swap(a.tablesPattern, b.tablesPattern);
  swap(a.__isset, b.__isset);
}

GetTablesRequest::GetTablesRequest(const GetTablesRequest& other1218) {
  dbName = other1218.dbName;
  tblNames = other1218.tblNames;
  capabilities = other1218.capabilities;
  catName = other1218.catName;
  processorCapabilities = other1218.processorCapabilities;
  processorIdentifier = other1218.processorIdentifier;
  projectionSpec = other1218.projectionSpec;
  tablesPattern = other1218.tablesPattern;
  __isset = other1218.__isset;
}
GetTablesRequest& GetTablesRequest::operator=(const GetTablesRequest& other1219) {
  dbName = other1219.dbName;
  tblNames = other1219.tblNames;
  capabilities = other1219.capabilities;
  catName = other1219.catName;
  processorCapabilities = other1219.processorCapabilities;
  processorIdentifier = other1219.processorIdentifier;
  projectionSpec = other1219.projectionSpec;
  tablesPattern = other1219.tablesPattern;
  __isset = other1219.__isset;
  return *this;
}
void GetTablesRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTablesRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblNames="; (__isset.tblNames ? (out << to_string(tblNames)) : (out << "<null>"));
  out << ", " << "capabilities="; (__isset.capabilities ? (out << to_string(capabilities)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "processorCapabilities="; (__isset.processorCapabilities ? (out << to_string(processorCapabilities)) : (out << "<null>"));
  out << ", " << "processorIdentifier="; (__isset.processorIdentifier ? (out << to_string(processorIdentifier)) : (out << "<null>"));
  out << ", " << "projectionSpec="; (__isset.projectionSpec ? (out << to_string(projectionSpec)) : (out << "<null>"));
  out << ", " << "tablesPattern="; (__isset.tablesPattern ? (out << to_string(tablesPattern)) : (out << "<null>"));
  out << ")";
}


GetTablesResult::~GetTablesResult() noexcept {
}


void GetTablesResult::__set_tables(const std::vector<Table> & val) {
  this->tables = val;
}
std::ostream& operator<<(std::ostream& out, const GetTablesResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTablesResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tables = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tables.clear();
            uint32_t _size1220;
            ::apache::thrift::protocol::TType _etype1223;
            xfer += iprot->readListBegin(_etype1223, _size1220);
            this->tables.resize(_size1220);
            uint32_t _i1224;
            for (_i1224 = 0; _i1224 < _size1220; ++_i1224)
            {
              xfer += this->tables[_i1224].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_tables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tables)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetTablesResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTablesResult");

  xfer += oprot->writeFieldBegin("tables", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tables.size()));
    std::vector<Table> ::const_iterator _iter1225;
    for (_iter1225 = this->tables.begin(); _iter1225 != this->tables.end(); ++_iter1225)
    {
      xfer += (*_iter1225).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTablesResult &a, GetTablesResult &b) {
  using ::std::swap;
  swap(a.tables, b.tables);
}

GetTablesResult::GetTablesResult(const GetTablesResult& other1226) {
  tables = other1226.tables;
}
GetTablesResult& GetTablesResult::operator=(const GetTablesResult& other1227) {
  tables = other1227.tables;
  return *this;
}
void GetTablesResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTablesResult(";
  out << "tables=" << to_string(tables);
  out << ")";
}


GetTablesExtRequest::~GetTablesExtRequest() noexcept {
}


void GetTablesExtRequest::__set_catalog(const std::string& val) {
  this->catalog = val;
}

void GetTablesExtRequest::__set_database(const std::string& val) {
  this->database = val;
}

void GetTablesExtRequest::__set_tableNamePattern(const std::string& val) {
  this->tableNamePattern = val;
}

void GetTablesExtRequest::__set_requestedFields(const int32_t val) {
  this->requestedFields = val;
}

void GetTablesExtRequest::__set_limit(const int32_t val) {
  this->limit = val;
__isset.limit = true;
}

void GetTablesExtRequest::__set_processorCapabilities(const std::vector<std::string> & val) {
  this->processorCapabilities = val;
__isset.processorCapabilities = true;
}

void GetTablesExtRequest::__set_processorIdentifier(const std::string& val) {
  this->processorIdentifier = val;
__isset.processorIdentifier = true;
}
std::ostream& operator<<(std::ostream& out, const GetTablesExtRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTablesExtRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catalog = false;
  bool isset_database = false;
  bool isset_tableNamePattern = false;
  bool isset_requestedFields = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalog);
          isset_catalog = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->database);
          isset_database = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableNamePattern);
          isset_tableNamePattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->requestedFields);
          isset_requestedFields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->processorCapabilities.clear();
            uint32_t _size1228;
            ::apache::thrift::protocol::TType _etype1231;
            xfer += iprot->readListBegin(_etype1231, _size1228);
            this->processorCapabilities.resize(_size1228);
            uint32_t _i1232;
            for (_i1232 = 0; _i1232 < _size1228; ++_i1232)
            {
              xfer += iprot->readString(this->processorCapabilities[_i1232]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.processorCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->processorIdentifier);
          this->__isset.processorIdentifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catalog)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_database)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableNamePattern)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_requestedFields)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetTablesExtRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTablesExtRequest");

  xfer += oprot->writeFieldBegin("catalog", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catalog);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("database", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->database);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableNamePattern", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableNamePattern);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("requestedFields", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->requestedFields);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.limit) {
    xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorCapabilities) {
    xfer += oprot->writeFieldBegin("processorCapabilities", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->processorCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter1233;
      for (_iter1233 = this->processorCapabilities.begin(); _iter1233 != this->processorCapabilities.end(); ++_iter1233)
      {
        xfer += oprot->writeString((*_iter1233));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorIdentifier) {
    xfer += oprot->writeFieldBegin("processorIdentifier", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->processorIdentifier);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTablesExtRequest &a, GetTablesExtRequest &b) {
  using ::std::swap;
  swap(a.catalog, b.catalog);
  swap(a.database, b.database);
  swap(a.tableNamePattern, b.tableNamePattern);
  swap(a.requestedFields, b.requestedFields);
  swap(a.limit, b.limit);
  swap(a.processorCapabilities, b.processorCapabilities);
  swap(a.processorIdentifier, b.processorIdentifier);
  swap(a.__isset, b.__isset);
}

GetTablesExtRequest::GetTablesExtRequest(const GetTablesExtRequest& other1234) {
  catalog = other1234.catalog;
  database = other1234.database;
  tableNamePattern = other1234.tableNamePattern;
  requestedFields = other1234.requestedFields;
  limit = other1234.limit;
  processorCapabilities = other1234.processorCapabilities;
  processorIdentifier = other1234.processorIdentifier;
  __isset = other1234.__isset;
}
GetTablesExtRequest& GetTablesExtRequest::operator=(const GetTablesExtRequest& other1235) {
  catalog = other1235.catalog;
  database = other1235.database;
  tableNamePattern = other1235.tableNamePattern;
  requestedFields = other1235.requestedFields;
  limit = other1235.limit;
  processorCapabilities = other1235.processorCapabilities;
  processorIdentifier = other1235.processorIdentifier;
  __isset = other1235.__isset;
  return *this;
}
void GetTablesExtRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTablesExtRequest(";
  out << "catalog=" << to_string(catalog);
  out << ", " << "database=" << to_string(database);
  out << ", " << "tableNamePattern=" << to_string(tableNamePattern);
  out << ", " << "requestedFields=" << to_string(requestedFields);
  out << ", " << "limit="; (__isset.limit ? (out << to_string(limit)) : (out << "<null>"));
  out << ", " << "processorCapabilities="; (__isset.processorCapabilities ? (out << to_string(processorCapabilities)) : (out << "<null>"));
  out << ", " << "processorIdentifier="; (__isset.processorIdentifier ? (out << to_string(processorIdentifier)) : (out << "<null>"));
  out << ")";
}


ExtendedTableInfo::~ExtendedTableInfo() noexcept {
}


void ExtendedTableInfo::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void ExtendedTableInfo::__set_accessType(const int32_t val) {
  this->accessType = val;
__isset.accessType = true;
}

void ExtendedTableInfo::__set_requiredReadCapabilities(const std::vector<std::string> & val) {
  this->requiredReadCapabilities = val;
__isset.requiredReadCapabilities = true;
}

void ExtendedTableInfo::__set_requiredWriteCapabilities(const std::vector<std::string> & val) {
  this->requiredWriteCapabilities = val;
__isset.requiredWriteCapabilities = true;
}
std::ostream& operator<<(std::ostream& out, const ExtendedTableInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ExtendedTableInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tblName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->accessType);
          this->__isset.accessType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->requiredReadCapabilities.clear();
            uint32_t _size1236;
            ::apache::thrift::protocol::TType _etype1239;
            xfer += iprot->readListBegin(_etype1239, _size1236);
            this->requiredReadCapabilities.resize(_size1236);
            uint32_t _i1240;
            for (_i1240 = 0; _i1240 < _size1236; ++_i1240)
            {
              xfer += iprot->readString(this->requiredReadCapabilities[_i1240]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.requiredReadCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->requiredWriteCapabilities.clear();
            uint32_t _size1241;
            ::apache::thrift::protocol::TType _etype1244;
            xfer += iprot->readListBegin(_etype1244, _size1241);
            this->requiredWriteCapabilities.resize(_size1241);
            uint32_t _i1245;
            for (_i1245 = 0; _i1245 < _size1241; ++_i1245)
            {
              xfer += iprot->readString(this->requiredWriteCapabilities[_i1245]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.requiredWriteCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ExtendedTableInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ExtendedTableInfo");

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.accessType) {
    xfer += oprot->writeFieldBegin("accessType", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->accessType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.requiredReadCapabilities) {
    xfer += oprot->writeFieldBegin("requiredReadCapabilities", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->requiredReadCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter1246;
      for (_iter1246 = this->requiredReadCapabilities.begin(); _iter1246 != this->requiredReadCapabilities.end(); ++_iter1246)
      {
        xfer += oprot->writeString((*_iter1246));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.requiredWriteCapabilities) {
    xfer += oprot->writeFieldBegin("requiredWriteCapabilities", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->requiredWriteCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter1247;
      for (_iter1247 = this->requiredWriteCapabilities.begin(); _iter1247 != this->requiredWriteCapabilities.end(); ++_iter1247)
      {
        xfer += oprot->writeString((*_iter1247));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExtendedTableInfo &a, ExtendedTableInfo &b) {
  using ::std::swap;
  swap(a.tblName, b.tblName);
  swap(a.accessType, b.accessType);
  swap(a.requiredReadCapabilities, b.requiredReadCapabilities);
  swap(a.requiredWriteCapabilities, b.requiredWriteCapabilities);
  swap(a.__isset, b.__isset);
}

ExtendedTableInfo::ExtendedTableInfo(const ExtendedTableInfo& other1248) {
  tblName = other1248.tblName;
  accessType = other1248.accessType;
  requiredReadCapabilities = other1248.requiredReadCapabilities;
  requiredWriteCapabilities = other1248.requiredWriteCapabilities;
  __isset = other1248.__isset;
}
ExtendedTableInfo& ExtendedTableInfo::operator=(const ExtendedTableInfo& other1249) {
  tblName = other1249.tblName;
  accessType = other1249.accessType;
  requiredReadCapabilities = other1249.requiredReadCapabilities;
  requiredWriteCapabilities = other1249.requiredWriteCapabilities;
  __isset = other1249.__isset;
  return *this;
}
void ExtendedTableInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ExtendedTableInfo(";
  out << "tblName=" << to_string(tblName);
  out << ", " << "accessType="; (__isset.accessType ? (out << to_string(accessType)) : (out << "<null>"));
  out << ", " << "requiredReadCapabilities="; (__isset.requiredReadCapabilities ? (out << to_string(requiredReadCapabilities)) : (out << "<null>"));
  out << ", " << "requiredWriteCapabilities="; (__isset.requiredWriteCapabilities ? (out << to_string(requiredWriteCapabilities)) : (out << "<null>"));
  out << ")";
}


GetDatabaseRequest::~GetDatabaseRequest() noexcept {
}


void GetDatabaseRequest::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void GetDatabaseRequest::__set_catalogName(const std::string& val) {
  this->catalogName = val;
__isset.catalogName = true;
}

void GetDatabaseRequest::__set_processorCapabilities(const std::vector<std::string> & val) {
  this->processorCapabilities = val;
__isset.processorCapabilities = true;
}

void GetDatabaseRequest::__set_processorIdentifier(const std::string& val) {
  this->processorIdentifier = val;
__isset.processorIdentifier = true;
}
std::ostream& operator<<(std::ostream& out, const GetDatabaseRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetDatabaseRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogName);
          this->__isset.catalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->processorCapabilities.clear();
            uint32_t _size1250;
            ::apache::thrift::protocol::TType _etype1253;
            xfer += iprot->readListBegin(_etype1253, _size1250);
            this->processorCapabilities.resize(_size1250);
            uint32_t _i1254;
            for (_i1254 = 0; _i1254 < _size1250; ++_i1254)
            {
              xfer += iprot->readString(this->processorCapabilities[_i1254]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.processorCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->processorIdentifier);
          this->__isset.processorIdentifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetDatabaseRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetDatabaseRequest");

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalogName) {
    xfer += oprot->writeFieldBegin("catalogName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->catalogName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorCapabilities) {
    xfer += oprot->writeFieldBegin("processorCapabilities", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->processorCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter1255;
      for (_iter1255 = this->processorCapabilities.begin(); _iter1255 != this->processorCapabilities.end(); ++_iter1255)
      {
        xfer += oprot->writeString((*_iter1255));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorIdentifier) {
    xfer += oprot->writeFieldBegin("processorIdentifier", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->processorIdentifier);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetDatabaseRequest &a, GetDatabaseRequest &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.catalogName, b.catalogName);
  swap(a.processorCapabilities, b.processorCapabilities);
  swap(a.processorIdentifier, b.processorIdentifier);
  swap(a.__isset, b.__isset);
}

GetDatabaseRequest::GetDatabaseRequest(const GetDatabaseRequest& other1256) {
  name = other1256.name;
  catalogName = other1256.catalogName;
  processorCapabilities = other1256.processorCapabilities;
  processorIdentifier = other1256.processorIdentifier;
  __isset = other1256.__isset;
}
GetDatabaseRequest& GetDatabaseRequest::operator=(const GetDatabaseRequest& other1257) {
  name = other1257.name;
  catalogName = other1257.catalogName;
  processorCapabilities = other1257.processorCapabilities;
  processorIdentifier = other1257.processorIdentifier;
  __isset = other1257.__isset;
  return *this;
}
void GetDatabaseRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetDatabaseRequest(";
  out << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "catalogName="; (__isset.catalogName ? (out << to_string(catalogName)) : (out << "<null>"));
  out << ", " << "processorCapabilities="; (__isset.processorCapabilities ? (out << to_string(processorCapabilities)) : (out << "<null>"));
  out << ", " << "processorIdentifier="; (__isset.processorIdentifier ? (out << to_string(processorIdentifier)) : (out << "<null>"));
  out << ")";
}


CmRecycleRequest::~CmRecycleRequest() noexcept {
}


void CmRecycleRequest::__set_dataPath(const std::string& val) {
  this->dataPath = val;
}

void CmRecycleRequest::__set_purge(const bool val) {
  this->purge = val;
}
std::ostream& operator<<(std::ostream& out, const CmRecycleRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CmRecycleRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dataPath = false;
  bool isset_purge = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataPath);
          isset_dataPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->purge);
          isset_purge = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dataPath)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_purge)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CmRecycleRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CmRecycleRequest");

  xfer += oprot->writeFieldBegin("dataPath", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dataPath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("purge", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->purge);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CmRecycleRequest &a, CmRecycleRequest &b) {
  using ::std::swap;
  swap(a.dataPath, b.dataPath);
  swap(a.purge, b.purge);
}

CmRecycleRequest::CmRecycleRequest(const CmRecycleRequest& other1258) {
  dataPath = other1258.dataPath;
  purge = other1258.purge;
}
CmRecycleRequest& CmRecycleRequest::operator=(const CmRecycleRequest& other1259) {
  dataPath = other1259.dataPath;
  purge = other1259.purge;
  return *this;
}
void CmRecycleRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CmRecycleRequest(";
  out << "dataPath=" << to_string(dataPath);
  out << ", " << "purge=" << to_string(purge);
  out << ")";
}


CmRecycleResponse::~CmRecycleResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const CmRecycleResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CmRecycleResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CmRecycleResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CmRecycleResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CmRecycleResponse &a, CmRecycleResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CmRecycleResponse::CmRecycleResponse(const CmRecycleResponse& other1260) {
  (void) other1260;
}
CmRecycleResponse& CmRecycleResponse::operator=(const CmRecycleResponse& other1261) {
  (void) other1261;
  return *this;
}
void CmRecycleResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CmRecycleResponse(";
  out << ")";
}


TableMeta::~TableMeta() noexcept {
}


void TableMeta::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void TableMeta::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void TableMeta::__set_tableType(const std::string& val) {
  this->tableType = val;
}

void TableMeta::__set_comments(const std::string& val) {
  this->comments = val;
__isset.comments = true;
}

void TableMeta::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}
std::ostream& operator<<(std::ostream& out, const TableMeta& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TableMeta::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tableName = false;
  bool isset_tableType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableType);
          isset_tableType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comments);
          this->__isset.comments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TableMeta::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TableMeta");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableType", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comments) {
    xfer += oprot->writeFieldBegin("comments", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->comments);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableMeta &a, TableMeta &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.tableType, b.tableType);
  swap(a.comments, b.comments);
  swap(a.catName, b.catName);
  swap(a.__isset, b.__isset);
}

TableMeta::TableMeta(const TableMeta& other1262) {
  dbName = other1262.dbName;
  tableName = other1262.tableName;
  tableType = other1262.tableType;
  comments = other1262.comments;
  catName = other1262.catName;
  __isset = other1262.__isset;
}
TableMeta& TableMeta::operator=(const TableMeta& other1263) {
  dbName = other1263.dbName;
  tableName = other1263.tableName;
  tableType = other1263.tableType;
  comments = other1263.comments;
  catName = other1263.catName;
  __isset = other1263.__isset;
  return *this;
}
void TableMeta::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TableMeta(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "tableType=" << to_string(tableType);
  out << ", " << "comments="; (__isset.comments ? (out << to_string(comments)) : (out << "<null>"));
  out << ", " << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ")";
}


Materialization::~Materialization() noexcept {
}


void Materialization::__set_sourceTablesUpdateDeleteModified(const bool val) {
  this->sourceTablesUpdateDeleteModified = val;
}

void Materialization::__set_sourceTablesCompacted(const bool val) {
  this->sourceTablesCompacted = val;
}
std::ostream& operator<<(std::ostream& out, const Materialization& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Materialization::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sourceTablesUpdateDeleteModified = false;
  bool isset_sourceTablesCompacted = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sourceTablesUpdateDeleteModified);
          isset_sourceTablesUpdateDeleteModified = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sourceTablesCompacted);
          isset_sourceTablesCompacted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sourceTablesUpdateDeleteModified)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sourceTablesCompacted)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Materialization::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Materialization");

  xfer += oprot->writeFieldBegin("sourceTablesUpdateDeleteModified", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->sourceTablesUpdateDeleteModified);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sourceTablesCompacted", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->sourceTablesCompacted);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Materialization &a, Materialization &b) {
  using ::std::swap;
  swap(a.sourceTablesUpdateDeleteModified, b.sourceTablesUpdateDeleteModified);
  swap(a.sourceTablesCompacted, b.sourceTablesCompacted);
}

Materialization::Materialization(const Materialization& other1264) {
  sourceTablesUpdateDeleteModified = other1264.sourceTablesUpdateDeleteModified;
  sourceTablesCompacted = other1264.sourceTablesCompacted;
}
Materialization& Materialization::operator=(const Materialization& other1265) {
  sourceTablesUpdateDeleteModified = other1265.sourceTablesUpdateDeleteModified;
  sourceTablesCompacted = other1265.sourceTablesCompacted;
  return *this;
}
void Materialization::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Materialization(";
  out << "sourceTablesUpdateDeleteModified=" << to_string(sourceTablesUpdateDeleteModified);
  out << ", " << "sourceTablesCompacted=" << to_string(sourceTablesCompacted);
  out << ")";
}


WMResourcePlan::~WMResourcePlan() noexcept {
}


void WMResourcePlan::__set_name(const std::string& val) {
  this->name = val;
}

void WMResourcePlan::__set_status(const WMResourcePlanStatus::type val) {
  this->status = val;
__isset.status = true;
}

void WMResourcePlan::__set_queryParallelism(const int32_t val) {
  this->queryParallelism = val;
__isset.queryParallelism = true;
}

void WMResourcePlan::__set_defaultPoolPath(const std::string& val) {
  this->defaultPoolPath = val;
__isset.defaultPoolPath = true;
}

void WMResourcePlan::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMResourcePlan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMResourcePlan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1266;
          xfer += iprot->readI32(ecast1266);
          this->status = (WMResourcePlanStatus::type)ecast1266;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->queryParallelism);
          this->__isset.queryParallelism = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->defaultPoolPath);
          this->__isset.defaultPoolPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WMResourcePlan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMResourcePlan");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->status);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queryParallelism) {
    xfer += oprot->writeFieldBegin("queryParallelism", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->queryParallelism);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.defaultPoolPath) {
    xfer += oprot->writeFieldBegin("defaultPoolPath", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->defaultPoolPath);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMResourcePlan &a, WMResourcePlan &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.status, b.status);
  swap(a.queryParallelism, b.queryParallelism);
  swap(a.defaultPoolPath, b.defaultPoolPath);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMResourcePlan::WMResourcePlan(const WMResourcePlan& other1267) {
  name = other1267.name;
  status = other1267.status;
  queryParallelism = other1267.queryParallelism;
  defaultPoolPath = other1267.defaultPoolPath;
  ns = other1267.ns;
  __isset = other1267.__isset;
}
WMResourcePlan& WMResourcePlan::operator=(const WMResourcePlan& other1268) {
  name = other1268.name;
  status = other1268.status;
  queryParallelism = other1268.queryParallelism;
  defaultPoolPath = other1268.defaultPoolPath;
  ns = other1268.ns;
  __isset = other1268.__isset;
  return *this;
}
void WMResourcePlan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMResourcePlan(";
  out << "name=" << to_string(name);
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ", " << "queryParallelism="; (__isset.queryParallelism ? (out << to_string(queryParallelism)) : (out << "<null>"));
  out << ", " << "defaultPoolPath="; (__isset.defaultPoolPath ? (out << to_string(defaultPoolPath)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMNullableResourcePlan::~WMNullableResourcePlan() noexcept {
}


void WMNullableResourcePlan::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void WMNullableResourcePlan::__set_status(const WMResourcePlanStatus::type val) {
  this->status = val;
__isset.status = true;
}

void WMNullableResourcePlan::__set_queryParallelism(const int32_t val) {
  this->queryParallelism = val;
__isset.queryParallelism = true;
}

void WMNullableResourcePlan::__set_isSetQueryParallelism(const bool val) {
  this->isSetQueryParallelism = val;
__isset.isSetQueryParallelism = true;
}

void WMNullableResourcePlan::__set_defaultPoolPath(const std::string& val) {
  this->defaultPoolPath = val;
__isset.defaultPoolPath = true;
}

void WMNullableResourcePlan::__set_isSetDefaultPoolPath(const bool val) {
  this->isSetDefaultPoolPath = val;
__isset.isSetDefaultPoolPath = true;
}

void WMNullableResourcePlan::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMNullableResourcePlan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMNullableResourcePlan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1269;
          xfer += iprot->readI32(ecast1269);
          this->status = (WMResourcePlanStatus::type)ecast1269;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->queryParallelism);
          this->__isset.queryParallelism = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isSetQueryParallelism);
          this->__isset.isSetQueryParallelism = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->defaultPoolPath);
          this->__isset.defaultPoolPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isSetDefaultPoolPath);
          this->__isset.isSetDefaultPoolPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMNullableResourcePlan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMNullableResourcePlan");

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->status);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queryParallelism) {
    xfer += oprot->writeFieldBegin("queryParallelism", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->queryParallelism);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isSetQueryParallelism) {
    xfer += oprot->writeFieldBegin("isSetQueryParallelism", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->isSetQueryParallelism);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.defaultPoolPath) {
    xfer += oprot->writeFieldBegin("defaultPoolPath", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->defaultPoolPath);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isSetDefaultPoolPath) {
    xfer += oprot->writeFieldBegin("isSetDefaultPoolPath", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->isSetDefaultPoolPath);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMNullableResourcePlan &a, WMNullableResourcePlan &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.status, b.status);
  swap(a.queryParallelism, b.queryParallelism);
  swap(a.isSetQueryParallelism, b.isSetQueryParallelism);
  swap(a.defaultPoolPath, b.defaultPoolPath);
  swap(a.isSetDefaultPoolPath, b.isSetDefaultPoolPath);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMNullableResourcePlan::WMNullableResourcePlan(const WMNullableResourcePlan& other1270) {
  name = other1270.name;
  status = other1270.status;
  queryParallelism = other1270.queryParallelism;
  isSetQueryParallelism = other1270.isSetQueryParallelism;
  defaultPoolPath = other1270.defaultPoolPath;
  isSetDefaultPoolPath = other1270.isSetDefaultPoolPath;
  ns = other1270.ns;
  __isset = other1270.__isset;
}
WMNullableResourcePlan& WMNullableResourcePlan::operator=(const WMNullableResourcePlan& other1271) {
  name = other1271.name;
  status = other1271.status;
  queryParallelism = other1271.queryParallelism;
  isSetQueryParallelism = other1271.isSetQueryParallelism;
  defaultPoolPath = other1271.defaultPoolPath;
  isSetDefaultPoolPath = other1271.isSetDefaultPoolPath;
  ns = other1271.ns;
  __isset = other1271.__isset;
  return *this;
}
void WMNullableResourcePlan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMNullableResourcePlan(";
  out << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ", " << "queryParallelism="; (__isset.queryParallelism ? (out << to_string(queryParallelism)) : (out << "<null>"));
  out << ", " << "isSetQueryParallelism="; (__isset.isSetQueryParallelism ? (out << to_string(isSetQueryParallelism)) : (out << "<null>"));
  out << ", " << "defaultPoolPath="; (__isset.defaultPoolPath ? (out << to_string(defaultPoolPath)) : (out << "<null>"));
  out << ", " << "isSetDefaultPoolPath="; (__isset.isSetDefaultPoolPath ? (out << to_string(isSetDefaultPoolPath)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMPool::~WMPool() noexcept {
}


void WMPool::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
}

void WMPool::__set_poolPath(const std::string& val) {
  this->poolPath = val;
}

void WMPool::__set_allocFraction(const double val) {
  this->allocFraction = val;
__isset.allocFraction = true;
}

void WMPool::__set_queryParallelism(const int32_t val) {
  this->queryParallelism = val;
__isset.queryParallelism = true;
}

void WMPool::__set_schedulingPolicy(const std::string& val) {
  this->schedulingPolicy = val;
__isset.schedulingPolicy = true;
}

void WMPool::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMPool& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMPool::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resourcePlanName = false;
  bool isset_poolPath = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          isset_resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->poolPath);
          isset_poolPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->allocFraction);
          this->__isset.allocFraction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->queryParallelism);
          this->__isset.queryParallelism = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schedulingPolicy);
          this->__isset.schedulingPolicy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resourcePlanName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_poolPath)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WMPool::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMPool");

  xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->resourcePlanName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("poolPath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->poolPath);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.allocFraction) {
    xfer += oprot->writeFieldBegin("allocFraction", ::apache::thrift::protocol::T_DOUBLE, 3);
    xfer += oprot->writeDouble(this->allocFraction);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queryParallelism) {
    xfer += oprot->writeFieldBegin("queryParallelism", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->queryParallelism);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schedulingPolicy) {
    xfer += oprot->writeFieldBegin("schedulingPolicy", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->schedulingPolicy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMPool &a, WMPool &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.poolPath, b.poolPath);
  swap(a.allocFraction, b.allocFraction);
  swap(a.queryParallelism, b.queryParallelism);
  swap(a.schedulingPolicy, b.schedulingPolicy);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMPool::WMPool(const WMPool& other1272) {
  resourcePlanName = other1272.resourcePlanName;
  poolPath = other1272.poolPath;
  allocFraction = other1272.allocFraction;
  queryParallelism = other1272.queryParallelism;
  schedulingPolicy = other1272.schedulingPolicy;
  ns = other1272.ns;
  __isset = other1272.__isset;
}
WMPool& WMPool::operator=(const WMPool& other1273) {
  resourcePlanName = other1273.resourcePlanName;
  poolPath = other1273.poolPath;
  allocFraction = other1273.allocFraction;
  queryParallelism = other1273.queryParallelism;
  schedulingPolicy = other1273.schedulingPolicy;
  ns = other1273.ns;
  __isset = other1273.__isset;
  return *this;
}
void WMPool::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMPool(";
  out << "resourcePlanName=" << to_string(resourcePlanName);
  out << ", " << "poolPath=" << to_string(poolPath);
  out << ", " << "allocFraction="; (__isset.allocFraction ? (out << to_string(allocFraction)) : (out << "<null>"));
  out << ", " << "queryParallelism="; (__isset.queryParallelism ? (out << to_string(queryParallelism)) : (out << "<null>"));
  out << ", " << "schedulingPolicy="; (__isset.schedulingPolicy ? (out << to_string(schedulingPolicy)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMNullablePool::~WMNullablePool() noexcept {
}


void WMNullablePool::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
}

void WMNullablePool::__set_poolPath(const std::string& val) {
  this->poolPath = val;
}

void WMNullablePool::__set_allocFraction(const double val) {
  this->allocFraction = val;
__isset.allocFraction = true;
}

void WMNullablePool::__set_queryParallelism(const int32_t val) {
  this->queryParallelism = val;
__isset.queryParallelism = true;
}

void WMNullablePool::__set_schedulingPolicy(const std::string& val) {
  this->schedulingPolicy = val;
__isset.schedulingPolicy = true;
}

void WMNullablePool::__set_isSetSchedulingPolicy(const bool val) {
  this->isSetSchedulingPolicy = val;
__isset.isSetSchedulingPolicy = true;
}

void WMNullablePool::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMNullablePool& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMNullablePool::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resourcePlanName = false;
  bool isset_poolPath = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          isset_resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->poolPath);
          isset_poolPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->allocFraction);
          this->__isset.allocFraction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->queryParallelism);
          this->__isset.queryParallelism = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schedulingPolicy);
          this->__isset.schedulingPolicy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isSetSchedulingPolicy);
          this->__isset.isSetSchedulingPolicy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resourcePlanName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_poolPath)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WMNullablePool::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMNullablePool");

  xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->resourcePlanName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("poolPath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->poolPath);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.allocFraction) {
    xfer += oprot->writeFieldBegin("allocFraction", ::apache::thrift::protocol::T_DOUBLE, 3);
    xfer += oprot->writeDouble(this->allocFraction);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queryParallelism) {
    xfer += oprot->writeFieldBegin("queryParallelism", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->queryParallelism);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schedulingPolicy) {
    xfer += oprot->writeFieldBegin("schedulingPolicy", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->schedulingPolicy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isSetSchedulingPolicy) {
    xfer += oprot->writeFieldBegin("isSetSchedulingPolicy", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->isSetSchedulingPolicy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMNullablePool &a, WMNullablePool &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.poolPath, b.poolPath);
  swap(a.allocFraction, b.allocFraction);
  swap(a.queryParallelism, b.queryParallelism);
  swap(a.schedulingPolicy, b.schedulingPolicy);
  swap(a.isSetSchedulingPolicy, b.isSetSchedulingPolicy);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMNullablePool::WMNullablePool(const WMNullablePool& other1274) {
  resourcePlanName = other1274.resourcePlanName;
  poolPath = other1274.poolPath;
  allocFraction = other1274.allocFraction;
  queryParallelism = other1274.queryParallelism;
  schedulingPolicy = other1274.schedulingPolicy;
  isSetSchedulingPolicy = other1274.isSetSchedulingPolicy;
  ns = other1274.ns;
  __isset = other1274.__isset;
}
WMNullablePool& WMNullablePool::operator=(const WMNullablePool& other1275) {
  resourcePlanName = other1275.resourcePlanName;
  poolPath = other1275.poolPath;
  allocFraction = other1275.allocFraction;
  queryParallelism = other1275.queryParallelism;
  schedulingPolicy = other1275.schedulingPolicy;
  isSetSchedulingPolicy = other1275.isSetSchedulingPolicy;
  ns = other1275.ns;
  __isset = other1275.__isset;
  return *this;
}
void WMNullablePool::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMNullablePool(";
  out << "resourcePlanName=" << to_string(resourcePlanName);
  out << ", " << "poolPath=" << to_string(poolPath);
  out << ", " << "allocFraction="; (__isset.allocFraction ? (out << to_string(allocFraction)) : (out << "<null>"));
  out << ", " << "queryParallelism="; (__isset.queryParallelism ? (out << to_string(queryParallelism)) : (out << "<null>"));
  out << ", " << "schedulingPolicy="; (__isset.schedulingPolicy ? (out << to_string(schedulingPolicy)) : (out << "<null>"));
  out << ", " << "isSetSchedulingPolicy="; (__isset.isSetSchedulingPolicy ? (out << to_string(isSetSchedulingPolicy)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMTrigger::~WMTrigger() noexcept {
}


void WMTrigger::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
}

void WMTrigger::__set_triggerName(const std::string& val) {
  this->triggerName = val;
}

void WMTrigger::__set_triggerExpression(const std::string& val) {
  this->triggerExpression = val;
__isset.triggerExpression = true;
}

void WMTrigger::__set_actionExpression(const std::string& val) {
  this->actionExpression = val;
__isset.actionExpression = true;
}

void WMTrigger::__set_isInUnmanaged(const bool val) {
  this->isInUnmanaged = val;
__isset.isInUnmanaged = true;
}

void WMTrigger::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMTrigger& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMTrigger::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resourcePlanName = false;
  bool isset_triggerName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          isset_resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->triggerName);
          isset_triggerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->triggerExpression);
          this->__isset.triggerExpression = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->actionExpression);
          this->__isset.actionExpression = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isInUnmanaged);
          this->__isset.isInUnmanaged = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resourcePlanName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_triggerName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WMTrigger::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMTrigger");

  xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->resourcePlanName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("triggerName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->triggerName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.triggerExpression) {
    xfer += oprot->writeFieldBegin("triggerExpression", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->triggerExpression);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.actionExpression) {
    xfer += oprot->writeFieldBegin("actionExpression", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->actionExpression);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isInUnmanaged) {
    xfer += oprot->writeFieldBegin("isInUnmanaged", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->isInUnmanaged);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMTrigger &a, WMTrigger &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.triggerName, b.triggerName);
  swap(a.triggerExpression, b.triggerExpression);
  swap(a.actionExpression, b.actionExpression);
  swap(a.isInUnmanaged, b.isInUnmanaged);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMTrigger::WMTrigger(const WMTrigger& other1276) {
  resourcePlanName = other1276.resourcePlanName;
  triggerName = other1276.triggerName;
  triggerExpression = other1276.triggerExpression;
  actionExpression = other1276.actionExpression;
  isInUnmanaged = other1276.isInUnmanaged;
  ns = other1276.ns;
  __isset = other1276.__isset;
}
WMTrigger& WMTrigger::operator=(const WMTrigger& other1277) {
  resourcePlanName = other1277.resourcePlanName;
  triggerName = other1277.triggerName;
  triggerExpression = other1277.triggerExpression;
  actionExpression = other1277.actionExpression;
  isInUnmanaged = other1277.isInUnmanaged;
  ns = other1277.ns;
  __isset = other1277.__isset;
  return *this;
}
void WMTrigger::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMTrigger(";
  out << "resourcePlanName=" << to_string(resourcePlanName);
  out << ", " << "triggerName=" << to_string(triggerName);
  out << ", " << "triggerExpression="; (__isset.triggerExpression ? (out << to_string(triggerExpression)) : (out << "<null>"));
  out << ", " << "actionExpression="; (__isset.actionExpression ? (out << to_string(actionExpression)) : (out << "<null>"));
  out << ", " << "isInUnmanaged="; (__isset.isInUnmanaged ? (out << to_string(isInUnmanaged)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMMapping::~WMMapping() noexcept {
}


void WMMapping::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
}

void WMMapping::__set_entityType(const std::string& val) {
  this->entityType = val;
}

void WMMapping::__set_entityName(const std::string& val) {
  this->entityName = val;
}

void WMMapping::__set_poolPath(const std::string& val) {
  this->poolPath = val;
__isset.poolPath = true;
}

void WMMapping::__set_ordering(const int32_t val) {
  this->ordering = val;
__isset.ordering = true;
}

void WMMapping::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMMapping& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMMapping::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resourcePlanName = false;
  bool isset_entityType = false;
  bool isset_entityName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          isset_resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->entityType);
          isset_entityType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->entityName);
          isset_entityName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->poolPath);
          this->__isset.poolPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ordering);
          this->__isset.ordering = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resourcePlanName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_entityType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_entityName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WMMapping::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMMapping");

  xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->resourcePlanName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entityType", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->entityType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entityName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->entityName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.poolPath) {
    xfer += oprot->writeFieldBegin("poolPath", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->poolPath);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ordering) {
    xfer += oprot->writeFieldBegin("ordering", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->ordering);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMMapping &a, WMMapping &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.entityType, b.entityType);
  swap(a.entityName, b.entityName);
  swap(a.poolPath, b.poolPath);
  swap(a.ordering, b.ordering);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMMapping::WMMapping(const WMMapping& other1278) {
  resourcePlanName = other1278.resourcePlanName;
  entityType = other1278.entityType;
  entityName = other1278.entityName;
  poolPath = other1278.poolPath;
  ordering = other1278.ordering;
  ns = other1278.ns;
  __isset = other1278.__isset;
}
WMMapping& WMMapping::operator=(const WMMapping& other1279) {
  resourcePlanName = other1279.resourcePlanName;
  entityType = other1279.entityType;
  entityName = other1279.entityName;
  poolPath = other1279.poolPath;
  ordering = other1279.ordering;
  ns = other1279.ns;
  __isset = other1279.__isset;
  return *this;
}
void WMMapping::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMMapping(";
  out << "resourcePlanName=" << to_string(resourcePlanName);
  out << ", " << "entityType=" << to_string(entityType);
  out << ", " << "entityName=" << to_string(entityName);
  out << ", " << "poolPath="; (__isset.poolPath ? (out << to_string(poolPath)) : (out << "<null>"));
  out << ", " << "ordering="; (__isset.ordering ? (out << to_string(ordering)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMPoolTrigger::~WMPoolTrigger() noexcept {
}


void WMPoolTrigger::__set_pool(const std::string& val) {
  this->pool = val;
}

void WMPoolTrigger::__set_trigger(const std::string& val) {
  this->trigger = val;
}

void WMPoolTrigger::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMPoolTrigger& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMPoolTrigger::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_pool = false;
  bool isset_trigger = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pool);
          isset_pool = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->trigger);
          isset_trigger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_pool)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_trigger)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WMPoolTrigger::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMPoolTrigger");

  xfer += oprot->writeFieldBegin("pool", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->pool);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("trigger", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->trigger);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMPoolTrigger &a, WMPoolTrigger &b) {
  using ::std::swap;
  swap(a.pool, b.pool);
  swap(a.trigger, b.trigger);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMPoolTrigger::WMPoolTrigger(const WMPoolTrigger& other1280) {
  pool = other1280.pool;
  trigger = other1280.trigger;
  ns = other1280.ns;
  __isset = other1280.__isset;
}
WMPoolTrigger& WMPoolTrigger::operator=(const WMPoolTrigger& other1281) {
  pool = other1281.pool;
  trigger = other1281.trigger;
  ns = other1281.ns;
  __isset = other1281.__isset;
  return *this;
}
void WMPoolTrigger::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMPoolTrigger(";
  out << "pool=" << to_string(pool);
  out << ", " << "trigger=" << to_string(trigger);
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMFullResourcePlan::~WMFullResourcePlan() noexcept {
}


void WMFullResourcePlan::__set_plan(const WMResourcePlan& val) {
  this->plan = val;
}

void WMFullResourcePlan::__set_pools(const std::vector<WMPool> & val) {
  this->pools = val;
}

void WMFullResourcePlan::__set_mappings(const std::vector<WMMapping> & val) {
  this->mappings = val;
__isset.mappings = true;
}

void WMFullResourcePlan::__set_triggers(const std::vector<WMTrigger> & val) {
  this->triggers = val;
__isset.triggers = true;
}

void WMFullResourcePlan::__set_poolTriggers(const std::vector<WMPoolTrigger> & val) {
  this->poolTriggers = val;
__isset.poolTriggers = true;
}
std::ostream& operator<<(std::ostream& out, const WMFullResourcePlan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMFullResourcePlan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_plan = false;
  bool isset_pools = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->plan.read(iprot);
          isset_plan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pools.clear();
            uint32_t _size1282;
            ::apache::thrift::protocol::TType _etype1285;
            xfer += iprot->readListBegin(_etype1285, _size1282);
            this->pools.resize(_size1282);
            uint32_t _i1286;
            for (_i1286 = 0; _i1286 < _size1282; ++_i1286)
            {
              xfer += this->pools[_i1286].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_pools = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->mappings.clear();
            uint32_t _size1287;
            ::apache::thrift::protocol::TType _etype1290;
            xfer += iprot->readListBegin(_etype1290, _size1287);
            this->mappings.resize(_size1287);
            uint32_t _i1291;
            for (_i1291 = 0; _i1291 < _size1287; ++_i1291)
            {
              xfer += this->mappings[_i1291].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.mappings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->triggers.clear();
            uint32_t _size1292;
            ::apache::thrift::protocol::TType _etype1295;
            xfer += iprot->readListBegin(_etype1295, _size1292);
            this->triggers.resize(_size1292);
            uint32_t _i1296;
            for (_i1296 = 0; _i1296 < _size1292; ++_i1296)
            {
              xfer += this->triggers[_i1296].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.triggers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->poolTriggers.clear();
            uint32_t _size1297;
            ::apache::thrift::protocol::TType _etype1300;
            xfer += iprot->readListBegin(_etype1300, _size1297);
            this->poolTriggers.resize(_size1297);
            uint32_t _i1301;
            for (_i1301 = 0; _i1301 < _size1297; ++_i1301)
            {
              xfer += this->poolTriggers[_i1301].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.poolTriggers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_plan)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_pools)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WMFullResourcePlan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMFullResourcePlan");

  xfer += oprot->writeFieldBegin("plan", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->plan.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pools", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->pools.size()));
    std::vector<WMPool> ::const_iterator _iter1302;
    for (_iter1302 = this->pools.begin(); _iter1302 != this->pools.end(); ++_iter1302)
    {
      xfer += (*_iter1302).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.mappings) {
    xfer += oprot->writeFieldBegin("mappings", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->mappings.size()));
      std::vector<WMMapping> ::const_iterator _iter1303;
      for (_iter1303 = this->mappings.begin(); _iter1303 != this->mappings.end(); ++_iter1303)
      {
        xfer += (*_iter1303).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.triggers) {
    xfer += oprot->writeFieldBegin("triggers", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->triggers.size()));
      std::vector<WMTrigger> ::const_iterator _iter1304;
      for (_iter1304 = this->triggers.begin(); _iter1304 != this->triggers.end(); ++_iter1304)
      {
        xfer += (*_iter1304).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.poolTriggers) {
    xfer += oprot->writeFieldBegin("poolTriggers", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->poolTriggers.size()));
      std::vector<WMPoolTrigger> ::const_iterator _iter1305;
      for (_iter1305 = this->poolTriggers.begin(); _iter1305 != this->poolTriggers.end(); ++_iter1305)
      {
        xfer += (*_iter1305).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMFullResourcePlan &a, WMFullResourcePlan &b) {
  using ::std::swap;
  swap(a.plan, b.plan);
  swap(a.pools, b.pools);
  swap(a.mappings, b.mappings);
  swap(a.triggers, b.triggers);
  swap(a.poolTriggers, b.poolTriggers);
  swap(a.__isset, b.__isset);
}

WMFullResourcePlan::WMFullResourcePlan(const WMFullResourcePlan& other1306) {
  plan = other1306.plan;
  pools = other1306.pools;
  mappings = other1306.mappings;
  triggers = other1306.triggers;
  poolTriggers = other1306.poolTriggers;
  __isset = other1306.__isset;
}
WMFullResourcePlan& WMFullResourcePlan::operator=(const WMFullResourcePlan& other1307) {
  plan = other1307.plan;
  pools = other1307.pools;
  mappings = other1307.mappings;
  triggers = other1307.triggers;
  poolTriggers = other1307.poolTriggers;
  __isset = other1307.__isset;
  return *this;
}
void WMFullResourcePlan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMFullResourcePlan(";
  out << "plan=" << to_string(plan);
  out << ", " << "pools=" << to_string(pools);
  out << ", " << "mappings="; (__isset.mappings ? (out << to_string(mappings)) : (out << "<null>"));
  out << ", " << "triggers="; (__isset.triggers ? (out << to_string(triggers)) : (out << "<null>"));
  out << ", " << "poolTriggers="; (__isset.poolTriggers ? (out << to_string(poolTriggers)) : (out << "<null>"));
  out << ")";
}


WMCreateResourcePlanRequest::~WMCreateResourcePlanRequest() noexcept {
}


void WMCreateResourcePlanRequest::__set_resourcePlan(const WMResourcePlan& val) {
  this->resourcePlan = val;
__isset.resourcePlan = true;
}

void WMCreateResourcePlanRequest::__set_copyFrom(const std::string& val) {
  this->copyFrom = val;
__isset.copyFrom = true;
}
std::ostream& operator<<(std::ostream& out, const WMCreateResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreateResourcePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resourcePlan.read(iprot);
          this->__isset.resourcePlan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->copyFrom);
          this->__isset.copyFrom = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreateResourcePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreateResourcePlanRequest");

  if (this->__isset.resourcePlan) {
    xfer += oprot->writeFieldBegin("resourcePlan", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->resourcePlan.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.copyFrom) {
    xfer += oprot->writeFieldBegin("copyFrom", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->copyFrom);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreateResourcePlanRequest &a, WMCreateResourcePlanRequest &b) {
  using ::std::swap;
  swap(a.resourcePlan, b.resourcePlan);
  swap(a.copyFrom, b.copyFrom);
  swap(a.__isset, b.__isset);
}

WMCreateResourcePlanRequest::WMCreateResourcePlanRequest(const WMCreateResourcePlanRequest& other1308) {
  resourcePlan = other1308.resourcePlan;
  copyFrom = other1308.copyFrom;
  __isset = other1308.__isset;
}
WMCreateResourcePlanRequest& WMCreateResourcePlanRequest::operator=(const WMCreateResourcePlanRequest& other1309) {
  resourcePlan = other1309.resourcePlan;
  copyFrom = other1309.copyFrom;
  __isset = other1309.__isset;
  return *this;
}
void WMCreateResourcePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreateResourcePlanRequest(";
  out << "resourcePlan="; (__isset.resourcePlan ? (out << to_string(resourcePlan)) : (out << "<null>"));
  out << ", " << "copyFrom="; (__isset.copyFrom ? (out << to_string(copyFrom)) : (out << "<null>"));
  out << ")";
}


WMCreateResourcePlanResponse::~WMCreateResourcePlanResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMCreateResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreateResourcePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreateResourcePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreateResourcePlanResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreateResourcePlanResponse &a, WMCreateResourcePlanResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMCreateResourcePlanResponse::WMCreateResourcePlanResponse(const WMCreateResourcePlanResponse& other1310) {
  (void) other1310;
}
WMCreateResourcePlanResponse& WMCreateResourcePlanResponse::operator=(const WMCreateResourcePlanResponse& other1311) {
  (void) other1311;
  return *this;
}
void WMCreateResourcePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreateResourcePlanResponse(";
  out << ")";
}


WMGetActiveResourcePlanRequest::~WMGetActiveResourcePlanRequest() noexcept {
}


void WMGetActiveResourcePlanRequest::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetActiveResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetActiveResourcePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetActiveResourcePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetActiveResourcePlanRequest");

  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetActiveResourcePlanRequest &a, WMGetActiveResourcePlanRequest &b) {
  using ::std::swap;
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMGetActiveResourcePlanRequest::WMGetActiveResourcePlanRequest(const WMGetActiveResourcePlanRequest& other1312) {
  ns = other1312.ns;
  __isset = other1312.__isset;
}
WMGetActiveResourcePlanRequest& WMGetActiveResourcePlanRequest::operator=(const WMGetActiveResourcePlanRequest& other1313) {
  ns = other1313.ns;
  __isset = other1313.__isset;
  return *this;
}
void WMGetActiveResourcePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetActiveResourcePlanRequest(";
  out << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMGetActiveResourcePlanResponse::~WMGetActiveResourcePlanResponse() noexcept {
}


void WMGetActiveResourcePlanResponse::__set_resourcePlan(const WMFullResourcePlan& val) {
  this->resourcePlan = val;
__isset.resourcePlan = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetActiveResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetActiveResourcePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resourcePlan.read(iprot);
          this->__isset.resourcePlan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetActiveResourcePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetActiveResourcePlanResponse");

  if (this->__isset.resourcePlan) {
    xfer += oprot->writeFieldBegin("resourcePlan", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->resourcePlan.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetActiveResourcePlanResponse &a, WMGetActiveResourcePlanResponse &b) {
  using ::std::swap;
  swap(a.resourcePlan, b.resourcePlan);
  swap(a.__isset, b.__isset);
}

WMGetActiveResourcePlanResponse::WMGetActiveResourcePlanResponse(const WMGetActiveResourcePlanResponse& other1314) {
  resourcePlan = other1314.resourcePlan;
  __isset = other1314.__isset;
}
WMGetActiveResourcePlanResponse& WMGetActiveResourcePlanResponse::operator=(const WMGetActiveResourcePlanResponse& other1315) {
  resourcePlan = other1315.resourcePlan;
  __isset = other1315.__isset;
  return *this;
}
void WMGetActiveResourcePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetActiveResourcePlanResponse(";
  out << "resourcePlan="; (__isset.resourcePlan ? (out << to_string(resourcePlan)) : (out << "<null>"));
  out << ")";
}


WMGetResourcePlanRequest::~WMGetResourcePlanRequest() noexcept {
}


void WMGetResourcePlanRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}

void WMGetResourcePlanRequest::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetResourcePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetResourcePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetResourcePlanRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetResourcePlanRequest &a, WMGetResourcePlanRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMGetResourcePlanRequest::WMGetResourcePlanRequest(const WMGetResourcePlanRequest& other1316) {
  resourcePlanName = other1316.resourcePlanName;
  ns = other1316.ns;
  __isset = other1316.__isset;
}
WMGetResourcePlanRequest& WMGetResourcePlanRequest::operator=(const WMGetResourcePlanRequest& other1317) {
  resourcePlanName = other1317.resourcePlanName;
  ns = other1317.ns;
  __isset = other1317.__isset;
  return *this;
}
void WMGetResourcePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetResourcePlanRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMGetResourcePlanResponse::~WMGetResourcePlanResponse() noexcept {
}


void WMGetResourcePlanResponse::__set_resourcePlan(const WMFullResourcePlan& val) {
  this->resourcePlan = val;
__isset.resourcePlan = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetResourcePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resourcePlan.read(iprot);
          this->__isset.resourcePlan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetResourcePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetResourcePlanResponse");

  if (this->__isset.resourcePlan) {
    xfer += oprot->writeFieldBegin("resourcePlan", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->resourcePlan.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetResourcePlanResponse &a, WMGetResourcePlanResponse &b) {
  using ::std::swap;
  swap(a.resourcePlan, b.resourcePlan);
  swap(a.__isset, b.__isset);
}

WMGetResourcePlanResponse::WMGetResourcePlanResponse(const WMGetResourcePlanResponse& other1318) {
  resourcePlan = other1318.resourcePlan;
  __isset = other1318.__isset;
}
WMGetResourcePlanResponse& WMGetResourcePlanResponse::operator=(const WMGetResourcePlanResponse& other1319) {
  resourcePlan = other1319.resourcePlan;
  __isset = other1319.__isset;
  return *this;
}
void WMGetResourcePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetResourcePlanResponse(";
  out << "resourcePlan="; (__isset.resourcePlan ? (out << to_string(resourcePlan)) : (out << "<null>"));
  out << ")";
}


WMGetAllResourcePlanRequest::~WMGetAllResourcePlanRequest() noexcept {
}


void WMGetAllResourcePlanRequest::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetAllResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetAllResourcePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetAllResourcePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetAllResourcePlanRequest");

  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetAllResourcePlanRequest &a, WMGetAllResourcePlanRequest &b) {
  using ::std::swap;
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMGetAllResourcePlanRequest::WMGetAllResourcePlanRequest(const WMGetAllResourcePlanRequest& other1320) {
  ns = other1320.ns;
  __isset = other1320.__isset;
}
WMGetAllResourcePlanRequest& WMGetAllResourcePlanRequest::operator=(const WMGetAllResourcePlanRequest& other1321) {
  ns = other1321.ns;
  __isset = other1321.__isset;
  return *this;
}
void WMGetAllResourcePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetAllResourcePlanRequest(";
  out << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMGetAllResourcePlanResponse::~WMGetAllResourcePlanResponse() noexcept {
}


void WMGetAllResourcePlanResponse::__set_resourcePlans(const std::vector<WMResourcePlan> & val) {
  this->resourcePlans = val;
__isset.resourcePlans = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetAllResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetAllResourcePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->resourcePlans.clear();
            uint32_t _size1322;
            ::apache::thrift::protocol::TType _etype1325;
            xfer += iprot->readListBegin(_etype1325, _size1322);
            this->resourcePlans.resize(_size1322);
            uint32_t _i1326;
            for (_i1326 = 0; _i1326 < _size1322; ++_i1326)
            {
              xfer += this->resourcePlans[_i1326].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.resourcePlans = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetAllResourcePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetAllResourcePlanResponse");

  if (this->__isset.resourcePlans) {
    xfer += oprot->writeFieldBegin("resourcePlans", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->resourcePlans.size()));
      std::vector<WMResourcePlan> ::const_iterator _iter1327;
      for (_iter1327 = this->resourcePlans.begin(); _iter1327 != this->resourcePlans.end(); ++_iter1327)
      {
        xfer += (*_iter1327).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetAllResourcePlanResponse &a, WMGetAllResourcePlanResponse &b) {
  using ::std::swap;
  swap(a.resourcePlans, b.resourcePlans);
  swap(a.__isset, b.__isset);
}

WMGetAllResourcePlanResponse::WMGetAllResourcePlanResponse(const WMGetAllResourcePlanResponse& other1328) {
  resourcePlans = other1328.resourcePlans;
  __isset = other1328.__isset;
}
WMGetAllResourcePlanResponse& WMGetAllResourcePlanResponse::operator=(const WMGetAllResourcePlanResponse& other1329) {
  resourcePlans = other1329.resourcePlans;
  __isset = other1329.__isset;
  return *this;
}
void WMGetAllResourcePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetAllResourcePlanResponse(";
  out << "resourcePlans="; (__isset.resourcePlans ? (out << to_string(resourcePlans)) : (out << "<null>"));
  out << ")";
}


WMAlterResourcePlanRequest::~WMAlterResourcePlanRequest() noexcept {
}


void WMAlterResourcePlanRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}

void WMAlterResourcePlanRequest::__set_resourcePlan(const WMNullableResourcePlan& val) {
  this->resourcePlan = val;
__isset.resourcePlan = true;
}

void WMAlterResourcePlanRequest::__set_isEnableAndActivate(const bool val) {
  this->isEnableAndActivate = val;
__isset.isEnableAndActivate = true;
}

void WMAlterResourcePlanRequest::__set_isForceDeactivate(const bool val) {
  this->isForceDeactivate = val;
__isset.isForceDeactivate = true;
}

void WMAlterResourcePlanRequest::__set_isReplace(const bool val) {
  this->isReplace = val;
__isset.isReplace = true;
}

void WMAlterResourcePlanRequest::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMAlterResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMAlterResourcePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resourcePlan.read(iprot);
          this->__isset.resourcePlan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isEnableAndActivate);
          this->__isset.isEnableAndActivate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isForceDeactivate);
          this->__isset.isForceDeactivate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isReplace);
          this->__isset.isReplace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMAlterResourcePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMAlterResourcePlanRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resourcePlan) {
    xfer += oprot->writeFieldBegin("resourcePlan", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->resourcePlan.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isEnableAndActivate) {
    xfer += oprot->writeFieldBegin("isEnableAndActivate", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->isEnableAndActivate);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isForceDeactivate) {
    xfer += oprot->writeFieldBegin("isForceDeactivate", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->isForceDeactivate);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isReplace) {
    xfer += oprot->writeFieldBegin("isReplace", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->isReplace);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMAlterResourcePlanRequest &a, WMAlterResourcePlanRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.resourcePlan, b.resourcePlan);
  swap(a.isEnableAndActivate, b.isEnableAndActivate);
  swap(a.isForceDeactivate, b.isForceDeactivate);
  swap(a.isReplace, b.isReplace);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMAlterResourcePlanRequest::WMAlterResourcePlanRequest(const WMAlterResourcePlanRequest& other1330) {
  resourcePlanName = other1330.resourcePlanName;
  resourcePlan = other1330.resourcePlan;
  isEnableAndActivate = other1330.isEnableAndActivate;
  isForceDeactivate = other1330.isForceDeactivate;
  isReplace = other1330.isReplace;
  ns = other1330.ns;
  __isset = other1330.__isset;
}
WMAlterResourcePlanRequest& WMAlterResourcePlanRequest::operator=(const WMAlterResourcePlanRequest& other1331) {
  resourcePlanName = other1331.resourcePlanName;
  resourcePlan = other1331.resourcePlan;
  isEnableAndActivate = other1331.isEnableAndActivate;
  isForceDeactivate = other1331.isForceDeactivate;
  isReplace = other1331.isReplace;
  ns = other1331.ns;
  __isset = other1331.__isset;
  return *this;
}
void WMAlterResourcePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMAlterResourcePlanRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ", " << "resourcePlan="; (__isset.resourcePlan ? (out << to_string(resourcePlan)) : (out << "<null>"));
  out << ", " << "isEnableAndActivate="; (__isset.isEnableAndActivate ? (out << to_string(isEnableAndActivate)) : (out << "<null>"));
  out << ", " << "isForceDeactivate="; (__isset.isForceDeactivate ? (out << to_string(isForceDeactivate)) : (out << "<null>"));
  out << ", " << "isReplace="; (__isset.isReplace ? (out << to_string(isReplace)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMAlterResourcePlanResponse::~WMAlterResourcePlanResponse() noexcept {
}


void WMAlterResourcePlanResponse::__set_fullResourcePlan(const WMFullResourcePlan& val) {
  this->fullResourcePlan = val;
__isset.fullResourcePlan = true;
}
std::ostream& operator<<(std::ostream& out, const WMAlterResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMAlterResourcePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fullResourcePlan.read(iprot);
          this->__isset.fullResourcePlan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMAlterResourcePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMAlterResourcePlanResponse");

  if (this->__isset.fullResourcePlan) {
    xfer += oprot->writeFieldBegin("fullResourcePlan", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->fullResourcePlan.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMAlterResourcePlanResponse &a, WMAlterResourcePlanResponse &b) {
  using ::std::swap;
  swap(a.fullResourcePlan, b.fullResourcePlan);
  swap(a.__isset, b.__isset);
}

WMAlterResourcePlanResponse::WMAlterResourcePlanResponse(const WMAlterResourcePlanResponse& other1332) {
  fullResourcePlan = other1332.fullResourcePlan;
  __isset = other1332.__isset;
}
WMAlterResourcePlanResponse& WMAlterResourcePlanResponse::operator=(const WMAlterResourcePlanResponse& other1333) {
  fullResourcePlan = other1333.fullResourcePlan;
  __isset = other1333.__isset;
  return *this;
}
void WMAlterResourcePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMAlterResourcePlanResponse(";
  out << "fullResourcePlan="; (__isset.fullResourcePlan ? (out << to_string(fullResourcePlan)) : (out << "<null>"));
  out << ")";
}


WMValidateResourcePlanRequest::~WMValidateResourcePlanRequest() noexcept {
}


void WMValidateResourcePlanRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}

void WMValidateResourcePlanRequest::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMValidateResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMValidateResourcePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMValidateResourcePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMValidateResourcePlanRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMValidateResourcePlanRequest &a, WMValidateResourcePlanRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMValidateResourcePlanRequest::WMValidateResourcePlanRequest(const WMValidateResourcePlanRequest& other1334) {
  resourcePlanName = other1334.resourcePlanName;
  ns = other1334.ns;
  __isset = other1334.__isset;
}
WMValidateResourcePlanRequest& WMValidateResourcePlanRequest::operator=(const WMValidateResourcePlanRequest& other1335) {
  resourcePlanName = other1335.resourcePlanName;
  ns = other1335.ns;
  __isset = other1335.__isset;
  return *this;
}
void WMValidateResourcePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMValidateResourcePlanRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMValidateResourcePlanResponse::~WMValidateResourcePlanResponse() noexcept {
}


void WMValidateResourcePlanResponse::__set_errors(const std::vector<std::string> & val) {
  this->errors = val;
__isset.errors = true;
}

void WMValidateResourcePlanResponse::__set_warnings(const std::vector<std::string> & val) {
  this->warnings = val;
__isset.warnings = true;
}
std::ostream& operator<<(std::ostream& out, const WMValidateResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMValidateResourcePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->errors.clear();
            uint32_t _size1336;
            ::apache::thrift::protocol::TType _etype1339;
            xfer += iprot->readListBegin(_etype1339, _size1336);
            this->errors.resize(_size1336);
            uint32_t _i1340;
            for (_i1340 = 0; _i1340 < _size1336; ++_i1340)
            {
              xfer += iprot->readString(this->errors[_i1340]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.errors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->warnings.clear();
            uint32_t _size1341;
            ::apache::thrift::protocol::TType _etype1344;
            xfer += iprot->readListBegin(_etype1344, _size1341);
            this->warnings.resize(_size1341);
            uint32_t _i1345;
            for (_i1345 = 0; _i1345 < _size1341; ++_i1345)
            {
              xfer += iprot->readString(this->warnings[_i1345]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.warnings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMValidateResourcePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMValidateResourcePlanResponse");

  if (this->__isset.errors) {
    xfer += oprot->writeFieldBegin("errors", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->errors.size()));
      std::vector<std::string> ::const_iterator _iter1346;
      for (_iter1346 = this->errors.begin(); _iter1346 != this->errors.end(); ++_iter1346)
      {
        xfer += oprot->writeString((*_iter1346));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.warnings) {
    xfer += oprot->writeFieldBegin("warnings", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->warnings.size()));
      std::vector<std::string> ::const_iterator _iter1347;
      for (_iter1347 = this->warnings.begin(); _iter1347 != this->warnings.end(); ++_iter1347)
      {
        xfer += oprot->writeString((*_iter1347));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMValidateResourcePlanResponse &a, WMValidateResourcePlanResponse &b) {
  using ::std::swap;
  swap(a.errors, b.errors);
  swap(a.warnings, b.warnings);
  swap(a.__isset, b.__isset);
}

WMValidateResourcePlanResponse::WMValidateResourcePlanResponse(const WMValidateResourcePlanResponse& other1348) {
  errors = other1348.errors;
  warnings = other1348.warnings;
  __isset = other1348.__isset;
}
WMValidateResourcePlanResponse& WMValidateResourcePlanResponse::operator=(const WMValidateResourcePlanResponse& other1349) {
  errors = other1349.errors;
  warnings = other1349.warnings;
  __isset = other1349.__isset;
  return *this;
}
void WMValidateResourcePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMValidateResourcePlanResponse(";
  out << "errors="; (__isset.errors ? (out << to_string(errors)) : (out << "<null>"));
  out << ", " << "warnings="; (__isset.warnings ? (out << to_string(warnings)) : (out << "<null>"));
  out << ")";
}


WMDropResourcePlanRequest::~WMDropResourcePlanRequest() noexcept {
}


void WMDropResourcePlanRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}

void WMDropResourcePlanRequest::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMDropResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMDropResourcePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMDropResourcePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMDropResourcePlanRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMDropResourcePlanRequest &a, WMDropResourcePlanRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMDropResourcePlanRequest::WMDropResourcePlanRequest(const WMDropResourcePlanRequest& other1350) {
  resourcePlanName = other1350.resourcePlanName;
  ns = other1350.ns;
  __isset = other1350.__isset;
}
WMDropResourcePlanRequest& WMDropResourcePlanRequest::operator=(const WMDropResourcePlanRequest& other1351) {
  resourcePlanName = other1351.resourcePlanName;
  ns = other1351.ns;
  __isset = other1351.__isset;
  return *this;
}
void WMDropResourcePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMDropResourcePlanRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMDropResourcePlanResponse::~WMDropResourcePlanResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMDropResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMDropResourcePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMDropResourcePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMDropResourcePlanResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMDropResourcePlanResponse &a, WMDropResourcePlanResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMDropResourcePlanResponse::WMDropResourcePlanResponse(const WMDropResourcePlanResponse& other1352) {
  (void) other1352;
}
WMDropResourcePlanResponse& WMDropResourcePlanResponse::operator=(const WMDropResourcePlanResponse& other1353) {
  (void) other1353;
  return *this;
}
void WMDropResourcePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMDropResourcePlanResponse(";
  out << ")";
}


WMCreateTriggerRequest::~WMCreateTriggerRequest() noexcept {
}


void WMCreateTriggerRequest::__set_trigger(const WMTrigger& val) {
  this->trigger = val;
__isset.trigger = true;
}
std::ostream& operator<<(std::ostream& out, const WMCreateTriggerRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreateTriggerRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->trigger.read(iprot);
          this->__isset.trigger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreateTriggerRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreateTriggerRequest");

  if (this->__isset.trigger) {
    xfer += oprot->writeFieldBegin("trigger", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->trigger.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreateTriggerRequest &a, WMCreateTriggerRequest &b) {
  using ::std::swap;
  swap(a.trigger, b.trigger);
  swap(a.__isset, b.__isset);
}

WMCreateTriggerRequest::WMCreateTriggerRequest(const WMCreateTriggerRequest& other1354) {
  trigger = other1354.trigger;
  __isset = other1354.__isset;
}
WMCreateTriggerRequest& WMCreateTriggerRequest::operator=(const WMCreateTriggerRequest& other1355) {
  trigger = other1355.trigger;
  __isset = other1355.__isset;
  return *this;
}
void WMCreateTriggerRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreateTriggerRequest(";
  out << "trigger="; (__isset.trigger ? (out << to_string(trigger)) : (out << "<null>"));
  out << ")";
}


WMCreateTriggerResponse::~WMCreateTriggerResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMCreateTriggerResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreateTriggerResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreateTriggerResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreateTriggerResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreateTriggerResponse &a, WMCreateTriggerResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMCreateTriggerResponse::WMCreateTriggerResponse(const WMCreateTriggerResponse& other1356) {
  (void) other1356;
}
WMCreateTriggerResponse& WMCreateTriggerResponse::operator=(const WMCreateTriggerResponse& other1357) {
  (void) other1357;
  return *this;
}
void WMCreateTriggerResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreateTriggerResponse(";
  out << ")";
}


WMAlterTriggerRequest::~WMAlterTriggerRequest() noexcept {
}


void WMAlterTriggerRequest::__set_trigger(const WMTrigger& val) {
  this->trigger = val;
__isset.trigger = true;
}
std::ostream& operator<<(std::ostream& out, const WMAlterTriggerRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMAlterTriggerRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->trigger.read(iprot);
          this->__isset.trigger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMAlterTriggerRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMAlterTriggerRequest");

  if (this->__isset.trigger) {
    xfer += oprot->writeFieldBegin("trigger", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->trigger.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMAlterTriggerRequest &a, WMAlterTriggerRequest &b) {
  using ::std::swap;
  swap(a.trigger, b.trigger);
  swap(a.__isset, b.__isset);
}

WMAlterTriggerRequest::WMAlterTriggerRequest(const WMAlterTriggerRequest& other1358) {
  trigger = other1358.trigger;
  __isset = other1358.__isset;
}
WMAlterTriggerRequest& WMAlterTriggerRequest::operator=(const WMAlterTriggerRequest& other1359) {
  trigger = other1359.trigger;
  __isset = other1359.__isset;
  return *this;
}
void WMAlterTriggerRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMAlterTriggerRequest(";
  out << "trigger="; (__isset.trigger ? (out << to_string(trigger)) : (out << "<null>"));
  out << ")";
}


WMAlterTriggerResponse::~WMAlterTriggerResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMAlterTriggerResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMAlterTriggerResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMAlterTriggerResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMAlterTriggerResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMAlterTriggerResponse &a, WMAlterTriggerResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMAlterTriggerResponse::WMAlterTriggerResponse(const WMAlterTriggerResponse& other1360) {
  (void) other1360;
}
WMAlterTriggerResponse& WMAlterTriggerResponse::operator=(const WMAlterTriggerResponse& other1361) {
  (void) other1361;
  return *this;
}
void WMAlterTriggerResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMAlterTriggerResponse(";
  out << ")";
}


WMDropTriggerRequest::~WMDropTriggerRequest() noexcept {
}


void WMDropTriggerRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}

void WMDropTriggerRequest::__set_triggerName(const std::string& val) {
  this->triggerName = val;
__isset.triggerName = true;
}

void WMDropTriggerRequest::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMDropTriggerRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMDropTriggerRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->triggerName);
          this->__isset.triggerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMDropTriggerRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMDropTriggerRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.triggerName) {
    xfer += oprot->writeFieldBegin("triggerName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->triggerName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMDropTriggerRequest &a, WMDropTriggerRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.triggerName, b.triggerName);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMDropTriggerRequest::WMDropTriggerRequest(const WMDropTriggerRequest& other1362) {
  resourcePlanName = other1362.resourcePlanName;
  triggerName = other1362.triggerName;
  ns = other1362.ns;
  __isset = other1362.__isset;
}
WMDropTriggerRequest& WMDropTriggerRequest::operator=(const WMDropTriggerRequest& other1363) {
  resourcePlanName = other1363.resourcePlanName;
  triggerName = other1363.triggerName;
  ns = other1363.ns;
  __isset = other1363.__isset;
  return *this;
}
void WMDropTriggerRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMDropTriggerRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ", " << "triggerName="; (__isset.triggerName ? (out << to_string(triggerName)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMDropTriggerResponse::~WMDropTriggerResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMDropTriggerResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMDropTriggerResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMDropTriggerResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMDropTriggerResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMDropTriggerResponse &a, WMDropTriggerResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMDropTriggerResponse::WMDropTriggerResponse(const WMDropTriggerResponse& other1364) {
  (void) other1364;
}
WMDropTriggerResponse& WMDropTriggerResponse::operator=(const WMDropTriggerResponse& other1365) {
  (void) other1365;
  return *this;
}
void WMDropTriggerResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMDropTriggerResponse(";
  out << ")";
}


WMGetTriggersForResourePlanRequest::~WMGetTriggersForResourePlanRequest() noexcept {
}


void WMGetTriggersForResourePlanRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}

void WMGetTriggersForResourePlanRequest::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetTriggersForResourePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetTriggersForResourePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetTriggersForResourePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetTriggersForResourePlanRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetTriggersForResourePlanRequest &a, WMGetTriggersForResourePlanRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMGetTriggersForResourePlanRequest::WMGetTriggersForResourePlanRequest(const WMGetTriggersForResourePlanRequest& other1366) {
  resourcePlanName = other1366.resourcePlanName;
  ns = other1366.ns;
  __isset = other1366.__isset;
}
WMGetTriggersForResourePlanRequest& WMGetTriggersForResourePlanRequest::operator=(const WMGetTriggersForResourePlanRequest& other1367) {
  resourcePlanName = other1367.resourcePlanName;
  ns = other1367.ns;
  __isset = other1367.__isset;
  return *this;
}
void WMGetTriggersForResourePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetTriggersForResourePlanRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMGetTriggersForResourePlanResponse::~WMGetTriggersForResourePlanResponse() noexcept {
}


void WMGetTriggersForResourePlanResponse::__set_triggers(const std::vector<WMTrigger> & val) {
  this->triggers = val;
__isset.triggers = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetTriggersForResourePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetTriggersForResourePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->triggers.clear();
            uint32_t _size1368;
            ::apache::thrift::protocol::TType _etype1371;
            xfer += iprot->readListBegin(_etype1371, _size1368);
            this->triggers.resize(_size1368);
            uint32_t _i1372;
            for (_i1372 = 0; _i1372 < _size1368; ++_i1372)
            {
              xfer += this->triggers[_i1372].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.triggers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetTriggersForResourePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetTriggersForResourePlanResponse");

  if (this->__isset.triggers) {
    xfer += oprot->writeFieldBegin("triggers", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->triggers.size()));
      std::vector<WMTrigger> ::const_iterator _iter1373;
      for (_iter1373 = this->triggers.begin(); _iter1373 != this->triggers.end(); ++_iter1373)
      {
        xfer += (*_iter1373).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetTriggersForResourePlanResponse &a, WMGetTriggersForResourePlanResponse &b) {
  using ::std::swap;
  swap(a.triggers, b.triggers);
  swap(a.__isset, b.__isset);
}

WMGetTriggersForResourePlanResponse::WMGetTriggersForResourePlanResponse(const WMGetTriggersForResourePlanResponse& other1374) {
  triggers = other1374.triggers;
  __isset = other1374.__isset;
}
WMGetTriggersForResourePlanResponse& WMGetTriggersForResourePlanResponse::operator=(const WMGetTriggersForResourePlanResponse& other1375) {
  triggers = other1375.triggers;
  __isset = other1375.__isset;
  return *this;
}
void WMGetTriggersForResourePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetTriggersForResourePlanResponse(";
  out << "triggers="; (__isset.triggers ? (out << to_string(triggers)) : (out << "<null>"));
  out << ")";
}


WMCreatePoolRequest::~WMCreatePoolRequest() noexcept {
}


void WMCreatePoolRequest::__set_pool(const WMPool& val) {
  this->pool = val;
__isset.pool = true;
}
std::ostream& operator<<(std::ostream& out, const WMCreatePoolRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreatePoolRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pool.read(iprot);
          this->__isset.pool = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreatePoolRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreatePoolRequest");

  if (this->__isset.pool) {
    xfer += oprot->writeFieldBegin("pool", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->pool.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreatePoolRequest &a, WMCreatePoolRequest &b) {
  using ::std::swap;
  swap(a.pool, b.pool);
  swap(a.__isset, b.__isset);
}

WMCreatePoolRequest::WMCreatePoolRequest(const WMCreatePoolRequest& other1376) {
  pool = other1376.pool;
  __isset = other1376.__isset;
}
WMCreatePoolRequest& WMCreatePoolRequest::operator=(const WMCreatePoolRequest& other1377) {
  pool = other1377.pool;
  __isset = other1377.__isset;
  return *this;
}
void WMCreatePoolRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreatePoolRequest(";
  out << "pool="; (__isset.pool ? (out << to_string(pool)) : (out << "<null>"));
  out << ")";
}


WMCreatePoolResponse::~WMCreatePoolResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMCreatePoolResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreatePoolResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreatePoolResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreatePoolResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreatePoolResponse &a, WMCreatePoolResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMCreatePoolResponse::WMCreatePoolResponse(const WMCreatePoolResponse& other1378) {
  (void) other1378;
}
WMCreatePoolResponse& WMCreatePoolResponse::operator=(const WMCreatePoolResponse& other1379) {
  (void) other1379;
  return *this;
}
void WMCreatePoolResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreatePoolResponse(";
  out << ")";
}


WMAlterPoolRequest::~WMAlterPoolRequest() noexcept {
}


void WMAlterPoolRequest::__set_pool(const WMNullablePool& val) {
  this->pool = val;
__isset.pool = true;
}

void WMAlterPoolRequest::__set_poolPath(const std::string& val) {
  this->poolPath = val;
__isset.poolPath = true;
}
std::ostream& operator<<(std::ostream& out, const WMAlterPoolRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMAlterPoolRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pool.read(iprot);
          this->__isset.pool = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->poolPath);
          this->__isset.poolPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMAlterPoolRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMAlterPoolRequest");

  if (this->__isset.pool) {
    xfer += oprot->writeFieldBegin("pool", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->pool.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.poolPath) {
    xfer += oprot->writeFieldBegin("poolPath", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->poolPath);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMAlterPoolRequest &a, WMAlterPoolRequest &b) {
  using ::std::swap;
  swap(a.pool, b.pool);
  swap(a.poolPath, b.poolPath);
  swap(a.__isset, b.__isset);
}

WMAlterPoolRequest::WMAlterPoolRequest(const WMAlterPoolRequest& other1380) {
  pool = other1380.pool;
  poolPath = other1380.poolPath;
  __isset = other1380.__isset;
}
WMAlterPoolRequest& WMAlterPoolRequest::operator=(const WMAlterPoolRequest& other1381) {
  pool = other1381.pool;
  poolPath = other1381.poolPath;
  __isset = other1381.__isset;
  return *this;
}
void WMAlterPoolRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMAlterPoolRequest(";
  out << "pool="; (__isset.pool ? (out << to_string(pool)) : (out << "<null>"));
  out << ", " << "poolPath="; (__isset.poolPath ? (out << to_string(poolPath)) : (out << "<null>"));
  out << ")";
}


WMAlterPoolResponse::~WMAlterPoolResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMAlterPoolResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMAlterPoolResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMAlterPoolResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMAlterPoolResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMAlterPoolResponse &a, WMAlterPoolResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMAlterPoolResponse::WMAlterPoolResponse(const WMAlterPoolResponse& other1382) {
  (void) other1382;
}
WMAlterPoolResponse& WMAlterPoolResponse::operator=(const WMAlterPoolResponse& other1383) {
  (void) other1383;
  return *this;
}
void WMAlterPoolResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMAlterPoolResponse(";
  out << ")";
}


WMDropPoolRequest::~WMDropPoolRequest() noexcept {
}


void WMDropPoolRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}

void WMDropPoolRequest::__set_poolPath(const std::string& val) {
  this->poolPath = val;
__isset.poolPath = true;
}

void WMDropPoolRequest::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMDropPoolRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMDropPoolRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->poolPath);
          this->__isset.poolPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMDropPoolRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMDropPoolRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.poolPath) {
    xfer += oprot->writeFieldBegin("poolPath", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->poolPath);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMDropPoolRequest &a, WMDropPoolRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.poolPath, b.poolPath);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMDropPoolRequest::WMDropPoolRequest(const WMDropPoolRequest& other1384) {
  resourcePlanName = other1384.resourcePlanName;
  poolPath = other1384.poolPath;
  ns = other1384.ns;
  __isset = other1384.__isset;
}
WMDropPoolRequest& WMDropPoolRequest::operator=(const WMDropPoolRequest& other1385) {
  resourcePlanName = other1385.resourcePlanName;
  poolPath = other1385.poolPath;
  ns = other1385.ns;
  __isset = other1385.__isset;
  return *this;
}
void WMDropPoolRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMDropPoolRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ", " << "poolPath="; (__isset.poolPath ? (out << to_string(poolPath)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMDropPoolResponse::~WMDropPoolResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMDropPoolResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMDropPoolResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMDropPoolResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMDropPoolResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMDropPoolResponse &a, WMDropPoolResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMDropPoolResponse::WMDropPoolResponse(const WMDropPoolResponse& other1386) {
  (void) other1386;
}
WMDropPoolResponse& WMDropPoolResponse::operator=(const WMDropPoolResponse& other1387) {
  (void) other1387;
  return *this;
}
void WMDropPoolResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMDropPoolResponse(";
  out << ")";
}


WMCreateOrUpdateMappingRequest::~WMCreateOrUpdateMappingRequest() noexcept {
}


void WMCreateOrUpdateMappingRequest::__set_mapping(const WMMapping& val) {
  this->mapping = val;
__isset.mapping = true;
}

void WMCreateOrUpdateMappingRequest::__set_update(const bool val) {
  this->update = val;
__isset.update = true;
}
std::ostream& operator<<(std::ostream& out, const WMCreateOrUpdateMappingRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreateOrUpdateMappingRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mapping.read(iprot);
          this->__isset.mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->update);
          this->__isset.update = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreateOrUpdateMappingRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreateOrUpdateMappingRequest");

  if (this->__isset.mapping) {
    xfer += oprot->writeFieldBegin("mapping", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->mapping.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.update) {
    xfer += oprot->writeFieldBegin("update", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->update);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreateOrUpdateMappingRequest &a, WMCreateOrUpdateMappingRequest &b) {
  using ::std::swap;
  swap(a.mapping, b.mapping);
  swap(a.update, b.update);
  swap(a.__isset, b.__isset);
}

WMCreateOrUpdateMappingRequest::WMCreateOrUpdateMappingRequest(const WMCreateOrUpdateMappingRequest& other1388) {
  mapping = other1388.mapping;
  update = other1388.update;
  __isset = other1388.__isset;
}
WMCreateOrUpdateMappingRequest& WMCreateOrUpdateMappingRequest::operator=(const WMCreateOrUpdateMappingRequest& other1389) {
  mapping = other1389.mapping;
  update = other1389.update;
  __isset = other1389.__isset;
  return *this;
}
void WMCreateOrUpdateMappingRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreateOrUpdateMappingRequest(";
  out << "mapping="; (__isset.mapping ? (out << to_string(mapping)) : (out << "<null>"));
  out << ", " << "update="; (__isset.update ? (out << to_string(update)) : (out << "<null>"));
  out << ")";
}


WMCreateOrUpdateMappingResponse::~WMCreateOrUpdateMappingResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMCreateOrUpdateMappingResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreateOrUpdateMappingResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreateOrUpdateMappingResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreateOrUpdateMappingResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreateOrUpdateMappingResponse &a, WMCreateOrUpdateMappingResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMCreateOrUpdateMappingResponse::WMCreateOrUpdateMappingResponse(const WMCreateOrUpdateMappingResponse& other1390) {
  (void) other1390;
}
WMCreateOrUpdateMappingResponse& WMCreateOrUpdateMappingResponse::operator=(const WMCreateOrUpdateMappingResponse& other1391) {
  (void) other1391;
  return *this;
}
void WMCreateOrUpdateMappingResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreateOrUpdateMappingResponse(";
  out << ")";
}


WMDropMappingRequest::~WMDropMappingRequest() noexcept {
}


void WMDropMappingRequest::__set_mapping(const WMMapping& val) {
  this->mapping = val;
__isset.mapping = true;
}
std::ostream& operator<<(std::ostream& out, const WMDropMappingRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMDropMappingRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mapping.read(iprot);
          this->__isset.mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMDropMappingRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMDropMappingRequest");

  if (this->__isset.mapping) {
    xfer += oprot->writeFieldBegin("mapping", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->mapping.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMDropMappingRequest &a, WMDropMappingRequest &b) {
  using ::std::swap;
  swap(a.mapping, b.mapping);
  swap(a.__isset, b.__isset);
}

WMDropMappingRequest::WMDropMappingRequest(const WMDropMappingRequest& other1392) {
  mapping = other1392.mapping;
  __isset = other1392.__isset;
}
WMDropMappingRequest& WMDropMappingRequest::operator=(const WMDropMappingRequest& other1393) {
  mapping = other1393.mapping;
  __isset = other1393.__isset;
  return *this;
}
void WMDropMappingRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMDropMappingRequest(";
  out << "mapping="; (__isset.mapping ? (out << to_string(mapping)) : (out << "<null>"));
  out << ")";
}


WMDropMappingResponse::~WMDropMappingResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMDropMappingResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMDropMappingResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMDropMappingResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMDropMappingResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMDropMappingResponse &a, WMDropMappingResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMDropMappingResponse::WMDropMappingResponse(const WMDropMappingResponse& other1394) {
  (void) other1394;
}
WMDropMappingResponse& WMDropMappingResponse::operator=(const WMDropMappingResponse& other1395) {
  (void) other1395;
  return *this;
}
void WMDropMappingResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMDropMappingResponse(";
  out << ")";
}


WMCreateOrDropTriggerToPoolMappingRequest::~WMCreateOrDropTriggerToPoolMappingRequest() noexcept {
}


void WMCreateOrDropTriggerToPoolMappingRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}

void WMCreateOrDropTriggerToPoolMappingRequest::__set_triggerName(const std::string& val) {
  this->triggerName = val;
__isset.triggerName = true;
}

void WMCreateOrDropTriggerToPoolMappingRequest::__set_poolPath(const std::string& val) {
  this->poolPath = val;
__isset.poolPath = true;
}

void WMCreateOrDropTriggerToPoolMappingRequest::__set_drop(const bool val) {
  this->drop = val;
__isset.drop = true;
}

void WMCreateOrDropTriggerToPoolMappingRequest::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}
std::ostream& operator<<(std::ostream& out, const WMCreateOrDropTriggerToPoolMappingRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreateOrDropTriggerToPoolMappingRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->triggerName);
          this->__isset.triggerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->poolPath);
          this->__isset.poolPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->drop);
          this->__isset.drop = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreateOrDropTriggerToPoolMappingRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreateOrDropTriggerToPoolMappingRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.triggerName) {
    xfer += oprot->writeFieldBegin("triggerName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->triggerName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.poolPath) {
    xfer += oprot->writeFieldBegin("poolPath", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->poolPath);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drop) {
    xfer += oprot->writeFieldBegin("drop", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->drop);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreateOrDropTriggerToPoolMappingRequest &a, WMCreateOrDropTriggerToPoolMappingRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.triggerName, b.triggerName);
  swap(a.poolPath, b.poolPath);
  swap(a.drop, b.drop);
  swap(a.ns, b.ns);
  swap(a.__isset, b.__isset);
}

WMCreateOrDropTriggerToPoolMappingRequest::WMCreateOrDropTriggerToPoolMappingRequest(const WMCreateOrDropTriggerToPoolMappingRequest& other1396) {
  resourcePlanName = other1396.resourcePlanName;
  triggerName = other1396.triggerName;
  poolPath = other1396.poolPath;
  drop = other1396.drop;
  ns = other1396.ns;
  __isset = other1396.__isset;
}
WMCreateOrDropTriggerToPoolMappingRequest& WMCreateOrDropTriggerToPoolMappingRequest::operator=(const WMCreateOrDropTriggerToPoolMappingRequest& other1397) {
  resourcePlanName = other1397.resourcePlanName;
  triggerName = other1397.triggerName;
  poolPath = other1397.poolPath;
  drop = other1397.drop;
  ns = other1397.ns;
  __isset = other1397.__isset;
  return *this;
}
void WMCreateOrDropTriggerToPoolMappingRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreateOrDropTriggerToPoolMappingRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ", " << "triggerName="; (__isset.triggerName ? (out << to_string(triggerName)) : (out << "<null>"));
  out << ", " << "poolPath="; (__isset.poolPath ? (out << to_string(poolPath)) : (out << "<null>"));
  out << ", " << "drop="; (__isset.drop ? (out << to_string(drop)) : (out << "<null>"));
  out << ", " << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ")";
}


WMCreateOrDropTriggerToPoolMappingResponse::~WMCreateOrDropTriggerToPoolMappingResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMCreateOrDropTriggerToPoolMappingResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreateOrDropTriggerToPoolMappingResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreateOrDropTriggerToPoolMappingResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreateOrDropTriggerToPoolMappingResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreateOrDropTriggerToPoolMappingResponse &a, WMCreateOrDropTriggerToPoolMappingResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMCreateOrDropTriggerToPoolMappingResponse::WMCreateOrDropTriggerToPoolMappingResponse(const WMCreateOrDropTriggerToPoolMappingResponse& other1398) {
  (void) other1398;
}
WMCreateOrDropTriggerToPoolMappingResponse& WMCreateOrDropTriggerToPoolMappingResponse::operator=(const WMCreateOrDropTriggerToPoolMappingResponse& other1399) {
  (void) other1399;
  return *this;
}
void WMCreateOrDropTriggerToPoolMappingResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreateOrDropTriggerToPoolMappingResponse(";
  out << ")";
}


ISchema::~ISchema() noexcept {
}


void ISchema::__set_schemaType(const SchemaType::type val) {
  this->schemaType = val;
}

void ISchema::__set_name(const std::string& val) {
  this->name = val;
}

void ISchema::__set_catName(const std::string& val) {
  this->catName = val;
}

void ISchema::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void ISchema::__set_compatibility(const SchemaCompatibility::type val) {
  this->compatibility = val;
}

void ISchema::__set_validationLevel(const SchemaValidation::type val) {
  this->validationLevel = val;
}

void ISchema::__set_canEvolve(const bool val) {
  this->canEvolve = val;
}

void ISchema::__set_schemaGroup(const std::string& val) {
  this->schemaGroup = val;
__isset.schemaGroup = true;
}

void ISchema::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}
std::ostream& operator<<(std::ostream& out, const ISchema& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ISchema::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1400;
          xfer += iprot->readI32(ecast1400);
          this->schemaType = (SchemaType::type)ecast1400;
          this->__isset.schemaType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1401;
          xfer += iprot->readI32(ecast1401);
          this->compatibility = (SchemaCompatibility::type)ecast1401;
          this->__isset.compatibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1402;
          xfer += iprot->readI32(ecast1402);
          this->validationLevel = (SchemaValidation::type)ecast1402;
          this->__isset.validationLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->canEvolve);
          this->__isset.canEvolve = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaGroup);
          this->__isset.schemaGroup = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ISchema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ISchema");

  xfer += oprot->writeFieldBegin("schemaType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->schemaType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compatibility", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->compatibility);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validationLevel", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->validationLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("canEvolve", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->canEvolve);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.schemaGroup) {
    xfer += oprot->writeFieldBegin("schemaGroup", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->schemaGroup);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ISchema &a, ISchema &b) {
  using ::std::swap;
  swap(a.schemaType, b.schemaType);
  swap(a.name, b.name);
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.compatibility, b.compatibility);
  swap(a.validationLevel, b.validationLevel);
  swap(a.canEvolve, b.canEvolve);
  swap(a.schemaGroup, b.schemaGroup);
  swap(a.description, b.description);
  swap(a.__isset, b.__isset);
}

ISchema::ISchema(const ISchema& other1403) {
  schemaType = other1403.schemaType;
  name = other1403.name;
  catName = other1403.catName;
  dbName = other1403.dbName;
  compatibility = other1403.compatibility;
  validationLevel = other1403.validationLevel;
  canEvolve = other1403.canEvolve;
  schemaGroup = other1403.schemaGroup;
  description = other1403.description;
  __isset = other1403.__isset;
}
ISchema& ISchema::operator=(const ISchema& other1404) {
  schemaType = other1404.schemaType;
  name = other1404.name;
  catName = other1404.catName;
  dbName = other1404.dbName;
  compatibility = other1404.compatibility;
  validationLevel = other1404.validationLevel;
  canEvolve = other1404.canEvolve;
  schemaGroup = other1404.schemaGroup;
  description = other1404.description;
  __isset = other1404.__isset;
  return *this;
}
void ISchema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ISchema(";
  out << "schemaType=" << to_string(schemaType);
  out << ", " << "name=" << to_string(name);
  out << ", " << "catName=" << to_string(catName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "compatibility=" << to_string(compatibility);
  out << ", " << "validationLevel=" << to_string(validationLevel);
  out << ", " << "canEvolve=" << to_string(canEvolve);
  out << ", " << "schemaGroup="; (__isset.schemaGroup ? (out << to_string(schemaGroup)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ")";
}


ISchemaName::~ISchemaName() noexcept {
}


void ISchemaName::__set_catName(const std::string& val) {
  this->catName = val;
}

void ISchemaName::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void ISchemaName::__set_schemaName(const std::string& val) {
  this->schemaName = val;
}
std::ostream& operator<<(std::ostream& out, const ISchemaName& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ISchemaName::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaName);
          this->__isset.schemaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ISchemaName::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ISchemaName");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schemaName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->schemaName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ISchemaName &a, ISchemaName &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.schemaName, b.schemaName);
  swap(a.__isset, b.__isset);
}

ISchemaName::ISchemaName(const ISchemaName& other1405) {
  catName = other1405.catName;
  dbName = other1405.dbName;
  schemaName = other1405.schemaName;
  __isset = other1405.__isset;
}
ISchemaName& ISchemaName::operator=(const ISchemaName& other1406) {
  catName = other1406.catName;
  dbName = other1406.dbName;
  schemaName = other1406.schemaName;
  __isset = other1406.__isset;
  return *this;
}
void ISchemaName::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ISchemaName(";
  out << "catName=" << to_string(catName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "schemaName=" << to_string(schemaName);
  out << ")";
}


AlterISchemaRequest::~AlterISchemaRequest() noexcept {
}


void AlterISchemaRequest::__set_name(const ISchemaName& val) {
  this->name = val;
}

void AlterISchemaRequest::__set_newSchema(const ISchema& val) {
  this->newSchema = val;
}
std::ostream& operator<<(std::ostream& out, const AlterISchemaRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AlterISchemaRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->name.read(iprot);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->newSchema.read(iprot);
          this->__isset.newSchema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlterISchemaRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AlterISchemaRequest");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->name.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newSchema", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->newSchema.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlterISchemaRequest &a, AlterISchemaRequest &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.newSchema, b.newSchema);
  swap(a.__isset, b.__isset);
}

AlterISchemaRequest::AlterISchemaRequest(const AlterISchemaRequest& other1407) {
  name = other1407.name;
  newSchema = other1407.newSchema;
  __isset = other1407.__isset;
}
AlterISchemaRequest& AlterISchemaRequest::operator=(const AlterISchemaRequest& other1408) {
  name = other1408.name;
  newSchema = other1408.newSchema;
  __isset = other1408.__isset;
  return *this;
}
void AlterISchemaRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AlterISchemaRequest(";
  out << "name=" << to_string(name);
  out << ", " << "newSchema=" << to_string(newSchema);
  out << ")";
}


SchemaVersion::~SchemaVersion() noexcept {
}


void SchemaVersion::__set_schema(const ISchemaName& val) {
  this->schema = val;
}

void SchemaVersion::__set_version(const int32_t val) {
  this->version = val;
}

void SchemaVersion::__set_createdAt(const int64_t val) {
  this->createdAt = val;
}

void SchemaVersion::__set_cols(const std::vector<FieldSchema> & val) {
  this->cols = val;
}

void SchemaVersion::__set_state(const SchemaVersionState::type val) {
  this->state = val;
__isset.state = true;
}

void SchemaVersion::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void SchemaVersion::__set_schemaText(const std::string& val) {
  this->schemaText = val;
__isset.schemaText = true;
}

void SchemaVersion::__set_fingerprint(const std::string& val) {
  this->fingerprint = val;
__isset.fingerprint = true;
}

void SchemaVersion::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void SchemaVersion::__set_serDe(const SerDeInfo& val) {
  this->serDe = val;
__isset.serDe = true;
}
std::ostream& operator<<(std::ostream& out, const SchemaVersion& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SchemaVersion::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schema.read(iprot);
          this->__isset.schema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createdAt);
          this->__isset.createdAt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cols.clear();
            uint32_t _size1409;
            ::apache::thrift::protocol::TType _etype1412;
            xfer += iprot->readListBegin(_etype1412, _size1409);
            this->cols.resize(_size1409);
            uint32_t _i1413;
            for (_i1413 = 0; _i1413 < _size1409; ++_i1413)
            {
              xfer += this->cols[_i1413].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1414;
          xfer += iprot->readI32(ecast1414);
          this->state = (SchemaVersionState::type)ecast1414;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaText);
          this->__isset.schemaText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fingerprint);
          this->__isset.fingerprint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->serDe.read(iprot);
          this->__isset.serDe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SchemaVersion::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SchemaVersion");

  xfer += oprot->writeFieldBegin("schema", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->schema.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createdAt", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->createdAt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cols", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cols.size()));
    std::vector<FieldSchema> ::const_iterator _iter1415;
    for (_iter1415 = this->cols.begin(); _iter1415 != this->cols.end(); ++_iter1415)
    {
      xfer += (*_iter1415).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schemaText) {
    xfer += oprot->writeFieldBegin("schemaText", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->schemaText);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fingerprint) {
    xfer += oprot->writeFieldBegin("fingerprint", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->fingerprint);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.serDe) {
    xfer += oprot->writeFieldBegin("serDe", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->serDe.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SchemaVersion &a, SchemaVersion &b) {
  using ::std::swap;
  swap(a.schema, b.schema);
  swap(a.version, b.version);
  swap(a.createdAt, b.createdAt);
  swap(a.cols, b.cols);
  swap(a.state, b.state);
  swap(a.description, b.description);
  swap(a.schemaText, b.schemaText);
  swap(a.fingerprint, b.fingerprint);
  swap(a.name, b.name);
  swap(a.serDe, b.serDe);
  swap(a.__isset, b.__isset);
}

SchemaVersion::SchemaVersion(const SchemaVersion& other1416) {
  schema = other1416.schema;
  version = other1416.version;
  createdAt = other1416.createdAt;
  cols = other1416.cols;
  state = other1416.state;
  description = other1416.description;
  schemaText = other1416.schemaText;
  fingerprint = other1416.fingerprint;
  name = other1416.name;
  serDe = other1416.serDe;
  __isset = other1416.__isset;
}
SchemaVersion& SchemaVersion::operator=(const SchemaVersion& other1417) {
  schema = other1417.schema;
  version = other1417.version;
  createdAt = other1417.createdAt;
  cols = other1417.cols;
  state = other1417.state;
  description = other1417.description;
  schemaText = other1417.schemaText;
  fingerprint = other1417.fingerprint;
  name = other1417.name;
  serDe = other1417.serDe;
  __isset = other1417.__isset;
  return *this;
}
void SchemaVersion::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SchemaVersion(";
  out << "schema=" << to_string(schema);
  out << ", " << "version=" << to_string(version);
  out << ", " << "createdAt=" << to_string(createdAt);
  out << ", " << "cols=" << to_string(cols);
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "schemaText="; (__isset.schemaText ? (out << to_string(schemaText)) : (out << "<null>"));
  out << ", " << "fingerprint="; (__isset.fingerprint ? (out << to_string(fingerprint)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "serDe="; (__isset.serDe ? (out << to_string(serDe)) : (out << "<null>"));
  out << ")";
}


SchemaVersionDescriptor::~SchemaVersionDescriptor() noexcept {
}


void SchemaVersionDescriptor::__set_schema(const ISchemaName& val) {
  this->schema = val;
}

void SchemaVersionDescriptor::__set_version(const int32_t val) {
  this->version = val;
}
std::ostream& operator<<(std::ostream& out, const SchemaVersionDescriptor& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SchemaVersionDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schema.read(iprot);
          this->__isset.schema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SchemaVersionDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SchemaVersionDescriptor");

  xfer += oprot->writeFieldBegin("schema", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->schema.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SchemaVersionDescriptor &a, SchemaVersionDescriptor &b) {
  using ::std::swap;
  swap(a.schema, b.schema);
  swap(a.version, b.version);
  swap(a.__isset, b.__isset);
}

SchemaVersionDescriptor::SchemaVersionDescriptor(const SchemaVersionDescriptor& other1418) {
  schema = other1418.schema;
  version = other1418.version;
  __isset = other1418.__isset;
}
SchemaVersionDescriptor& SchemaVersionDescriptor::operator=(const SchemaVersionDescriptor& other1419) {
  schema = other1419.schema;
  version = other1419.version;
  __isset = other1419.__isset;
  return *this;
}
void SchemaVersionDescriptor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SchemaVersionDescriptor(";
  out << "schema=" << to_string(schema);
  out << ", " << "version=" << to_string(version);
  out << ")";
}


FindSchemasByColsRqst::~FindSchemasByColsRqst() noexcept {
}


void FindSchemasByColsRqst::__set_colName(const std::string& val) {
  this->colName = val;
__isset.colName = true;
}

void FindSchemasByColsRqst::__set_colNamespace(const std::string& val) {
  this->colNamespace = val;
__isset.colNamespace = true;
}

void FindSchemasByColsRqst::__set_type(const std::string& val) {
  this->type = val;
__isset.type = true;
}
std::ostream& operator<<(std::ostream& out, const FindSchemasByColsRqst& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FindSchemasByColsRqst::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->colName);
          this->__isset.colName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->colNamespace);
          this->__isset.colNamespace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FindSchemasByColsRqst::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FindSchemasByColsRqst");

  if (this->__isset.colName) {
    xfer += oprot->writeFieldBegin("colName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->colName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.colNamespace) {
    xfer += oprot->writeFieldBegin("colNamespace", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->colNamespace);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FindSchemasByColsRqst &a, FindSchemasByColsRqst &b) {
  using ::std::swap;
  swap(a.colName, b.colName);
  swap(a.colNamespace, b.colNamespace);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

FindSchemasByColsRqst::FindSchemasByColsRqst(const FindSchemasByColsRqst& other1420) {
  colName = other1420.colName;
  colNamespace = other1420.colNamespace;
  type = other1420.type;
  __isset = other1420.__isset;
}
FindSchemasByColsRqst& FindSchemasByColsRqst::operator=(const FindSchemasByColsRqst& other1421) {
  colName = other1421.colName;
  colNamespace = other1421.colNamespace;
  type = other1421.type;
  __isset = other1421.__isset;
  return *this;
}
void FindSchemasByColsRqst::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FindSchemasByColsRqst(";
  out << "colName="; (__isset.colName ? (out << to_string(colName)) : (out << "<null>"));
  out << ", " << "colNamespace="; (__isset.colNamespace ? (out << to_string(colNamespace)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ")";
}


FindSchemasByColsResp::~FindSchemasByColsResp() noexcept {
}


void FindSchemasByColsResp::__set_schemaVersions(const std::vector<SchemaVersionDescriptor> & val) {
  this->schemaVersions = val;
}
std::ostream& operator<<(std::ostream& out, const FindSchemasByColsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FindSchemasByColsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->schemaVersions.clear();
            uint32_t _size1422;
            ::apache::thrift::protocol::TType _etype1425;
            xfer += iprot->readListBegin(_etype1425, _size1422);
            this->schemaVersions.resize(_size1422);
            uint32_t _i1426;
            for (_i1426 = 0; _i1426 < _size1422; ++_i1426)
            {
              xfer += this->schemaVersions[_i1426].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.schemaVersions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FindSchemasByColsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FindSchemasByColsResp");

  xfer += oprot->writeFieldBegin("schemaVersions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->schemaVersions.size()));
    std::vector<SchemaVersionDescriptor> ::const_iterator _iter1427;
    for (_iter1427 = this->schemaVersions.begin(); _iter1427 != this->schemaVersions.end(); ++_iter1427)
    {
      xfer += (*_iter1427).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FindSchemasByColsResp &a, FindSchemasByColsResp &b) {
  using ::std::swap;
  swap(a.schemaVersions, b.schemaVersions);
  swap(a.__isset, b.__isset);
}

FindSchemasByColsResp::FindSchemasByColsResp(const FindSchemasByColsResp& other1428) {
  schemaVersions = other1428.schemaVersions;
  __isset = other1428.__isset;
}
FindSchemasByColsResp& FindSchemasByColsResp::operator=(const FindSchemasByColsResp& other1429) {
  schemaVersions = other1429.schemaVersions;
  __isset = other1429.__isset;
  return *this;
}
void FindSchemasByColsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FindSchemasByColsResp(";
  out << "schemaVersions=" << to_string(schemaVersions);
  out << ")";
}


MapSchemaVersionToSerdeRequest::~MapSchemaVersionToSerdeRequest() noexcept {
}


void MapSchemaVersionToSerdeRequest::__set_schemaVersion(const SchemaVersionDescriptor& val) {
  this->schemaVersion = val;
}

void MapSchemaVersionToSerdeRequest::__set_serdeName(const std::string& val) {
  this->serdeName = val;
}
std::ostream& operator<<(std::ostream& out, const MapSchemaVersionToSerdeRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MapSchemaVersionToSerdeRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schemaVersion.read(iprot);
          this->__isset.schemaVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serdeName);
          this->__isset.serdeName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MapSchemaVersionToSerdeRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MapSchemaVersionToSerdeRequest");

  xfer += oprot->writeFieldBegin("schemaVersion", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->schemaVersion.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serdeName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->serdeName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MapSchemaVersionToSerdeRequest &a, MapSchemaVersionToSerdeRequest &b) {
  using ::std::swap;
  swap(a.schemaVersion, b.schemaVersion);
  swap(a.serdeName, b.serdeName);
  swap(a.__isset, b.__isset);
}

MapSchemaVersionToSerdeRequest::MapSchemaVersionToSerdeRequest(const MapSchemaVersionToSerdeRequest& other1430) {
  schemaVersion = other1430.schemaVersion;
  serdeName = other1430.serdeName;
  __isset = other1430.__isset;
}
MapSchemaVersionToSerdeRequest& MapSchemaVersionToSerdeRequest::operator=(const MapSchemaVersionToSerdeRequest& other1431) {
  schemaVersion = other1431.schemaVersion;
  serdeName = other1431.serdeName;
  __isset = other1431.__isset;
  return *this;
}
void MapSchemaVersionToSerdeRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MapSchemaVersionToSerdeRequest(";
  out << "schemaVersion=" << to_string(schemaVersion);
  out << ", " << "serdeName=" << to_string(serdeName);
  out << ")";
}


SetSchemaVersionStateRequest::~SetSchemaVersionStateRequest() noexcept {
}


void SetSchemaVersionStateRequest::__set_schemaVersion(const SchemaVersionDescriptor& val) {
  this->schemaVersion = val;
}

void SetSchemaVersionStateRequest::__set_state(const SchemaVersionState::type val) {
  this->state = val;
}
std::ostream& operator<<(std::ostream& out, const SetSchemaVersionStateRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SetSchemaVersionStateRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schemaVersion.read(iprot);
          this->__isset.schemaVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1432;
          xfer += iprot->readI32(ecast1432);
          this->state = (SchemaVersionState::type)ecast1432;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SetSchemaVersionStateRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SetSchemaVersionStateRequest");

  xfer += oprot->writeFieldBegin("schemaVersion", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->schemaVersion.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SetSchemaVersionStateRequest &a, SetSchemaVersionStateRequest &b) {
  using ::std::swap;
  swap(a.schemaVersion, b.schemaVersion);
  swap(a.state, b.state);
  swap(a.__isset, b.__isset);
}

SetSchemaVersionStateRequest::SetSchemaVersionStateRequest(const SetSchemaVersionStateRequest& other1433) {
  schemaVersion = other1433.schemaVersion;
  state = other1433.state;
  __isset = other1433.__isset;
}
SetSchemaVersionStateRequest& SetSchemaVersionStateRequest::operator=(const SetSchemaVersionStateRequest& other1434) {
  schemaVersion = other1434.schemaVersion;
  state = other1434.state;
  __isset = other1434.__isset;
  return *this;
}
void SetSchemaVersionStateRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SetSchemaVersionStateRequest(";
  out << "schemaVersion=" << to_string(schemaVersion);
  out << ", " << "state=" << to_string(state);
  out << ")";
}


GetSerdeRequest::~GetSerdeRequest() noexcept {
}


void GetSerdeRequest::__set_serdeName(const std::string& val) {
  this->serdeName = val;
}
std::ostream& operator<<(std::ostream& out, const GetSerdeRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetSerdeRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serdeName);
          this->__isset.serdeName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetSerdeRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetSerdeRequest");

  xfer += oprot->writeFieldBegin("serdeName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->serdeName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetSerdeRequest &a, GetSerdeRequest &b) {
  using ::std::swap;
  swap(a.serdeName, b.serdeName);
  swap(a.__isset, b.__isset);
}

GetSerdeRequest::GetSerdeRequest(const GetSerdeRequest& other1435) {
  serdeName = other1435.serdeName;
  __isset = other1435.__isset;
}
GetSerdeRequest& GetSerdeRequest::operator=(const GetSerdeRequest& other1436) {
  serdeName = other1436.serdeName;
  __isset = other1436.__isset;
  return *this;
}
void GetSerdeRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetSerdeRequest(";
  out << "serdeName=" << to_string(serdeName);
  out << ")";
}


RuntimeStat::~RuntimeStat() noexcept {
}


void RuntimeStat::__set_createTime(const int32_t val) {
  this->createTime = val;
__isset.createTime = true;
}

void RuntimeStat::__set_weight(const int32_t val) {
  this->weight = val;
}

void RuntimeStat::__set_payload(const std::string& val) {
  this->payload = val;
}
std::ostream& operator<<(std::ostream& out, const RuntimeStat& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RuntimeStat::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_weight = false;
  bool isset_payload = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->weight);
          isset_weight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->payload);
          isset_payload = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_weight)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_payload)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RuntimeStat::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RuntimeStat");

  if (this->__isset.createTime) {
    xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->createTime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("weight", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->weight);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("payload", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->payload);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RuntimeStat &a, RuntimeStat &b) {
  using ::std::swap;
  swap(a.createTime, b.createTime);
  swap(a.weight, b.weight);
  swap(a.payload, b.payload);
  swap(a.__isset, b.__isset);
}

RuntimeStat::RuntimeStat(const RuntimeStat& other1437) {
  createTime = other1437.createTime;
  weight = other1437.weight;
  payload = other1437.payload;
  __isset = other1437.__isset;
}
RuntimeStat& RuntimeStat::operator=(const RuntimeStat& other1438) {
  createTime = other1438.createTime;
  weight = other1438.weight;
  payload = other1438.payload;
  __isset = other1438.__isset;
  return *this;
}
void RuntimeStat::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RuntimeStat(";
  out << "createTime="; (__isset.createTime ? (out << to_string(createTime)) : (out << "<null>"));
  out << ", " << "weight=" << to_string(weight);
  out << ", " << "payload=" << to_string(payload);
  out << ")";
}


GetRuntimeStatsRequest::~GetRuntimeStatsRequest() noexcept {
}


void GetRuntimeStatsRequest::__set_maxWeight(const int32_t val) {
  this->maxWeight = val;
}

void GetRuntimeStatsRequest::__set_maxCreateTime(const int32_t val) {
  this->maxCreateTime = val;
}
std::ostream& operator<<(std::ostream& out, const GetRuntimeStatsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetRuntimeStatsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_maxWeight = false;
  bool isset_maxCreateTime = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxWeight);
          isset_maxWeight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxCreateTime);
          isset_maxCreateTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_maxWeight)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxCreateTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetRuntimeStatsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetRuntimeStatsRequest");

  xfer += oprot->writeFieldBegin("maxWeight", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->maxWeight);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxCreateTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->maxCreateTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetRuntimeStatsRequest &a, GetRuntimeStatsRequest &b) {
  using ::std::swap;
  swap(a.maxWeight, b.maxWeight);
  swap(a.maxCreateTime, b.maxCreateTime);
}

GetRuntimeStatsRequest::GetRuntimeStatsRequest(const GetRuntimeStatsRequest& other1439) {
  maxWeight = other1439.maxWeight;
  maxCreateTime = other1439.maxCreateTime;
}
GetRuntimeStatsRequest& GetRuntimeStatsRequest::operator=(const GetRuntimeStatsRequest& other1440) {
  maxWeight = other1440.maxWeight;
  maxCreateTime = other1440.maxCreateTime;
  return *this;
}
void GetRuntimeStatsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetRuntimeStatsRequest(";
  out << "maxWeight=" << to_string(maxWeight);
  out << ", " << "maxCreateTime=" << to_string(maxCreateTime);
  out << ")";
}


CreateTableRequest::~CreateTableRequest() noexcept {
}


void CreateTableRequest::__set_table(const Table& val) {
  this->table = val;
}

void CreateTableRequest::__set_envContext(const EnvironmentContext& val) {
  this->envContext = val;
__isset.envContext = true;
}

void CreateTableRequest::__set_primaryKeys(const std::vector<SQLPrimaryKey> & val) {
  this->primaryKeys = val;
__isset.primaryKeys = true;
}

void CreateTableRequest::__set_foreignKeys(const std::vector<SQLForeignKey> & val) {
  this->foreignKeys = val;
__isset.foreignKeys = true;
}

void CreateTableRequest::__set_uniqueConstraints(const std::vector<SQLUniqueConstraint> & val) {
  this->uniqueConstraints = val;
__isset.uniqueConstraints = true;
}

void CreateTableRequest::__set_notNullConstraints(const std::vector<SQLNotNullConstraint> & val) {
  this->notNullConstraints = val;
__isset.notNullConstraints = true;
}

void CreateTableRequest::__set_defaultConstraints(const std::vector<SQLDefaultConstraint> & val) {
  this->defaultConstraints = val;
__isset.defaultConstraints = true;
}

void CreateTableRequest::__set_checkConstraints(const std::vector<SQLCheckConstraint> & val) {
  this->checkConstraints = val;
__isset.checkConstraints = true;
}

void CreateTableRequest::__set_processorCapabilities(const std::vector<std::string> & val) {
  this->processorCapabilities = val;
__isset.processorCapabilities = true;
}

void CreateTableRequest::__set_processorIdentifier(const std::string& val) {
  this->processorIdentifier = val;
__isset.processorIdentifier = true;
}
std::ostream& operator<<(std::ostream& out, const CreateTableRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateTableRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table.read(iprot);
          isset_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->envContext.read(iprot);
          this->__isset.envContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->primaryKeys.clear();
            uint32_t _size1441;
            ::apache::thrift::protocol::TType _etype1444;
            xfer += iprot->readListBegin(_etype1444, _size1441);
            this->primaryKeys.resize(_size1441);
            uint32_t _i1445;
            for (_i1445 = 0; _i1445 < _size1441; ++_i1445)
            {
              xfer += this->primaryKeys[_i1445].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.primaryKeys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->foreignKeys.clear();
            uint32_t _size1446;
            ::apache::thrift::protocol::TType _etype1449;
            xfer += iprot->readListBegin(_etype1449, _size1446);
            this->foreignKeys.resize(_size1446);
            uint32_t _i1450;
            for (_i1450 = 0; _i1450 < _size1446; ++_i1450)
            {
              xfer += this->foreignKeys[_i1450].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.foreignKeys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->uniqueConstraints.clear();
            uint32_t _size1451;
            ::apache::thrift::protocol::TType _etype1454;
            xfer += iprot->readListBegin(_etype1454, _size1451);
            this->uniqueConstraints.resize(_size1451);
            uint32_t _i1455;
            for (_i1455 = 0; _i1455 < _size1451; ++_i1455)
            {
              xfer += this->uniqueConstraints[_i1455].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.uniqueConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->notNullConstraints.clear();
            uint32_t _size1456;
            ::apache::thrift::protocol::TType _etype1459;
            xfer += iprot->readListBegin(_etype1459, _size1456);
            this->notNullConstraints.resize(_size1456);
            uint32_t _i1460;
            for (_i1460 = 0; _i1460 < _size1456; ++_i1460)
            {
              xfer += this->notNullConstraints[_i1460].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.notNullConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->defaultConstraints.clear();
            uint32_t _size1461;
            ::apache::thrift::protocol::TType _etype1464;
            xfer += iprot->readListBegin(_etype1464, _size1461);
            this->defaultConstraints.resize(_size1461);
            uint32_t _i1465;
            for (_i1465 = 0; _i1465 < _size1461; ++_i1465)
            {
              xfer += this->defaultConstraints[_i1465].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.defaultConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->checkConstraints.clear();
            uint32_t _size1466;
            ::apache::thrift::protocol::TType _etype1469;
            xfer += iprot->readListBegin(_etype1469, _size1466);
            this->checkConstraints.resize(_size1466);
            uint32_t _i1470;
            for (_i1470 = 0; _i1470 < _size1466; ++_i1470)
            {
              xfer += this->checkConstraints[_i1470].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.checkConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->processorCapabilities.clear();
            uint32_t _size1471;
            ::apache::thrift::protocol::TType _etype1474;
            xfer += iprot->readListBegin(_etype1474, _size1471);
            this->processorCapabilities.resize(_size1471);
            uint32_t _i1475;
            for (_i1475 = 0; _i1475 < _size1471; ++_i1475)
            {
              xfer += iprot->readString(this->processorCapabilities[_i1475]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.processorCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->processorIdentifier);
          this->__isset.processorIdentifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CreateTableRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateTableRequest");

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.envContext) {
    xfer += oprot->writeFieldBegin("envContext", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->envContext.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.primaryKeys) {
    xfer += oprot->writeFieldBegin("primaryKeys", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->primaryKeys.size()));
      std::vector<SQLPrimaryKey> ::const_iterator _iter1476;
      for (_iter1476 = this->primaryKeys.begin(); _iter1476 != this->primaryKeys.end(); ++_iter1476)
      {
        xfer += (*_iter1476).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.foreignKeys) {
    xfer += oprot->writeFieldBegin("foreignKeys", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->foreignKeys.size()));
      std::vector<SQLForeignKey> ::const_iterator _iter1477;
      for (_iter1477 = this->foreignKeys.begin(); _iter1477 != this->foreignKeys.end(); ++_iter1477)
      {
        xfer += (*_iter1477).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.uniqueConstraints) {
    xfer += oprot->writeFieldBegin("uniqueConstraints", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->uniqueConstraints.size()));
      std::vector<SQLUniqueConstraint> ::const_iterator _iter1478;
      for (_iter1478 = this->uniqueConstraints.begin(); _iter1478 != this->uniqueConstraints.end(); ++_iter1478)
      {
        xfer += (*_iter1478).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.notNullConstraints) {
    xfer += oprot->writeFieldBegin("notNullConstraints", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->notNullConstraints.size()));
      std::vector<SQLNotNullConstraint> ::const_iterator _iter1479;
      for (_iter1479 = this->notNullConstraints.begin(); _iter1479 != this->notNullConstraints.end(); ++_iter1479)
      {
        xfer += (*_iter1479).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.defaultConstraints) {
    xfer += oprot->writeFieldBegin("defaultConstraints", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->defaultConstraints.size()));
      std::vector<SQLDefaultConstraint> ::const_iterator _iter1480;
      for (_iter1480 = this->defaultConstraints.begin(); _iter1480 != this->defaultConstraints.end(); ++_iter1480)
      {
        xfer += (*_iter1480).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.checkConstraints) {
    xfer += oprot->writeFieldBegin("checkConstraints", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->checkConstraints.size()));
      std::vector<SQLCheckConstraint> ::const_iterator _iter1481;
      for (_iter1481 = this->checkConstraints.begin(); _iter1481 != this->checkConstraints.end(); ++_iter1481)
      {
        xfer += (*_iter1481).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorCapabilities) {
    xfer += oprot->writeFieldBegin("processorCapabilities", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->processorCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter1482;
      for (_iter1482 = this->processorCapabilities.begin(); _iter1482 != this->processorCapabilities.end(); ++_iter1482)
      {
        xfer += oprot->writeString((*_iter1482));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorIdentifier) {
    xfer += oprot->writeFieldBegin("processorIdentifier", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->processorIdentifier);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateTableRequest &a, CreateTableRequest &b) {
  using ::std::swap;
  swap(a.table, b.table);
  swap(a.envContext, b.envContext);
  swap(a.primaryKeys, b.primaryKeys);
  swap(a.foreignKeys, b.foreignKeys);
  swap(a.uniqueConstraints, b.uniqueConstraints);
  swap(a.notNullConstraints, b.notNullConstraints);
  swap(a.defaultConstraints, b.defaultConstraints);
  swap(a.checkConstraints, b.checkConstraints);
  swap(a.processorCapabilities, b.processorCapabilities);
  swap(a.processorIdentifier, b.processorIdentifier);
  swap(a.__isset, b.__isset);
}

CreateTableRequest::CreateTableRequest(const CreateTableRequest& other1483) {
  table = other1483.table;
  envContext = other1483.envContext;
  primaryKeys = other1483.primaryKeys;
  foreignKeys = other1483.foreignKeys;
  uniqueConstraints = other1483.uniqueConstraints;
  notNullConstraints = other1483.notNullConstraints;
  defaultConstraints = other1483.defaultConstraints;
  checkConstraints = other1483.checkConstraints;
  processorCapabilities = other1483.processorCapabilities;
  processorIdentifier = other1483.processorIdentifier;
  __isset = other1483.__isset;
}
CreateTableRequest& CreateTableRequest::operator=(const CreateTableRequest& other1484) {
  table = other1484.table;
  envContext = other1484.envContext;
  primaryKeys = other1484.primaryKeys;
  foreignKeys = other1484.foreignKeys;
  uniqueConstraints = other1484.uniqueConstraints;
  notNullConstraints = other1484.notNullConstraints;
  defaultConstraints = other1484.defaultConstraints;
  checkConstraints = other1484.checkConstraints;
  processorCapabilities = other1484.processorCapabilities;
  processorIdentifier = other1484.processorIdentifier;
  __isset = other1484.__isset;
  return *this;
}
void CreateTableRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateTableRequest(";
  out << "table=" << to_string(table);
  out << ", " << "envContext="; (__isset.envContext ? (out << to_string(envContext)) : (out << "<null>"));
  out << ", " << "primaryKeys="; (__isset.primaryKeys ? (out << to_string(primaryKeys)) : (out << "<null>"));
  out << ", " << "foreignKeys="; (__isset.foreignKeys ? (out << to_string(foreignKeys)) : (out << "<null>"));
  out << ", " << "uniqueConstraints="; (__isset.uniqueConstraints ? (out << to_string(uniqueConstraints)) : (out << "<null>"));
  out << ", " << "notNullConstraints="; (__isset.notNullConstraints ? (out << to_string(notNullConstraints)) : (out << "<null>"));
  out << ", " << "defaultConstraints="; (__isset.defaultConstraints ? (out << to_string(defaultConstraints)) : (out << "<null>"));
  out << ", " << "checkConstraints="; (__isset.checkConstraints ? (out << to_string(checkConstraints)) : (out << "<null>"));
  out << ", " << "processorCapabilities="; (__isset.processorCapabilities ? (out << to_string(processorCapabilities)) : (out << "<null>"));
  out << ", " << "processorIdentifier="; (__isset.processorIdentifier ? (out << to_string(processorIdentifier)) : (out << "<null>"));
  out << ")";
}


CreateDatabaseRequest::~CreateDatabaseRequest() noexcept {
}


void CreateDatabaseRequest::__set_databaseName(const std::string& val) {
  this->databaseName = val;
}

void CreateDatabaseRequest::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void CreateDatabaseRequest::__set_locationUri(const std::string& val) {
  this->locationUri = val;
__isset.locationUri = true;
}

void CreateDatabaseRequest::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
__isset.parameters = true;
}

void CreateDatabaseRequest::__set_privileges(const PrincipalPrivilegeSet& val) {
  this->privileges = val;
__isset.privileges = true;
}

void CreateDatabaseRequest::__set_ownerName(const std::string& val) {
  this->ownerName = val;
__isset.ownerName = true;
}

void CreateDatabaseRequest::__set_ownerType(const PrincipalType::type val) {
  this->ownerType = val;
__isset.ownerType = true;
}

void CreateDatabaseRequest::__set_catalogName(const std::string& val) {
  this->catalogName = val;
__isset.catalogName = true;
}

void CreateDatabaseRequest::__set_createTime(const int32_t val) {
  this->createTime = val;
__isset.createTime = true;
}

void CreateDatabaseRequest::__set_managedLocationUri(const std::string& val) {
  this->managedLocationUri = val;
__isset.managedLocationUri = true;
}

void CreateDatabaseRequest::__set_type(const std::string& val) {
  this->type = val;
__isset.type = true;
}

void CreateDatabaseRequest::__set_dataConnectorName(const std::string& val) {
  this->dataConnectorName = val;
__isset.dataConnectorName = true;
}
std::ostream& operator<<(std::ostream& out, const CreateDatabaseRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateDatabaseRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_databaseName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->databaseName);
          isset_databaseName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->locationUri);
          this->__isset.locationUri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size1485;
            ::apache::thrift::protocol::TType _ktype1486;
            ::apache::thrift::protocol::TType _vtype1487;
            xfer += iprot->readMapBegin(_ktype1486, _vtype1487, _size1485);
            uint32_t _i1489;
            for (_i1489 = 0; _i1489 < _size1485; ++_i1489)
            {
              std::string _key1490;
              xfer += iprot->readString(_key1490);
              std::string& _val1491 = this->parameters[_key1490];
              xfer += iprot->readString(_val1491);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1492;
          xfer += iprot->readI32(ecast1492);
          this->ownerType = (PrincipalType::type)ecast1492;
          this->__isset.ownerType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogName);
          this->__isset.catalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->managedLocationUri);
          this->__isset.managedLocationUri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataConnectorName);
          this->__isset.dataConnectorName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_databaseName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CreateDatabaseRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateDatabaseRequest");

  xfer += oprot->writeFieldBegin("databaseName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->databaseName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.locationUri) {
    xfer += oprot->writeFieldBegin("locationUri", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->locationUri);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parameters) {
    xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
      std::map<std::string, std::string> ::const_iterator _iter1493;
      for (_iter1493 = this->parameters.begin(); _iter1493 != this->parameters.end(); ++_iter1493)
      {
        xfer += oprot->writeString(_iter1493->first);
        xfer += oprot->writeString(_iter1493->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.privileges) {
    xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->privileges.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ownerName) {
    xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->ownerName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ownerType) {
    xfer += oprot->writeFieldBegin("ownerType", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->ownerType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalogName) {
    xfer += oprot->writeFieldBegin("catalogName", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->catalogName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTime) {
    xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->createTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.managedLocationUri) {
    xfer += oprot->writeFieldBegin("managedLocationUri", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->managedLocationUri);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dataConnectorName) {
    xfer += oprot->writeFieldBegin("dataConnectorName", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->dataConnectorName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateDatabaseRequest &a, CreateDatabaseRequest &b) {
  using ::std::swap;
  swap(a.databaseName, b.databaseName);
  swap(a.description, b.description);
  swap(a.locationUri, b.locationUri);
  swap(a.parameters, b.parameters);
  swap(a.privileges, b.privileges);
  swap(a.ownerName, b.ownerName);
  swap(a.ownerType, b.ownerType);
  swap(a.catalogName, b.catalogName);
  swap(a.createTime, b.createTime);
  swap(a.managedLocationUri, b.managedLocationUri);
  swap(a.type, b.type);
  swap(a.dataConnectorName, b.dataConnectorName);
  swap(a.__isset, b.__isset);
}

CreateDatabaseRequest::CreateDatabaseRequest(const CreateDatabaseRequest& other1494) {
  databaseName = other1494.databaseName;
  description = other1494.description;
  locationUri = other1494.locationUri;
  parameters = other1494.parameters;
  privileges = other1494.privileges;
  ownerName = other1494.ownerName;
  ownerType = other1494.ownerType;
  catalogName = other1494.catalogName;
  createTime = other1494.createTime;
  managedLocationUri = other1494.managedLocationUri;
  type = other1494.type;
  dataConnectorName = other1494.dataConnectorName;
  __isset = other1494.__isset;
}
CreateDatabaseRequest& CreateDatabaseRequest::operator=(const CreateDatabaseRequest& other1495) {
  databaseName = other1495.databaseName;
  description = other1495.description;
  locationUri = other1495.locationUri;
  parameters = other1495.parameters;
  privileges = other1495.privileges;
  ownerName = other1495.ownerName;
  ownerType = other1495.ownerType;
  catalogName = other1495.catalogName;
  createTime = other1495.createTime;
  managedLocationUri = other1495.managedLocationUri;
  type = other1495.type;
  dataConnectorName = other1495.dataConnectorName;
  __isset = other1495.__isset;
  return *this;
}
void CreateDatabaseRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateDatabaseRequest(";
  out << "databaseName=" << to_string(databaseName);
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "locationUri="; (__isset.locationUri ? (out << to_string(locationUri)) : (out << "<null>"));
  out << ", " << "parameters="; (__isset.parameters ? (out << to_string(parameters)) : (out << "<null>"));
  out << ", " << "privileges="; (__isset.privileges ? (out << to_string(privileges)) : (out << "<null>"));
  out << ", " << "ownerName="; (__isset.ownerName ? (out << to_string(ownerName)) : (out << "<null>"));
  out << ", " << "ownerType="; (__isset.ownerType ? (out << to_string(ownerType)) : (out << "<null>"));
  out << ", " << "catalogName="; (__isset.catalogName ? (out << to_string(catalogName)) : (out << "<null>"));
  out << ", " << "createTime="; (__isset.createTime ? (out << to_string(createTime)) : (out << "<null>"));
  out << ", " << "managedLocationUri="; (__isset.managedLocationUri ? (out << to_string(managedLocationUri)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "dataConnectorName="; (__isset.dataConnectorName ? (out << to_string(dataConnectorName)) : (out << "<null>"));
  out << ")";
}


CreateDataConnectorRequest::~CreateDataConnectorRequest() noexcept {
}


void CreateDataConnectorRequest::__set_connector(const DataConnector& val) {
  this->connector = val;
}
std::ostream& operator<<(std::ostream& out, const CreateDataConnectorRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateDataConnectorRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->connector.read(iprot);
          this->__isset.connector = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateDataConnectorRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateDataConnectorRequest");

  xfer += oprot->writeFieldBegin("connector", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->connector.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateDataConnectorRequest &a, CreateDataConnectorRequest &b) {
  using ::std::swap;
  swap(a.connector, b.connector);
  swap(a.__isset, b.__isset);
}

CreateDataConnectorRequest::CreateDataConnectorRequest(const CreateDataConnectorRequest& other1496) {
  connector = other1496.connector;
  __isset = other1496.__isset;
}
CreateDataConnectorRequest& CreateDataConnectorRequest::operator=(const CreateDataConnectorRequest& other1497) {
  connector = other1497.connector;
  __isset = other1497.__isset;
  return *this;
}
void CreateDataConnectorRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateDataConnectorRequest(";
  out << "connector=" << to_string(connector);
  out << ")";
}


GetDataConnectorRequest::~GetDataConnectorRequest() noexcept {
}


void GetDataConnectorRequest::__set_connectorName(const std::string& val) {
  this->connectorName = val;
}
std::ostream& operator<<(std::ostream& out, const GetDataConnectorRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetDataConnectorRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_connectorName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->connectorName);
          isset_connectorName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_connectorName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetDataConnectorRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetDataConnectorRequest");

  xfer += oprot->writeFieldBegin("connectorName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->connectorName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetDataConnectorRequest &a, GetDataConnectorRequest &b) {
  using ::std::swap;
  swap(a.connectorName, b.connectorName);
}

GetDataConnectorRequest::GetDataConnectorRequest(const GetDataConnectorRequest& other1498) {
  connectorName = other1498.connectorName;
}
GetDataConnectorRequest& GetDataConnectorRequest::operator=(const GetDataConnectorRequest& other1499) {
  connectorName = other1499.connectorName;
  return *this;
}
void GetDataConnectorRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetDataConnectorRequest(";
  out << "connectorName=" << to_string(connectorName);
  out << ")";
}


ScheduledQueryPollRequest::~ScheduledQueryPollRequest() noexcept {
}


void ScheduledQueryPollRequest::__set_clusterNamespace(const std::string& val) {
  this->clusterNamespace = val;
}
std::ostream& operator<<(std::ostream& out, const ScheduledQueryPollRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScheduledQueryPollRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_clusterNamespace = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clusterNamespace);
          isset_clusterNamespace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_clusterNamespace)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ScheduledQueryPollRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScheduledQueryPollRequest");

  xfer += oprot->writeFieldBegin("clusterNamespace", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->clusterNamespace);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScheduledQueryPollRequest &a, ScheduledQueryPollRequest &b) {
  using ::std::swap;
  swap(a.clusterNamespace, b.clusterNamespace);
}

ScheduledQueryPollRequest::ScheduledQueryPollRequest(const ScheduledQueryPollRequest& other1500) {
  clusterNamespace = other1500.clusterNamespace;
}
ScheduledQueryPollRequest& ScheduledQueryPollRequest::operator=(const ScheduledQueryPollRequest& other1501) {
  clusterNamespace = other1501.clusterNamespace;
  return *this;
}
void ScheduledQueryPollRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScheduledQueryPollRequest(";
  out << "clusterNamespace=" << to_string(clusterNamespace);
  out << ")";
}


ScheduledQueryKey::~ScheduledQueryKey() noexcept {
}


void ScheduledQueryKey::__set_scheduleName(const std::string& val) {
  this->scheduleName = val;
}

void ScheduledQueryKey::__set_clusterNamespace(const std::string& val) {
  this->clusterNamespace = val;
}
std::ostream& operator<<(std::ostream& out, const ScheduledQueryKey& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScheduledQueryKey::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_scheduleName = false;
  bool isset_clusterNamespace = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->scheduleName);
          isset_scheduleName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clusterNamespace);
          isset_clusterNamespace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_scheduleName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_clusterNamespace)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ScheduledQueryKey::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScheduledQueryKey");

  xfer += oprot->writeFieldBegin("scheduleName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->scheduleName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("clusterNamespace", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->clusterNamespace);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScheduledQueryKey &a, ScheduledQueryKey &b) {
  using ::std::swap;
  swap(a.scheduleName, b.scheduleName);
  swap(a.clusterNamespace, b.clusterNamespace);
}

ScheduledQueryKey::ScheduledQueryKey(const ScheduledQueryKey& other1502) {
  scheduleName = other1502.scheduleName;
  clusterNamespace = other1502.clusterNamespace;
}
ScheduledQueryKey& ScheduledQueryKey::operator=(const ScheduledQueryKey& other1503) {
  scheduleName = other1503.scheduleName;
  clusterNamespace = other1503.clusterNamespace;
  return *this;
}
void ScheduledQueryKey::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScheduledQueryKey(";
  out << "scheduleName=" << to_string(scheduleName);
  out << ", " << "clusterNamespace=" << to_string(clusterNamespace);
  out << ")";
}


ScheduledQueryPollResponse::~ScheduledQueryPollResponse() noexcept {
}


void ScheduledQueryPollResponse::__set_scheduleKey(const ScheduledQueryKey& val) {
  this->scheduleKey = val;
__isset.scheduleKey = true;
}

void ScheduledQueryPollResponse::__set_executionId(const int64_t val) {
  this->executionId = val;
__isset.executionId = true;
}

void ScheduledQueryPollResponse::__set_query(const std::string& val) {
  this->query = val;
__isset.query = true;
}

void ScheduledQueryPollResponse::__set_user(const std::string& val) {
  this->user = val;
__isset.user = true;
}
std::ostream& operator<<(std::ostream& out, const ScheduledQueryPollResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScheduledQueryPollResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scheduleKey.read(iprot);
          this->__isset.scheduleKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->executionId);
          this->__isset.executionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->query);
          this->__isset.query = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ScheduledQueryPollResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScheduledQueryPollResponse");

  if (this->__isset.scheduleKey) {
    xfer += oprot->writeFieldBegin("scheduleKey", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->scheduleKey.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.executionId) {
    xfer += oprot->writeFieldBegin("executionId", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->executionId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.query) {
    xfer += oprot->writeFieldBegin("query", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->query);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.user) {
    xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->user);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScheduledQueryPollResponse &a, ScheduledQueryPollResponse &b) {
  using ::std::swap;
  swap(a.scheduleKey, b.scheduleKey);
  swap(a.executionId, b.executionId);
  swap(a.query, b.query);
  swap(a.user, b.user);
  swap(a.__isset, b.__isset);
}

ScheduledQueryPollResponse::ScheduledQueryPollResponse(const ScheduledQueryPollResponse& other1504) {
  scheduleKey = other1504.scheduleKey;
  executionId = other1504.executionId;
  query = other1504.query;
  user = other1504.user;
  __isset = other1504.__isset;
}
ScheduledQueryPollResponse& ScheduledQueryPollResponse::operator=(const ScheduledQueryPollResponse& other1505) {
  scheduleKey = other1505.scheduleKey;
  executionId = other1505.executionId;
  query = other1505.query;
  user = other1505.user;
  __isset = other1505.__isset;
  return *this;
}
void ScheduledQueryPollResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScheduledQueryPollResponse(";
  out << "scheduleKey="; (__isset.scheduleKey ? (out << to_string(scheduleKey)) : (out << "<null>"));
  out << ", " << "executionId="; (__isset.executionId ? (out << to_string(executionId)) : (out << "<null>"));
  out << ", " << "query="; (__isset.query ? (out << to_string(query)) : (out << "<null>"));
  out << ", " << "user="; (__isset.user ? (out << to_string(user)) : (out << "<null>"));
  out << ")";
}


ScheduledQuery::~ScheduledQuery() noexcept {
}


void ScheduledQuery::__set_scheduleKey(const ScheduledQueryKey& val) {
  this->scheduleKey = val;
}

void ScheduledQuery::__set_enabled(const bool val) {
  this->enabled = val;
__isset.enabled = true;
}

void ScheduledQuery::__set_schedule(const std::string& val) {
  this->schedule = val;
__isset.schedule = true;
}

void ScheduledQuery::__set_user(const std::string& val) {
  this->user = val;
__isset.user = true;
}

void ScheduledQuery::__set_query(const std::string& val) {
  this->query = val;
__isset.query = true;
}

void ScheduledQuery::__set_nextExecution(const int32_t val) {
  this->nextExecution = val;
__isset.nextExecution = true;
}
std::ostream& operator<<(std::ostream& out, const ScheduledQuery& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScheduledQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_scheduleKey = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scheduleKey.read(iprot);
          isset_scheduleKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enabled);
          this->__isset.enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schedule);
          this->__isset.schedule = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->query);
          this->__isset.query = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nextExecution);
          this->__isset.nextExecution = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_scheduleKey)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ScheduledQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScheduledQuery");

  xfer += oprot->writeFieldBegin("scheduleKey", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->scheduleKey.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.enabled) {
    xfer += oprot->writeFieldBegin("enabled", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->enabled);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schedule) {
    xfer += oprot->writeFieldBegin("schedule", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->schedule);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.user) {
    xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->user);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.query) {
    xfer += oprot->writeFieldBegin("query", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->query);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nextExecution) {
    xfer += oprot->writeFieldBegin("nextExecution", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->nextExecution);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScheduledQuery &a, ScheduledQuery &b) {
  using ::std::swap;
  swap(a.scheduleKey, b.scheduleKey);
  swap(a.enabled, b.enabled);
  swap(a.schedule, b.schedule);
  swap(a.user, b.user);
  swap(a.query, b.query);
  swap(a.nextExecution, b.nextExecution);
  swap(a.__isset, b.__isset);
}

ScheduledQuery::ScheduledQuery(const ScheduledQuery& other1506) {
  scheduleKey = other1506.scheduleKey;
  enabled = other1506.enabled;
  schedule = other1506.schedule;
  user = other1506.user;
  query = other1506.query;
  nextExecution = other1506.nextExecution;
  __isset = other1506.__isset;
}
ScheduledQuery& ScheduledQuery::operator=(const ScheduledQuery& other1507) {
  scheduleKey = other1507.scheduleKey;
  enabled = other1507.enabled;
  schedule = other1507.schedule;
  user = other1507.user;
  query = other1507.query;
  nextExecution = other1507.nextExecution;
  __isset = other1507.__isset;
  return *this;
}
void ScheduledQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScheduledQuery(";
  out << "scheduleKey=" << to_string(scheduleKey);
  out << ", " << "enabled="; (__isset.enabled ? (out << to_string(enabled)) : (out << "<null>"));
  out << ", " << "schedule="; (__isset.schedule ? (out << to_string(schedule)) : (out << "<null>"));
  out << ", " << "user="; (__isset.user ? (out << to_string(user)) : (out << "<null>"));
  out << ", " << "query="; (__isset.query ? (out << to_string(query)) : (out << "<null>"));
  out << ", " << "nextExecution="; (__isset.nextExecution ? (out << to_string(nextExecution)) : (out << "<null>"));
  out << ")";
}


ScheduledQueryMaintenanceRequest::~ScheduledQueryMaintenanceRequest() noexcept {
}


void ScheduledQueryMaintenanceRequest::__set_type(const ScheduledQueryMaintenanceRequestType::type val) {
  this->type = val;
}

void ScheduledQueryMaintenanceRequest::__set_scheduledQuery(const ScheduledQuery& val) {
  this->scheduledQuery = val;
}
std::ostream& operator<<(std::ostream& out, const ScheduledQueryMaintenanceRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScheduledQueryMaintenanceRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;
  bool isset_scheduledQuery = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1508;
          xfer += iprot->readI32(ecast1508);
          this->type = (ScheduledQueryMaintenanceRequestType::type)ecast1508;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scheduledQuery.read(iprot);
          isset_scheduledQuery = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_scheduledQuery)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ScheduledQueryMaintenanceRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScheduledQueryMaintenanceRequest");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scheduledQuery", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->scheduledQuery.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScheduledQueryMaintenanceRequest &a, ScheduledQueryMaintenanceRequest &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.scheduledQuery, b.scheduledQuery);
}

ScheduledQueryMaintenanceRequest::ScheduledQueryMaintenanceRequest(const ScheduledQueryMaintenanceRequest& other1509) {
  type = other1509.type;
  scheduledQuery = other1509.scheduledQuery;
}
ScheduledQueryMaintenanceRequest& ScheduledQueryMaintenanceRequest::operator=(const ScheduledQueryMaintenanceRequest& other1510) {
  type = other1510.type;
  scheduledQuery = other1510.scheduledQuery;
  return *this;
}
void ScheduledQueryMaintenanceRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScheduledQueryMaintenanceRequest(";
  out << "type=" << to_string(type);
  out << ", " << "scheduledQuery=" << to_string(scheduledQuery);
  out << ")";
}


ScheduledQueryProgressInfo::~ScheduledQueryProgressInfo() noexcept {
}


void ScheduledQueryProgressInfo::__set_scheduledExecutionId(const int64_t val) {
  this->scheduledExecutionId = val;
}

void ScheduledQueryProgressInfo::__set_state(const QueryState::type val) {
  this->state = val;
}

void ScheduledQueryProgressInfo::__set_executorQueryId(const std::string& val) {
  this->executorQueryId = val;
}

void ScheduledQueryProgressInfo::__set_errorMessage(const std::string& val) {
  this->errorMessage = val;
__isset.errorMessage = true;
}
std::ostream& operator<<(std::ostream& out, const ScheduledQueryProgressInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScheduledQueryProgressInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_scheduledExecutionId = false;
  bool isset_state = false;
  bool isset_executorQueryId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->scheduledExecutionId);
          isset_scheduledExecutionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1511;
          xfer += iprot->readI32(ecast1511);
          this->state = (QueryState::type)ecast1511;
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->executorQueryId);
          isset_executorQueryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errorMessage);
          this->__isset.errorMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_scheduledExecutionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_executorQueryId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ScheduledQueryProgressInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScheduledQueryProgressInfo");

  xfer += oprot->writeFieldBegin("scheduledExecutionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->scheduledExecutionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("executorQueryId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->executorQueryId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.errorMessage) {
    xfer += oprot->writeFieldBegin("errorMessage", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->errorMessage);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScheduledQueryProgressInfo &a, ScheduledQueryProgressInfo &b) {
  using ::std::swap;
  swap(a.scheduledExecutionId, b.scheduledExecutionId);
  swap(a.state, b.state);
  swap(a.executorQueryId, b.executorQueryId);
  swap(a.errorMessage, b.errorMessage);
  swap(a.__isset, b.__isset);
}

ScheduledQueryProgressInfo::ScheduledQueryProgressInfo(const ScheduledQueryProgressInfo& other1512) {
  scheduledExecutionId = other1512.scheduledExecutionId;
  state = other1512.state;
  executorQueryId = other1512.executorQueryId;
  errorMessage = other1512.errorMessage;
  __isset = other1512.__isset;
}
ScheduledQueryProgressInfo& ScheduledQueryProgressInfo::operator=(const ScheduledQueryProgressInfo& other1513) {
  scheduledExecutionId = other1513.scheduledExecutionId;
  state = other1513.state;
  executorQueryId = other1513.executorQueryId;
  errorMessage = other1513.errorMessage;
  __isset = other1513.__isset;
  return *this;
}
void ScheduledQueryProgressInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScheduledQueryProgressInfo(";
  out << "scheduledExecutionId=" << to_string(scheduledExecutionId);
  out << ", " << "state=" << to_string(state);
  out << ", " << "executorQueryId=" << to_string(executorQueryId);
  out << ", " << "errorMessage="; (__isset.errorMessage ? (out << to_string(errorMessage)) : (out << "<null>"));
  out << ")";
}


AlterPartitionsRequest::~AlterPartitionsRequest() noexcept {
}


void AlterPartitionsRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void AlterPartitionsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void AlterPartitionsRequest::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void AlterPartitionsRequest::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
}

void AlterPartitionsRequest::__set_environmentContext(const EnvironmentContext& val) {
  this->environmentContext = val;
__isset.environmentContext = true;
}

void AlterPartitionsRequest::__set_writeId(const int64_t val) {
  this->writeId = val;
__isset.writeId = true;
}

void AlterPartitionsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}
std::ostream& operator<<(std::ostream& out, const AlterPartitionsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AlterPartitionsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tableName = false;
  bool isset_partitions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size1514;
            ::apache::thrift::protocol::TType _etype1517;
            xfer += iprot->readListBegin(_etype1517, _size1514);
            this->partitions.resize(_size1514);
            uint32_t _i1518;
            for (_i1518 = 0; _i1518 < _size1514; ++_i1518)
            {
              xfer += this->partitions[_i1518].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->environmentContext.read(iprot);
          this->__isset.environmentContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          this->__isset.writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AlterPartitionsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AlterPartitionsRequest");

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<Partition> ::const_iterator _iter1519;
    for (_iter1519 = this->partitions.begin(); _iter1519 != this->partitions.end(); ++_iter1519)
    {
      xfer += (*_iter1519).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.environmentContext) {
    xfer += oprot->writeFieldBegin("environmentContext", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->environmentContext.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writeId) {
    xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->writeId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlterPartitionsRequest &a, AlterPartitionsRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.partitions, b.partitions);
  swap(a.environmentContext, b.environmentContext);
  swap(a.writeId, b.writeId);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.__isset, b.__isset);
}

AlterPartitionsRequest::AlterPartitionsRequest(const AlterPartitionsRequest& other1520) {
  catName = other1520.catName;
  dbName = other1520.dbName;
  tableName = other1520.tableName;
  partitions = other1520.partitions;
  environmentContext = other1520.environmentContext;
  writeId = other1520.writeId;
  validWriteIdList = other1520.validWriteIdList;
  __isset = other1520.__isset;
}
AlterPartitionsRequest& AlterPartitionsRequest::operator=(const AlterPartitionsRequest& other1521) {
  catName = other1521.catName;
  dbName = other1521.dbName;
  tableName = other1521.tableName;
  partitions = other1521.partitions;
  environmentContext = other1521.environmentContext;
  writeId = other1521.writeId;
  validWriteIdList = other1521.validWriteIdList;
  __isset = other1521.__isset;
  return *this;
}
void AlterPartitionsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AlterPartitionsRequest(";
  out << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "partitions=" << to_string(partitions);
  out << ", " << "environmentContext="; (__isset.environmentContext ? (out << to_string(environmentContext)) : (out << "<null>"));
  out << ", " << "writeId="; (__isset.writeId ? (out << to_string(writeId)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ")";
}


AlterPartitionsResponse::~AlterPartitionsResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const AlterPartitionsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AlterPartitionsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlterPartitionsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AlterPartitionsResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlterPartitionsResponse &a, AlterPartitionsResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

AlterPartitionsResponse::AlterPartitionsResponse(const AlterPartitionsResponse& other1522) {
  (void) other1522;
}
AlterPartitionsResponse& AlterPartitionsResponse::operator=(const AlterPartitionsResponse& other1523) {
  (void) other1523;
  return *this;
}
void AlterPartitionsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AlterPartitionsResponse(";
  out << ")";
}


RenamePartitionRequest::~RenamePartitionRequest() noexcept {
}


void RenamePartitionRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void RenamePartitionRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void RenamePartitionRequest::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void RenamePartitionRequest::__set_partVals(const std::vector<std::string> & val) {
  this->partVals = val;
}

void RenamePartitionRequest::__set_newPart(const Partition& val) {
  this->newPart = val;
}

void RenamePartitionRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}
std::ostream& operator<<(std::ostream& out, const RenamePartitionRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RenamePartitionRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tableName = false;
  bool isset_partVals = false;
  bool isset_newPart = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partVals.clear();
            uint32_t _size1524;
            ::apache::thrift::protocol::TType _etype1527;
            xfer += iprot->readListBegin(_etype1527, _size1524);
            this->partVals.resize(_size1524);
            uint32_t _i1528;
            for (_i1528 = 0; _i1528 < _size1524; ++_i1528)
            {
              xfer += iprot->readString(this->partVals[_i1528]);
            }
            xfer += iprot->readListEnd();
          }
          isset_partVals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->newPart.read(iprot);
          isset_newPart = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partVals)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_newPart)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RenamePartitionRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RenamePartitionRequest");

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partVals", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partVals.size()));
    std::vector<std::string> ::const_iterator _iter1529;
    for (_iter1529 = this->partVals.begin(); _iter1529 != this->partVals.end(); ++_iter1529)
    {
      xfer += oprot->writeString((*_iter1529));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newPart", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->newPart.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RenamePartitionRequest &a, RenamePartitionRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.partVals, b.partVals);
  swap(a.newPart, b.newPart);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.__isset, b.__isset);
}

RenamePartitionRequest::RenamePartitionRequest(const RenamePartitionRequest& other1530) {
  catName = other1530.catName;
  dbName = other1530.dbName;
  tableName = other1530.tableName;
  partVals = other1530.partVals;
  newPart = other1530.newPart;
  validWriteIdList = other1530.validWriteIdList;
  __isset = other1530.__isset;
}
RenamePartitionRequest& RenamePartitionRequest::operator=(const RenamePartitionRequest& other1531) {
  catName = other1531.catName;
  dbName = other1531.dbName;
  tableName = other1531.tableName;
  partVals = other1531.partVals;
  newPart = other1531.newPart;
  validWriteIdList = other1531.validWriteIdList;
  __isset = other1531.__isset;
  return *this;
}
void RenamePartitionRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RenamePartitionRequest(";
  out << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "partVals=" << to_string(partVals);
  out << ", " << "newPart=" << to_string(newPart);
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ")";
}


RenamePartitionResponse::~RenamePartitionResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const RenamePartitionResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RenamePartitionResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RenamePartitionResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RenamePartitionResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RenamePartitionResponse &a, RenamePartitionResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

RenamePartitionResponse::RenamePartitionResponse(const RenamePartitionResponse& other1532) {
  (void) other1532;
}
RenamePartitionResponse& RenamePartitionResponse::operator=(const RenamePartitionResponse& other1533) {
  (void) other1533;
  return *this;
}
void RenamePartitionResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RenamePartitionResponse(";
  out << ")";
}


AlterTableRequest::~AlterTableRequest() noexcept {
}


void AlterTableRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void AlterTableRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void AlterTableRequest::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void AlterTableRequest::__set_table(const Table& val) {
  this->table = val;
}

void AlterTableRequest::__set_environmentContext(const EnvironmentContext& val) {
  this->environmentContext = val;
__isset.environmentContext = true;
}

void AlterTableRequest::__set_writeId(const int64_t val) {
  this->writeId = val;
__isset.writeId = true;
}

void AlterTableRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void AlterTableRequest::__set_processorCapabilities(const std::vector<std::string> & val) {
  this->processorCapabilities = val;
__isset.processorCapabilities = true;
}

void AlterTableRequest::__set_processorIdentifier(const std::string& val) {
  this->processorIdentifier = val;
__isset.processorIdentifier = true;
}
std::ostream& operator<<(std::ostream& out, const AlterTableRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AlterTableRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tableName = false;
  bool isset_table = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table.read(iprot);
          isset_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->environmentContext.read(iprot);
          this->__isset.environmentContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->writeId);
          this->__isset.writeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->processorCapabilities.clear();
            uint32_t _size1534;
            ::apache::thrift::protocol::TType _etype1537;
            xfer += iprot->readListBegin(_etype1537, _size1534);
            this->processorCapabilities.resize(_size1534);
            uint32_t _i1538;
            for (_i1538 = 0; _i1538 < _size1534; ++_i1538)
            {
              xfer += iprot->readString(this->processorCapabilities[_i1538]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.processorCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->processorIdentifier);
          this->__isset.processorIdentifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AlterTableRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AlterTableRequest");

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->table.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.environmentContext) {
    xfer += oprot->writeFieldBegin("environmentContext", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->environmentContext.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writeId) {
    xfer += oprot->writeFieldBegin("writeId", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->writeId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorCapabilities) {
    xfer += oprot->writeFieldBegin("processorCapabilities", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->processorCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter1539;
      for (_iter1539 = this->processorCapabilities.begin(); _iter1539 != this->processorCapabilities.end(); ++_iter1539)
      {
        xfer += oprot->writeString((*_iter1539));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorIdentifier) {
    xfer += oprot->writeFieldBegin("processorIdentifier", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->processorIdentifier);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlterTableRequest &a, AlterTableRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.table, b.table);
  swap(a.environmentContext, b.environmentContext);
  swap(a.writeId, b.writeId);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.processorCapabilities, b.processorCapabilities);
  swap(a.processorIdentifier, b.processorIdentifier);
  swap(a.__isset, b.__isset);
}

AlterTableRequest::AlterTableRequest(const AlterTableRequest& other1540) {
  catName = other1540.catName;
  dbName = other1540.dbName;
  tableName = other1540.tableName;
  table = other1540.table;
  environmentContext = other1540.environmentContext;
  writeId = other1540.writeId;
  validWriteIdList = other1540.validWriteIdList;
  processorCapabilities = other1540.processorCapabilities;
  processorIdentifier = other1540.processorIdentifier;
  __isset = other1540.__isset;
}
AlterTableRequest& AlterTableRequest::operator=(const AlterTableRequest& other1541) {
  catName = other1541.catName;
  dbName = other1541.dbName;
  tableName = other1541.tableName;
  table = other1541.table;
  environmentContext = other1541.environmentContext;
  writeId = other1541.writeId;
  validWriteIdList = other1541.validWriteIdList;
  processorCapabilities = other1541.processorCapabilities;
  processorIdentifier = other1541.processorIdentifier;
  __isset = other1541.__isset;
  return *this;
}
void AlterTableRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AlterTableRequest(";
  out << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "table=" << to_string(table);
  out << ", " << "environmentContext="; (__isset.environmentContext ? (out << to_string(environmentContext)) : (out << "<null>"));
  out << ", " << "writeId="; (__isset.writeId ? (out << to_string(writeId)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "processorCapabilities="; (__isset.processorCapabilities ? (out << to_string(processorCapabilities)) : (out << "<null>"));
  out << ", " << "processorIdentifier="; (__isset.processorIdentifier ? (out << to_string(processorIdentifier)) : (out << "<null>"));
  out << ")";
}


AlterTableResponse::~AlterTableResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const AlterTableResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AlterTableResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlterTableResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AlterTableResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlterTableResponse &a, AlterTableResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

AlterTableResponse::AlterTableResponse(const AlterTableResponse& other1542) {
  (void) other1542;
}
AlterTableResponse& AlterTableResponse::operator=(const AlterTableResponse& other1543) {
  (void) other1543;
  return *this;
}
void AlterTableResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AlterTableResponse(";
  out << ")";
}


GetPartitionsFilterSpec::~GetPartitionsFilterSpec() noexcept {
}


void GetPartitionsFilterSpec::__set_filterMode(const PartitionFilterMode::type val) {
  this->filterMode = val;
__isset.filterMode = true;
}

void GetPartitionsFilterSpec::__set_filters(const std::vector<std::string> & val) {
  this->filters = val;
__isset.filters = true;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionsFilterSpec& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionsFilterSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1544;
          xfer += iprot->readI32(ecast1544);
          this->filterMode = (PartitionFilterMode::type)ecast1544;
          this->__isset.filterMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->filters.clear();
            uint32_t _size1545;
            ::apache::thrift::protocol::TType _etype1548;
            xfer += iprot->readListBegin(_etype1548, _size1545);
            this->filters.resize(_size1545);
            uint32_t _i1549;
            for (_i1549 = 0; _i1549 < _size1545; ++_i1549)
            {
              xfer += iprot->readString(this->filters[_i1549]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.filters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetPartitionsFilterSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionsFilterSpec");

  if (this->__isset.filterMode) {
    xfer += oprot->writeFieldBegin("filterMode", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->filterMode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filters) {
    xfer += oprot->writeFieldBegin("filters", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->filters.size()));
      std::vector<std::string> ::const_iterator _iter1550;
      for (_iter1550 = this->filters.begin(); _iter1550 != this->filters.end(); ++_iter1550)
      {
        xfer += oprot->writeString((*_iter1550));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionsFilterSpec &a, GetPartitionsFilterSpec &b) {
  using ::std::swap;
  swap(a.filterMode, b.filterMode);
  swap(a.filters, b.filters);
  swap(a.__isset, b.__isset);
}

GetPartitionsFilterSpec::GetPartitionsFilterSpec(const GetPartitionsFilterSpec& other1551) {
  filterMode = other1551.filterMode;
  filters = other1551.filters;
  __isset = other1551.__isset;
}
GetPartitionsFilterSpec& GetPartitionsFilterSpec::operator=(const GetPartitionsFilterSpec& other1552) {
  filterMode = other1552.filterMode;
  filters = other1552.filters;
  __isset = other1552.__isset;
  return *this;
}
void GetPartitionsFilterSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionsFilterSpec(";
  out << "filterMode="; (__isset.filterMode ? (out << to_string(filterMode)) : (out << "<null>"));
  out << ", " << "filters="; (__isset.filters ? (out << to_string(filters)) : (out << "<null>"));
  out << ")";
}


GetPartitionsResponse::~GetPartitionsResponse() noexcept {
}


void GetPartitionsResponse::__set_partitionSpec(const std::vector<PartitionSpec> & val) {
  this->partitionSpec = val;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionSpec.clear();
            uint32_t _size1553;
            ::apache::thrift::protocol::TType _etype1556;
            xfer += iprot->readListBegin(_etype1556, _size1553);
            this->partitionSpec.resize(_size1553);
            uint32_t _i1557;
            for (_i1557 = 0; _i1557 < _size1553; ++_i1557)
            {
              xfer += this->partitionSpec[_i1557].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionSpec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetPartitionsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionsResponse");

  xfer += oprot->writeFieldBegin("partitionSpec", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitionSpec.size()));
    std::vector<PartitionSpec> ::const_iterator _iter1558;
    for (_iter1558 = this->partitionSpec.begin(); _iter1558 != this->partitionSpec.end(); ++_iter1558)
    {
      xfer += (*_iter1558).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionsResponse &a, GetPartitionsResponse &b) {
  using ::std::swap;
  swap(a.partitionSpec, b.partitionSpec);
  swap(a.__isset, b.__isset);
}

GetPartitionsResponse::GetPartitionsResponse(const GetPartitionsResponse& other1559) {
  partitionSpec = other1559.partitionSpec;
  __isset = other1559.__isset;
}
GetPartitionsResponse& GetPartitionsResponse::operator=(const GetPartitionsResponse& other1560) {
  partitionSpec = other1560.partitionSpec;
  __isset = other1560.__isset;
  return *this;
}
void GetPartitionsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionsResponse(";
  out << "partitionSpec=" << to_string(partitionSpec);
  out << ")";
}


GetPartitionsRequest::~GetPartitionsRequest() noexcept {
}


void GetPartitionsRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void GetPartitionsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void GetPartitionsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void GetPartitionsRequest::__set_withAuth(const bool val) {
  this->withAuth = val;
__isset.withAuth = true;
}

void GetPartitionsRequest::__set_user(const std::string& val) {
  this->user = val;
__isset.user = true;
}

void GetPartitionsRequest::__set_groupNames(const std::vector<std::string> & val) {
  this->groupNames = val;
__isset.groupNames = true;
}

void GetPartitionsRequest::__set_projectionSpec(const GetProjectionsSpec& val) {
  this->projectionSpec = val;
}

void GetPartitionsRequest::__set_filterSpec(const GetPartitionsFilterSpec& val) {
  this->filterSpec = val;
}

void GetPartitionsRequest::__set_processorCapabilities(const std::vector<std::string> & val) {
  this->processorCapabilities = val;
__isset.processorCapabilities = true;
}

void GetPartitionsRequest::__set_processorIdentifier(const std::string& val) {
  this->processorIdentifier = val;
__isset.processorIdentifier = true;
}

void GetPartitionsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          this->__isset.tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->withAuth);
          this->__isset.withAuth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->groupNames.clear();
            uint32_t _size1561;
            ::apache::thrift::protocol::TType _etype1564;
            xfer += iprot->readListBegin(_etype1564, _size1561);
            this->groupNames.resize(_size1561);
            uint32_t _i1565;
            for (_i1565 = 0; _i1565 < _size1561; ++_i1565)
            {
              xfer += iprot->readString(this->groupNames[_i1565]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.groupNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->projectionSpec.read(iprot);
          this->__isset.projectionSpec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->filterSpec.read(iprot);
          this->__isset.filterSpec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->processorCapabilities.clear();
            uint32_t _size1566;
            ::apache::thrift::protocol::TType _etype1569;
            xfer += iprot->readListBegin(_etype1569, _size1566);
            this->processorCapabilities.resize(_size1566);
            uint32_t _i1570;
            for (_i1570 = 0; _i1570 < _size1566; ++_i1570)
            {
              xfer += iprot->readString(this->processorCapabilities[_i1570]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.processorCapabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->processorIdentifier);
          this->__isset.processorIdentifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetPartitionsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionsRequest");

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.withAuth) {
    xfer += oprot->writeFieldBegin("withAuth", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->withAuth);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.user) {
    xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->user);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.groupNames) {
    xfer += oprot->writeFieldBegin("groupNames", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->groupNames.size()));
      std::vector<std::string> ::const_iterator _iter1571;
      for (_iter1571 = this->groupNames.begin(); _iter1571 != this->groupNames.end(); ++_iter1571)
      {
        xfer += oprot->writeString((*_iter1571));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("projectionSpec", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->projectionSpec.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filterSpec", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->filterSpec.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.processorCapabilities) {
    xfer += oprot->writeFieldBegin("processorCapabilities", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->processorCapabilities.size()));
      std::vector<std::string> ::const_iterator _iter1572;
      for (_iter1572 = this->processorCapabilities.begin(); _iter1572 != this->processorCapabilities.end(); ++_iter1572)
      {
        xfer += oprot->writeString((*_iter1572));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processorIdentifier) {
    xfer += oprot->writeFieldBegin("processorIdentifier", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->processorIdentifier);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionsRequest &a, GetPartitionsRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.withAuth, b.withAuth);
  swap(a.user, b.user);
  swap(a.groupNames, b.groupNames);
  swap(a.projectionSpec, b.projectionSpec);
  swap(a.filterSpec, b.filterSpec);
  swap(a.processorCapabilities, b.processorCapabilities);
  swap(a.processorIdentifier, b.processorIdentifier);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.__isset, b.__isset);
}

GetPartitionsRequest::GetPartitionsRequest(const GetPartitionsRequest& other1573) {
  catName = other1573.catName;
  dbName = other1573.dbName;
  tblName = other1573.tblName;
  withAuth = other1573.withAuth;
  user = other1573.user;
  groupNames = other1573.groupNames;
  projectionSpec = other1573.projectionSpec;
  filterSpec = other1573.filterSpec;
  processorCapabilities = other1573.processorCapabilities;
  processorIdentifier = other1573.processorIdentifier;
  validWriteIdList = other1573.validWriteIdList;
  __isset = other1573.__isset;
}
GetPartitionsRequest& GetPartitionsRequest::operator=(const GetPartitionsRequest& other1574) {
  catName = other1574.catName;
  dbName = other1574.dbName;
  tblName = other1574.tblName;
  withAuth = other1574.withAuth;
  user = other1574.user;
  groupNames = other1574.groupNames;
  projectionSpec = other1574.projectionSpec;
  filterSpec = other1574.filterSpec;
  processorCapabilities = other1574.processorCapabilities;
  processorIdentifier = other1574.processorIdentifier;
  validWriteIdList = other1574.validWriteIdList;
  __isset = other1574.__isset;
  return *this;
}
void GetPartitionsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionsRequest(";
  out << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "withAuth="; (__isset.withAuth ? (out << to_string(withAuth)) : (out << "<null>"));
  out << ", " << "user="; (__isset.user ? (out << to_string(user)) : (out << "<null>"));
  out << ", " << "groupNames="; (__isset.groupNames ? (out << to_string(groupNames)) : (out << "<null>"));
  out << ", " << "projectionSpec=" << to_string(projectionSpec);
  out << ", " << "filterSpec=" << to_string(filterSpec);
  out << ", " << "processorCapabilities="; (__isset.processorCapabilities ? (out << to_string(processorCapabilities)) : (out << "<null>"));
  out << ", " << "processorIdentifier="; (__isset.processorIdentifier ? (out << to_string(processorIdentifier)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ")";
}


GetFieldsRequest::~GetFieldsRequest() noexcept {
}


void GetFieldsRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void GetFieldsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void GetFieldsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void GetFieldsRequest::__set_envContext(const EnvironmentContext& val) {
  this->envContext = val;
__isset.envContext = true;
}

void GetFieldsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void GetFieldsRequest::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}
std::ostream& operator<<(std::ostream& out, const GetFieldsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetFieldsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->envContext.read(iprot);
          this->__isset.envContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetFieldsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetFieldsRequest");

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.envContext) {
    xfer += oprot->writeFieldBegin("envContext", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->envContext.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetFieldsRequest &a, GetFieldsRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.envContext, b.envContext);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

GetFieldsRequest::GetFieldsRequest(const GetFieldsRequest& other1575) {
  catName = other1575.catName;
  dbName = other1575.dbName;
  tblName = other1575.tblName;
  envContext = other1575.envContext;
  validWriteIdList = other1575.validWriteIdList;
  id = other1575.id;
  __isset = other1575.__isset;
}
GetFieldsRequest& GetFieldsRequest::operator=(const GetFieldsRequest& other1576) {
  catName = other1576.catName;
  dbName = other1576.dbName;
  tblName = other1576.tblName;
  envContext = other1576.envContext;
  validWriteIdList = other1576.validWriteIdList;
  id = other1576.id;
  __isset = other1576.__isset;
  return *this;
}
void GetFieldsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetFieldsRequest(";
  out << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "envContext="; (__isset.envContext ? (out << to_string(envContext)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


GetFieldsResponse::~GetFieldsResponse() noexcept {
}


void GetFieldsResponse::__set_fields(const std::vector<FieldSchema> & val) {
  this->fields = val;
}
std::ostream& operator<<(std::ostream& out, const GetFieldsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetFieldsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fields = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fields.clear();
            uint32_t _size1577;
            ::apache::thrift::protocol::TType _etype1580;
            xfer += iprot->readListBegin(_etype1580, _size1577);
            this->fields.resize(_size1577);
            uint32_t _i1581;
            for (_i1581 = 0; _i1581 < _size1577; ++_i1581)
            {
              xfer += this->fields[_i1581].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fields)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetFieldsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetFieldsResponse");

  xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fields.size()));
    std::vector<FieldSchema> ::const_iterator _iter1582;
    for (_iter1582 = this->fields.begin(); _iter1582 != this->fields.end(); ++_iter1582)
    {
      xfer += (*_iter1582).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetFieldsResponse &a, GetFieldsResponse &b) {
  using ::std::swap;
  swap(a.fields, b.fields);
}

GetFieldsResponse::GetFieldsResponse(const GetFieldsResponse& other1583) {
  fields = other1583.fields;
}
GetFieldsResponse& GetFieldsResponse::operator=(const GetFieldsResponse& other1584) {
  fields = other1584.fields;
  return *this;
}
void GetFieldsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetFieldsResponse(";
  out << "fields=" << to_string(fields);
  out << ")";
}


GetSchemaRequest::~GetSchemaRequest() noexcept {
}


void GetSchemaRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void GetSchemaRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void GetSchemaRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void GetSchemaRequest::__set_envContext(const EnvironmentContext& val) {
  this->envContext = val;
__isset.envContext = true;
}

void GetSchemaRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void GetSchemaRequest::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}
std::ostream& operator<<(std::ostream& out, const GetSchemaRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetSchemaRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->envContext.read(iprot);
          this->__isset.envContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetSchemaRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetSchemaRequest");

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.envContext) {
    xfer += oprot->writeFieldBegin("envContext", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->envContext.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetSchemaRequest &a, GetSchemaRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.envContext, b.envContext);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

GetSchemaRequest::GetSchemaRequest(const GetSchemaRequest& other1585) {
  catName = other1585.catName;
  dbName = other1585.dbName;
  tblName = other1585.tblName;
  envContext = other1585.envContext;
  validWriteIdList = other1585.validWriteIdList;
  id = other1585.id;
  __isset = other1585.__isset;
}
GetSchemaRequest& GetSchemaRequest::operator=(const GetSchemaRequest& other1586) {
  catName = other1586.catName;
  dbName = other1586.dbName;
  tblName = other1586.tblName;
  envContext = other1586.envContext;
  validWriteIdList = other1586.validWriteIdList;
  id = other1586.id;
  __isset = other1586.__isset;
  return *this;
}
void GetSchemaRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetSchemaRequest(";
  out << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "envContext="; (__isset.envContext ? (out << to_string(envContext)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


GetSchemaResponse::~GetSchemaResponse() noexcept {
}


void GetSchemaResponse::__set_fields(const std::vector<FieldSchema> & val) {
  this->fields = val;
}
std::ostream& operator<<(std::ostream& out, const GetSchemaResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetSchemaResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fields = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fields.clear();
            uint32_t _size1587;
            ::apache::thrift::protocol::TType _etype1590;
            xfer += iprot->readListBegin(_etype1590, _size1587);
            this->fields.resize(_size1587);
            uint32_t _i1591;
            for (_i1591 = 0; _i1591 < _size1587; ++_i1591)
            {
              xfer += this->fields[_i1591].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fields)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetSchemaResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetSchemaResponse");

  xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fields.size()));
    std::vector<FieldSchema> ::const_iterator _iter1592;
    for (_iter1592 = this->fields.begin(); _iter1592 != this->fields.end(); ++_iter1592)
    {
      xfer += (*_iter1592).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetSchemaResponse &a, GetSchemaResponse &b) {
  using ::std::swap;
  swap(a.fields, b.fields);
}

GetSchemaResponse::GetSchemaResponse(const GetSchemaResponse& other1593) {
  fields = other1593.fields;
}
GetSchemaResponse& GetSchemaResponse::operator=(const GetSchemaResponse& other1594) {
  fields = other1594.fields;
  return *this;
}
void GetSchemaResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetSchemaResponse(";
  out << "fields=" << to_string(fields);
  out << ")";
}


GetPartitionRequest::~GetPartitionRequest() noexcept {
}


void GetPartitionRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void GetPartitionRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void GetPartitionRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void GetPartitionRequest::__set_partVals(const std::vector<std::string> & val) {
  this->partVals = val;
}

void GetPartitionRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void GetPartitionRequest::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_partVals = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partVals.clear();
            uint32_t _size1595;
            ::apache::thrift::protocol::TType _etype1598;
            xfer += iprot->readListBegin(_etype1598, _size1595);
            this->partVals.resize(_size1595);
            uint32_t _i1599;
            for (_i1599 = 0; _i1599 < _size1595; ++_i1599)
            {
              xfer += iprot->readString(this->partVals[_i1599]);
            }
            xfer += iprot->readListEnd();
          }
          isset_partVals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partVals)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPartitionRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionRequest");

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partVals", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partVals.size()));
    std::vector<std::string> ::const_iterator _iter1600;
    for (_iter1600 = this->partVals.begin(); _iter1600 != this->partVals.end(); ++_iter1600)
    {
      xfer += oprot->writeString((*_iter1600));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionRequest &a, GetPartitionRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.partVals, b.partVals);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

GetPartitionRequest::GetPartitionRequest(const GetPartitionRequest& other1601) {
  catName = other1601.catName;
  dbName = other1601.dbName;
  tblName = other1601.tblName;
  partVals = other1601.partVals;
  validWriteIdList = other1601.validWriteIdList;
  id = other1601.id;
  __isset = other1601.__isset;
}
GetPartitionRequest& GetPartitionRequest::operator=(const GetPartitionRequest& other1602) {
  catName = other1602.catName;
  dbName = other1602.dbName;
  tblName = other1602.tblName;
  partVals = other1602.partVals;
  validWriteIdList = other1602.validWriteIdList;
  id = other1602.id;
  __isset = other1602.__isset;
  return *this;
}
void GetPartitionRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionRequest(";
  out << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "partVals=" << to_string(partVals);
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


GetPartitionResponse::~GetPartitionResponse() noexcept {
}


void GetPartitionResponse::__set_partition(const Partition& val) {
  this->partition = val;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partition = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->partition.read(iprot);
          isset_partition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partition)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPartitionResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionResponse");

  xfer += oprot->writeFieldBegin("partition", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->partition.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionResponse &a, GetPartitionResponse &b) {
  using ::std::swap;
  swap(a.partition, b.partition);
}

GetPartitionResponse::GetPartitionResponse(const GetPartitionResponse& other1603) {
  partition = other1603.partition;
}
GetPartitionResponse& GetPartitionResponse::operator=(const GetPartitionResponse& other1604) {
  partition = other1604.partition;
  return *this;
}
void GetPartitionResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionResponse(";
  out << "partition=" << to_string(partition);
  out << ")";
}


PartitionsRequest::~PartitionsRequest() noexcept {
}


void PartitionsRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void PartitionsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void PartitionsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void PartitionsRequest::__set_maxParts(const int16_t val) {
  this->maxParts = val;
__isset.maxParts = true;
}

void PartitionsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void PartitionsRequest::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}
std::ostream& operator<<(std::ostream& out, const PartitionsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->maxParts);
          this->__isset.maxParts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsRequest");

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.maxParts) {
    xfer += oprot->writeFieldBegin("maxParts", ::apache::thrift::protocol::T_I16, 4);
    xfer += oprot->writeI16(this->maxParts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsRequest &a, PartitionsRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.maxParts, b.maxParts);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

PartitionsRequest::PartitionsRequest(const PartitionsRequest& other1605) {
  catName = other1605.catName;
  dbName = other1605.dbName;
  tblName = other1605.tblName;
  maxParts = other1605.maxParts;
  validWriteIdList = other1605.validWriteIdList;
  id = other1605.id;
  __isset = other1605.__isset;
}
PartitionsRequest& PartitionsRequest::operator=(const PartitionsRequest& other1606) {
  catName = other1606.catName;
  dbName = other1606.dbName;
  tblName = other1606.tblName;
  maxParts = other1606.maxParts;
  validWriteIdList = other1606.validWriteIdList;
  id = other1606.id;
  __isset = other1606.__isset;
  return *this;
}
void PartitionsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsRequest(";
  out << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "maxParts="; (__isset.maxParts ? (out << to_string(maxParts)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


PartitionsResponse::~PartitionsResponse() noexcept {
}


void PartitionsResponse::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partitions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size1607;
            ::apache::thrift::protocol::TType _etype1610;
            xfer += iprot->readListBegin(_etype1610, _size1607);
            this->partitions.resize(_size1607);
            uint32_t _i1611;
            for (_i1611 = 0; _i1611 < _size1607; ++_i1611)
            {
              xfer += this->partitions[_i1611].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsResponse");

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<Partition> ::const_iterator _iter1612;
    for (_iter1612 = this->partitions.begin(); _iter1612 != this->partitions.end(); ++_iter1612)
    {
      xfer += (*_iter1612).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsResponse &a, PartitionsResponse &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
}

PartitionsResponse::PartitionsResponse(const PartitionsResponse& other1613) {
  partitions = other1613.partitions;
}
PartitionsResponse& PartitionsResponse::operator=(const PartitionsResponse& other1614) {
  partitions = other1614.partitions;
  return *this;
}
void PartitionsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsResponse(";
  out << "partitions=" << to_string(partitions);
  out << ")";
}


GetPartitionNamesPsRequest::~GetPartitionNamesPsRequest() noexcept {
}


void GetPartitionNamesPsRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void GetPartitionNamesPsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void GetPartitionNamesPsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void GetPartitionNamesPsRequest::__set_partValues(const std::vector<std::string> & val) {
  this->partValues = val;
__isset.partValues = true;
}

void GetPartitionNamesPsRequest::__set_maxParts(const int16_t val) {
  this->maxParts = val;
__isset.maxParts = true;
}

void GetPartitionNamesPsRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void GetPartitionNamesPsRequest::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionNamesPsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionNamesPsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partValues.clear();
            uint32_t _size1615;
            ::apache::thrift::protocol::TType _etype1618;
            xfer += iprot->readListBegin(_etype1618, _size1615);
            this->partValues.resize(_size1615);
            uint32_t _i1619;
            for (_i1619 = 0; _i1619 < _size1615; ++_i1619)
            {
              xfer += iprot->readString(this->partValues[_i1619]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->maxParts);
          this->__isset.maxParts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPartitionNamesPsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionNamesPsRequest");

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partValues) {
    xfer += oprot->writeFieldBegin("partValues", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partValues.size()));
      std::vector<std::string> ::const_iterator _iter1620;
      for (_iter1620 = this->partValues.begin(); _iter1620 != this->partValues.end(); ++_iter1620)
      {
        xfer += oprot->writeString((*_iter1620));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxParts) {
    xfer += oprot->writeFieldBegin("maxParts", ::apache::thrift::protocol::T_I16, 5);
    xfer += oprot->writeI16(this->maxParts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionNamesPsRequest &a, GetPartitionNamesPsRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.partValues, b.partValues);
  swap(a.maxParts, b.maxParts);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

GetPartitionNamesPsRequest::GetPartitionNamesPsRequest(const GetPartitionNamesPsRequest& other1621) {
  catName = other1621.catName;
  dbName = other1621.dbName;
  tblName = other1621.tblName;
  partValues = other1621.partValues;
  maxParts = other1621.maxParts;
  validWriteIdList = other1621.validWriteIdList;
  id = other1621.id;
  __isset = other1621.__isset;
}
GetPartitionNamesPsRequest& GetPartitionNamesPsRequest::operator=(const GetPartitionNamesPsRequest& other1622) {
  catName = other1622.catName;
  dbName = other1622.dbName;
  tblName = other1622.tblName;
  partValues = other1622.partValues;
  maxParts = other1622.maxParts;
  validWriteIdList = other1622.validWriteIdList;
  id = other1622.id;
  __isset = other1622.__isset;
  return *this;
}
void GetPartitionNamesPsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionNamesPsRequest(";
  out << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "partValues="; (__isset.partValues ? (out << to_string(partValues)) : (out << "<null>"));
  out << ", " << "maxParts="; (__isset.maxParts ? (out << to_string(maxParts)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


GetPartitionNamesPsResponse::~GetPartitionNamesPsResponse() noexcept {
}


void GetPartitionNamesPsResponse::__set_names(const std::vector<std::string> & val) {
  this->names = val;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionNamesPsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionNamesPsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_names = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size1623;
            ::apache::thrift::protocol::TType _etype1626;
            xfer += iprot->readListBegin(_etype1626, _size1623);
            this->names.resize(_size1623);
            uint32_t _i1627;
            for (_i1627 = 0; _i1627 < _size1623; ++_i1627)
            {
              xfer += iprot->readString(this->names[_i1627]);
            }
            xfer += iprot->readListEnd();
          }
          isset_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_names)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPartitionNamesPsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionNamesPsResponse");

  xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->names.size()));
    std::vector<std::string> ::const_iterator _iter1628;
    for (_iter1628 = this->names.begin(); _iter1628 != this->names.end(); ++_iter1628)
    {
      xfer += oprot->writeString((*_iter1628));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionNamesPsResponse &a, GetPartitionNamesPsResponse &b) {
  using ::std::swap;
  swap(a.names, b.names);
}

GetPartitionNamesPsResponse::GetPartitionNamesPsResponse(const GetPartitionNamesPsResponse& other1629) {
  names = other1629.names;
}
GetPartitionNamesPsResponse& GetPartitionNamesPsResponse::operator=(const GetPartitionNamesPsResponse& other1630) {
  names = other1630.names;
  return *this;
}
void GetPartitionNamesPsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionNamesPsResponse(";
  out << "names=" << to_string(names);
  out << ")";
}


GetPartitionsPsWithAuthRequest::~GetPartitionsPsWithAuthRequest() noexcept {
}


void GetPartitionsPsWithAuthRequest::__set_catName(const std::string& val) {
  this->catName = val;
__isset.catName = true;
}

void GetPartitionsPsWithAuthRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void GetPartitionsPsWithAuthRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void GetPartitionsPsWithAuthRequest::__set_partVals(const std::vector<std::string> & val) {
  this->partVals = val;
__isset.partVals = true;
}

void GetPartitionsPsWithAuthRequest::__set_maxParts(const int16_t val) {
  this->maxParts = val;
__isset.maxParts = true;
}

void GetPartitionsPsWithAuthRequest::__set_userName(const std::string& val) {
  this->userName = val;
__isset.userName = true;
}

void GetPartitionsPsWithAuthRequest::__set_groupNames(const std::vector<std::string> & val) {
  this->groupNames = val;
__isset.groupNames = true;
}

void GetPartitionsPsWithAuthRequest::__set_validWriteIdList(const std::string& val) {
  this->validWriteIdList = val;
__isset.validWriteIdList = true;
}

void GetPartitionsPsWithAuthRequest::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionsPsWithAuthRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionsPsWithAuthRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partVals.clear();
            uint32_t _size1631;
            ::apache::thrift::protocol::TType _etype1634;
            xfer += iprot->readListBegin(_etype1634, _size1631);
            this->partVals.resize(_size1631);
            uint32_t _i1635;
            for (_i1635 = 0; _i1635 < _size1631; ++_i1635)
            {
              xfer += iprot->readString(this->partVals[_i1635]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partVals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->maxParts);
          this->__isset.maxParts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userName);
          this->__isset.userName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->groupNames.clear();
            uint32_t _size1636;
            ::apache::thrift::protocol::TType _etype1639;
            xfer += iprot->readListBegin(_etype1639, _size1636);
            this->groupNames.resize(_size1636);
            uint32_t _i1640;
            for (_i1640 = 0; _i1640 < _size1636; ++_i1640)
            {
              xfer += iprot->readString(this->groupNames[_i1640]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.groupNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validWriteIdList);
          this->__isset.validWriteIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPartitionsPsWithAuthRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionsPsWithAuthRequest");

  if (this->__isset.catName) {
    xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->catName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partVals) {
    xfer += oprot->writeFieldBegin("partVals", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partVals.size()));
      std::vector<std::string> ::const_iterator _iter1641;
      for (_iter1641 = this->partVals.begin(); _iter1641 != this->partVals.end(); ++_iter1641)
      {
        xfer += oprot->writeString((*_iter1641));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxParts) {
    xfer += oprot->writeFieldBegin("maxParts", ::apache::thrift::protocol::T_I16, 5);
    xfer += oprot->writeI16(this->maxParts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.userName) {
    xfer += oprot->writeFieldBegin("userName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->userName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.groupNames) {
    xfer += oprot->writeFieldBegin("groupNames", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->groupNames.size()));
      std::vector<std::string> ::const_iterator _iter1642;
      for (_iter1642 = this->groupNames.begin(); _iter1642 != this->groupNames.end(); ++_iter1642)
      {
        xfer += oprot->writeString((*_iter1642));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.validWriteIdList) {
    xfer += oprot->writeFieldBegin("validWriteIdList", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->validWriteIdList);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionsPsWithAuthRequest &a, GetPartitionsPsWithAuthRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.partVals, b.partVals);
  swap(a.maxParts, b.maxParts);
  swap(a.userName, b.userName);
  swap(a.groupNames, b.groupNames);
  swap(a.validWriteIdList, b.validWriteIdList);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

GetPartitionsPsWithAuthRequest::GetPartitionsPsWithAuthRequest(const GetPartitionsPsWithAuthRequest& other1643) {
  catName = other1643.catName;
  dbName = other1643.dbName;
  tblName = other1643.tblName;
  partVals = other1643.partVals;
  maxParts = other1643.maxParts;
  userName = other1643.userName;
  groupNames = other1643.groupNames;
  validWriteIdList = other1643.validWriteIdList;
  id = other1643.id;
  __isset = other1643.__isset;
}
GetPartitionsPsWithAuthRequest& GetPartitionsPsWithAuthRequest::operator=(const GetPartitionsPsWithAuthRequest& other1644) {
  catName = other1644.catName;
  dbName = other1644.dbName;
  tblName = other1644.tblName;
  partVals = other1644.partVals;
  maxParts = other1644.maxParts;
  userName = other1644.userName;
  groupNames = other1644.groupNames;
  validWriteIdList = other1644.validWriteIdList;
  id = other1644.id;
  __isset = other1644.__isset;
  return *this;
}
void GetPartitionsPsWithAuthRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionsPsWithAuthRequest(";
  out << "catName="; (__isset.catName ? (out << to_string(catName)) : (out << "<null>"));
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "partVals="; (__isset.partVals ? (out << to_string(partVals)) : (out << "<null>"));
  out << ", " << "maxParts="; (__isset.maxParts ? (out << to_string(maxParts)) : (out << "<null>"));
  out << ", " << "userName="; (__isset.userName ? (out << to_string(userName)) : (out << "<null>"));
  out << ", " << "groupNames="; (__isset.groupNames ? (out << to_string(groupNames)) : (out << "<null>"));
  out << ", " << "validWriteIdList="; (__isset.validWriteIdList ? (out << to_string(validWriteIdList)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


GetPartitionsPsWithAuthResponse::~GetPartitionsPsWithAuthResponse() noexcept {
}


void GetPartitionsPsWithAuthResponse::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
}
std::ostream& operator<<(std::ostream& out, const GetPartitionsPsWithAuthResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPartitionsPsWithAuthResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partitions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size1645;
            ::apache::thrift::protocol::TType _etype1648;
            xfer += iprot->readListBegin(_etype1648, _size1645);
            this->partitions.resize(_size1645);
            uint32_t _i1649;
            for (_i1649 = 0; _i1649 < _size1645; ++_i1649)
            {
              xfer += this->partitions[_i1649].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPartitionsPsWithAuthResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPartitionsPsWithAuthResponse");

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<Partition> ::const_iterator _iter1650;
    for (_iter1650 = this->partitions.begin(); _iter1650 != this->partitions.end(); ++_iter1650)
    {
      xfer += (*_iter1650).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPartitionsPsWithAuthResponse &a, GetPartitionsPsWithAuthResponse &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
}

GetPartitionsPsWithAuthResponse::GetPartitionsPsWithAuthResponse(const GetPartitionsPsWithAuthResponse& other1651) {
  partitions = other1651.partitions;
}
GetPartitionsPsWithAuthResponse& GetPartitionsPsWithAuthResponse::operator=(const GetPartitionsPsWithAuthResponse& other1652) {
  partitions = other1652.partitions;
  return *this;
}
void GetPartitionsPsWithAuthResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPartitionsPsWithAuthResponse(";
  out << "partitions=" << to_string(partitions);
  out << ")";
}


ReplicationMetrics::~ReplicationMetrics() noexcept {
}


void ReplicationMetrics::__set_scheduledExecutionId(const int64_t val) {
  this->scheduledExecutionId = val;
}

void ReplicationMetrics::__set_policy(const std::string& val) {
  this->policy = val;
}

void ReplicationMetrics::__set_dumpExecutionId(const int64_t val) {
  this->dumpExecutionId = val;
}

void ReplicationMetrics::__set_metadata(const std::string& val) {
  this->metadata = val;
__isset.metadata = true;
}

void ReplicationMetrics::__set_progress(const std::string& val) {
  this->progress = val;
__isset.progress = true;
}
std::ostream& operator<<(std::ostream& out, const ReplicationMetrics& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ReplicationMetrics::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_scheduledExecutionId = false;
  bool isset_policy = false;
  bool isset_dumpExecutionId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->scheduledExecutionId);
          isset_scheduledExecutionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->policy);
          isset_policy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dumpExecutionId);
          isset_dumpExecutionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metadata);
          this->__isset.metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->progress);
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_scheduledExecutionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_policy)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dumpExecutionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ReplicationMetrics::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ReplicationMetrics");

  xfer += oprot->writeFieldBegin("scheduledExecutionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->scheduledExecutionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("policy", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->policy);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dumpExecutionId", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->dumpExecutionId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.metadata) {
    xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->metadata);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.progress) {
    xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->progress);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReplicationMetrics &a, ReplicationMetrics &b) {
  using ::std::swap;
  swap(a.scheduledExecutionId, b.scheduledExecutionId);
  swap(a.policy, b.policy);
  swap(a.dumpExecutionId, b.dumpExecutionId);
  swap(a.metadata, b.metadata);
  swap(a.progress, b.progress);
  swap(a.__isset, b.__isset);
}

ReplicationMetrics::ReplicationMetrics(const ReplicationMetrics& other1653) {
  scheduledExecutionId = other1653.scheduledExecutionId;
  policy = other1653.policy;
  dumpExecutionId = other1653.dumpExecutionId;
  metadata = other1653.metadata;
  progress = other1653.progress;
  __isset = other1653.__isset;
}
ReplicationMetrics& ReplicationMetrics::operator=(const ReplicationMetrics& other1654) {
  scheduledExecutionId = other1654.scheduledExecutionId;
  policy = other1654.policy;
  dumpExecutionId = other1654.dumpExecutionId;
  metadata = other1654.metadata;
  progress = other1654.progress;
  __isset = other1654.__isset;
  return *this;
}
void ReplicationMetrics::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ReplicationMetrics(";
  out << "scheduledExecutionId=" << to_string(scheduledExecutionId);
  out << ", " << "policy=" << to_string(policy);
  out << ", " << "dumpExecutionId=" << to_string(dumpExecutionId);
  out << ", " << "metadata="; (__isset.metadata ? (out << to_string(metadata)) : (out << "<null>"));
  out << ", " << "progress="; (__isset.progress ? (out << to_string(progress)) : (out << "<null>"));
  out << ")";
}


ReplicationMetricList::~ReplicationMetricList() noexcept {
}


void ReplicationMetricList::__set_replicationMetricList(const std::vector<ReplicationMetrics> & val) {
  this->replicationMetricList = val;
}
std::ostream& operator<<(std::ostream& out, const ReplicationMetricList& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ReplicationMetricList::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_replicationMetricList = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->replicationMetricList.clear();
            uint32_t _size1655;
            ::apache::thrift::protocol::TType _etype1658;
            xfer += iprot->readListBegin(_etype1658, _size1655);
            this->replicationMetricList.resize(_size1655);
            uint32_t _i1659;
            for (_i1659 = 0; _i1659 < _size1655; ++_i1659)
            {
              xfer += this->replicationMetricList[_i1659].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_replicationMetricList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_replicationMetricList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ReplicationMetricList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ReplicationMetricList");

  xfer += oprot->writeFieldBegin("replicationMetricList", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->replicationMetricList.size()));
    std::vector<ReplicationMetrics> ::const_iterator _iter1660;
    for (_iter1660 = this->replicationMetricList.begin(); _iter1660 != this->replicationMetricList.end(); ++_iter1660)
    {
      xfer += (*_iter1660).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReplicationMetricList &a, ReplicationMetricList &b) {
  using ::std::swap;
  swap(a.replicationMetricList, b.replicationMetricList);
}

ReplicationMetricList::ReplicationMetricList(const ReplicationMetricList& other1661) {
  replicationMetricList = other1661.replicationMetricList;
}
ReplicationMetricList& ReplicationMetricList::operator=(const ReplicationMetricList& other1662) {
  replicationMetricList = other1662.replicationMetricList;
  return *this;
}
void ReplicationMetricList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ReplicationMetricList(";
  out << "replicationMetricList=" << to_string(replicationMetricList);
  out << ")";
}


GetReplicationMetricsRequest::~GetReplicationMetricsRequest() noexcept {
}


void GetReplicationMetricsRequest::__set_scheduledExecutionId(const int64_t val) {
  this->scheduledExecutionId = val;
__isset.scheduledExecutionId = true;
}

void GetReplicationMetricsRequest::__set_policy(const std::string& val) {
  this->policy = val;
__isset.policy = true;
}

void GetReplicationMetricsRequest::__set_dumpExecutionId(const int64_t val) {
  this->dumpExecutionId = val;
__isset.dumpExecutionId = true;
}
std::ostream& operator<<(std::ostream& out, const GetReplicationMetricsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetReplicationMetricsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->scheduledExecutionId);
          this->__isset.scheduledExecutionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->policy);
          this->__isset.policy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dumpExecutionId);
          this->__isset.dumpExecutionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetReplicationMetricsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetReplicationMetricsRequest");

  if (this->__isset.scheduledExecutionId) {
    xfer += oprot->writeFieldBegin("scheduledExecutionId", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->scheduledExecutionId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.policy) {
    xfer += oprot->writeFieldBegin("policy", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->policy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dumpExecutionId) {
    xfer += oprot->writeFieldBegin("dumpExecutionId", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->dumpExecutionId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetReplicationMetricsRequest &a, GetReplicationMetricsRequest &b) {
  using ::std::swap;
  swap(a.scheduledExecutionId, b.scheduledExecutionId);
  swap(a.policy, b.policy);
  swap(a.dumpExecutionId, b.dumpExecutionId);
  swap(a.__isset, b.__isset);
}

GetReplicationMetricsRequest::GetReplicationMetricsRequest(const GetReplicationMetricsRequest& other1663) {
  scheduledExecutionId = other1663.scheduledExecutionId;
  policy = other1663.policy;
  dumpExecutionId = other1663.dumpExecutionId;
  __isset = other1663.__isset;
}
GetReplicationMetricsRequest& GetReplicationMetricsRequest::operator=(const GetReplicationMetricsRequest& other1664) {
  scheduledExecutionId = other1664.scheduledExecutionId;
  policy = other1664.policy;
  dumpExecutionId = other1664.dumpExecutionId;
  __isset = other1664.__isset;
  return *this;
}
void GetReplicationMetricsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetReplicationMetricsRequest(";
  out << "scheduledExecutionId="; (__isset.scheduledExecutionId ? (out << to_string(scheduledExecutionId)) : (out << "<null>"));
  out << ", " << "policy="; (__isset.policy ? (out << to_string(policy)) : (out << "<null>"));
  out << ", " << "dumpExecutionId="; (__isset.dumpExecutionId ? (out << to_string(dumpExecutionId)) : (out << "<null>"));
  out << ")";
}


GetOpenTxnsRequest::~GetOpenTxnsRequest() noexcept {
}


void GetOpenTxnsRequest::__set_excludeTxnTypes(const std::vector<TxnType::type> & val) {
  this->excludeTxnTypes = val;
__isset.excludeTxnTypes = true;
}
std::ostream& operator<<(std::ostream& out, const GetOpenTxnsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetOpenTxnsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->excludeTxnTypes.clear();
            uint32_t _size1665;
            ::apache::thrift::protocol::TType _etype1668;
            xfer += iprot->readListBegin(_etype1668, _size1665);
            this->excludeTxnTypes.resize(_size1665);
            uint32_t _i1669;
            for (_i1669 = 0; _i1669 < _size1665; ++_i1669)
            {
              int32_t ecast1670;
              xfer += iprot->readI32(ecast1670);
              this->excludeTxnTypes[_i1669] = (TxnType::type)ecast1670;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.excludeTxnTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetOpenTxnsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetOpenTxnsRequest");

  if (this->__isset.excludeTxnTypes) {
    xfer += oprot->writeFieldBegin("excludeTxnTypes", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->excludeTxnTypes.size()));
      std::vector<TxnType::type> ::const_iterator _iter1671;
      for (_iter1671 = this->excludeTxnTypes.begin(); _iter1671 != this->excludeTxnTypes.end(); ++_iter1671)
      {
        xfer += oprot->writeI32((int32_t)(*_iter1671));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetOpenTxnsRequest &a, GetOpenTxnsRequest &b) {
  using ::std::swap;
  swap(a.excludeTxnTypes, b.excludeTxnTypes);
  swap(a.__isset, b.__isset);
}

GetOpenTxnsRequest::GetOpenTxnsRequest(const GetOpenTxnsRequest& other1672) {
  excludeTxnTypes = other1672.excludeTxnTypes;
  __isset = other1672.__isset;
}
GetOpenTxnsRequest& GetOpenTxnsRequest::operator=(const GetOpenTxnsRequest& other1673) {
  excludeTxnTypes = other1673.excludeTxnTypes;
  __isset = other1673.__isset;
  return *this;
}
void GetOpenTxnsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetOpenTxnsRequest(";
  out << "excludeTxnTypes="; (__isset.excludeTxnTypes ? (out << to_string(excludeTxnTypes)) : (out << "<null>"));
  out << ")";
}


StoredProcedureRequest::~StoredProcedureRequest() noexcept {
}


void StoredProcedureRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void StoredProcedureRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void StoredProcedureRequest::__set_procName(const std::string& val) {
  this->procName = val;
}
std::ostream& operator<<(std::ostream& out, const StoredProcedureRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StoredProcedureRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catName = false;
  bool isset_dbName = false;
  bool isset_procName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->procName);
          isset_procName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_procName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t StoredProcedureRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StoredProcedureRequest");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("procName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->procName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StoredProcedureRequest &a, StoredProcedureRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.procName, b.procName);
}

StoredProcedureRequest::StoredProcedureRequest(const StoredProcedureRequest& other1674) {
  catName = other1674.catName;
  dbName = other1674.dbName;
  procName = other1674.procName;
}
StoredProcedureRequest& StoredProcedureRequest::operator=(const StoredProcedureRequest& other1675) {
  catName = other1675.catName;
  dbName = other1675.dbName;
  procName = other1675.procName;
  return *this;
}
void StoredProcedureRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StoredProcedureRequest(";
  out << "catName=" << to_string(catName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "procName=" << to_string(procName);
  out << ")";
}


ListStoredProcedureRequest::~ListStoredProcedureRequest() noexcept {
}


void ListStoredProcedureRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void ListStoredProcedureRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
__isset.dbName = true;
}
std::ostream& operator<<(std::ostream& out, const ListStoredProcedureRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ListStoredProcedureRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ListStoredProcedureRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListStoredProcedureRequest");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dbName) {
    xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->dbName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListStoredProcedureRequest &a, ListStoredProcedureRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.__isset, b.__isset);
}

ListStoredProcedureRequest::ListStoredProcedureRequest(const ListStoredProcedureRequest& other1676) {
  catName = other1676.catName;
  dbName = other1676.dbName;
  __isset = other1676.__isset;
}
ListStoredProcedureRequest& ListStoredProcedureRequest::operator=(const ListStoredProcedureRequest& other1677) {
  catName = other1677.catName;
  dbName = other1677.dbName;
  __isset = other1677.__isset;
  return *this;
}
void ListStoredProcedureRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListStoredProcedureRequest(";
  out << "catName=" << to_string(catName);
  out << ", " << "dbName="; (__isset.dbName ? (out << to_string(dbName)) : (out << "<null>"));
  out << ")";
}


StoredProcedure::~StoredProcedure() noexcept {
}


void StoredProcedure::__set_name(const std::string& val) {
  this->name = val;
}

void StoredProcedure::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void StoredProcedure::__set_catName(const std::string& val) {
  this->catName = val;
}

void StoredProcedure::__set_ownerName(const std::string& val) {
  this->ownerName = val;
}

void StoredProcedure::__set_source(const std::string& val) {
  this->source = val;
}
std::ostream& operator<<(std::ostream& out, const StoredProcedure& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StoredProcedure::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->source);
          this->__isset.source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StoredProcedure::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StoredProcedure");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->ownerName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("source", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->source);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StoredProcedure &a, StoredProcedure &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.dbName, b.dbName);
  swap(a.catName, b.catName);
  swap(a.ownerName, b.ownerName);
  swap(a.source, b.source);
  swap(a.__isset, b.__isset);
}

StoredProcedure::StoredProcedure(const StoredProcedure& other1678) {
  name = other1678.name;
  dbName = other1678.dbName;
  catName = other1678.catName;
  ownerName = other1678.ownerName;
  source = other1678.source;
  __isset = other1678.__isset;
}
StoredProcedure& StoredProcedure::operator=(const StoredProcedure& other1679) {
  name = other1679.name;
  dbName = other1679.dbName;
  catName = other1679.catName;
  ownerName = other1679.ownerName;
  source = other1679.source;
  __isset = other1679.__isset;
  return *this;
}
void StoredProcedure::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StoredProcedure(";
  out << "name=" << to_string(name);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "catName=" << to_string(catName);
  out << ", " << "ownerName=" << to_string(ownerName);
  out << ", " << "source=" << to_string(source);
  out << ")";
}


AddPackageRequest::~AddPackageRequest() noexcept {
}


void AddPackageRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void AddPackageRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void AddPackageRequest::__set_packageName(const std::string& val) {
  this->packageName = val;
}

void AddPackageRequest::__set_ownerName(const std::string& val) {
  this->ownerName = val;
}

void AddPackageRequest::__set_header(const std::string& val) {
  this->header = val;
}

void AddPackageRequest::__set_body(const std::string& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const AddPackageRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddPackageRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->packageName);
          this->__isset.packageName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->header);
          this->__isset.header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->body);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AddPackageRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddPackageRequest");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("packageName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->packageName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->ownerName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("header", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->header);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->body);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddPackageRequest &a, AddPackageRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.packageName, b.packageName);
  swap(a.ownerName, b.ownerName);
  swap(a.header, b.header);
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

AddPackageRequest::AddPackageRequest(const AddPackageRequest& other1680) {
  catName = other1680.catName;
  dbName = other1680.dbName;
  packageName = other1680.packageName;
  ownerName = other1680.ownerName;
  header = other1680.header;
  body = other1680.body;
  __isset = other1680.__isset;
}
AddPackageRequest& AddPackageRequest::operator=(const AddPackageRequest& other1681) {
  catName = other1681.catName;
  dbName = other1681.dbName;
  packageName = other1681.packageName;
  ownerName = other1681.ownerName;
  header = other1681.header;
  body = other1681.body;
  __isset = other1681.__isset;
  return *this;
}
void AddPackageRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddPackageRequest(";
  out << "catName=" << to_string(catName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "packageName=" << to_string(packageName);
  out << ", " << "ownerName=" << to_string(ownerName);
  out << ", " << "header=" << to_string(header);
  out << ", " << "body=" << to_string(body);
  out << ")";
}


GetPackageRequest::~GetPackageRequest() noexcept {
}


void GetPackageRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void GetPackageRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void GetPackageRequest::__set_packageName(const std::string& val) {
  this->packageName = val;
}
std::ostream& operator<<(std::ostream& out, const GetPackageRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPackageRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catName = false;
  bool isset_dbName = false;
  bool isset_packageName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->packageName);
          isset_packageName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_packageName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPackageRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPackageRequest");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("packageName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->packageName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPackageRequest &a, GetPackageRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.packageName, b.packageName);
}

GetPackageRequest::GetPackageRequest(const GetPackageRequest& other1682) {
  catName = other1682.catName;
  dbName = other1682.dbName;
  packageName = other1682.packageName;
}
GetPackageRequest& GetPackageRequest::operator=(const GetPackageRequest& other1683) {
  catName = other1683.catName;
  dbName = other1683.dbName;
  packageName = other1683.packageName;
  return *this;
}
void GetPackageRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPackageRequest(";
  out << "catName=" << to_string(catName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "packageName=" << to_string(packageName);
  out << ")";
}


DropPackageRequest::~DropPackageRequest() noexcept {
}


void DropPackageRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void DropPackageRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void DropPackageRequest::__set_packageName(const std::string& val) {
  this->packageName = val;
}
std::ostream& operator<<(std::ostream& out, const DropPackageRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropPackageRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catName = false;
  bool isset_dbName = false;
  bool isset_packageName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->packageName);
          isset_packageName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_packageName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DropPackageRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropPackageRequest");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("packageName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->packageName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropPackageRequest &a, DropPackageRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.packageName, b.packageName);
}

DropPackageRequest::DropPackageRequest(const DropPackageRequest& other1684) {
  catName = other1684.catName;
  dbName = other1684.dbName;
  packageName = other1684.packageName;
}
DropPackageRequest& DropPackageRequest::operator=(const DropPackageRequest& other1685) {
  catName = other1685.catName;
  dbName = other1685.dbName;
  packageName = other1685.packageName;
  return *this;
}
void DropPackageRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropPackageRequest(";
  out << "catName=" << to_string(catName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "packageName=" << to_string(packageName);
  out << ")";
}


ListPackageRequest::~ListPackageRequest() noexcept {
}


void ListPackageRequest::__set_catName(const std::string& val) {
  this->catName = val;
}

void ListPackageRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
__isset.dbName = true;
}
std::ostream& operator<<(std::ostream& out, const ListPackageRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ListPackageRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          isset_catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ListPackageRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListPackageRequest");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dbName) {
    xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->dbName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListPackageRequest &a, ListPackageRequest &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.__isset, b.__isset);
}

ListPackageRequest::ListPackageRequest(const ListPackageRequest& other1686) {
  catName = other1686.catName;
  dbName = other1686.dbName;
  __isset = other1686.__isset;
}
ListPackageRequest& ListPackageRequest::operator=(const ListPackageRequest& other1687) {
  catName = other1687.catName;
  dbName = other1687.dbName;
  __isset = other1687.__isset;
  return *this;
}
void ListPackageRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListPackageRequest(";
  out << "catName=" << to_string(catName);
  out << ", " << "dbName="; (__isset.dbName ? (out << to_string(dbName)) : (out << "<null>"));
  out << ")";
}


Package::~Package() noexcept {
}


void Package::__set_catName(const std::string& val) {
  this->catName = val;
}

void Package::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void Package::__set_packageName(const std::string& val) {
  this->packageName = val;
}

void Package::__set_ownerName(const std::string& val) {
  this->ownerName = val;
}

void Package::__set_header(const std::string& val) {
  this->header = val;
}

void Package::__set_body(const std::string& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const Package& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Package::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catName);
          this->__isset.catName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->packageName);
          this->__isset.packageName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->header);
          this->__isset.header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->body);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Package::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Package");

  xfer += oprot->writeFieldBegin("catName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("packageName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->packageName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->ownerName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("header", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->header);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->body);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Package &a, Package &b) {
  using ::std::swap;
  swap(a.catName, b.catName);
  swap(a.dbName, b.dbName);
  swap(a.packageName, b.packageName);
  swap(a.ownerName, b.ownerName);
  swap(a.header, b.header);
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

Package::Package(const Package& other1688) {
  catName = other1688.catName;
  dbName = other1688.dbName;
  packageName = other1688.packageName;
  ownerName = other1688.ownerName;
  header = other1688.header;
  body = other1688.body;
  __isset = other1688.__isset;
}
Package& Package::operator=(const Package& other1689) {
  catName = other1689.catName;
  dbName = other1689.dbName;
  packageName = other1689.packageName;
  ownerName = other1689.ownerName;
  header = other1689.header;
  body = other1689.body;
  __isset = other1689.__isset;
  return *this;
}
void Package::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Package(";
  out << "catName=" << to_string(catName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "packageName=" << to_string(packageName);
  out << ", " << "ownerName=" << to_string(ownerName);
  out << ", " << "header=" << to_string(header);
  out << ", " << "body=" << to_string(body);
  out << ")";
}


MetaException::~MetaException() noexcept {
}


void MetaException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const MetaException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MetaException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MetaException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MetaException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MetaException &a, MetaException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

MetaException::MetaException(const MetaException& other1690) : TException() {
  message = other1690.message;
  __isset = other1690.__isset;
}
MetaException& MetaException::operator=(const MetaException& other1691) {
  message = other1691.message;
  __isset = other1691.__isset;
  return *this;
}
void MetaException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MetaException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* MetaException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: MetaException";
  }
}


UnknownTableException::~UnknownTableException() noexcept {
}


void UnknownTableException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const UnknownTableException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UnknownTableException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnknownTableException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnknownTableException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnknownTableException &a, UnknownTableException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

UnknownTableException::UnknownTableException(const UnknownTableException& other1692) : TException() {
  message = other1692.message;
  __isset = other1692.__isset;
}
UnknownTableException& UnknownTableException::operator=(const UnknownTableException& other1693) {
  message = other1693.message;
  __isset = other1693.__isset;
  return *this;
}
void UnknownTableException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnknownTableException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* UnknownTableException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UnknownTableException";
  }
}


UnknownDBException::~UnknownDBException() noexcept {
}


void UnknownDBException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const UnknownDBException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UnknownDBException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnknownDBException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnknownDBException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnknownDBException &a, UnknownDBException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

UnknownDBException::UnknownDBException(const UnknownDBException& other1694) : TException() {
  message = other1694.message;
  __isset = other1694.__isset;
}
UnknownDBException& UnknownDBException::operator=(const UnknownDBException& other1695) {
  message = other1695.message;
  __isset = other1695.__isset;
  return *this;
}
void UnknownDBException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnknownDBException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* UnknownDBException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UnknownDBException";
  }
}


AlreadyExistsException::~AlreadyExistsException() noexcept {
}


void AlreadyExistsException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const AlreadyExistsException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AlreadyExistsException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlreadyExistsException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AlreadyExistsException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlreadyExistsException &a, AlreadyExistsException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

AlreadyExistsException::AlreadyExistsException(const AlreadyExistsException& other1696) : TException() {
  message = other1696.message;
  __isset = other1696.__isset;
}
AlreadyExistsException& AlreadyExistsException::operator=(const AlreadyExistsException& other1697) {
  message = other1697.message;
  __isset = other1697.__isset;
  return *this;
}
void AlreadyExistsException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AlreadyExistsException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* AlreadyExistsException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: AlreadyExistsException";
  }
}


InvalidPartitionException::~InvalidPartitionException() noexcept {
}


void InvalidPartitionException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidPartitionException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidPartitionException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidPartitionException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidPartitionException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidPartitionException &a, InvalidPartitionException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

InvalidPartitionException::InvalidPartitionException(const InvalidPartitionException& other1698) : TException() {
  message = other1698.message;
  __isset = other1698.__isset;
}
InvalidPartitionException& InvalidPartitionException::operator=(const InvalidPartitionException& other1699) {
  message = other1699.message;
  __isset = other1699.__isset;
  return *this;
}
void InvalidPartitionException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidPartitionException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* InvalidPartitionException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidPartitionException";
  }
}


UnknownPartitionException::~UnknownPartitionException() noexcept {
}


void UnknownPartitionException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const UnknownPartitionException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UnknownPartitionException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnknownPartitionException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnknownPartitionException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnknownPartitionException &a, UnknownPartitionException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

UnknownPartitionException::UnknownPartitionException(const UnknownPartitionException& other1700) : TException() {
  message = other1700.message;
  __isset = other1700.__isset;
}
UnknownPartitionException& UnknownPartitionException::operator=(const UnknownPartitionException& other1701) {
  message = other1701.message;
  __isset = other1701.__isset;
  return *this;
}
void UnknownPartitionException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnknownPartitionException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* UnknownPartitionException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UnknownPartitionException";
  }
}


InvalidObjectException::~InvalidObjectException() noexcept {
}


void InvalidObjectException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidObjectException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidObjectException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidObjectException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidObjectException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidObjectException &a, InvalidObjectException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

InvalidObjectException::InvalidObjectException(const InvalidObjectException& other1702) : TException() {
  message = other1702.message;
  __isset = other1702.__isset;
}
InvalidObjectException& InvalidObjectException::operator=(const InvalidObjectException& other1703) {
  message = other1703.message;
  __isset = other1703.__isset;
  return *this;
}
void InvalidObjectException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidObjectException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* InvalidObjectException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidObjectException";
  }
}


NoSuchObjectException::~NoSuchObjectException() noexcept {
}


void NoSuchObjectException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const NoSuchObjectException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NoSuchObjectException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchObjectException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchObjectException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchObjectException &a, NoSuchObjectException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoSuchObjectException::NoSuchObjectException(const NoSuchObjectException& other1704) : TException() {
  message = other1704.message;
  __isset = other1704.__isset;
}
NoSuchObjectException& NoSuchObjectException::operator=(const NoSuchObjectException& other1705) {
  message = other1705.message;
  __isset = other1705.__isset;
  return *this;
}
void NoSuchObjectException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchObjectException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* NoSuchObjectException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchObjectException";
  }
}


InvalidOperationException::~InvalidOperationException() noexcept {
}


void InvalidOperationException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidOperationException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidOperationException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidOperationException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidOperationException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidOperationException &a, InvalidOperationException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

InvalidOperationException::InvalidOperationException(const InvalidOperationException& other1706) : TException() {
  message = other1706.message;
  __isset = other1706.__isset;
}
InvalidOperationException& InvalidOperationException::operator=(const InvalidOperationException& other1707) {
  message = other1707.message;
  __isset = other1707.__isset;
  return *this;
}
void InvalidOperationException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidOperationException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* InvalidOperationException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidOperationException";
  }
}


ConfigValSecurityException::~ConfigValSecurityException() noexcept {
}


void ConfigValSecurityException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const ConfigValSecurityException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ConfigValSecurityException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConfigValSecurityException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ConfigValSecurityException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ConfigValSecurityException &a, ConfigValSecurityException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

ConfigValSecurityException::ConfigValSecurityException(const ConfigValSecurityException& other1708) : TException() {
  message = other1708.message;
  __isset = other1708.__isset;
}
ConfigValSecurityException& ConfigValSecurityException::operator=(const ConfigValSecurityException& other1709) {
  message = other1709.message;
  __isset = other1709.__isset;
  return *this;
}
void ConfigValSecurityException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ConfigValSecurityException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* ConfigValSecurityException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: ConfigValSecurityException";
  }
}


InvalidInputException::~InvalidInputException() noexcept {
}


void InvalidInputException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidInputException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidInputException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidInputException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidInputException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidInputException &a, InvalidInputException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

InvalidInputException::InvalidInputException(const InvalidInputException& other1710) : TException() {
  message = other1710.message;
  __isset = other1710.__isset;
}
InvalidInputException& InvalidInputException::operator=(const InvalidInputException& other1711) {
  message = other1711.message;
  __isset = other1711.__isset;
  return *this;
}
void InvalidInputException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidInputException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* InvalidInputException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidInputException";
  }
}


NoSuchTxnException::~NoSuchTxnException() noexcept {
}


void NoSuchTxnException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const NoSuchTxnException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NoSuchTxnException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchTxnException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchTxnException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchTxnException &a, NoSuchTxnException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoSuchTxnException::NoSuchTxnException(const NoSuchTxnException& other1712) : TException() {
  message = other1712.message;
  __isset = other1712.__isset;
}
NoSuchTxnException& NoSuchTxnException::operator=(const NoSuchTxnException& other1713) {
  message = other1713.message;
  __isset = other1713.__isset;
  return *this;
}
void NoSuchTxnException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchTxnException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* NoSuchTxnException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchTxnException";
  }
}


TxnAbortedException::~TxnAbortedException() noexcept {
}


void TxnAbortedException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const TxnAbortedException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TxnAbortedException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TxnAbortedException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TxnAbortedException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TxnAbortedException &a, TxnAbortedException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

TxnAbortedException::TxnAbortedException(const TxnAbortedException& other1714) : TException() {
  message = other1714.message;
  __isset = other1714.__isset;
}
TxnAbortedException& TxnAbortedException::operator=(const TxnAbortedException& other1715) {
  message = other1715.message;
  __isset = other1715.__isset;
  return *this;
}
void TxnAbortedException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TxnAbortedException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* TxnAbortedException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TxnAbortedException";
  }
}


TxnOpenException::~TxnOpenException() noexcept {
}


void TxnOpenException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const TxnOpenException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TxnOpenException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TxnOpenException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TxnOpenException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TxnOpenException &a, TxnOpenException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

TxnOpenException::TxnOpenException(const TxnOpenException& other1716) : TException() {
  message = other1716.message;
  __isset = other1716.__isset;
}
TxnOpenException& TxnOpenException::operator=(const TxnOpenException& other1717) {
  message = other1717.message;
  __isset = other1717.__isset;
  return *this;
}
void TxnOpenException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TxnOpenException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* TxnOpenException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TxnOpenException";
  }
}


NoSuchLockException::~NoSuchLockException() noexcept {
}


void NoSuchLockException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const NoSuchLockException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NoSuchLockException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchLockException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchLockException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchLockException &a, NoSuchLockException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoSuchLockException::NoSuchLockException(const NoSuchLockException& other1718) : TException() {
  message = other1718.message;
  __isset = other1718.__isset;
}
NoSuchLockException& NoSuchLockException::operator=(const NoSuchLockException& other1719) {
  message = other1719.message;
  __isset = other1719.__isset;
  return *this;
}
void NoSuchLockException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchLockException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* NoSuchLockException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchLockException";
  }
}

}}} // namespace
