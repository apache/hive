<?php
namespace metastore;

/**
 * Autogenerated by Thrift Compiler (0.14.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;

class ThriftHiveMetastoreClient extends \FacebookServiceClient implements \metastore\ThriftHiveMetastoreIf
{
    public function __construct($input, $output = null)
    {
        parent::__construct($input, $output);
    }


    public function getMetaConf($key)
    {
        $this->send_getMetaConf($key);
        return $this->recv_getMetaConf();
    }

    public function send_getMetaConf($key)
    {
        $args = new \metastore\ThriftHiveMetastore_getMetaConf_args();
        $args->key = $key;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'getMetaConf',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('getMetaConf', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_getMetaConf()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_getMetaConf_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_getMetaConf_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("getMetaConf failed: unknown result");
    }

    public function setMetaConf($key, $value)
    {
        $this->send_setMetaConf($key, $value);
        $this->recv_setMetaConf();
    }

    public function send_setMetaConf($key, $value)
    {
        $args = new \metastore\ThriftHiveMetastore_setMetaConf_args();
        $args->key = $key;
        $args->value = $value;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'setMetaConf',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('setMetaConf', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_setMetaConf()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_setMetaConf_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_setMetaConf_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        return;
    }

    public function create_catalog(\metastore\CreateCatalogRequest $catalog)
    {
        $this->send_create_catalog($catalog);
        $this->recv_create_catalog();
    }

    public function send_create_catalog(\metastore\CreateCatalogRequest $catalog)
    {
        $args = new \metastore\ThriftHiveMetastore_create_catalog_args();
        $args->catalog = $catalog;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_catalog',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_catalog', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_catalog()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_catalog_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_catalog_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function alter_catalog(\metastore\AlterCatalogRequest $rqst)
    {
        $this->send_alter_catalog($rqst);
        $this->recv_alter_catalog();
    }

    public function send_alter_catalog(\metastore\AlterCatalogRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_catalog_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_catalog',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_catalog', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_catalog()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_catalog_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_catalog_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function get_catalog(\metastore\GetCatalogRequest $catName)
    {
        $this->send_get_catalog($catName);
        return $this->recv_get_catalog();
    }

    public function send_get_catalog(\metastore\GetCatalogRequest $catName)
    {
        $args = new \metastore\ThriftHiveMetastore_get_catalog_args();
        $args->catName = $catName;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_catalog',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_catalog', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_catalog()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_catalog_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_catalog_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_catalog failed: unknown result");
    }

    public function get_catalogs()
    {
        $this->send_get_catalogs();
        return $this->recv_get_catalogs();
    }

    public function send_get_catalogs()
    {
        $args = new \metastore\ThriftHiveMetastore_get_catalogs_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_catalogs',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_catalogs', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_catalogs()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_catalogs_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_catalogs_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_catalogs failed: unknown result");
    }

    public function drop_catalog(\metastore\DropCatalogRequest $catName)
    {
        $this->send_drop_catalog($catName);
        $this->recv_drop_catalog();
    }

    public function send_drop_catalog(\metastore\DropCatalogRequest $catName)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_catalog_args();
        $args->catName = $catName;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_catalog',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_catalog', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_catalog()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_catalog_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_catalog_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function create_database(\metastore\Database $database)
    {
        $this->send_create_database($database);
        $this->recv_create_database();
    }

    public function send_create_database(\metastore\Database $database)
    {
        $args = new \metastore\ThriftHiveMetastore_create_database_args();
        $args->database = $database;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_database',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_database', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_database()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_database_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_database_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function get_database($name)
    {
        $this->send_get_database($name);
        return $this->recv_get_database();
    }

    public function send_get_database($name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_database_args();
        $args->name = $name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_database',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_database', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_database()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_database_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_database_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_database failed: unknown result");
    }

    public function get_database_req(\metastore\GetDatabaseRequest $request)
    {
        $this->send_get_database_req($request);
        return $this->recv_get_database_req();
    }

    public function send_get_database_req(\metastore\GetDatabaseRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_database_req_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_database_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_database_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_database_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_database_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_database_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_database_req failed: unknown result");
    }

    public function drop_database($name, $deleteData, $cascade)
    {
        $this->send_drop_database($name, $deleteData, $cascade);
        $this->recv_drop_database();
    }

    public function send_drop_database($name, $deleteData, $cascade)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_database_args();
        $args->name = $name;
        $args->deleteData = $deleteData;
        $args->cascade = $cascade;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_database',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_database', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_database()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_database_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_database_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function get_databases($pattern)
    {
        $this->send_get_databases($pattern);
        return $this->recv_get_databases();
    }

    public function send_get_databases($pattern)
    {
        $args = new \metastore\ThriftHiveMetastore_get_databases_args();
        $args->pattern = $pattern;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_databases',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_databases', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_databases()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_databases_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_databases_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_databases failed: unknown result");
    }

    public function get_all_databases()
    {
        $this->send_get_all_databases();
        return $this->recv_get_all_databases();
    }

    public function send_get_all_databases()
    {
        $args = new \metastore\ThriftHiveMetastore_get_all_databases_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_all_databases',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_all_databases', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_all_databases()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_all_databases_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_all_databases_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_all_databases failed: unknown result");
    }

    public function alter_database($dbname, \metastore\Database $db)
    {
        $this->send_alter_database($dbname, $db);
        $this->recv_alter_database();
    }

    public function send_alter_database($dbname, \metastore\Database $db)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_database_args();
        $args->dbname = $dbname;
        $args->db = $db;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_database',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_database', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_database()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_database_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_database_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function create_dataconnector(\metastore\DataConnector $connector)
    {
        $this->send_create_dataconnector($connector);
        $this->recv_create_dataconnector();
    }

    public function send_create_dataconnector(\metastore\DataConnector $connector)
    {
        $args = new \metastore\ThriftHiveMetastore_create_dataconnector_args();
        $args->connector = $connector;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_dataconnector',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_dataconnector', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_dataconnector()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_dataconnector_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_dataconnector_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function get_dataconnector_req(\metastore\GetDataConnectorRequest $request)
    {
        $this->send_get_dataconnector_req($request);
        return $this->recv_get_dataconnector_req();
    }

    public function send_get_dataconnector_req(\metastore\GetDataConnectorRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_dataconnector_req_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_dataconnector_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_dataconnector_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_dataconnector_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_dataconnector_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_dataconnector_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_dataconnector_req failed: unknown result");
    }

    public function drop_dataconnector($name, $ifNotExists, $checkReferences)
    {
        $this->send_drop_dataconnector($name, $ifNotExists, $checkReferences);
        $this->recv_drop_dataconnector();
    }

    public function send_drop_dataconnector($name, $ifNotExists, $checkReferences)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_dataconnector_args();
        $args->name = $name;
        $args->ifNotExists = $ifNotExists;
        $args->checkReferences = $checkReferences;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_dataconnector',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_dataconnector', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_dataconnector()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_dataconnector_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_dataconnector_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function get_dataconnectors()
    {
        $this->send_get_dataconnectors();
        return $this->recv_get_dataconnectors();
    }

    public function send_get_dataconnectors()
    {
        $args = new \metastore\ThriftHiveMetastore_get_dataconnectors_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_dataconnectors',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_dataconnectors', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_dataconnectors()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_dataconnectors_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_dataconnectors_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_dataconnectors failed: unknown result");
    }

    public function alter_dataconnector($name, \metastore\DataConnector $connector)
    {
        $this->send_alter_dataconnector($name, $connector);
        $this->recv_alter_dataconnector();
    }

    public function send_alter_dataconnector($name, \metastore\DataConnector $connector)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_dataconnector_args();
        $args->name = $name;
        $args->connector = $connector;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_dataconnector',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_dataconnector', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_dataconnector()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_dataconnector_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_dataconnector_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function get_type($name)
    {
        $this->send_get_type($name);
        return $this->recv_get_type();
    }

    public function send_get_type($name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_type_args();
        $args->name = $name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_type',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_type', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_type()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_type_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_type_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_type failed: unknown result");
    }

    public function create_type(\metastore\Type $type)
    {
        $this->send_create_type($type);
        return $this->recv_create_type();
    }

    public function send_create_type(\metastore\Type $type)
    {
        $args = new \metastore\ThriftHiveMetastore_create_type_args();
        $args->type = $type;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_type',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_type', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_type()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_type_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_type_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("create_type failed: unknown result");
    }

    public function drop_type($type)
    {
        $this->send_drop_type($type);
        return $this->recv_drop_type();
    }

    public function send_drop_type($type)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_type_args();
        $args->type = $type;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_type',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_type', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_type()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_type_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_type_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("drop_type failed: unknown result");
    }

    public function get_type_all($name)
    {
        $this->send_get_type_all($name);
        return $this->recv_get_type_all();
    }

    public function send_get_type_all($name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_type_all_args();
        $args->name = $name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_type_all',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_type_all', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_type_all()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_type_all_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_type_all_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_type_all failed: unknown result");
    }

    public function get_fields($db_name, $table_name)
    {
        $this->send_get_fields($db_name, $table_name);
        return $this->recv_get_fields();
    }

    public function send_get_fields($db_name, $table_name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_fields_args();
        $args->db_name = $db_name;
        $args->table_name = $table_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_fields',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_fields', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_fields()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_fields_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_fields_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("get_fields failed: unknown result");
    }

    public function get_fields_with_environment_context($db_name, $table_name, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_get_fields_with_environment_context($db_name, $table_name, $environment_context);
        return $this->recv_get_fields_with_environment_context();
    }

    public function send_get_fields_with_environment_context($db_name, $table_name, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_get_fields_with_environment_context_args();
        $args->db_name = $db_name;
        $args->table_name = $table_name;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_fields_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_fields_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_fields_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_fields_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_fields_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("get_fields_with_environment_context failed: unknown result");
    }

    public function get_fields_req(\metastore\GetFieldsRequest $req)
    {
        $this->send_get_fields_req($req);
        return $this->recv_get_fields_req();
    }

    public function send_get_fields_req(\metastore\GetFieldsRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_get_fields_req_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_fields_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_fields_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_fields_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_fields_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_fields_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("get_fields_req failed: unknown result");
    }

    public function get_schema($db_name, $table_name)
    {
        $this->send_get_schema($db_name, $table_name);
        return $this->recv_get_schema();
    }

    public function send_get_schema($db_name, $table_name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_schema_args();
        $args->db_name = $db_name;
        $args->table_name = $table_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_schema',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_schema', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_schema()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_schema_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_schema_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("get_schema failed: unknown result");
    }

    public function get_schema_with_environment_context($db_name, $table_name, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_get_schema_with_environment_context($db_name, $table_name, $environment_context);
        return $this->recv_get_schema_with_environment_context();
    }

    public function send_get_schema_with_environment_context($db_name, $table_name, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_get_schema_with_environment_context_args();
        $args->db_name = $db_name;
        $args->table_name = $table_name;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_schema_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_schema_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_schema_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_schema_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_schema_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("get_schema_with_environment_context failed: unknown result");
    }

    public function get_schema_req(\metastore\GetSchemaRequest $req)
    {
        $this->send_get_schema_req($req);
        return $this->recv_get_schema_req();
    }

    public function send_get_schema_req(\metastore\GetSchemaRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_get_schema_req_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_schema_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_schema_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_schema_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_schema_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_schema_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("get_schema_req failed: unknown result");
    }

    public function create_table(\metastore\Table $tbl)
    {
        $this->send_create_table($tbl);
        $this->recv_create_table();
    }

    public function send_create_table(\metastore\Table $tbl)
    {
        $args = new \metastore\ThriftHiveMetastore_create_table_args();
        $args->tbl = $tbl;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_table',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_table', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_table()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_table_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_table_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        return;
    }

    public function create_table_with_environment_context(\metastore\Table $tbl, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_create_table_with_environment_context($tbl, $environment_context);
        $this->recv_create_table_with_environment_context();
    }

    public function send_create_table_with_environment_context(\metastore\Table $tbl, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_create_table_with_environment_context_args();
        $args->tbl = $tbl;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_table_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_table_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_table_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_table_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_table_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        return;
    }

    public function create_table_with_constraints(\metastore\Table $tbl, array $primaryKeys, array $foreignKeys, array $uniqueConstraints, array $notNullConstraints, array $defaultConstraints, array $checkConstraints)
    {
        $this->send_create_table_with_constraints($tbl, $primaryKeys, $foreignKeys, $uniqueConstraints, $notNullConstraints, $defaultConstraints, $checkConstraints);
        $this->recv_create_table_with_constraints();
    }

    public function send_create_table_with_constraints(\metastore\Table $tbl, array $primaryKeys, array $foreignKeys, array $uniqueConstraints, array $notNullConstraints, array $defaultConstraints, array $checkConstraints)
    {
        $args = new \metastore\ThriftHiveMetastore_create_table_with_constraints_args();
        $args->tbl = $tbl;
        $args->primaryKeys = $primaryKeys;
        $args->foreignKeys = $foreignKeys;
        $args->uniqueConstraints = $uniqueConstraints;
        $args->notNullConstraints = $notNullConstraints;
        $args->defaultConstraints = $defaultConstraints;
        $args->checkConstraints = $checkConstraints;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_table_with_constraints',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_table_with_constraints', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_table_with_constraints()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_table_with_constraints_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_table_with_constraints_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        return;
    }

    public function create_table_req(\metastore\CreateTableRequest $request)
    {
        $this->send_create_table_req($request);
        $this->recv_create_table_req();
    }

    public function send_create_table_req(\metastore\CreateTableRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_create_table_req_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_table_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_table_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_table_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_table_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_table_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        return;
    }

    public function drop_constraint(\metastore\DropConstraintRequest $req)
    {
        $this->send_drop_constraint($req);
        $this->recv_drop_constraint();
    }

    public function send_drop_constraint(\metastore\DropConstraintRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_constraint_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_constraint',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_constraint', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_constraint()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_constraint_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_constraint_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function add_primary_key(\metastore\AddPrimaryKeyRequest $req)
    {
        $this->send_add_primary_key($req);
        $this->recv_add_primary_key();
    }

    public function send_add_primary_key(\metastore\AddPrimaryKeyRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_add_primary_key_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_primary_key',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_primary_key', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_primary_key()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_primary_key_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_primary_key_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function add_foreign_key(\metastore\AddForeignKeyRequest $req)
    {
        $this->send_add_foreign_key($req);
        $this->recv_add_foreign_key();
    }

    public function send_add_foreign_key(\metastore\AddForeignKeyRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_add_foreign_key_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_foreign_key',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_foreign_key', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_foreign_key()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_foreign_key_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_foreign_key_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function add_unique_constraint(\metastore\AddUniqueConstraintRequest $req)
    {
        $this->send_add_unique_constraint($req);
        $this->recv_add_unique_constraint();
    }

    public function send_add_unique_constraint(\metastore\AddUniqueConstraintRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_add_unique_constraint_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_unique_constraint',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_unique_constraint', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_unique_constraint()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_unique_constraint_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_unique_constraint_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function add_not_null_constraint(\metastore\AddNotNullConstraintRequest $req)
    {
        $this->send_add_not_null_constraint($req);
        $this->recv_add_not_null_constraint();
    }

    public function send_add_not_null_constraint(\metastore\AddNotNullConstraintRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_add_not_null_constraint_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_not_null_constraint',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_not_null_constraint', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_not_null_constraint()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_not_null_constraint_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_not_null_constraint_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function add_default_constraint(\metastore\AddDefaultConstraintRequest $req)
    {
        $this->send_add_default_constraint($req);
        $this->recv_add_default_constraint();
    }

    public function send_add_default_constraint(\metastore\AddDefaultConstraintRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_add_default_constraint_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_default_constraint',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_default_constraint', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_default_constraint()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_default_constraint_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_default_constraint_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function add_check_constraint(\metastore\AddCheckConstraintRequest $req)
    {
        $this->send_add_check_constraint($req);
        $this->recv_add_check_constraint();
    }

    public function send_add_check_constraint(\metastore\AddCheckConstraintRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_add_check_constraint_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_check_constraint',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_check_constraint', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_check_constraint()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_check_constraint_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_check_constraint_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function drop_table($dbname, $name, $deleteData)
    {
        $this->send_drop_table($dbname, $name, $deleteData);
        $this->recv_drop_table();
    }

    public function send_drop_table($dbname, $name, $deleteData)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_table_args();
        $args->dbname = $dbname;
        $args->name = $name;
        $args->deleteData = $deleteData;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_table',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_table', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_table()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_table_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_table_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function drop_table_with_environment_context($dbname, $name, $deleteData, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_drop_table_with_environment_context($dbname, $name, $deleteData, $environment_context);
        $this->recv_drop_table_with_environment_context();
    }

    public function send_drop_table_with_environment_context($dbname, $name, $deleteData, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_table_with_environment_context_args();
        $args->dbname = $dbname;
        $args->name = $name;
        $args->deleteData = $deleteData;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_table_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_table_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_table_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_table_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_table_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function truncate_table($dbName, $tableName, array $partNames)
    {
        $this->send_truncate_table($dbName, $tableName, $partNames);
        $this->recv_truncate_table();
    }

    public function send_truncate_table($dbName, $tableName, array $partNames)
    {
        $args = new \metastore\ThriftHiveMetastore_truncate_table_args();
        $args->dbName = $dbName;
        $args->tableName = $tableName;
        $args->partNames = $partNames;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'truncate_table',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('truncate_table', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_truncate_table()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_truncate_table_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_truncate_table_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        return;
    }

    public function truncate_table_req(\metastore\TruncateTableRequest $req)
    {
        $this->send_truncate_table_req($req);
        return $this->recv_truncate_table_req();
    }

    public function send_truncate_table_req(\metastore\TruncateTableRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_truncate_table_req_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'truncate_table_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('truncate_table_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_truncate_table_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_truncate_table_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_truncate_table_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("truncate_table_req failed: unknown result");
    }

    public function get_tables($db_name, $pattern)
    {
        $this->send_get_tables($db_name, $pattern);
        return $this->recv_get_tables();
    }

    public function send_get_tables($db_name, $pattern)
    {
        $args = new \metastore\ThriftHiveMetastore_get_tables_args();
        $args->db_name = $db_name;
        $args->pattern = $pattern;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_tables',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_tables', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_tables()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_tables_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_tables_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_tables failed: unknown result");
    }

    public function get_tables_by_type($db_name, $pattern, $tableType)
    {
        $this->send_get_tables_by_type($db_name, $pattern, $tableType);
        return $this->recv_get_tables_by_type();
    }

    public function send_get_tables_by_type($db_name, $pattern, $tableType)
    {
        $args = new \metastore\ThriftHiveMetastore_get_tables_by_type_args();
        $args->db_name = $db_name;
        $args->pattern = $pattern;
        $args->tableType = $tableType;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_tables_by_type',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_tables_by_type', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_tables_by_type()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_tables_by_type_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_tables_by_type_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_tables_by_type failed: unknown result");
    }

    public function get_all_materialized_view_objects_for_rewriting()
    {
        $this->send_get_all_materialized_view_objects_for_rewriting();
        return $this->recv_get_all_materialized_view_objects_for_rewriting();
    }

    public function send_get_all_materialized_view_objects_for_rewriting()
    {
        $args = new \metastore\ThriftHiveMetastore_get_all_materialized_view_objects_for_rewriting_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_all_materialized_view_objects_for_rewriting',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_all_materialized_view_objects_for_rewriting', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_all_materialized_view_objects_for_rewriting()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_all_materialized_view_objects_for_rewriting_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_all_materialized_view_objects_for_rewriting_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_all_materialized_view_objects_for_rewriting failed: unknown result");
    }

    public function get_materialized_views_for_rewriting($db_name)
    {
        $this->send_get_materialized_views_for_rewriting($db_name);
        return $this->recv_get_materialized_views_for_rewriting();
    }

    public function send_get_materialized_views_for_rewriting($db_name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_materialized_views_for_rewriting_args();
        $args->db_name = $db_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_materialized_views_for_rewriting',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_materialized_views_for_rewriting', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_materialized_views_for_rewriting()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_materialized_views_for_rewriting_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_materialized_views_for_rewriting_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_materialized_views_for_rewriting failed: unknown result");
    }

    public function get_table_meta($db_patterns, $tbl_patterns, array $tbl_types)
    {
        $this->send_get_table_meta($db_patterns, $tbl_patterns, $tbl_types);
        return $this->recv_get_table_meta();
    }

    public function send_get_table_meta($db_patterns, $tbl_patterns, array $tbl_types)
    {
        $args = new \metastore\ThriftHiveMetastore_get_table_meta_args();
        $args->db_patterns = $db_patterns;
        $args->tbl_patterns = $tbl_patterns;
        $args->tbl_types = $tbl_types;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_table_meta',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_table_meta', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_table_meta()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_table_meta_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_table_meta_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_table_meta failed: unknown result");
    }

    public function get_all_tables($db_name)
    {
        $this->send_get_all_tables($db_name);
        return $this->recv_get_all_tables();
    }

    public function send_get_all_tables($db_name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_all_tables_args();
        $args->db_name = $db_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_all_tables',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_all_tables', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_all_tables()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_all_tables_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_all_tables_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_all_tables failed: unknown result");
    }

    public function get_table($dbname, $tbl_name)
    {
        $this->send_get_table($dbname, $tbl_name);
        return $this->recv_get_table();
    }

    public function send_get_table($dbname, $tbl_name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_table_args();
        $args->dbname = $dbname;
        $args->tbl_name = $tbl_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_table',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_table', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_table()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_table_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_table_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_table failed: unknown result");
    }

    public function get_table_objects_by_name($dbname, array $tbl_names)
    {
        $this->send_get_table_objects_by_name($dbname, $tbl_names);
        return $this->recv_get_table_objects_by_name();
    }

    public function send_get_table_objects_by_name($dbname, array $tbl_names)
    {
        $args = new \metastore\ThriftHiveMetastore_get_table_objects_by_name_args();
        $args->dbname = $dbname;
        $args->tbl_names = $tbl_names;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_table_objects_by_name',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_table_objects_by_name', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_table_objects_by_name()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_table_objects_by_name_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_table_objects_by_name_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_table_objects_by_name failed: unknown result");
    }

    public function get_tables_ext(\metastore\GetTablesExtRequest $req)
    {
        $this->send_get_tables_ext($req);
        return $this->recv_get_tables_ext();
    }

    public function send_get_tables_ext(\metastore\GetTablesExtRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_get_tables_ext_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_tables_ext',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_tables_ext', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_tables_ext()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_tables_ext_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_tables_ext_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_tables_ext failed: unknown result");
    }

    public function get_table_req(\metastore\GetTableRequest $req)
    {
        $this->send_get_table_req($req);
        return $this->recv_get_table_req();
    }

    public function send_get_table_req(\metastore\GetTableRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_get_table_req_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_table_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_table_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_table_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_table_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_table_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_table_req failed: unknown result");
    }

    public function get_table_objects_by_name_req(\metastore\GetTablesRequest $req)
    {
        $this->send_get_table_objects_by_name_req($req);
        return $this->recv_get_table_objects_by_name_req();
    }

    public function send_get_table_objects_by_name_req(\metastore\GetTablesRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_get_table_objects_by_name_req_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_table_objects_by_name_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_table_objects_by_name_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_table_objects_by_name_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_table_objects_by_name_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_table_objects_by_name_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("get_table_objects_by_name_req failed: unknown result");
    }

    public function get_materialization_invalidation_info(\metastore\CreationMetadata $creation_metadata, $validTxnList)
    {
        $this->send_get_materialization_invalidation_info($creation_metadata, $validTxnList);
        return $this->recv_get_materialization_invalidation_info();
    }

    public function send_get_materialization_invalidation_info(\metastore\CreationMetadata $creation_metadata, $validTxnList)
    {
        $args = new \metastore\ThriftHiveMetastore_get_materialization_invalidation_info_args();
        $args->creation_metadata = $creation_metadata;
        $args->validTxnList = $validTxnList;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_materialization_invalidation_info',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_materialization_invalidation_info', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_materialization_invalidation_info()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_materialization_invalidation_info_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_materialization_invalidation_info_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("get_materialization_invalidation_info failed: unknown result");
    }

    public function update_creation_metadata($catName, $dbname, $tbl_name, \metastore\CreationMetadata $creation_metadata)
    {
        $this->send_update_creation_metadata($catName, $dbname, $tbl_name, $creation_metadata);
        $this->recv_update_creation_metadata();
    }

    public function send_update_creation_metadata($catName, $dbname, $tbl_name, \metastore\CreationMetadata $creation_metadata)
    {
        $args = new \metastore\ThriftHiveMetastore_update_creation_metadata_args();
        $args->catName = $catName;
        $args->dbname = $dbname;
        $args->tbl_name = $tbl_name;
        $args->creation_metadata = $creation_metadata;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'update_creation_metadata',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('update_creation_metadata', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_update_creation_metadata()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_update_creation_metadata_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_update_creation_metadata_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function get_table_names_by_filter($dbname, $filter, $max_tables)
    {
        $this->send_get_table_names_by_filter($dbname, $filter, $max_tables);
        return $this->recv_get_table_names_by_filter();
    }

    public function send_get_table_names_by_filter($dbname, $filter, $max_tables)
    {
        $args = new \metastore\ThriftHiveMetastore_get_table_names_by_filter_args();
        $args->dbname = $dbname;
        $args->filter = $filter;
        $args->max_tables = $max_tables;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_table_names_by_filter',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_table_names_by_filter', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_table_names_by_filter()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_table_names_by_filter_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_table_names_by_filter_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("get_table_names_by_filter failed: unknown result");
    }

    public function alter_table($dbname, $tbl_name, \metastore\Table $new_tbl)
    {
        $this->send_alter_table($dbname, $tbl_name, $new_tbl);
        $this->recv_alter_table();
    }

    public function send_alter_table($dbname, $tbl_name, \metastore\Table $new_tbl)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_table_args();
        $args->dbname = $dbname;
        $args->tbl_name = $tbl_name;
        $args->new_tbl = $new_tbl;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_table',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_table', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_table()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_table_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_table_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function alter_table_with_environment_context($dbname, $tbl_name, \metastore\Table $new_tbl, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_alter_table_with_environment_context($dbname, $tbl_name, $new_tbl, $environment_context);
        $this->recv_alter_table_with_environment_context();
    }

    public function send_alter_table_with_environment_context($dbname, $tbl_name, \metastore\Table $new_tbl, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_table_with_environment_context_args();
        $args->dbname = $dbname;
        $args->tbl_name = $tbl_name;
        $args->new_tbl = $new_tbl;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_table_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_table_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_table_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_table_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_table_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function alter_table_with_cascade($dbname, $tbl_name, \metastore\Table $new_tbl, $cascade)
    {
        $this->send_alter_table_with_cascade($dbname, $tbl_name, $new_tbl, $cascade);
        $this->recv_alter_table_with_cascade();
    }

    public function send_alter_table_with_cascade($dbname, $tbl_name, \metastore\Table $new_tbl, $cascade)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_table_with_cascade_args();
        $args->dbname = $dbname;
        $args->tbl_name = $tbl_name;
        $args->new_tbl = $new_tbl;
        $args->cascade = $cascade;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_table_with_cascade',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_table_with_cascade', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_table_with_cascade()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_table_with_cascade_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_table_with_cascade_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function alter_table_req(\metastore\AlterTableRequest $req)
    {
        $this->send_alter_table_req($req);
        return $this->recv_alter_table_req();
    }

    public function send_alter_table_req(\metastore\AlterTableRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_table_req_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_table_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_table_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_table_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_table_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_table_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("alter_table_req failed: unknown result");
    }

    public function add_partition(\metastore\Partition $new_part)
    {
        $this->send_add_partition($new_part);
        return $this->recv_add_partition();
    }

    public function send_add_partition(\metastore\Partition $new_part)
    {
        $args = new \metastore\ThriftHiveMetastore_add_partition_args();
        $args->new_part = $new_part;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_partition',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_partition', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_partition()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_partition_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_partition_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("add_partition failed: unknown result");
    }

    public function add_partition_with_environment_context(\metastore\Partition $new_part, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_add_partition_with_environment_context($new_part, $environment_context);
        return $this->recv_add_partition_with_environment_context();
    }

    public function send_add_partition_with_environment_context(\metastore\Partition $new_part, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_add_partition_with_environment_context_args();
        $args->new_part = $new_part;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_partition_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_partition_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_partition_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_partition_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_partition_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("add_partition_with_environment_context failed: unknown result");
    }

    public function add_partitions(array $new_parts)
    {
        $this->send_add_partitions($new_parts);
        return $this->recv_add_partitions();
    }

    public function send_add_partitions(array $new_parts)
    {
        $args = new \metastore\ThriftHiveMetastore_add_partitions_args();
        $args->new_parts = $new_parts;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_partitions',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_partitions', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_partitions()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_partitions_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_partitions_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("add_partitions failed: unknown result");
    }

    public function add_partitions_pspec(array $new_parts)
    {
        $this->send_add_partitions_pspec($new_parts);
        return $this->recv_add_partitions_pspec();
    }

    public function send_add_partitions_pspec(array $new_parts)
    {
        $args = new \metastore\ThriftHiveMetastore_add_partitions_pspec_args();
        $args->new_parts = $new_parts;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_partitions_pspec',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_partitions_pspec', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_partitions_pspec()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_partitions_pspec_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_partitions_pspec_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("add_partitions_pspec failed: unknown result");
    }

    public function append_partition($db_name, $tbl_name, array $part_vals)
    {
        $this->send_append_partition($db_name, $tbl_name, $part_vals);
        return $this->recv_append_partition();
    }

    public function send_append_partition($db_name, $tbl_name, array $part_vals)
    {
        $args = new \metastore\ThriftHiveMetastore_append_partition_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'append_partition',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('append_partition', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_append_partition()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_append_partition_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_append_partition_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("append_partition failed: unknown result");
    }

    public function add_partitions_req(\metastore\AddPartitionsRequest $request)
    {
        $this->send_add_partitions_req($request);
        return $this->recv_add_partitions_req();
    }

    public function send_add_partitions_req(\metastore\AddPartitionsRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_add_partitions_req_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_partitions_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_partitions_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_partitions_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_partitions_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_partitions_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("add_partitions_req failed: unknown result");
    }

    public function append_partition_with_environment_context($db_name, $tbl_name, array $part_vals, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_append_partition_with_environment_context($db_name, $tbl_name, $part_vals, $environment_context);
        return $this->recv_append_partition_with_environment_context();
    }

    public function send_append_partition_with_environment_context($db_name, $tbl_name, array $part_vals, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_append_partition_with_environment_context_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'append_partition_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('append_partition_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_append_partition_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_append_partition_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_append_partition_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("append_partition_with_environment_context failed: unknown result");
    }

    public function append_partition_by_name($db_name, $tbl_name, $part_name)
    {
        $this->send_append_partition_by_name($db_name, $tbl_name, $part_name);
        return $this->recv_append_partition_by_name();
    }

    public function send_append_partition_by_name($db_name, $tbl_name, $part_name)
    {
        $args = new \metastore\ThriftHiveMetastore_append_partition_by_name_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_name = $part_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'append_partition_by_name',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('append_partition_by_name', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_append_partition_by_name()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_append_partition_by_name_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_append_partition_by_name_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("append_partition_by_name failed: unknown result");
    }

    public function append_partition_by_name_with_environment_context($db_name, $tbl_name, $part_name, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_append_partition_by_name_with_environment_context($db_name, $tbl_name, $part_name, $environment_context);
        return $this->recv_append_partition_by_name_with_environment_context();
    }

    public function send_append_partition_by_name_with_environment_context($db_name, $tbl_name, $part_name, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_append_partition_by_name_with_environment_context_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_name = $part_name;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'append_partition_by_name_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('append_partition_by_name_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_append_partition_by_name_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_append_partition_by_name_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_append_partition_by_name_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("append_partition_by_name_with_environment_context failed: unknown result");
    }

    public function drop_partition($db_name, $tbl_name, array $part_vals, $deleteData)
    {
        $this->send_drop_partition($db_name, $tbl_name, $part_vals, $deleteData);
        return $this->recv_drop_partition();
    }

    public function send_drop_partition($db_name, $tbl_name, array $part_vals, $deleteData)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_partition_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $args->deleteData = $deleteData;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_partition',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_partition', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_partition()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_partition_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_partition_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("drop_partition failed: unknown result");
    }

    public function drop_partition_with_environment_context($db_name, $tbl_name, array $part_vals, $deleteData, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_drop_partition_with_environment_context($db_name, $tbl_name, $part_vals, $deleteData, $environment_context);
        return $this->recv_drop_partition_with_environment_context();
    }

    public function send_drop_partition_with_environment_context($db_name, $tbl_name, array $part_vals, $deleteData, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_partition_with_environment_context_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $args->deleteData = $deleteData;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_partition_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_partition_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_partition_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_partition_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_partition_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("drop_partition_with_environment_context failed: unknown result");
    }

    public function drop_partition_by_name($db_name, $tbl_name, $part_name, $deleteData)
    {
        $this->send_drop_partition_by_name($db_name, $tbl_name, $part_name, $deleteData);
        return $this->recv_drop_partition_by_name();
    }

    public function send_drop_partition_by_name($db_name, $tbl_name, $part_name, $deleteData)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_partition_by_name_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_name = $part_name;
        $args->deleteData = $deleteData;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_partition_by_name',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_partition_by_name', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_partition_by_name()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_partition_by_name_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_partition_by_name_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("drop_partition_by_name failed: unknown result");
    }

    public function drop_partition_by_name_with_environment_context($db_name, $tbl_name, $part_name, $deleteData, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_drop_partition_by_name_with_environment_context($db_name, $tbl_name, $part_name, $deleteData, $environment_context);
        return $this->recv_drop_partition_by_name_with_environment_context();
    }

    public function send_drop_partition_by_name_with_environment_context($db_name, $tbl_name, $part_name, $deleteData, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_partition_by_name_with_environment_context_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_name = $part_name;
        $args->deleteData = $deleteData;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_partition_by_name_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_partition_by_name_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_partition_by_name_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_partition_by_name_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_partition_by_name_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("drop_partition_by_name_with_environment_context failed: unknown result");
    }

    public function drop_partitions_req(\metastore\DropPartitionsRequest $req)
    {
        $this->send_drop_partitions_req($req);
        return $this->recv_drop_partitions_req();
    }

    public function send_drop_partitions_req(\metastore\DropPartitionsRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_partitions_req_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_partitions_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_partitions_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_partitions_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_partitions_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_partitions_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("drop_partitions_req failed: unknown result");
    }

    public function get_partition($db_name, $tbl_name, array $part_vals)
    {
        $this->send_get_partition($db_name, $tbl_name, $part_vals);
        return $this->recv_get_partition();
    }

    public function send_get_partition($db_name, $tbl_name, array $part_vals)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partition_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partition',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partition', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partition()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partition_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partition_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partition failed: unknown result");
    }

    public function get_partition_req(\metastore\GetPartitionRequest $req)
    {
        $this->send_get_partition_req($req);
        return $this->recv_get_partition_req();
    }

    public function send_get_partition_req(\metastore\GetPartitionRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partition_req_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partition_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partition_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partition_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partition_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partition_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partition_req failed: unknown result");
    }

    public function exchange_partition(array $partitionSpecs, $source_db, $source_table_name, $dest_db, $dest_table_name)
    {
        $this->send_exchange_partition($partitionSpecs, $source_db, $source_table_name, $dest_db, $dest_table_name);
        return $this->recv_exchange_partition();
    }

    public function send_exchange_partition(array $partitionSpecs, $source_db, $source_table_name, $dest_db, $dest_table_name)
    {
        $args = new \metastore\ThriftHiveMetastore_exchange_partition_args();
        $args->partitionSpecs = $partitionSpecs;
        $args->source_db = $source_db;
        $args->source_table_name = $source_table_name;
        $args->dest_db = $dest_db;
        $args->dest_table_name = $dest_table_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'exchange_partition',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('exchange_partition', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_exchange_partition()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_exchange_partition_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_exchange_partition_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("exchange_partition failed: unknown result");
    }

    public function exchange_partitions(array $partitionSpecs, $source_db, $source_table_name, $dest_db, $dest_table_name)
    {
        $this->send_exchange_partitions($partitionSpecs, $source_db, $source_table_name, $dest_db, $dest_table_name);
        return $this->recv_exchange_partitions();
    }

    public function send_exchange_partitions(array $partitionSpecs, $source_db, $source_table_name, $dest_db, $dest_table_name)
    {
        $args = new \metastore\ThriftHiveMetastore_exchange_partitions_args();
        $args->partitionSpecs = $partitionSpecs;
        $args->source_db = $source_db;
        $args->source_table_name = $source_table_name;
        $args->dest_db = $dest_db;
        $args->dest_table_name = $dest_table_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'exchange_partitions',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('exchange_partitions', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_exchange_partitions()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_exchange_partitions_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_exchange_partitions_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("exchange_partitions failed: unknown result");
    }

    public function get_partition_with_auth($db_name, $tbl_name, array $part_vals, $user_name, array $group_names)
    {
        $this->send_get_partition_with_auth($db_name, $tbl_name, $part_vals, $user_name, $group_names);
        return $this->recv_get_partition_with_auth();
    }

    public function send_get_partition_with_auth($db_name, $tbl_name, array $part_vals, $user_name, array $group_names)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partition_with_auth_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $args->user_name = $user_name;
        $args->group_names = $group_names;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partition_with_auth',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partition_with_auth', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partition_with_auth()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partition_with_auth_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partition_with_auth_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partition_with_auth failed: unknown result");
    }

    public function get_partition_by_name($db_name, $tbl_name, $part_name)
    {
        $this->send_get_partition_by_name($db_name, $tbl_name, $part_name);
        return $this->recv_get_partition_by_name();
    }

    public function send_get_partition_by_name($db_name, $tbl_name, $part_name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partition_by_name_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_name = $part_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partition_by_name',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partition_by_name', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partition_by_name()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partition_by_name_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partition_by_name_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partition_by_name failed: unknown result");
    }

    public function get_partitions($db_name, $tbl_name, $max_parts)
    {
        $this->send_get_partitions($db_name, $tbl_name, $max_parts);
        return $this->recv_get_partitions();
    }

    public function send_get_partitions($db_name, $tbl_name, $max_parts)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->max_parts = $max_parts;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions failed: unknown result");
    }

    public function get_partitions_req(\metastore\PartitionsRequest $req)
    {
        $this->send_get_partitions_req($req);
        return $this->recv_get_partitions_req();
    }

    public function send_get_partitions_req(\metastore\PartitionsRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_req_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions_req failed: unknown result");
    }

    public function get_partitions_with_auth($db_name, $tbl_name, $max_parts, $user_name, array $group_names)
    {
        $this->send_get_partitions_with_auth($db_name, $tbl_name, $max_parts, $user_name, $group_names);
        return $this->recv_get_partitions_with_auth();
    }

    public function send_get_partitions_with_auth($db_name, $tbl_name, $max_parts, $user_name, array $group_names)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_with_auth_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->max_parts = $max_parts;
        $args->user_name = $user_name;
        $args->group_names = $group_names;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions_with_auth',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions_with_auth', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions_with_auth()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_with_auth_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_with_auth_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions_with_auth failed: unknown result");
    }

    public function get_partitions_pspec($db_name, $tbl_name, $max_parts)
    {
        $this->send_get_partitions_pspec($db_name, $tbl_name, $max_parts);
        return $this->recv_get_partitions_pspec();
    }

    public function send_get_partitions_pspec($db_name, $tbl_name, $max_parts)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_pspec_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->max_parts = $max_parts;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions_pspec',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions_pspec', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions_pspec()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_pspec_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_pspec_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions_pspec failed: unknown result");
    }

    public function get_partition_names($db_name, $tbl_name, $max_parts)
    {
        $this->send_get_partition_names($db_name, $tbl_name, $max_parts);
        return $this->recv_get_partition_names();
    }

    public function send_get_partition_names($db_name, $tbl_name, $max_parts)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partition_names_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->max_parts = $max_parts;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partition_names',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partition_names', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partition_names()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partition_names_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partition_names_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partition_names failed: unknown result");
    }

    public function get_partition_values(\metastore\PartitionValuesRequest $request)
    {
        $this->send_get_partition_values($request);
        return $this->recv_get_partition_values();
    }

    public function send_get_partition_values(\metastore\PartitionValuesRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partition_values_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partition_values',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partition_values', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partition_values()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partition_values_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partition_values_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partition_values failed: unknown result");
    }

    public function get_partitions_ps($db_name, $tbl_name, array $part_vals, $max_parts)
    {
        $this->send_get_partitions_ps($db_name, $tbl_name, $part_vals, $max_parts);
        return $this->recv_get_partitions_ps();
    }

    public function send_get_partitions_ps($db_name, $tbl_name, array $part_vals, $max_parts)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_ps_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $args->max_parts = $max_parts;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions_ps',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions_ps', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions_ps()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_ps_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_ps_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions_ps failed: unknown result");
    }

    public function get_partitions_ps_with_auth($db_name, $tbl_name, array $part_vals, $max_parts, $user_name, array $group_names)
    {
        $this->send_get_partitions_ps_with_auth($db_name, $tbl_name, $part_vals, $max_parts, $user_name, $group_names);
        return $this->recv_get_partitions_ps_with_auth();
    }

    public function send_get_partitions_ps_with_auth($db_name, $tbl_name, array $part_vals, $max_parts, $user_name, array $group_names)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_ps_with_auth_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $args->max_parts = $max_parts;
        $args->user_name = $user_name;
        $args->group_names = $group_names;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions_ps_with_auth',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions_ps_with_auth', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions_ps_with_auth()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_ps_with_auth_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_ps_with_auth_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions_ps_with_auth failed: unknown result");
    }

    public function get_partitions_ps_with_auth_req(\metastore\GetPartitionsPsWithAuthRequest $req)
    {
        $this->send_get_partitions_ps_with_auth_req($req);
        return $this->recv_get_partitions_ps_with_auth_req();
    }

    public function send_get_partitions_ps_with_auth_req(\metastore\GetPartitionsPsWithAuthRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_ps_with_auth_req_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions_ps_with_auth_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions_ps_with_auth_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions_ps_with_auth_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_ps_with_auth_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_ps_with_auth_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions_ps_with_auth_req failed: unknown result");
    }

    public function get_partition_names_ps($db_name, $tbl_name, array $part_vals, $max_parts)
    {
        $this->send_get_partition_names_ps($db_name, $tbl_name, $part_vals, $max_parts);
        return $this->recv_get_partition_names_ps();
    }

    public function send_get_partition_names_ps($db_name, $tbl_name, array $part_vals, $max_parts)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partition_names_ps_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $args->max_parts = $max_parts;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partition_names_ps',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partition_names_ps', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partition_names_ps()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partition_names_ps_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partition_names_ps_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partition_names_ps failed: unknown result");
    }

    public function get_partition_names_ps_req(\metastore\GetPartitionNamesPsRequest $req)
    {
        $this->send_get_partition_names_ps_req($req);
        return $this->recv_get_partition_names_ps_req();
    }

    public function send_get_partition_names_ps_req(\metastore\GetPartitionNamesPsRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partition_names_ps_req_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partition_names_ps_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partition_names_ps_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partition_names_ps_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partition_names_ps_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partition_names_ps_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partition_names_ps_req failed: unknown result");
    }

    public function get_partition_names_req(\metastore\PartitionsByExprRequest $req)
    {
        $this->send_get_partition_names_req($req);
        return $this->recv_get_partition_names_req();
    }

    public function send_get_partition_names_req(\metastore\PartitionsByExprRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partition_names_req_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partition_names_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partition_names_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partition_names_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partition_names_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partition_names_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partition_names_req failed: unknown result");
    }

    public function get_partitions_by_filter($db_name, $tbl_name, $filter, $max_parts)
    {
        $this->send_get_partitions_by_filter($db_name, $tbl_name, $filter, $max_parts);
        return $this->recv_get_partitions_by_filter();
    }

    public function send_get_partitions_by_filter($db_name, $tbl_name, $filter, $max_parts)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_by_filter_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->filter = $filter;
        $args->max_parts = $max_parts;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions_by_filter',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions_by_filter', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions_by_filter()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_by_filter_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_by_filter_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions_by_filter failed: unknown result");
    }

    public function get_part_specs_by_filter($db_name, $tbl_name, $filter, $max_parts)
    {
        $this->send_get_part_specs_by_filter($db_name, $tbl_name, $filter, $max_parts);
        return $this->recv_get_part_specs_by_filter();
    }

    public function send_get_part_specs_by_filter($db_name, $tbl_name, $filter, $max_parts)
    {
        $args = new \metastore\ThriftHiveMetastore_get_part_specs_by_filter_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->filter = $filter;
        $args->max_parts = $max_parts;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_part_specs_by_filter',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_part_specs_by_filter', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_part_specs_by_filter()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_part_specs_by_filter_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_part_specs_by_filter_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_part_specs_by_filter failed: unknown result");
    }

    public function get_partitions_by_expr(\metastore\PartitionsByExprRequest $req)
    {
        $this->send_get_partitions_by_expr($req);
        return $this->recv_get_partitions_by_expr();
    }

    public function send_get_partitions_by_expr(\metastore\PartitionsByExprRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_by_expr_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions_by_expr',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions_by_expr', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions_by_expr()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_by_expr_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_by_expr_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions_by_expr failed: unknown result");
    }

    public function get_partitions_spec_by_expr(\metastore\PartitionsByExprRequest $req)
    {
        $this->send_get_partitions_spec_by_expr($req);
        return $this->recv_get_partitions_spec_by_expr();
    }

    public function send_get_partitions_spec_by_expr(\metastore\PartitionsByExprRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_spec_by_expr_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions_spec_by_expr',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions_spec_by_expr', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions_spec_by_expr()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_spec_by_expr_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_spec_by_expr_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions_spec_by_expr failed: unknown result");
    }

    public function get_num_partitions_by_filter($db_name, $tbl_name, $filter)
    {
        $this->send_get_num_partitions_by_filter($db_name, $tbl_name, $filter);
        return $this->recv_get_num_partitions_by_filter();
    }

    public function send_get_num_partitions_by_filter($db_name, $tbl_name, $filter)
    {
        $args = new \metastore\ThriftHiveMetastore_get_num_partitions_by_filter_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->filter = $filter;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_num_partitions_by_filter',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_num_partitions_by_filter', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_num_partitions_by_filter()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_num_partitions_by_filter_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_num_partitions_by_filter_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_num_partitions_by_filter failed: unknown result");
    }

    public function get_partitions_by_names($db_name, $tbl_name, array $names)
    {
        $this->send_get_partitions_by_names($db_name, $tbl_name, $names);
        return $this->recv_get_partitions_by_names();
    }

    public function send_get_partitions_by_names($db_name, $tbl_name, array $names)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_by_names_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->names = $names;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions_by_names',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions_by_names', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions_by_names()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_by_names_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_by_names_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions_by_names failed: unknown result");
    }

    public function get_partitions_by_names_req(\metastore\GetPartitionsByNamesRequest $req)
    {
        $this->send_get_partitions_by_names_req($req);
        return $this->recv_get_partitions_by_names_req();
    }

    public function send_get_partitions_by_names_req(\metastore\GetPartitionsByNamesRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_by_names_req_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions_by_names_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions_by_names_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions_by_names_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_by_names_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_by_names_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions_by_names_req failed: unknown result");
    }

    public function alter_partition($db_name, $tbl_name, \metastore\Partition $new_part)
    {
        $this->send_alter_partition($db_name, $tbl_name, $new_part);
        $this->recv_alter_partition();
    }

    public function send_alter_partition($db_name, $tbl_name, \metastore\Partition $new_part)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_partition_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->new_part = $new_part;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_partition',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_partition', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_partition()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_partition_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_partition_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function alter_partitions($db_name, $tbl_name, array $new_parts)
    {
        $this->send_alter_partitions($db_name, $tbl_name, $new_parts);
        $this->recv_alter_partitions();
    }

    public function send_alter_partitions($db_name, $tbl_name, array $new_parts)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_partitions_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->new_parts = $new_parts;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_partitions',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_partitions', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_partitions()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_partitions_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_partitions_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function alter_partitions_with_environment_context($db_name, $tbl_name, array $new_parts, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_alter_partitions_with_environment_context($db_name, $tbl_name, $new_parts, $environment_context);
        $this->recv_alter_partitions_with_environment_context();
    }

    public function send_alter_partitions_with_environment_context($db_name, $tbl_name, array $new_parts, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_partitions_with_environment_context_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->new_parts = $new_parts;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_partitions_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_partitions_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_partitions_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_partitions_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_partitions_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function alter_partitions_req(\metastore\AlterPartitionsRequest $req)
    {
        $this->send_alter_partitions_req($req);
        return $this->recv_alter_partitions_req();
    }

    public function send_alter_partitions_req(\metastore\AlterPartitionsRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_partitions_req_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_partitions_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_partitions_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_partitions_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_partitions_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_partitions_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("alter_partitions_req failed: unknown result");
    }

    public function alter_partition_with_environment_context($db_name, $tbl_name, \metastore\Partition $new_part, \metastore\EnvironmentContext $environment_context)
    {
        $this->send_alter_partition_with_environment_context($db_name, $tbl_name, $new_part, $environment_context);
        $this->recv_alter_partition_with_environment_context();
    }

    public function send_alter_partition_with_environment_context($db_name, $tbl_name, \metastore\Partition $new_part, \metastore\EnvironmentContext $environment_context)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_partition_with_environment_context_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->new_part = $new_part;
        $args->environment_context = $environment_context;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_partition_with_environment_context',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_partition_with_environment_context', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_partition_with_environment_context()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_partition_with_environment_context_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_partition_with_environment_context_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function rename_partition($db_name, $tbl_name, array $part_vals, \metastore\Partition $new_part)
    {
        $this->send_rename_partition($db_name, $tbl_name, $part_vals, $new_part);
        $this->recv_rename_partition();
    }

    public function send_rename_partition($db_name, $tbl_name, array $part_vals, \metastore\Partition $new_part)
    {
        $args = new \metastore\ThriftHiveMetastore_rename_partition_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $args->new_part = $new_part;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'rename_partition',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('rename_partition', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_rename_partition()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_rename_partition_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_rename_partition_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function rename_partition_req(\metastore\RenamePartitionRequest $req)
    {
        $this->send_rename_partition_req($req);
        return $this->recv_rename_partition_req();
    }

    public function send_rename_partition_req(\metastore\RenamePartitionRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_rename_partition_req_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'rename_partition_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('rename_partition_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_rename_partition_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_rename_partition_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_rename_partition_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("rename_partition_req failed: unknown result");
    }

    public function partition_name_has_valid_characters(array $part_vals, $throw_exception)
    {
        $this->send_partition_name_has_valid_characters($part_vals, $throw_exception);
        return $this->recv_partition_name_has_valid_characters();
    }

    public function send_partition_name_has_valid_characters(array $part_vals, $throw_exception)
    {
        $args = new \metastore\ThriftHiveMetastore_partition_name_has_valid_characters_args();
        $args->part_vals = $part_vals;
        $args->throw_exception = $throw_exception;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'partition_name_has_valid_characters',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('partition_name_has_valid_characters', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_partition_name_has_valid_characters()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_partition_name_has_valid_characters_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_partition_name_has_valid_characters_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("partition_name_has_valid_characters failed: unknown result");
    }

    public function get_config_value($name, $defaultValue)
    {
        $this->send_get_config_value($name, $defaultValue);
        return $this->recv_get_config_value();
    }

    public function send_get_config_value($name, $defaultValue)
    {
        $args = new \metastore\ThriftHiveMetastore_get_config_value_args();
        $args->name = $name;
        $args->defaultValue = $defaultValue;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_config_value',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_config_value', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_config_value()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_config_value_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_config_value_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_config_value failed: unknown result");
    }

    public function partition_name_to_vals($part_name)
    {
        $this->send_partition_name_to_vals($part_name);
        return $this->recv_partition_name_to_vals();
    }

    public function send_partition_name_to_vals($part_name)
    {
        $args = new \metastore\ThriftHiveMetastore_partition_name_to_vals_args();
        $args->part_name = $part_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'partition_name_to_vals',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('partition_name_to_vals', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_partition_name_to_vals()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_partition_name_to_vals_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_partition_name_to_vals_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("partition_name_to_vals failed: unknown result");
    }

    public function partition_name_to_spec($part_name)
    {
        $this->send_partition_name_to_spec($part_name);
        return $this->recv_partition_name_to_spec();
    }

    public function send_partition_name_to_spec($part_name)
    {
        $args = new \metastore\ThriftHiveMetastore_partition_name_to_spec_args();
        $args->part_name = $part_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'partition_name_to_spec',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('partition_name_to_spec', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_partition_name_to_spec()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_partition_name_to_spec_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_partition_name_to_spec_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("partition_name_to_spec failed: unknown result");
    }

    public function markPartitionForEvent($db_name, $tbl_name, array $part_vals, $eventType)
    {
        $this->send_markPartitionForEvent($db_name, $tbl_name, $part_vals, $eventType);
        $this->recv_markPartitionForEvent();
    }

    public function send_markPartitionForEvent($db_name, $tbl_name, array $part_vals, $eventType)
    {
        $args = new \metastore\ThriftHiveMetastore_markPartitionForEvent_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $args->eventType = $eventType;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'markPartitionForEvent',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('markPartitionForEvent', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_markPartitionForEvent()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_markPartitionForEvent_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_markPartitionForEvent_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        if ($result->o5 !== null) {
            throw $result->o5;
        }
        if ($result->o6 !== null) {
            throw $result->o6;
        }
        return;
    }

    public function isPartitionMarkedForEvent($db_name, $tbl_name, array $part_vals, $eventType)
    {
        $this->send_isPartitionMarkedForEvent($db_name, $tbl_name, $part_vals, $eventType);
        return $this->recv_isPartitionMarkedForEvent();
    }

    public function send_isPartitionMarkedForEvent($db_name, $tbl_name, array $part_vals, $eventType)
    {
        $args = new \metastore\ThriftHiveMetastore_isPartitionMarkedForEvent_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_vals = $part_vals;
        $args->eventType = $eventType;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'isPartitionMarkedForEvent',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('isPartitionMarkedForEvent', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_isPartitionMarkedForEvent()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_isPartitionMarkedForEvent_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_isPartitionMarkedForEvent_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        if ($result->o5 !== null) {
            throw $result->o5;
        }
        if ($result->o6 !== null) {
            throw $result->o6;
        }
        throw new \Exception("isPartitionMarkedForEvent failed: unknown result");
    }

    public function get_primary_keys(\metastore\PrimaryKeysRequest $request)
    {
        $this->send_get_primary_keys($request);
        return $this->recv_get_primary_keys();
    }

    public function send_get_primary_keys(\metastore\PrimaryKeysRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_primary_keys_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_primary_keys',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_primary_keys', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_primary_keys()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_primary_keys_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_primary_keys_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_primary_keys failed: unknown result");
    }

    public function get_foreign_keys(\metastore\ForeignKeysRequest $request)
    {
        $this->send_get_foreign_keys($request);
        return $this->recv_get_foreign_keys();
    }

    public function send_get_foreign_keys(\metastore\ForeignKeysRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_foreign_keys_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_foreign_keys',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_foreign_keys', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_foreign_keys()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_foreign_keys_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_foreign_keys_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_foreign_keys failed: unknown result");
    }

    public function get_unique_constraints(\metastore\UniqueConstraintsRequest $request)
    {
        $this->send_get_unique_constraints($request);
        return $this->recv_get_unique_constraints();
    }

    public function send_get_unique_constraints(\metastore\UniqueConstraintsRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_unique_constraints_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_unique_constraints',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_unique_constraints', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_unique_constraints()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_unique_constraints_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_unique_constraints_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_unique_constraints failed: unknown result");
    }

    public function get_not_null_constraints(\metastore\NotNullConstraintsRequest $request)
    {
        $this->send_get_not_null_constraints($request);
        return $this->recv_get_not_null_constraints();
    }

    public function send_get_not_null_constraints(\metastore\NotNullConstraintsRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_not_null_constraints_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_not_null_constraints',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_not_null_constraints', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_not_null_constraints()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_not_null_constraints_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_not_null_constraints_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_not_null_constraints failed: unknown result");
    }

    public function get_default_constraints(\metastore\DefaultConstraintsRequest $request)
    {
        $this->send_get_default_constraints($request);
        return $this->recv_get_default_constraints();
    }

    public function send_get_default_constraints(\metastore\DefaultConstraintsRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_default_constraints_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_default_constraints',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_default_constraints', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_default_constraints()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_default_constraints_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_default_constraints_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_default_constraints failed: unknown result");
    }

    public function get_check_constraints(\metastore\CheckConstraintsRequest $request)
    {
        $this->send_get_check_constraints($request);
        return $this->recv_get_check_constraints();
    }

    public function send_get_check_constraints(\metastore\CheckConstraintsRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_check_constraints_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_check_constraints',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_check_constraints', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_check_constraints()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_check_constraints_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_check_constraints_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_check_constraints failed: unknown result");
    }

    public function get_all_table_constraints(\metastore\AllTableConstraintsRequest $request)
    {
        $this->send_get_all_table_constraints($request);
        return $this->recv_get_all_table_constraints();
    }

    public function send_get_all_table_constraints(\metastore\AllTableConstraintsRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_all_table_constraints_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_all_table_constraints',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_all_table_constraints', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_all_table_constraints()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_all_table_constraints_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_all_table_constraints_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_all_table_constraints failed: unknown result");
    }

    public function update_table_column_statistics(\metastore\ColumnStatistics $stats_obj)
    {
        $this->send_update_table_column_statistics($stats_obj);
        return $this->recv_update_table_column_statistics();
    }

    public function send_update_table_column_statistics(\metastore\ColumnStatistics $stats_obj)
    {
        $args = new \metastore\ThriftHiveMetastore_update_table_column_statistics_args();
        $args->stats_obj = $stats_obj;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'update_table_column_statistics',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('update_table_column_statistics', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_update_table_column_statistics()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_update_table_column_statistics_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_update_table_column_statistics_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("update_table_column_statistics failed: unknown result");
    }

    public function update_partition_column_statistics(\metastore\ColumnStatistics $stats_obj)
    {
        $this->send_update_partition_column_statistics($stats_obj);
        return $this->recv_update_partition_column_statistics();
    }

    public function send_update_partition_column_statistics(\metastore\ColumnStatistics $stats_obj)
    {
        $args = new \metastore\ThriftHiveMetastore_update_partition_column_statistics_args();
        $args->stats_obj = $stats_obj;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'update_partition_column_statistics',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('update_partition_column_statistics', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_update_partition_column_statistics()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_update_partition_column_statistics_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_update_partition_column_statistics_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("update_partition_column_statistics failed: unknown result");
    }

    public function update_table_column_statistics_req(\metastore\SetPartitionsStatsRequest $req)
    {
        $this->send_update_table_column_statistics_req($req);
        return $this->recv_update_table_column_statistics_req();
    }

    public function send_update_table_column_statistics_req(\metastore\SetPartitionsStatsRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_update_table_column_statistics_req_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'update_table_column_statistics_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('update_table_column_statistics_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_update_table_column_statistics_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_update_table_column_statistics_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_update_table_column_statistics_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("update_table_column_statistics_req failed: unknown result");
    }

    public function update_partition_column_statistics_req(\metastore\SetPartitionsStatsRequest $req)
    {
        $this->send_update_partition_column_statistics_req($req);
        return $this->recv_update_partition_column_statistics_req();
    }

    public function send_update_partition_column_statistics_req(\metastore\SetPartitionsStatsRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_update_partition_column_statistics_req_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'update_partition_column_statistics_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('update_partition_column_statistics_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_update_partition_column_statistics_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_update_partition_column_statistics_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_update_partition_column_statistics_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("update_partition_column_statistics_req failed: unknown result");
    }

    public function get_table_column_statistics($db_name, $tbl_name, $col_name)
    {
        $this->send_get_table_column_statistics($db_name, $tbl_name, $col_name);
        return $this->recv_get_table_column_statistics();
    }

    public function send_get_table_column_statistics($db_name, $tbl_name, $col_name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_table_column_statistics_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->col_name = $col_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_table_column_statistics',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_table_column_statistics', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_table_column_statistics()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_table_column_statistics_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_table_column_statistics_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("get_table_column_statistics failed: unknown result");
    }

    public function get_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name)
    {
        $this->send_get_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name);
        return $this->recv_get_partition_column_statistics();
    }

    public function send_get_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partition_column_statistics_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_name = $part_name;
        $args->col_name = $col_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partition_column_statistics',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partition_column_statistics', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partition_column_statistics()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partition_column_statistics_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partition_column_statistics_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("get_partition_column_statistics failed: unknown result");
    }

    public function get_table_statistics_req(\metastore\TableStatsRequest $request)
    {
        $this->send_get_table_statistics_req($request);
        return $this->recv_get_table_statistics_req();
    }

    public function send_get_table_statistics_req(\metastore\TableStatsRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_table_statistics_req_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_table_statistics_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_table_statistics_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_table_statistics_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_table_statistics_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_table_statistics_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_table_statistics_req failed: unknown result");
    }

    public function get_partitions_statistics_req(\metastore\PartitionsStatsRequest $request)
    {
        $this->send_get_partitions_statistics_req($request);
        return $this->recv_get_partitions_statistics_req();
    }

    public function send_get_partitions_statistics_req(\metastore\PartitionsStatsRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_statistics_req_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions_statistics_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions_statistics_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions_statistics_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_statistics_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_statistics_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_partitions_statistics_req failed: unknown result");
    }

    public function get_aggr_stats_for(\metastore\PartitionsStatsRequest $request)
    {
        $this->send_get_aggr_stats_for($request);
        return $this->recv_get_aggr_stats_for();
    }

    public function send_get_aggr_stats_for(\metastore\PartitionsStatsRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_aggr_stats_for_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_aggr_stats_for',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_aggr_stats_for', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_aggr_stats_for()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_aggr_stats_for_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_aggr_stats_for_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_aggr_stats_for failed: unknown result");
    }

    public function set_aggr_stats_for(\metastore\SetPartitionsStatsRequest $request)
    {
        $this->send_set_aggr_stats_for($request);
        return $this->recv_set_aggr_stats_for();
    }

    public function send_set_aggr_stats_for(\metastore\SetPartitionsStatsRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_set_aggr_stats_for_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'set_aggr_stats_for',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('set_aggr_stats_for', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_set_aggr_stats_for()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_set_aggr_stats_for_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_set_aggr_stats_for_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("set_aggr_stats_for failed: unknown result");
    }

    public function delete_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name, $engine)
    {
        $this->send_delete_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name, $engine);
        return $this->recv_delete_partition_column_statistics();
    }

    public function send_delete_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name, $engine)
    {
        $args = new \metastore\ThriftHiveMetastore_delete_partition_column_statistics_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->part_name = $part_name;
        $args->col_name = $col_name;
        $args->engine = $engine;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'delete_partition_column_statistics',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('delete_partition_column_statistics', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_delete_partition_column_statistics()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_delete_partition_column_statistics_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_delete_partition_column_statistics_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("delete_partition_column_statistics failed: unknown result");
    }

    public function delete_table_column_statistics($db_name, $tbl_name, $col_name, $engine)
    {
        $this->send_delete_table_column_statistics($db_name, $tbl_name, $col_name, $engine);
        return $this->recv_delete_table_column_statistics();
    }

    public function send_delete_table_column_statistics($db_name, $tbl_name, $col_name, $engine)
    {
        $args = new \metastore\ThriftHiveMetastore_delete_table_column_statistics_args();
        $args->db_name = $db_name;
        $args->tbl_name = $tbl_name;
        $args->col_name = $col_name;
        $args->engine = $engine;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'delete_table_column_statistics',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('delete_table_column_statistics', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_delete_table_column_statistics()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_delete_table_column_statistics_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_delete_table_column_statistics_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("delete_table_column_statistics failed: unknown result");
    }

    public function create_function(\metastore\Function $func)
    {
        $this->send_create_function($func);
        $this->recv_create_function();
    }

    public function send_create_function(\metastore\Function $func)
    {
        $args = new \metastore\ThriftHiveMetastore_create_function_args();
        $args->func = $func;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_function',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_function', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_function()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_function_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_function_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        return;
    }

    public function drop_function($dbName, $funcName)
    {
        $this->send_drop_function($dbName, $funcName);
        $this->recv_drop_function();
    }

    public function send_drop_function($dbName, $funcName)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_function_args();
        $args->dbName = $dbName;
        $args->funcName = $funcName;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_function',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_function', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_function()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_function_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_function_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function alter_function($dbName, $funcName, \metastore\Function $newFunc)
    {
        $this->send_alter_function($dbName, $funcName, $newFunc);
        $this->recv_alter_function();
    }

    public function send_alter_function($dbName, $funcName, \metastore\Function $newFunc)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_function_args();
        $args->dbName = $dbName;
        $args->funcName = $funcName;
        $args->newFunc = $newFunc;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_function',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_function', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_function()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_function_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_function_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function get_functions($dbName, $pattern)
    {
        $this->send_get_functions($dbName, $pattern);
        return $this->recv_get_functions();
    }

    public function send_get_functions($dbName, $pattern)
    {
        $args = new \metastore\ThriftHiveMetastore_get_functions_args();
        $args->dbName = $dbName;
        $args->pattern = $pattern;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_functions',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_functions', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_functions()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_functions_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_functions_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_functions failed: unknown result");
    }

    public function get_function($dbName, $funcName)
    {
        $this->send_get_function($dbName, $funcName);
        return $this->recv_get_function();
    }

    public function send_get_function($dbName, $funcName)
    {
        $args = new \metastore\ThriftHiveMetastore_get_function_args();
        $args->dbName = $dbName;
        $args->funcName = $funcName;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_function',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_function', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_function()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_function_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_function_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_function failed: unknown result");
    }

    public function get_all_functions()
    {
        $this->send_get_all_functions();
        return $this->recv_get_all_functions();
    }

    public function send_get_all_functions()
    {
        $args = new \metastore\ThriftHiveMetastore_get_all_functions_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_all_functions',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_all_functions', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_all_functions()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_all_functions_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_all_functions_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_all_functions failed: unknown result");
    }

    public function create_role(\metastore\Role $role)
    {
        $this->send_create_role($role);
        return $this->recv_create_role();
    }

    public function send_create_role(\metastore\Role $role)
    {
        $args = new \metastore\ThriftHiveMetastore_create_role_args();
        $args->role = $role;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_role',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_role', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_role()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_role_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_role_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("create_role failed: unknown result");
    }

    public function drop_role($role_name)
    {
        $this->send_drop_role($role_name);
        return $this->recv_drop_role();
    }

    public function send_drop_role($role_name)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_role_args();
        $args->role_name = $role_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_role',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_role', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_role()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_role_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_role_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("drop_role failed: unknown result");
    }

    public function get_role_names()
    {
        $this->send_get_role_names();
        return $this->recv_get_role_names();
    }

    public function send_get_role_names()
    {
        $args = new \metastore\ThriftHiveMetastore_get_role_names_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_role_names',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_role_names', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_role_names()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_role_names_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_role_names_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_role_names failed: unknown result");
    }

    public function grant_role($role_name, $principal_name, $principal_type, $grantor, $grantorType, $grant_option)
    {
        $this->send_grant_role($role_name, $principal_name, $principal_type, $grantor, $grantorType, $grant_option);
        return $this->recv_grant_role();
    }

    public function send_grant_role($role_name, $principal_name, $principal_type, $grantor, $grantorType, $grant_option)
    {
        $args = new \metastore\ThriftHiveMetastore_grant_role_args();
        $args->role_name = $role_name;
        $args->principal_name = $principal_name;
        $args->principal_type = $principal_type;
        $args->grantor = $grantor;
        $args->grantorType = $grantorType;
        $args->grant_option = $grant_option;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'grant_role',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('grant_role', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_grant_role()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_grant_role_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_grant_role_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("grant_role failed: unknown result");
    }

    public function revoke_role($role_name, $principal_name, $principal_type)
    {
        $this->send_revoke_role($role_name, $principal_name, $principal_type);
        return $this->recv_revoke_role();
    }

    public function send_revoke_role($role_name, $principal_name, $principal_type)
    {
        $args = new \metastore\ThriftHiveMetastore_revoke_role_args();
        $args->role_name = $role_name;
        $args->principal_name = $principal_name;
        $args->principal_type = $principal_type;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'revoke_role',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('revoke_role', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_revoke_role()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_revoke_role_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_revoke_role_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("revoke_role failed: unknown result");
    }

    public function list_roles($principal_name, $principal_type)
    {
        $this->send_list_roles($principal_name, $principal_type);
        return $this->recv_list_roles();
    }

    public function send_list_roles($principal_name, $principal_type)
    {
        $args = new \metastore\ThriftHiveMetastore_list_roles_args();
        $args->principal_name = $principal_name;
        $args->principal_type = $principal_type;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'list_roles',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('list_roles', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_list_roles()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_list_roles_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_list_roles_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("list_roles failed: unknown result");
    }

    public function grant_revoke_role(\metastore\GrantRevokeRoleRequest $request)
    {
        $this->send_grant_revoke_role($request);
        return $this->recv_grant_revoke_role();
    }

    public function send_grant_revoke_role(\metastore\GrantRevokeRoleRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_grant_revoke_role_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'grant_revoke_role',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('grant_revoke_role', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_grant_revoke_role()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_grant_revoke_role_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_grant_revoke_role_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("grant_revoke_role failed: unknown result");
    }

    public function get_principals_in_role(\metastore\GetPrincipalsInRoleRequest $request)
    {
        $this->send_get_principals_in_role($request);
        return $this->recv_get_principals_in_role();
    }

    public function send_get_principals_in_role(\metastore\GetPrincipalsInRoleRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_principals_in_role_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_principals_in_role',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_principals_in_role', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_principals_in_role()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_principals_in_role_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_principals_in_role_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_principals_in_role failed: unknown result");
    }

    public function get_role_grants_for_principal(\metastore\GetRoleGrantsForPrincipalRequest $request)
    {
        $this->send_get_role_grants_for_principal($request);
        return $this->recv_get_role_grants_for_principal();
    }

    public function send_get_role_grants_for_principal(\metastore\GetRoleGrantsForPrincipalRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_role_grants_for_principal_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_role_grants_for_principal',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_role_grants_for_principal', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_role_grants_for_principal()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_role_grants_for_principal_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_role_grants_for_principal_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_role_grants_for_principal failed: unknown result");
    }

    public function get_privilege_set(\metastore\HiveObjectRef $hiveObject, $user_name, array $group_names)
    {
        $this->send_get_privilege_set($hiveObject, $user_name, $group_names);
        return $this->recv_get_privilege_set();
    }

    public function send_get_privilege_set(\metastore\HiveObjectRef $hiveObject, $user_name, array $group_names)
    {
        $args = new \metastore\ThriftHiveMetastore_get_privilege_set_args();
        $args->hiveObject = $hiveObject;
        $args->user_name = $user_name;
        $args->group_names = $group_names;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_privilege_set',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_privilege_set', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_privilege_set()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_privilege_set_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_privilege_set_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_privilege_set failed: unknown result");
    }

    public function list_privileges($principal_name, $principal_type, \metastore\HiveObjectRef $hiveObject)
    {
        $this->send_list_privileges($principal_name, $principal_type, $hiveObject);
        return $this->recv_list_privileges();
    }

    public function send_list_privileges($principal_name, $principal_type, \metastore\HiveObjectRef $hiveObject)
    {
        $args = new \metastore\ThriftHiveMetastore_list_privileges_args();
        $args->principal_name = $principal_name;
        $args->principal_type = $principal_type;
        $args->hiveObject = $hiveObject;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'list_privileges',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('list_privileges', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_list_privileges()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_list_privileges_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_list_privileges_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("list_privileges failed: unknown result");
    }

    public function grant_privileges(\metastore\PrivilegeBag $privileges)
    {
        $this->send_grant_privileges($privileges);
        return $this->recv_grant_privileges();
    }

    public function send_grant_privileges(\metastore\PrivilegeBag $privileges)
    {
        $args = new \metastore\ThriftHiveMetastore_grant_privileges_args();
        $args->privileges = $privileges;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'grant_privileges',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('grant_privileges', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_grant_privileges()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_grant_privileges_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_grant_privileges_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("grant_privileges failed: unknown result");
    }

    public function revoke_privileges(\metastore\PrivilegeBag $privileges)
    {
        $this->send_revoke_privileges($privileges);
        return $this->recv_revoke_privileges();
    }

    public function send_revoke_privileges(\metastore\PrivilegeBag $privileges)
    {
        $args = new \metastore\ThriftHiveMetastore_revoke_privileges_args();
        $args->privileges = $privileges;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'revoke_privileges',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('revoke_privileges', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_revoke_privileges()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_revoke_privileges_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_revoke_privileges_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("revoke_privileges failed: unknown result");
    }

    public function grant_revoke_privileges(\metastore\GrantRevokePrivilegeRequest $request)
    {
        $this->send_grant_revoke_privileges($request);
        return $this->recv_grant_revoke_privileges();
    }

    public function send_grant_revoke_privileges(\metastore\GrantRevokePrivilegeRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_grant_revoke_privileges_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'grant_revoke_privileges',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('grant_revoke_privileges', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_grant_revoke_privileges()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_grant_revoke_privileges_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_grant_revoke_privileges_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("grant_revoke_privileges failed: unknown result");
    }

    public function refresh_privileges(\metastore\HiveObjectRef $objToRefresh, $authorizer, \metastore\GrantRevokePrivilegeRequest $grantRequest)
    {
        $this->send_refresh_privileges($objToRefresh, $authorizer, $grantRequest);
        return $this->recv_refresh_privileges();
    }

    public function send_refresh_privileges(\metastore\HiveObjectRef $objToRefresh, $authorizer, \metastore\GrantRevokePrivilegeRequest $grantRequest)
    {
        $args = new \metastore\ThriftHiveMetastore_refresh_privileges_args();
        $args->objToRefresh = $objToRefresh;
        $args->authorizer = $authorizer;
        $args->grantRequest = $grantRequest;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'refresh_privileges',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('refresh_privileges', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_refresh_privileges()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_refresh_privileges_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_refresh_privileges_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("refresh_privileges failed: unknown result");
    }

    public function set_ugi($user_name, array $group_names)
    {
        $this->send_set_ugi($user_name, $group_names);
        return $this->recv_set_ugi();
    }

    public function send_set_ugi($user_name, array $group_names)
    {
        $args = new \metastore\ThriftHiveMetastore_set_ugi_args();
        $args->user_name = $user_name;
        $args->group_names = $group_names;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'set_ugi',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('set_ugi', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_set_ugi()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_set_ugi_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_set_ugi_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("set_ugi failed: unknown result");
    }

    public function get_delegation_token($token_owner, $renewer_kerberos_principal_name)
    {
        $this->send_get_delegation_token($token_owner, $renewer_kerberos_principal_name);
        return $this->recv_get_delegation_token();
    }

    public function send_get_delegation_token($token_owner, $renewer_kerberos_principal_name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_delegation_token_args();
        $args->token_owner = $token_owner;
        $args->renewer_kerberos_principal_name = $renewer_kerberos_principal_name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_delegation_token',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_delegation_token', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_delegation_token()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_delegation_token_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_delegation_token_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_delegation_token failed: unknown result");
    }

    public function renew_delegation_token($token_str_form)
    {
        $this->send_renew_delegation_token($token_str_form);
        return $this->recv_renew_delegation_token();
    }

    public function send_renew_delegation_token($token_str_form)
    {
        $args = new \metastore\ThriftHiveMetastore_renew_delegation_token_args();
        $args->token_str_form = $token_str_form;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'renew_delegation_token',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('renew_delegation_token', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_renew_delegation_token()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_renew_delegation_token_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_renew_delegation_token_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("renew_delegation_token failed: unknown result");
    }

    public function cancel_delegation_token($token_str_form)
    {
        $this->send_cancel_delegation_token($token_str_form);
        $this->recv_cancel_delegation_token();
    }

    public function send_cancel_delegation_token($token_str_form)
    {
        $args = new \metastore\ThriftHiveMetastore_cancel_delegation_token_args();
        $args->token_str_form = $token_str_form;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'cancel_delegation_token',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('cancel_delegation_token', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_cancel_delegation_token()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_cancel_delegation_token_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_cancel_delegation_token_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        return;
    }

    public function add_token($token_identifier, $delegation_token)
    {
        $this->send_add_token($token_identifier, $delegation_token);
        return $this->recv_add_token();
    }

    public function send_add_token($token_identifier, $delegation_token)
    {
        $args = new \metastore\ThriftHiveMetastore_add_token_args();
        $args->token_identifier = $token_identifier;
        $args->delegation_token = $delegation_token;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_token',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_token', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_token()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_token_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_token_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("add_token failed: unknown result");
    }

    public function remove_token($token_identifier)
    {
        $this->send_remove_token($token_identifier);
        return $this->recv_remove_token();
    }

    public function send_remove_token($token_identifier)
    {
        $args = new \metastore\ThriftHiveMetastore_remove_token_args();
        $args->token_identifier = $token_identifier;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'remove_token',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('remove_token', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_remove_token()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_remove_token_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_remove_token_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("remove_token failed: unknown result");
    }

    public function get_token($token_identifier)
    {
        $this->send_get_token($token_identifier);
        return $this->recv_get_token();
    }

    public function send_get_token($token_identifier)
    {
        $args = new \metastore\ThriftHiveMetastore_get_token_args();
        $args->token_identifier = $token_identifier;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_token',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_token', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_token()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_token_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_token_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_token failed: unknown result");
    }

    public function get_all_token_identifiers()
    {
        $this->send_get_all_token_identifiers();
        return $this->recv_get_all_token_identifiers();
    }

    public function send_get_all_token_identifiers()
    {
        $args = new \metastore\ThriftHiveMetastore_get_all_token_identifiers_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_all_token_identifiers',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_all_token_identifiers', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_all_token_identifiers()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_all_token_identifiers_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_all_token_identifiers_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_all_token_identifiers failed: unknown result");
    }

    public function add_master_key($key)
    {
        $this->send_add_master_key($key);
        return $this->recv_add_master_key();
    }

    public function send_add_master_key($key)
    {
        $args = new \metastore\ThriftHiveMetastore_add_master_key_args();
        $args->key = $key;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_master_key',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_master_key', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_master_key()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_master_key_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_master_key_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("add_master_key failed: unknown result");
    }

    public function update_master_key($seq_number, $key)
    {
        $this->send_update_master_key($seq_number, $key);
        $this->recv_update_master_key();
    }

    public function send_update_master_key($seq_number, $key)
    {
        $args = new \metastore\ThriftHiveMetastore_update_master_key_args();
        $args->seq_number = $seq_number;
        $args->key = $key;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'update_master_key',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('update_master_key', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_update_master_key()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_update_master_key_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_update_master_key_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function remove_master_key($key_seq)
    {
        $this->send_remove_master_key($key_seq);
        return $this->recv_remove_master_key();
    }

    public function send_remove_master_key($key_seq)
    {
        $args = new \metastore\ThriftHiveMetastore_remove_master_key_args();
        $args->key_seq = $key_seq;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'remove_master_key',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('remove_master_key', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_remove_master_key()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_remove_master_key_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_remove_master_key_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("remove_master_key failed: unknown result");
    }

    public function get_master_keys()
    {
        $this->send_get_master_keys();
        return $this->recv_get_master_keys();
    }

    public function send_get_master_keys()
    {
        $args = new \metastore\ThriftHiveMetastore_get_master_keys_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_master_keys',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_master_keys', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_master_keys()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_master_keys_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_master_keys_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_master_keys failed: unknown result");
    }

    public function get_open_txns()
    {
        $this->send_get_open_txns();
        return $this->recv_get_open_txns();
    }

    public function send_get_open_txns()
    {
        $args = new \metastore\ThriftHiveMetastore_get_open_txns_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_open_txns',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_open_txns', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_open_txns()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_open_txns_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_open_txns_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_open_txns failed: unknown result");
    }

    public function get_open_txns_info()
    {
        $this->send_get_open_txns_info();
        return $this->recv_get_open_txns_info();
    }

    public function send_get_open_txns_info()
    {
        $args = new \metastore\ThriftHiveMetastore_get_open_txns_info_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_open_txns_info',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_open_txns_info', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_open_txns_info()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_open_txns_info_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_open_txns_info_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_open_txns_info failed: unknown result");
    }

    public function open_txns(\metastore\OpenTxnRequest $rqst)
    {
        $this->send_open_txns($rqst);
        return $this->recv_open_txns();
    }

    public function send_open_txns(\metastore\OpenTxnRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_open_txns_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'open_txns',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('open_txns', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_open_txns()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_open_txns_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_open_txns_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("open_txns failed: unknown result");
    }

    public function abort_txn(\metastore\AbortTxnRequest $rqst)
    {
        $this->send_abort_txn($rqst);
        $this->recv_abort_txn();
    }

    public function send_abort_txn(\metastore\AbortTxnRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_abort_txn_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'abort_txn',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('abort_txn', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_abort_txn()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_abort_txn_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_abort_txn_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        return;
    }

    public function abort_txns(\metastore\AbortTxnsRequest $rqst)
    {
        $this->send_abort_txns($rqst);
        $this->recv_abort_txns();
    }

    public function send_abort_txns(\metastore\AbortTxnsRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_abort_txns_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'abort_txns',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('abort_txns', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_abort_txns()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_abort_txns_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_abort_txns_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        return;
    }

    public function commit_txn(\metastore\CommitTxnRequest $rqst)
    {
        $this->send_commit_txn($rqst);
        $this->recv_commit_txn();
    }

    public function send_commit_txn(\metastore\CommitTxnRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_commit_txn_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'commit_txn',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('commit_txn', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_commit_txn()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_commit_txn_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_commit_txn_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function get_latest_txnid_in_conflict($txnId)
    {
        $this->send_get_latest_txnid_in_conflict($txnId);
        return $this->recv_get_latest_txnid_in_conflict();
    }

    public function send_get_latest_txnid_in_conflict($txnId)
    {
        $args = new \metastore\ThriftHiveMetastore_get_latest_txnid_in_conflict_args();
        $args->txnId = $txnId;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_latest_txnid_in_conflict',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_latest_txnid_in_conflict', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_latest_txnid_in_conflict()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_latest_txnid_in_conflict_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_latest_txnid_in_conflict_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_latest_txnid_in_conflict failed: unknown result");
    }

    public function repl_tbl_writeid_state(\metastore\ReplTblWriteIdStateRequest $rqst)
    {
        $this->send_repl_tbl_writeid_state($rqst);
        $this->recv_repl_tbl_writeid_state();
    }

    public function send_repl_tbl_writeid_state(\metastore\ReplTblWriteIdStateRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_repl_tbl_writeid_state_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'repl_tbl_writeid_state',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('repl_tbl_writeid_state', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_repl_tbl_writeid_state()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_repl_tbl_writeid_state_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_repl_tbl_writeid_state_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        return;
    }

    public function get_valid_write_ids(\metastore\GetValidWriteIdsRequest $rqst)
    {
        $this->send_get_valid_write_ids($rqst);
        return $this->recv_get_valid_write_ids();
    }

    public function send_get_valid_write_ids(\metastore\GetValidWriteIdsRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_get_valid_write_ids_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_valid_write_ids',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_valid_write_ids', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_valid_write_ids()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_valid_write_ids_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_valid_write_ids_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_valid_write_ids failed: unknown result");
    }

    public function allocate_table_write_ids(\metastore\AllocateTableWriteIdsRequest $rqst)
    {
        $this->send_allocate_table_write_ids($rqst);
        return $this->recv_allocate_table_write_ids();
    }

    public function send_allocate_table_write_ids(\metastore\AllocateTableWriteIdsRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_allocate_table_write_ids_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'allocate_table_write_ids',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('allocate_table_write_ids', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_allocate_table_write_ids()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_allocate_table_write_ids_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_allocate_table_write_ids_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("allocate_table_write_ids failed: unknown result");
    }

    public function get_max_allocated_table_write_id(\metastore\MaxAllocatedTableWriteIdRequest $rqst)
    {
        $this->send_get_max_allocated_table_write_id($rqst);
        return $this->recv_get_max_allocated_table_write_id();
    }

    public function send_get_max_allocated_table_write_id(\metastore\MaxAllocatedTableWriteIdRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_get_max_allocated_table_write_id_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_max_allocated_table_write_id',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_max_allocated_table_write_id', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_max_allocated_table_write_id()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_max_allocated_table_write_id_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_max_allocated_table_write_id_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_max_allocated_table_write_id failed: unknown result");
    }

    public function seed_write_id(\metastore\SeedTableWriteIdsRequest $rqst)
    {
        $this->send_seed_write_id($rqst);
        $this->recv_seed_write_id();
    }

    public function send_seed_write_id(\metastore\SeedTableWriteIdsRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_seed_write_id_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'seed_write_id',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('seed_write_id', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_seed_write_id()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_seed_write_id_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_seed_write_id_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        return;
    }

    public function seed_txn_id(\metastore\SeedTxnIdRequest $rqst)
    {
        $this->send_seed_txn_id($rqst);
        $this->recv_seed_txn_id();
    }

    public function send_seed_txn_id(\metastore\SeedTxnIdRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_seed_txn_id_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'seed_txn_id',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('seed_txn_id', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_seed_txn_id()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_seed_txn_id_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_seed_txn_id_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        return;
    }

    public function lock(\metastore\LockRequest $rqst)
    {
        $this->send_lock($rqst);
        return $this->recv_lock();
    }

    public function send_lock(\metastore\LockRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_lock_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'lock',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('lock', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_lock()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_lock_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_lock_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("lock failed: unknown result");
    }

    public function check_lock(\metastore\CheckLockRequest $rqst)
    {
        $this->send_check_lock($rqst);
        return $this->recv_check_lock();
    }

    public function send_check_lock(\metastore\CheckLockRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_check_lock_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'check_lock',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('check_lock', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_check_lock()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_check_lock_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_check_lock_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("check_lock failed: unknown result");
    }

    public function unlock(\metastore\UnlockRequest $rqst)
    {
        $this->send_unlock($rqst);
        $this->recv_unlock();
    }

    public function send_unlock(\metastore\UnlockRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_unlock_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'unlock',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('unlock', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_unlock()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_unlock_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_unlock_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function show_locks(\metastore\ShowLocksRequest $rqst)
    {
        $this->send_show_locks($rqst);
        return $this->recv_show_locks();
    }

    public function send_show_locks(\metastore\ShowLocksRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_show_locks_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'show_locks',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('show_locks', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_show_locks()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_show_locks_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_show_locks_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("show_locks failed: unknown result");
    }

    public function heartbeat(\metastore\HeartbeatRequest $ids)
    {
        $this->send_heartbeat($ids);
        $this->recv_heartbeat();
    }

    public function send_heartbeat(\metastore\HeartbeatRequest $ids)
    {
        $args = new \metastore\ThriftHiveMetastore_heartbeat_args();
        $args->ids = $ids;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'heartbeat',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('heartbeat', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_heartbeat()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_heartbeat_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_heartbeat_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function heartbeat_txn_range(\metastore\HeartbeatTxnRangeRequest $txns)
    {
        $this->send_heartbeat_txn_range($txns);
        return $this->recv_heartbeat_txn_range();
    }

    public function send_heartbeat_txn_range(\metastore\HeartbeatTxnRangeRequest $txns)
    {
        $args = new \metastore\ThriftHiveMetastore_heartbeat_txn_range_args();
        $args->txns = $txns;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'heartbeat_txn_range',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('heartbeat_txn_range', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_heartbeat_txn_range()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_heartbeat_txn_range_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_heartbeat_txn_range_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("heartbeat_txn_range failed: unknown result");
    }

    public function compact(\metastore\CompactionRequest $rqst)
    {
        $this->send_compact($rqst);
        $this->recv_compact();
    }

    public function send_compact(\metastore\CompactionRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_compact_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'compact',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('compact', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_compact()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_compact_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_compact_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        return;
    }

    public function compact2(\metastore\CompactionRequest $rqst)
    {
        $this->send_compact2($rqst);
        return $this->recv_compact2();
    }

    public function send_compact2(\metastore\CompactionRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_compact2_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'compact2',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('compact2', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_compact2()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_compact2_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_compact2_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("compact2 failed: unknown result");
    }

    public function show_compact(\metastore\ShowCompactRequest $rqst)
    {
        $this->send_show_compact($rqst);
        return $this->recv_show_compact();
    }

    public function send_show_compact(\metastore\ShowCompactRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_show_compact_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'show_compact',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('show_compact', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_show_compact()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_show_compact_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_show_compact_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("show_compact failed: unknown result");
    }

    public function add_dynamic_partitions(\metastore\AddDynamicPartitions $rqst)
    {
        $this->send_add_dynamic_partitions($rqst);
        $this->recv_add_dynamic_partitions();
    }

    public function send_add_dynamic_partitions(\metastore\AddDynamicPartitions $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_add_dynamic_partitions_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_dynamic_partitions',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_dynamic_partitions', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_dynamic_partitions()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_dynamic_partitions_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_dynamic_partitions_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function find_next_compact($workerId, $workerVersion)
    {
        $this->send_find_next_compact($workerId, $workerVersion);
        return $this->recv_find_next_compact();
    }

    public function send_find_next_compact($workerId, $workerVersion)
    {
        $args = new \metastore\ThriftHiveMetastore_find_next_compact_args();
        $args->workerId = $workerId;
        $args->workerVersion = $workerVersion;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'find_next_compact',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('find_next_compact', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_find_next_compact()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_find_next_compact_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_find_next_compact_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("find_next_compact failed: unknown result");
    }

    public function update_compactor_state(\metastore\CompactionInfoStruct $cr, $txn_id)
    {
        $this->send_update_compactor_state($cr, $txn_id);
        $this->recv_update_compactor_state();
    }

    public function send_update_compactor_state(\metastore\CompactionInfoStruct $cr, $txn_id)
    {
        $args = new \metastore\ThriftHiveMetastore_update_compactor_state_args();
        $args->cr = $cr;
        $args->txn_id = $txn_id;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'update_compactor_state',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('update_compactor_state', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_update_compactor_state()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_update_compactor_state_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_update_compactor_state_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        return;
    }

    public function find_columns_with_stats(\metastore\CompactionInfoStruct $cr)
    {
        $this->send_find_columns_with_stats($cr);
        return $this->recv_find_columns_with_stats();
    }

    public function send_find_columns_with_stats(\metastore\CompactionInfoStruct $cr)
    {
        $args = new \metastore\ThriftHiveMetastore_find_columns_with_stats_args();
        $args->cr = $cr;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'find_columns_with_stats',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('find_columns_with_stats', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_find_columns_with_stats()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_find_columns_with_stats_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_find_columns_with_stats_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("find_columns_with_stats failed: unknown result");
    }

    public function mark_cleaned(\metastore\CompactionInfoStruct $cr)
    {
        $this->send_mark_cleaned($cr);
        $this->recv_mark_cleaned();
    }

    public function send_mark_cleaned(\metastore\CompactionInfoStruct $cr)
    {
        $args = new \metastore\ThriftHiveMetastore_mark_cleaned_args();
        $args->cr = $cr;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'mark_cleaned',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('mark_cleaned', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_mark_cleaned()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_mark_cleaned_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_mark_cleaned_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        return;
    }

    public function mark_compacted(\metastore\CompactionInfoStruct $cr)
    {
        $this->send_mark_compacted($cr);
        $this->recv_mark_compacted();
    }

    public function send_mark_compacted(\metastore\CompactionInfoStruct $cr)
    {
        $args = new \metastore\ThriftHiveMetastore_mark_compacted_args();
        $args->cr = $cr;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'mark_compacted',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('mark_compacted', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_mark_compacted()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_mark_compacted_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_mark_compacted_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        return;
    }

    public function mark_failed(\metastore\CompactionInfoStruct $cr)
    {
        $this->send_mark_failed($cr);
        $this->recv_mark_failed();
    }

    public function send_mark_failed(\metastore\CompactionInfoStruct $cr)
    {
        $args = new \metastore\ThriftHiveMetastore_mark_failed_args();
        $args->cr = $cr;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'mark_failed',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('mark_failed', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_mark_failed()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_mark_failed_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_mark_failed_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        return;
    }

    public function set_hadoop_jobid($jobId, $cq_id)
    {
        $this->send_set_hadoop_jobid($jobId, $cq_id);
        $this->recv_set_hadoop_jobid();
    }

    public function send_set_hadoop_jobid($jobId, $cq_id)
    {
        $args = new \metastore\ThriftHiveMetastore_set_hadoop_jobid_args();
        $args->jobId = $jobId;
        $args->cq_id = $cq_id;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'set_hadoop_jobid',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('set_hadoop_jobid', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_set_hadoop_jobid()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_set_hadoop_jobid_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_set_hadoop_jobid_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        return;
    }

    public function get_latest_committed_compaction_info(\metastore\GetLatestCommittedCompactionInfoRequest $rqst)
    {
        $this->send_get_latest_committed_compaction_info($rqst);
        return $this->recv_get_latest_committed_compaction_info();
    }

    public function send_get_latest_committed_compaction_info(\metastore\GetLatestCommittedCompactionInfoRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_get_latest_committed_compaction_info_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_latest_committed_compaction_info',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_latest_committed_compaction_info', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_latest_committed_compaction_info()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_latest_committed_compaction_info_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_latest_committed_compaction_info_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_latest_committed_compaction_info failed: unknown result");
    }

    public function get_next_notification(\metastore\NotificationEventRequest $rqst)
    {
        $this->send_get_next_notification($rqst);
        return $this->recv_get_next_notification();
    }

    public function send_get_next_notification(\metastore\NotificationEventRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_get_next_notification_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_next_notification',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_next_notification', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_next_notification()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_next_notification_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_next_notification_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_next_notification failed: unknown result");
    }

    public function get_current_notificationEventId()
    {
        $this->send_get_current_notificationEventId();
        return $this->recv_get_current_notificationEventId();
    }

    public function send_get_current_notificationEventId()
    {
        $args = new \metastore\ThriftHiveMetastore_get_current_notificationEventId_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_current_notificationEventId',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_current_notificationEventId', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_current_notificationEventId()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_current_notificationEventId_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_current_notificationEventId_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_current_notificationEventId failed: unknown result");
    }

    public function get_notification_events_count(\metastore\NotificationEventsCountRequest $rqst)
    {
        $this->send_get_notification_events_count($rqst);
        return $this->recv_get_notification_events_count();
    }

    public function send_get_notification_events_count(\metastore\NotificationEventsCountRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_get_notification_events_count_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_notification_events_count',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_notification_events_count', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_notification_events_count()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_notification_events_count_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_notification_events_count_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_notification_events_count failed: unknown result");
    }

    public function fire_listener_event(\metastore\FireEventRequest $rqst)
    {
        $this->send_fire_listener_event($rqst);
        return $this->recv_fire_listener_event();
    }

    public function send_fire_listener_event(\metastore\FireEventRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_fire_listener_event_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'fire_listener_event',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('fire_listener_event', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_fire_listener_event()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_fire_listener_event_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_fire_listener_event_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("fire_listener_event failed: unknown result");
    }

    public function flushCache()
    {
        $this->send_flushCache();
        $this->recv_flushCache();
    }

    public function send_flushCache()
    {
        $args = new \metastore\ThriftHiveMetastore_flushCache_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'flushCache',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('flushCache', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_flushCache()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_flushCache_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_flushCache_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        return;
    }

    public function add_write_notification_log(\metastore\WriteNotificationLogRequest $rqst)
    {
        $this->send_add_write_notification_log($rqst);
        return $this->recv_add_write_notification_log();
    }

    public function send_add_write_notification_log(\metastore\WriteNotificationLogRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_add_write_notification_log_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_write_notification_log',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_write_notification_log', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_write_notification_log()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_write_notification_log_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_write_notification_log_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("add_write_notification_log failed: unknown result");
    }

    public function cm_recycle(\metastore\CmRecycleRequest $request)
    {
        $this->send_cm_recycle($request);
        return $this->recv_cm_recycle();
    }

    public function send_cm_recycle(\metastore\CmRecycleRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_cm_recycle_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'cm_recycle',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('cm_recycle', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_cm_recycle()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_cm_recycle_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_cm_recycle_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("cm_recycle failed: unknown result");
    }

    public function get_file_metadata_by_expr(\metastore\GetFileMetadataByExprRequest $req)
    {
        $this->send_get_file_metadata_by_expr($req);
        return $this->recv_get_file_metadata_by_expr();
    }

    public function send_get_file_metadata_by_expr(\metastore\GetFileMetadataByExprRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_get_file_metadata_by_expr_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_file_metadata_by_expr',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_file_metadata_by_expr', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_file_metadata_by_expr()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_file_metadata_by_expr_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_file_metadata_by_expr_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_file_metadata_by_expr failed: unknown result");
    }

    public function get_file_metadata(\metastore\GetFileMetadataRequest $req)
    {
        $this->send_get_file_metadata($req);
        return $this->recv_get_file_metadata();
    }

    public function send_get_file_metadata(\metastore\GetFileMetadataRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_get_file_metadata_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_file_metadata',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_file_metadata', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_file_metadata()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_file_metadata_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_file_metadata_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_file_metadata failed: unknown result");
    }

    public function put_file_metadata(\metastore\PutFileMetadataRequest $req)
    {
        $this->send_put_file_metadata($req);
        return $this->recv_put_file_metadata();
    }

    public function send_put_file_metadata(\metastore\PutFileMetadataRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_put_file_metadata_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'put_file_metadata',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('put_file_metadata', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_put_file_metadata()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_put_file_metadata_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_put_file_metadata_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("put_file_metadata failed: unknown result");
    }

    public function clear_file_metadata(\metastore\ClearFileMetadataRequest $req)
    {
        $this->send_clear_file_metadata($req);
        return $this->recv_clear_file_metadata();
    }

    public function send_clear_file_metadata(\metastore\ClearFileMetadataRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_clear_file_metadata_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'clear_file_metadata',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('clear_file_metadata', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_clear_file_metadata()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_clear_file_metadata_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_clear_file_metadata_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("clear_file_metadata failed: unknown result");
    }

    public function cache_file_metadata(\metastore\CacheFileMetadataRequest $req)
    {
        $this->send_cache_file_metadata($req);
        return $this->recv_cache_file_metadata();
    }

    public function send_cache_file_metadata(\metastore\CacheFileMetadataRequest $req)
    {
        $args = new \metastore\ThriftHiveMetastore_cache_file_metadata_args();
        $args->req = $req;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'cache_file_metadata',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('cache_file_metadata', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_cache_file_metadata()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_cache_file_metadata_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_cache_file_metadata_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("cache_file_metadata failed: unknown result");
    }

    public function get_metastore_db_uuid()
    {
        $this->send_get_metastore_db_uuid();
        return $this->recv_get_metastore_db_uuid();
    }

    public function send_get_metastore_db_uuid()
    {
        $args = new \metastore\ThriftHiveMetastore_get_metastore_db_uuid_args();
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_metastore_db_uuid',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_metastore_db_uuid', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_metastore_db_uuid()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_metastore_db_uuid_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_metastore_db_uuid_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_metastore_db_uuid failed: unknown result");
    }

    public function create_resource_plan(\metastore\WMCreateResourcePlanRequest $request)
    {
        $this->send_create_resource_plan($request);
        return $this->recv_create_resource_plan();
    }

    public function send_create_resource_plan(\metastore\WMCreateResourcePlanRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_create_resource_plan_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_resource_plan',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_resource_plan', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_resource_plan()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_resource_plan_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_resource_plan_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("create_resource_plan failed: unknown result");
    }

    public function get_resource_plan(\metastore\WMGetResourcePlanRequest $request)
    {
        $this->send_get_resource_plan($request);
        return $this->recv_get_resource_plan();
    }

    public function send_get_resource_plan(\metastore\WMGetResourcePlanRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_resource_plan_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_resource_plan',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_resource_plan', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_resource_plan()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_resource_plan_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_resource_plan_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_resource_plan failed: unknown result");
    }

    public function get_active_resource_plan(\metastore\WMGetActiveResourcePlanRequest $request)
    {
        $this->send_get_active_resource_plan($request);
        return $this->recv_get_active_resource_plan();
    }

    public function send_get_active_resource_plan(\metastore\WMGetActiveResourcePlanRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_active_resource_plan_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_active_resource_plan',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_active_resource_plan', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_active_resource_plan()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_active_resource_plan_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_active_resource_plan_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_active_resource_plan failed: unknown result");
    }

    public function get_all_resource_plans(\metastore\WMGetAllResourcePlanRequest $request)
    {
        $this->send_get_all_resource_plans($request);
        return $this->recv_get_all_resource_plans();
    }

    public function send_get_all_resource_plans(\metastore\WMGetAllResourcePlanRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_all_resource_plans_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_all_resource_plans',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_all_resource_plans', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_all_resource_plans()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_all_resource_plans_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_all_resource_plans_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_all_resource_plans failed: unknown result");
    }

    public function alter_resource_plan(\metastore\WMAlterResourcePlanRequest $request)
    {
        $this->send_alter_resource_plan($request);
        return $this->recv_alter_resource_plan();
    }

    public function send_alter_resource_plan(\metastore\WMAlterResourcePlanRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_resource_plan_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_resource_plan',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_resource_plan', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_resource_plan()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_resource_plan_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_resource_plan_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("alter_resource_plan failed: unknown result");
    }

    public function validate_resource_plan(\metastore\WMValidateResourcePlanRequest $request)
    {
        $this->send_validate_resource_plan($request);
        return $this->recv_validate_resource_plan();
    }

    public function send_validate_resource_plan(\metastore\WMValidateResourcePlanRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_validate_resource_plan_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'validate_resource_plan',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('validate_resource_plan', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_validate_resource_plan()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_validate_resource_plan_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_validate_resource_plan_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("validate_resource_plan failed: unknown result");
    }

    public function drop_resource_plan(\metastore\WMDropResourcePlanRequest $request)
    {
        $this->send_drop_resource_plan($request);
        return $this->recv_drop_resource_plan();
    }

    public function send_drop_resource_plan(\metastore\WMDropResourcePlanRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_resource_plan_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_resource_plan',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_resource_plan', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_resource_plan()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_resource_plan_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_resource_plan_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("drop_resource_plan failed: unknown result");
    }

    public function create_wm_trigger(\metastore\WMCreateTriggerRequest $request)
    {
        $this->send_create_wm_trigger($request);
        return $this->recv_create_wm_trigger();
    }

    public function send_create_wm_trigger(\metastore\WMCreateTriggerRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_create_wm_trigger_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_wm_trigger',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_wm_trigger', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_wm_trigger()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_wm_trigger_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_wm_trigger_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("create_wm_trigger failed: unknown result");
    }

    public function alter_wm_trigger(\metastore\WMAlterTriggerRequest $request)
    {
        $this->send_alter_wm_trigger($request);
        return $this->recv_alter_wm_trigger();
    }

    public function send_alter_wm_trigger(\metastore\WMAlterTriggerRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_wm_trigger_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_wm_trigger',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_wm_trigger', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_wm_trigger()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_wm_trigger_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_wm_trigger_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("alter_wm_trigger failed: unknown result");
    }

    public function drop_wm_trigger(\metastore\WMDropTriggerRequest $request)
    {
        $this->send_drop_wm_trigger($request);
        return $this->recv_drop_wm_trigger();
    }

    public function send_drop_wm_trigger(\metastore\WMDropTriggerRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_wm_trigger_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_wm_trigger',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_wm_trigger', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_wm_trigger()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_wm_trigger_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_wm_trigger_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("drop_wm_trigger failed: unknown result");
    }

    public function get_triggers_for_resourceplan(\metastore\WMGetTriggersForResourePlanRequest $request)
    {
        $this->send_get_triggers_for_resourceplan($request);
        return $this->recv_get_triggers_for_resourceplan();
    }

    public function send_get_triggers_for_resourceplan(\metastore\WMGetTriggersForResourePlanRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_triggers_for_resourceplan_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_triggers_for_resourceplan',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_triggers_for_resourceplan', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_triggers_for_resourceplan()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_triggers_for_resourceplan_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_triggers_for_resourceplan_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_triggers_for_resourceplan failed: unknown result");
    }

    public function create_wm_pool(\metastore\WMCreatePoolRequest $request)
    {
        $this->send_create_wm_pool($request);
        return $this->recv_create_wm_pool();
    }

    public function send_create_wm_pool(\metastore\WMCreatePoolRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_create_wm_pool_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_wm_pool',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_wm_pool', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_wm_pool()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_wm_pool_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_wm_pool_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("create_wm_pool failed: unknown result");
    }

    public function alter_wm_pool(\metastore\WMAlterPoolRequest $request)
    {
        $this->send_alter_wm_pool($request);
        return $this->recv_alter_wm_pool();
    }

    public function send_alter_wm_pool(\metastore\WMAlterPoolRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_wm_pool_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_wm_pool',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_wm_pool', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_wm_pool()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_wm_pool_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_wm_pool_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("alter_wm_pool failed: unknown result");
    }

    public function drop_wm_pool(\metastore\WMDropPoolRequest $request)
    {
        $this->send_drop_wm_pool($request);
        return $this->recv_drop_wm_pool();
    }

    public function send_drop_wm_pool(\metastore\WMDropPoolRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_wm_pool_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_wm_pool',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_wm_pool', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_wm_pool()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_wm_pool_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_wm_pool_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("drop_wm_pool failed: unknown result");
    }

    public function create_or_update_wm_mapping(\metastore\WMCreateOrUpdateMappingRequest $request)
    {
        $this->send_create_or_update_wm_mapping($request);
        return $this->recv_create_or_update_wm_mapping();
    }

    public function send_create_or_update_wm_mapping(\metastore\WMCreateOrUpdateMappingRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_create_or_update_wm_mapping_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_or_update_wm_mapping',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_or_update_wm_mapping', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_or_update_wm_mapping()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_or_update_wm_mapping_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_or_update_wm_mapping_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("create_or_update_wm_mapping failed: unknown result");
    }

    public function drop_wm_mapping(\metastore\WMDropMappingRequest $request)
    {
        $this->send_drop_wm_mapping($request);
        return $this->recv_drop_wm_mapping();
    }

    public function send_drop_wm_mapping(\metastore\WMDropMappingRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_wm_mapping_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_wm_mapping',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_wm_mapping', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_wm_mapping()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_wm_mapping_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_wm_mapping_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        throw new \Exception("drop_wm_mapping failed: unknown result");
    }

    public function create_or_drop_wm_trigger_to_pool_mapping(\metastore\WMCreateOrDropTriggerToPoolMappingRequest $request)
    {
        $this->send_create_or_drop_wm_trigger_to_pool_mapping($request);
        return $this->recv_create_or_drop_wm_trigger_to_pool_mapping();
    }

    public function send_create_or_drop_wm_trigger_to_pool_mapping(\metastore\WMCreateOrDropTriggerToPoolMappingRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_create_or_drop_wm_trigger_to_pool_mapping_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_or_drop_wm_trigger_to_pool_mapping',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_or_drop_wm_trigger_to_pool_mapping', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_or_drop_wm_trigger_to_pool_mapping()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_or_drop_wm_trigger_to_pool_mapping_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_or_drop_wm_trigger_to_pool_mapping_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        throw new \Exception("create_or_drop_wm_trigger_to_pool_mapping failed: unknown result");
    }

    public function create_ischema(\metastore\ISchema $schema)
    {
        $this->send_create_ischema($schema);
        $this->recv_create_ischema();
    }

    public function send_create_ischema(\metastore\ISchema $schema)
    {
        $args = new \metastore\ThriftHiveMetastore_create_ischema_args();
        $args->schema = $schema;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_ischema',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_ischema', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_ischema()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_ischema_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_ischema_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function alter_ischema(\metastore\AlterISchemaRequest $rqst)
    {
        $this->send_alter_ischema($rqst);
        $this->recv_alter_ischema();
    }

    public function send_alter_ischema(\metastore\AlterISchemaRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_alter_ischema_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'alter_ischema',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('alter_ischema', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_alter_ischema()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_alter_ischema_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_alter_ischema_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function get_ischema(\metastore\ISchemaName $name)
    {
        $this->send_get_ischema($name);
        return $this->recv_get_ischema();
    }

    public function send_get_ischema(\metastore\ISchemaName $name)
    {
        $args = new \metastore\ThriftHiveMetastore_get_ischema_args();
        $args->name = $name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_ischema',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_ischema', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_ischema()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_ischema_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_ischema_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_ischema failed: unknown result");
    }

    public function drop_ischema(\metastore\ISchemaName $name)
    {
        $this->send_drop_ischema($name);
        $this->recv_drop_ischema();
    }

    public function send_drop_ischema(\metastore\ISchemaName $name)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_ischema_args();
        $args->name = $name;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_ischema',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_ischema', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_ischema()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_ischema_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_ischema_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function add_schema_version(\metastore\SchemaVersion $schemaVersion)
    {
        $this->send_add_schema_version($schemaVersion);
        $this->recv_add_schema_version();
    }

    public function send_add_schema_version(\metastore\SchemaVersion $schemaVersion)
    {
        $args = new \metastore\ThriftHiveMetastore_add_schema_version_args();
        $args->schemaVersion = $schemaVersion;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_schema_version',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_schema_version', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_schema_version()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_schema_version_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_schema_version_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function get_schema_version(\metastore\SchemaVersionDescriptor $schemaVersion)
    {
        $this->send_get_schema_version($schemaVersion);
        return $this->recv_get_schema_version();
    }

    public function send_get_schema_version(\metastore\SchemaVersionDescriptor $schemaVersion)
    {
        $args = new \metastore\ThriftHiveMetastore_get_schema_version_args();
        $args->schemaVersion = $schemaVersion;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_schema_version',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_schema_version', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_schema_version()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_schema_version_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_schema_version_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_schema_version failed: unknown result");
    }

    public function get_schema_latest_version(\metastore\ISchemaName $schemaName)
    {
        $this->send_get_schema_latest_version($schemaName);
        return $this->recv_get_schema_latest_version();
    }

    public function send_get_schema_latest_version(\metastore\ISchemaName $schemaName)
    {
        $args = new \metastore\ThriftHiveMetastore_get_schema_latest_version_args();
        $args->schemaName = $schemaName;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_schema_latest_version',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_schema_latest_version', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_schema_latest_version()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_schema_latest_version_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_schema_latest_version_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_schema_latest_version failed: unknown result");
    }

    public function get_schema_all_versions(\metastore\ISchemaName $schemaName)
    {
        $this->send_get_schema_all_versions($schemaName);
        return $this->recv_get_schema_all_versions();
    }

    public function send_get_schema_all_versions(\metastore\ISchemaName $schemaName)
    {
        $args = new \metastore\ThriftHiveMetastore_get_schema_all_versions_args();
        $args->schemaName = $schemaName;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_schema_all_versions',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_schema_all_versions', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_schema_all_versions()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_schema_all_versions_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_schema_all_versions_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_schema_all_versions failed: unknown result");
    }

    public function drop_schema_version(\metastore\SchemaVersionDescriptor $schemaVersion)
    {
        $this->send_drop_schema_version($schemaVersion);
        $this->recv_drop_schema_version();
    }

    public function send_drop_schema_version(\metastore\SchemaVersionDescriptor $schemaVersion)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_schema_version_args();
        $args->schemaVersion = $schemaVersion;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_schema_version',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_schema_version', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_schema_version()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_schema_version_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_schema_version_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function get_schemas_by_cols(\metastore\FindSchemasByColsRqst $rqst)
    {
        $this->send_get_schemas_by_cols($rqst);
        return $this->recv_get_schemas_by_cols();
    }

    public function send_get_schemas_by_cols(\metastore\FindSchemasByColsRqst $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_get_schemas_by_cols_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_schemas_by_cols',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_schemas_by_cols', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_schemas_by_cols()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_schemas_by_cols_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_schemas_by_cols_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_schemas_by_cols failed: unknown result");
    }

    public function map_schema_version_to_serde(\metastore\MapSchemaVersionToSerdeRequest $rqst)
    {
        $this->send_map_schema_version_to_serde($rqst);
        $this->recv_map_schema_version_to_serde();
    }

    public function send_map_schema_version_to_serde(\metastore\MapSchemaVersionToSerdeRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_map_schema_version_to_serde_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'map_schema_version_to_serde',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('map_schema_version_to_serde', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_map_schema_version_to_serde()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_map_schema_version_to_serde_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_map_schema_version_to_serde_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function set_schema_version_state(\metastore\SetSchemaVersionStateRequest $rqst)
    {
        $this->send_set_schema_version_state($rqst);
        $this->recv_set_schema_version_state();
    }

    public function send_set_schema_version_state(\metastore\SetSchemaVersionStateRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_set_schema_version_state_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'set_schema_version_state',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('set_schema_version_state', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_set_schema_version_state()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_set_schema_version_state_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_set_schema_version_state_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        return;
    }

    public function add_serde(\metastore\SerDeInfo $serde)
    {
        $this->send_add_serde($serde);
        $this->recv_add_serde();
    }

    public function send_add_serde(\metastore\SerDeInfo $serde)
    {
        $args = new \metastore\ThriftHiveMetastore_add_serde_args();
        $args->serde = $serde;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_serde',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_serde', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_serde()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_serde_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_serde_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function get_serde(\metastore\GetSerdeRequest $rqst)
    {
        $this->send_get_serde($rqst);
        return $this->recv_get_serde();
    }

    public function send_get_serde(\metastore\GetSerdeRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_get_serde_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_serde',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_serde', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_serde()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_serde_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_serde_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_serde failed: unknown result");
    }

    public function get_lock_materialization_rebuild($dbName, $tableName, $txnId)
    {
        $this->send_get_lock_materialization_rebuild($dbName, $tableName, $txnId);
        return $this->recv_get_lock_materialization_rebuild();
    }

    public function send_get_lock_materialization_rebuild($dbName, $tableName, $txnId)
    {
        $args = new \metastore\ThriftHiveMetastore_get_lock_materialization_rebuild_args();
        $args->dbName = $dbName;
        $args->tableName = $tableName;
        $args->txnId = $txnId;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_lock_materialization_rebuild',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_lock_materialization_rebuild', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_lock_materialization_rebuild()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_lock_materialization_rebuild_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_lock_materialization_rebuild_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_lock_materialization_rebuild failed: unknown result");
    }

    public function heartbeat_lock_materialization_rebuild($dbName, $tableName, $txnId)
    {
        $this->send_heartbeat_lock_materialization_rebuild($dbName, $tableName, $txnId);
        return $this->recv_heartbeat_lock_materialization_rebuild();
    }

    public function send_heartbeat_lock_materialization_rebuild($dbName, $tableName, $txnId)
    {
        $args = new \metastore\ThriftHiveMetastore_heartbeat_lock_materialization_rebuild_args();
        $args->dbName = $dbName;
        $args->tableName = $tableName;
        $args->txnId = $txnId;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'heartbeat_lock_materialization_rebuild',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('heartbeat_lock_materialization_rebuild', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_heartbeat_lock_materialization_rebuild()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_heartbeat_lock_materialization_rebuild_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_heartbeat_lock_materialization_rebuild_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("heartbeat_lock_materialization_rebuild failed: unknown result");
    }

    public function add_runtime_stats(\metastore\RuntimeStat $stat)
    {
        $this->send_add_runtime_stats($stat);
        $this->recv_add_runtime_stats();
    }

    public function send_add_runtime_stats(\metastore\RuntimeStat $stat)
    {
        $args = new \metastore\ThriftHiveMetastore_add_runtime_stats_args();
        $args->stat = $stat;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_runtime_stats',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_runtime_stats', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_runtime_stats()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_runtime_stats_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_runtime_stats_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        return;
    }

    public function get_runtime_stats(\metastore\GetRuntimeStatsRequest $rqst)
    {
        $this->send_get_runtime_stats($rqst);
        return $this->recv_get_runtime_stats();
    }

    public function send_get_runtime_stats(\metastore\GetRuntimeStatsRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_get_runtime_stats_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_runtime_stats',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_runtime_stats', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_runtime_stats()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_runtime_stats_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_runtime_stats_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_runtime_stats failed: unknown result");
    }

    public function get_partitions_with_specs(\metastore\GetPartitionsRequest $request)
    {
        $this->send_get_partitions_with_specs($request);
        return $this->recv_get_partitions_with_specs();
    }

    public function send_get_partitions_with_specs(\metastore\GetPartitionsRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_partitions_with_specs_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_partitions_with_specs',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_partitions_with_specs', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_partitions_with_specs()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_partitions_with_specs_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_partitions_with_specs_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_partitions_with_specs failed: unknown result");
    }

    public function scheduled_query_poll(\metastore\ScheduledQueryPollRequest $request)
    {
        $this->send_scheduled_query_poll($request);
        return $this->recv_scheduled_query_poll();
    }

    public function send_scheduled_query_poll(\metastore\ScheduledQueryPollRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_scheduled_query_poll_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'scheduled_query_poll',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('scheduled_query_poll', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_scheduled_query_poll()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_scheduled_query_poll_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_scheduled_query_poll_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("scheduled_query_poll failed: unknown result");
    }

    public function scheduled_query_maintenance(\metastore\ScheduledQueryMaintenanceRequest $request)
    {
        $this->send_scheduled_query_maintenance($request);
        $this->recv_scheduled_query_maintenance();
    }

    public function send_scheduled_query_maintenance(\metastore\ScheduledQueryMaintenanceRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_scheduled_query_maintenance_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'scheduled_query_maintenance',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('scheduled_query_maintenance', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_scheduled_query_maintenance()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_scheduled_query_maintenance_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_scheduled_query_maintenance_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        if ($result->o3 !== null) {
            throw $result->o3;
        }
        if ($result->o4 !== null) {
            throw $result->o4;
        }
        return;
    }

    public function scheduled_query_progress(\metastore\ScheduledQueryProgressInfo $info)
    {
        $this->send_scheduled_query_progress($info);
        $this->recv_scheduled_query_progress();
    }

    public function send_scheduled_query_progress(\metastore\ScheduledQueryProgressInfo $info)
    {
        $args = new \metastore\ThriftHiveMetastore_scheduled_query_progress_args();
        $args->info = $info;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'scheduled_query_progress',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('scheduled_query_progress', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_scheduled_query_progress()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_scheduled_query_progress_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_scheduled_query_progress_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function get_scheduled_query(\metastore\ScheduledQueryKey $scheduleKey)
    {
        $this->send_get_scheduled_query($scheduleKey);
        return $this->recv_get_scheduled_query();
    }

    public function send_get_scheduled_query(\metastore\ScheduledQueryKey $scheduleKey)
    {
        $args = new \metastore\ThriftHiveMetastore_get_scheduled_query_args();
        $args->scheduleKey = $scheduleKey;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_scheduled_query',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_scheduled_query', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_scheduled_query()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_scheduled_query_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_scheduled_query_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_scheduled_query failed: unknown result");
    }

    public function add_replication_metrics(\metastore\ReplicationMetricList $replicationMetricList)
    {
        $this->send_add_replication_metrics($replicationMetricList);
        $this->recv_add_replication_metrics();
    }

    public function send_add_replication_metrics(\metastore\ReplicationMetricList $replicationMetricList)
    {
        $args = new \metastore\ThriftHiveMetastore_add_replication_metrics_args();
        $args->replicationMetricList = $replicationMetricList;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_replication_metrics',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_replication_metrics', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_replication_metrics()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_replication_metrics_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_replication_metrics_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        return;
    }

    public function get_replication_metrics(\metastore\GetReplicationMetricsRequest $rqst)
    {
        $this->send_get_replication_metrics($rqst);
        return $this->recv_get_replication_metrics();
    }

    public function send_get_replication_metrics(\metastore\GetReplicationMetricsRequest $rqst)
    {
        $args = new \metastore\ThriftHiveMetastore_get_replication_metrics_args();
        $args->rqst = $rqst;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_replication_metrics',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_replication_metrics', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_replication_metrics()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_replication_metrics_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_replication_metrics_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_replication_metrics failed: unknown result");
    }

    public function get_open_txns_req(\metastore\GetOpenTxnsRequest $getOpenTxnsRequest)
    {
        $this->send_get_open_txns_req($getOpenTxnsRequest);
        return $this->recv_get_open_txns_req();
    }

    public function send_get_open_txns_req(\metastore\GetOpenTxnsRequest $getOpenTxnsRequest)
    {
        $args = new \metastore\ThriftHiveMetastore_get_open_txns_req_args();
        $args->getOpenTxnsRequest = $getOpenTxnsRequest;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_open_txns_req',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_open_txns_req', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_open_txns_req()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_open_txns_req_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_open_txns_req_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        throw new \Exception("get_open_txns_req failed: unknown result");
    }

    public function create_stored_procedure(\metastore\StoredProcedure $proc)
    {
        $this->send_create_stored_procedure($proc);
        $this->recv_create_stored_procedure();
    }

    public function send_create_stored_procedure(\metastore\StoredProcedure $proc)
    {
        $args = new \metastore\ThriftHiveMetastore_create_stored_procedure_args();
        $args->proc = $proc;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'create_stored_procedure',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('create_stored_procedure', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_create_stored_procedure()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_create_stored_procedure_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_create_stored_procedure_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        return;
    }

    public function get_stored_procedure(\metastore\StoredProcedureRequest $request)
    {
        $this->send_get_stored_procedure($request);
        return $this->recv_get_stored_procedure();
    }

    public function send_get_stored_procedure(\metastore\StoredProcedureRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_stored_procedure_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_stored_procedure',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_stored_procedure', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_stored_procedure()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_stored_procedure_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_stored_procedure_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("get_stored_procedure failed: unknown result");
    }

    public function drop_stored_procedure(\metastore\StoredProcedureRequest $request)
    {
        $this->send_drop_stored_procedure($request);
        $this->recv_drop_stored_procedure();
    }

    public function send_drop_stored_procedure(\metastore\StoredProcedureRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_stored_procedure_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_stored_procedure',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_stored_procedure', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_stored_procedure()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_stored_procedure_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_stored_procedure_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        return;
    }

    public function get_all_stored_procedures(\metastore\ListStoredProcedureRequest $request)
    {
        $this->send_get_all_stored_procedures($request);
        return $this->recv_get_all_stored_procedures();
    }

    public function send_get_all_stored_procedures(\metastore\ListStoredProcedureRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_all_stored_procedures_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_all_stored_procedures',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_all_stored_procedures', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_all_stored_procedures()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_all_stored_procedures_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_all_stored_procedures_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_all_stored_procedures failed: unknown result");
    }

    public function find_package(\metastore\GetPackageRequest $request)
    {
        $this->send_find_package($request);
        return $this->recv_find_package();
    }

    public function send_find_package(\metastore\GetPackageRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_find_package_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'find_package',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('find_package', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_find_package()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_find_package_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_find_package_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        if ($result->o2 !== null) {
            throw $result->o2;
        }
        throw new \Exception("find_package failed: unknown result");
    }

    public function add_package(\metastore\AddPackageRequest $request)
    {
        $this->send_add_package($request);
        $this->recv_add_package();
    }

    public function send_add_package(\metastore\AddPackageRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_add_package_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'add_package',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('add_package', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_add_package()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_add_package_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_add_package_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        return;
    }

    public function get_all_packages(\metastore\ListPackageRequest $request)
    {
        $this->send_get_all_packages($request);
        return $this->recv_get_all_packages();
    }

    public function send_get_all_packages(\metastore\ListPackageRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_get_all_packages_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'get_all_packages',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('get_all_packages', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_get_all_packages()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_get_all_packages_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_get_all_packages_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->success !== null) {
            return $result->success;
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        throw new \Exception("get_all_packages failed: unknown result");
    }

    public function drop_package(\metastore\DropPackageRequest $request)
    {
        $this->send_drop_package($request);
        $this->recv_drop_package();
    }

    public function send_drop_package(\metastore\DropPackageRequest $request)
    {
        $args = new \metastore\ThriftHiveMetastore_drop_package_args();
        $args->request = $request;
        $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
        if ($bin_accel) {
            thrift_protocol_write_binary(
                $this->output_,
                'drop_package',
                TMessageType::CALL,
                $args,
                $this->seqid_,
                $this->output_->isStrictWrite()
            );
        } else {
            $this->output_->writeMessageBegin('drop_package', TMessageType::CALL, $this->seqid_);
            $args->write($this->output_);
            $this->output_->writeMessageEnd();
            $this->output_->getTransport()->flush();
        }
    }

    public function recv_drop_package()
    {
        $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
        if ($bin_accel) {
            $result = thrift_protocol_read_binary(
                $this->input_,
                '\metastore\ThriftHiveMetastore_drop_package_result',
                $this->input_->isStrictRead()
            );
        } else {
            $rseqid = 0;
            $fname = null;
            $mtype = 0;

            $this->input_->readMessageBegin($fname, $mtype, $rseqid);
            if ($mtype == TMessageType::EXCEPTION) {
                $x = new TApplicationException();
                $x->read($this->input_);
                $this->input_->readMessageEnd();
                throw $x;
            }
            $result = new \metastore\ThriftHiveMetastore_drop_package_result();
            $result->read($this->input_);
            $this->input_->readMessageEnd();
        }
        if ($result->o1 !== null) {
            throw $result->o1;
        }
        return;
    }
}
