#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require 'fb303_types'


module HiveObjectType
  GLOBAL = 1
  DATABASE = 2
  TABLE = 3
  PARTITION = 4
  COLUMN = 5
  VALUE_MAP = {1 => "GLOBAL", 2 => "DATABASE", 3 => "TABLE", 4 => "PARTITION", 5 => "COLUMN"}
  VALID_VALUES = Set.new([GLOBAL, DATABASE, TABLE, PARTITION, COLUMN]).freeze
end

module PrincipalType
  USER = 1
  ROLE = 2
  GROUP = 3
  VALUE_MAP = {1 => "USER", 2 => "ROLE", 3 => "GROUP"}
  VALID_VALUES = Set.new([USER, ROLE, GROUP]).freeze
end

module PartitionEventType
  LOAD_DONE = 1
  VALUE_MAP = {1 => "LOAD_DONE"}
  VALID_VALUES = Set.new([LOAD_DONE]).freeze
end

module TxnState
  COMMITTED = 1
  ABORTED = 2
  OPEN = 3
  VALUE_MAP = {1 => "COMMITTED", 2 => "ABORTED", 3 => "OPEN"}
  VALID_VALUES = Set.new([COMMITTED, ABORTED, OPEN]).freeze
end

module LockLevel
  DB = 1
  TABLE = 2
  PARTITION = 3
  VALUE_MAP = {1 => "DB", 2 => "TABLE", 3 => "PARTITION"}
  VALID_VALUES = Set.new([DB, TABLE, PARTITION]).freeze
end

module LockState
  ACQUIRED = 1
  WAITING = 2
  ABORT = 3
  NOT_ACQUIRED = 4
  VALUE_MAP = {1 => "ACQUIRED", 2 => "WAITING", 3 => "ABORT", 4 => "NOT_ACQUIRED"}
  VALID_VALUES = Set.new([ACQUIRED, WAITING, ABORT, NOT_ACQUIRED]).freeze
end

module LockType
  SHARED_READ = 1
  SHARED_WRITE = 2
  EXCLUSIVE = 3
  EXCL_WRITE = 4
  VALUE_MAP = {1 => "SHARED_READ", 2 => "SHARED_WRITE", 3 => "EXCLUSIVE", 4 => "EXCL_WRITE"}
  VALID_VALUES = Set.new([SHARED_READ, SHARED_WRITE, EXCLUSIVE, EXCL_WRITE]).freeze
end

module CompactionType
  MINOR = 1
  MAJOR = 2
  VALUE_MAP = {1 => "MINOR", 2 => "MAJOR"}
  VALID_VALUES = Set.new([MINOR, MAJOR]).freeze
end

module GrantRevokeType
  GRANT = 1
  REVOKE = 2
  VALUE_MAP = {1 => "GRANT", 2 => "REVOKE"}
  VALID_VALUES = Set.new([GRANT, REVOKE]).freeze
end

module DataOperationType
  SELECT = 1
  INSERT = 2
  UPDATE = 3
  DELETE = 4
  UNSET = 5
  NO_TXN = 6
  VALUE_MAP = {1 => "SELECT", 2 => "INSERT", 3 => "UPDATE", 4 => "DELETE", 5 => "UNSET", 6 => "NO_TXN"}
  VALID_VALUES = Set.new([SELECT, INSERT, UPDATE, DELETE, UNSET, NO_TXN]).freeze
end

module EventRequestType
  INSERT = 1
  UPDATE = 2
  DELETE = 3
  VALUE_MAP = {1 => "INSERT", 2 => "UPDATE", 3 => "DELETE"}
  VALID_VALUES = Set.new([INSERT, UPDATE, DELETE]).freeze
end

module SerdeType
  HIVE = 1
  SCHEMA_REGISTRY = 2
  VALUE_MAP = {1 => "HIVE", 2 => "SCHEMA_REGISTRY"}
  VALID_VALUES = Set.new([HIVE, SCHEMA_REGISTRY]).freeze
end

module SchemaType
  HIVE = 1
  AVRO = 2
  VALUE_MAP = {1 => "HIVE", 2 => "AVRO"}
  VALID_VALUES = Set.new([HIVE, AVRO]).freeze
end

module SchemaCompatibility
  NONE = 1
  BACKWARD = 2
  FORWARD = 3
  BOTH = 4
  VALUE_MAP = {1 => "NONE", 2 => "BACKWARD", 3 => "FORWARD", 4 => "BOTH"}
  VALID_VALUES = Set.new([NONE, BACKWARD, FORWARD, BOTH]).freeze
end

module SchemaValidation
  LATEST = 1
  ALL = 2
  VALUE_MAP = {1 => "LATEST", 2 => "ALL"}
  VALID_VALUES = Set.new([LATEST, ALL]).freeze
end

module SchemaVersionState
  INITIATED = 1
  START_REVIEW = 2
  CHANGES_REQUIRED = 3
  REVIEWED = 4
  ENABLED = 5
  DISABLED = 6
  ARCHIVED = 7
  DELETED = 8
  VALUE_MAP = {1 => "INITIATED", 2 => "START_REVIEW", 3 => "CHANGES_REQUIRED", 4 => "REVIEWED", 5 => "ENABLED", 6 => "DISABLED", 7 => "ARCHIVED", 8 => "DELETED"}
  VALID_VALUES = Set.new([INITIATED, START_REVIEW, CHANGES_REQUIRED, REVIEWED, ENABLED, DISABLED, ARCHIVED, DELETED]).freeze
end

module FunctionType
  JAVA = 1
  VALUE_MAP = {1 => "JAVA"}
  VALID_VALUES = Set.new([JAVA]).freeze
end

module ResourceType
  JAR = 1
  FILE = 2
  ARCHIVE = 3
  VALUE_MAP = {1 => "JAR", 2 => "FILE", 3 => "ARCHIVE"}
  VALID_VALUES = Set.new([JAR, FILE, ARCHIVE]).freeze
end

module TxnType
  DEFAULT = 0
  REPL_CREATED = 1
  READ_ONLY = 2
  COMPACTION = 3
  MATER_VIEW_REBUILD = 4
  VALUE_MAP = {0 => "DEFAULT", 1 => "REPL_CREATED", 2 => "READ_ONLY", 3 => "COMPACTION", 4 => "MATER_VIEW_REBUILD"}
  VALID_VALUES = Set.new([DEFAULT, REPL_CREATED, READ_ONLY, COMPACTION, MATER_VIEW_REBUILD]).freeze
end

module GetTablesExtRequestFields
  ACCESS_TYPE = 1
  PROCESSOR_CAPABILITIES = 2
  ALL = 2147483647
  VALUE_MAP = {1 => "ACCESS_TYPE", 2 => "PROCESSOR_CAPABILITIES", 2147483647 => "ALL"}
  VALID_VALUES = Set.new([ACCESS_TYPE, PROCESSOR_CAPABILITIES, ALL]).freeze
end

module FileMetadataExprType
  ORC_SARG = 1
  VALUE_MAP = {1 => "ORC_SARG"}
  VALID_VALUES = Set.new([ORC_SARG]).freeze
end

module ClientCapability
  TEST_CAPABILITY = 1
  INSERT_ONLY_TABLES = 2
  VALUE_MAP = {1 => "TEST_CAPABILITY", 2 => "INSERT_ONLY_TABLES"}
  VALID_VALUES = Set.new([TEST_CAPABILITY, INSERT_ONLY_TABLES]).freeze
end

module WMResourcePlanStatus
  ACTIVE = 1
  ENABLED = 2
  DISABLED = 3
  VALUE_MAP = {1 => "ACTIVE", 2 => "ENABLED", 3 => "DISABLED"}
  VALID_VALUES = Set.new([ACTIVE, ENABLED, DISABLED]).freeze
end

module WMPoolSchedulingPolicy
  FAIR = 1
  FIFO = 2
  VALUE_MAP = {1 => "FAIR", 2 => "FIFO"}
  VALID_VALUES = Set.new([FAIR, FIFO]).freeze
end

module ScheduledQueryMaintenanceRequestType
  CREATE = 1
  ALTER = 2
  DROP = 3
  VALUE_MAP = {1 => "CREATE", 2 => "ALTER", 3 => "DROP"}
  VALID_VALUES = Set.new([CREATE, ALTER, DROP]).freeze
end

module QueryState
  INITED = 0
  EXECUTING = 1
  FAILED = 2
  FINISHED = 3
  TIMED_OUT = 4
  VALUE_MAP = {0 => "INITED", 1 => "EXECUTING", 2 => "FAILED", 3 => "FINISHED", 4 => "TIMED_OUT"}
  VALID_VALUES = Set.new([INITED, EXECUTING, FAILED, FINISHED, TIMED_OUT]).freeze
end

module PartitionFilterMode
  BY_NAMES = 0
  BY_VALUES = 1
  BY_EXPR = 2
  VALUE_MAP = {0 => "BY_NAMES", 1 => "BY_VALUES", 2 => "BY_EXPR"}
  VALID_VALUES = Set.new([BY_NAMES, BY_VALUES, BY_EXPR]).freeze
end

class Version; end

class FieldSchema; end

class SQLPrimaryKey; end

class SQLForeignKey; end

class SQLUniqueConstraint; end

class SQLNotNullConstraint; end

class SQLDefaultConstraint; end

class SQLCheckConstraint; end

class SQLAllTableConstraints; end

class Type; end

class HiveObjectRef; end

class PrivilegeGrantInfo; end

class HiveObjectPrivilege; end

class PrivilegeBag; end

class PrincipalPrivilegeSet; end

class GrantRevokePrivilegeRequest; end

class GrantRevokePrivilegeResponse; end

class TruncateTableRequest; end

class TruncateTableResponse; end

class Role; end

class RolePrincipalGrant; end

class GetRoleGrantsForPrincipalRequest; end

class GetRoleGrantsForPrincipalResponse; end

class GetPrincipalsInRoleRequest; end

class GetPrincipalsInRoleResponse; end

class GrantRevokeRoleRequest; end

class GrantRevokeRoleResponse; end

class Catalog; end

class CreateCatalogRequest; end

class AlterCatalogRequest; end

class GetCatalogRequest; end

class GetCatalogResponse; end

class GetCatalogsResponse; end

class DropCatalogRequest; end

class Database; end

class SerDeInfo; end

class Order; end

class SkewedInfo; end

class StorageDescriptor; end

class CreationMetadata; end

class BooleanColumnStatsData; end

class DoubleColumnStatsData; end

class LongColumnStatsData; end

class StringColumnStatsData; end

class BinaryColumnStatsData; end

class Decimal; end

class DecimalColumnStatsData; end

class Date; end

class DateColumnStatsData; end

class Timestamp; end

class TimestampColumnStatsData; end

class ColumnStatisticsData < ::Thrift::Union; end

class ColumnStatisticsObj; end

class ColumnStatisticsDesc; end

class ColumnStatistics; end

class Table; end

class Partition; end

class PartitionWithoutSD; end

class PartitionSpecWithSharedSD; end

class PartitionListComposingSpec; end

class PartitionSpec; end

class AggrStats; end

class SetPartitionsStatsRequest; end

class SetPartitionsStatsResponse; end

class Schema; end

class EnvironmentContext; end

class PrimaryKeysRequest; end

class PrimaryKeysResponse; end

class ForeignKeysRequest; end

class ForeignKeysResponse; end

class UniqueConstraintsRequest; end

class UniqueConstraintsResponse; end

class NotNullConstraintsRequest; end

class NotNullConstraintsResponse; end

class DefaultConstraintsRequest; end

class DefaultConstraintsResponse; end

class CheckConstraintsRequest; end

class CheckConstraintsResponse; end

class AllTableConstraintsRequest; end

class AllTableConstraintsResponse; end

class DropConstraintRequest; end

class AddPrimaryKeyRequest; end

class AddForeignKeyRequest; end

class AddUniqueConstraintRequest; end

class AddNotNullConstraintRequest; end

class AddDefaultConstraintRequest; end

class AddCheckConstraintRequest; end

class PartitionsByExprResult; end

class PartitionsSpecByExprResult; end

class PartitionsByExprRequest; end

class TableStatsResult; end

class PartitionsStatsResult; end

class TableStatsRequest; end

class PartitionsStatsRequest; end

class AddPartitionsResult; end

class AddPartitionsRequest; end

class DropPartitionsResult; end

class DropPartitionsExpr; end

class RequestPartsSpec < ::Thrift::Union; end

class DropPartitionsRequest; end

class PartitionValuesRequest; end

class PartitionValuesRow; end

class PartitionValuesResponse; end

class GetPartitionsByNamesRequest; end

class GetPartitionsByNamesResult; end

class ResourceUri; end

class Function; end

class TxnInfo; end

class GetOpenTxnsInfoResponse; end

class GetOpenTxnsResponse; end

class OpenTxnRequest; end

class OpenTxnsResponse; end

class AbortTxnRequest; end

class AbortTxnsRequest; end

class CommitTxnKeyValue; end

class WriteEventInfo; end

class ReplLastIdInfo; end

class CommitTxnRequest; end

class ReplTblWriteIdStateRequest; end

class GetValidWriteIdsRequest; end

class TableValidWriteIds; end

class GetValidWriteIdsResponse; end

class TxnToWriteId; end

class AllocateTableWriteIdsRequest; end

class AllocateTableWriteIdsResponse; end

class MaxAllocatedTableWriteIdRequest; end

class MaxAllocatedTableWriteIdResponse; end

class SeedTableWriteIdsRequest; end

class SeedTxnIdRequest; end

class LockComponent; end

class LockRequest; end

class LockResponse; end

class CheckLockRequest; end

class UnlockRequest; end

class ShowLocksRequest; end

class ShowLocksResponseElement; end

class ShowLocksResponse; end

class HeartbeatRequest; end

class HeartbeatTxnRangeRequest; end

class HeartbeatTxnRangeResponse; end

class CompactionRequest; end

class CompactionInfoStruct; end

class OptionalCompactionInfoStruct; end

class CompactionResponse; end

class ShowCompactRequest; end

class ShowCompactResponseElement; end

class ShowCompactResponse; end

class AddDynamicPartitions; end

class BasicTxnInfo; end

class NotificationEventRequest; end

class NotificationEvent; end

class NotificationEventResponse; end

class CurrentNotificationEventId; end

class NotificationEventsCountRequest; end

class NotificationEventsCountResponse; end

class InsertEventRequestData; end

class FireEventRequestData < ::Thrift::Union; end

class FireEventRequest; end

class FireEventResponse; end

class WriteNotificationLogRequest; end

class WriteNotificationLogResponse; end

class MetadataPpdResult; end

class GetFileMetadataByExprResult; end

class GetFileMetadataByExprRequest; end

class GetFileMetadataResult; end

class GetFileMetadataRequest; end

class PutFileMetadataResult; end

class PutFileMetadataRequest; end

class ClearFileMetadataResult; end

class ClearFileMetadataRequest; end

class CacheFileMetadataResult; end

class CacheFileMetadataRequest; end

class GetAllFunctionsResponse; end

class ClientCapabilities; end

class GetProjectionsSpec; end

class GetTableRequest; end

class GetTableResult; end

class GetTablesRequest; end

class GetTablesResult; end

class GetTablesExtRequest; end

class ExtendedTableInfo; end

class GetDatabaseRequest; end

class CmRecycleRequest; end

class CmRecycleResponse; end

class TableMeta; end

class Materialization; end

class WMResourcePlan; end

class WMNullableResourcePlan; end

class WMPool; end

class WMNullablePool; end

class WMTrigger; end

class WMMapping; end

class WMPoolTrigger; end

class WMFullResourcePlan; end

class WMCreateResourcePlanRequest; end

class WMCreateResourcePlanResponse; end

class WMGetActiveResourcePlanRequest; end

class WMGetActiveResourcePlanResponse; end

class WMGetResourcePlanRequest; end

class WMGetResourcePlanResponse; end

class WMGetAllResourcePlanRequest; end

class WMGetAllResourcePlanResponse; end

class WMAlterResourcePlanRequest; end

class WMAlterResourcePlanResponse; end

class WMValidateResourcePlanRequest; end

class WMValidateResourcePlanResponse; end

class WMDropResourcePlanRequest; end

class WMDropResourcePlanResponse; end

class WMCreateTriggerRequest; end

class WMCreateTriggerResponse; end

class WMAlterTriggerRequest; end

class WMAlterTriggerResponse; end

class WMDropTriggerRequest; end

class WMDropTriggerResponse; end

class WMGetTriggersForResourePlanRequest; end

class WMGetTriggersForResourePlanResponse; end

class WMCreatePoolRequest; end

class WMCreatePoolResponse; end

class WMAlterPoolRequest; end

class WMAlterPoolResponse; end

class WMDropPoolRequest; end

class WMDropPoolResponse; end

class WMCreateOrUpdateMappingRequest; end

class WMCreateOrUpdateMappingResponse; end

class WMDropMappingRequest; end

class WMDropMappingResponse; end

class WMCreateOrDropTriggerToPoolMappingRequest; end

class WMCreateOrDropTriggerToPoolMappingResponse; end

class ISchema; end

class ISchemaName; end

class AlterISchemaRequest; end

class SchemaVersion; end

class SchemaVersionDescriptor; end

class FindSchemasByColsRqst; end

class FindSchemasByColsResp; end

class MapSchemaVersionToSerdeRequest; end

class SetSchemaVersionStateRequest; end

class GetSerdeRequest; end

class RuntimeStat; end

class GetRuntimeStatsRequest; end

class CreateTableRequest; end

class ScheduledQueryPollRequest; end

class ScheduledQueryKey; end

class ScheduledQueryPollResponse; end

class ScheduledQuery; end

class ScheduledQueryMaintenanceRequest; end

class ScheduledQueryProgressInfo; end

class AlterPartitionsRequest; end

class AlterPartitionsResponse; end

class RenamePartitionRequest; end

class RenamePartitionResponse; end

class AlterTableRequest; end

class AlterTableResponse; end

class GetPartitionsFilterSpec; end

class GetPartitionsResponse; end

class GetPartitionsRequest; end

class GetFieldsRequest; end

class GetFieldsResponse; end

class GetSchemaRequest; end

class GetSchemaResponse; end

class GetPartitionRequest; end

class GetPartitionResponse; end

class PartitionsRequest; end

class PartitionsResponse; end

class GetPartitionNamesPsRequest; end

class GetPartitionNamesPsResponse; end

class GetPartitionsPsWithAuthRequest; end

class GetPartitionsPsWithAuthResponse; end

class ReplicationMetrics; end

class ReplicationMetricList; end

class GetReplicationMetricsRequest; end

class GetOpenTxnsRequest; end

class StoredProcedureRequest; end

class ListStoredProcedureRequest; end

class StoredProcedure; end

class MetaException < ::Thrift::Exception; end

class UnknownTableException < ::Thrift::Exception; end

class UnknownDBException < ::Thrift::Exception; end

class AlreadyExistsException < ::Thrift::Exception; end

class InvalidPartitionException < ::Thrift::Exception; end

class UnknownPartitionException < ::Thrift::Exception; end

class InvalidObjectException < ::Thrift::Exception; end

class NoSuchObjectException < ::Thrift::Exception; end

class InvalidOperationException < ::Thrift::Exception; end

class ConfigValSecurityException < ::Thrift::Exception; end

class InvalidInputException < ::Thrift::Exception; end

class NoSuchTxnException < ::Thrift::Exception; end

class TxnAbortedException < ::Thrift::Exception; end

class TxnOpenException < ::Thrift::Exception; end

class NoSuchLockException < ::Thrift::Exception; end

class Version
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VERSION = 1
  COMMENTS = 2

  FIELDS = {
    VERSION => {:type => ::Thrift::Types::STRING, :name => 'version'},
    COMMENTS => {:type => ::Thrift::Types::STRING, :name => 'comments'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class FieldSchema
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NAME = 1
  TYPE = 2
  COMMENT = 3

  FIELDS = {
    NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
    TYPE => {:type => ::Thrift::Types::STRING, :name => 'type'},
    COMMENT => {:type => ::Thrift::Types::STRING, :name => 'comment'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class SQLPrimaryKey
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TABLE_DB = 1
  TABLE_NAME = 2
  COLUMN_NAME = 3
  KEY_SEQ = 4
  PK_NAME = 5
  ENABLE_CSTR = 6
  VALIDATE_CSTR = 7
  RELY_CSTR = 8
  CATNAME = 9

  FIELDS = {
    TABLE_DB => {:type => ::Thrift::Types::STRING, :name => 'table_db'},
    TABLE_NAME => {:type => ::Thrift::Types::STRING, :name => 'table_name'},
    COLUMN_NAME => {:type => ::Thrift::Types::STRING, :name => 'column_name'},
    KEY_SEQ => {:type => ::Thrift::Types::I32, :name => 'key_seq'},
    PK_NAME => {:type => ::Thrift::Types::STRING, :name => 'pk_name'},
    ENABLE_CSTR => {:type => ::Thrift::Types::BOOL, :name => 'enable_cstr'},
    VALIDATE_CSTR => {:type => ::Thrift::Types::BOOL, :name => 'validate_cstr'},
    RELY_CSTR => {:type => ::Thrift::Types::BOOL, :name => 'rely_cstr'},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class SQLForeignKey
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PKTABLE_DB = 1
  PKTABLE_NAME = 2
  PKCOLUMN_NAME = 3
  FKTABLE_DB = 4
  FKTABLE_NAME = 5
  FKCOLUMN_NAME = 6
  KEY_SEQ = 7
  UPDATE_RULE = 8
  DELETE_RULE = 9
  FK_NAME = 10
  PK_NAME = 11
  ENABLE_CSTR = 12
  VALIDATE_CSTR = 13
  RELY_CSTR = 14
  CATNAME = 15

  FIELDS = {
    PKTABLE_DB => {:type => ::Thrift::Types::STRING, :name => 'pktable_db'},
    PKTABLE_NAME => {:type => ::Thrift::Types::STRING, :name => 'pktable_name'},
    PKCOLUMN_NAME => {:type => ::Thrift::Types::STRING, :name => 'pkcolumn_name'},
    FKTABLE_DB => {:type => ::Thrift::Types::STRING, :name => 'fktable_db'},
    FKTABLE_NAME => {:type => ::Thrift::Types::STRING, :name => 'fktable_name'},
    FKCOLUMN_NAME => {:type => ::Thrift::Types::STRING, :name => 'fkcolumn_name'},
    KEY_SEQ => {:type => ::Thrift::Types::I32, :name => 'key_seq'},
    UPDATE_RULE => {:type => ::Thrift::Types::I32, :name => 'update_rule'},
    DELETE_RULE => {:type => ::Thrift::Types::I32, :name => 'delete_rule'},
    FK_NAME => {:type => ::Thrift::Types::STRING, :name => 'fk_name'},
    PK_NAME => {:type => ::Thrift::Types::STRING, :name => 'pk_name'},
    ENABLE_CSTR => {:type => ::Thrift::Types::BOOL, :name => 'enable_cstr'},
    VALIDATE_CSTR => {:type => ::Thrift::Types::BOOL, :name => 'validate_cstr'},
    RELY_CSTR => {:type => ::Thrift::Types::BOOL, :name => 'rely_cstr'},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class SQLUniqueConstraint
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  TABLE_DB = 2
  TABLE_NAME = 3
  COLUMN_NAME = 4
  KEY_SEQ = 5
  UK_NAME = 6
  ENABLE_CSTR = 7
  VALIDATE_CSTR = 8
  RELY_CSTR = 9

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName'},
    TABLE_DB => {:type => ::Thrift::Types::STRING, :name => 'table_db'},
    TABLE_NAME => {:type => ::Thrift::Types::STRING, :name => 'table_name'},
    COLUMN_NAME => {:type => ::Thrift::Types::STRING, :name => 'column_name'},
    KEY_SEQ => {:type => ::Thrift::Types::I32, :name => 'key_seq'},
    UK_NAME => {:type => ::Thrift::Types::STRING, :name => 'uk_name'},
    ENABLE_CSTR => {:type => ::Thrift::Types::BOOL, :name => 'enable_cstr'},
    VALIDATE_CSTR => {:type => ::Thrift::Types::BOOL, :name => 'validate_cstr'},
    RELY_CSTR => {:type => ::Thrift::Types::BOOL, :name => 'rely_cstr'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class SQLNotNullConstraint
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  TABLE_DB = 2
  TABLE_NAME = 3
  COLUMN_NAME = 4
  NN_NAME = 5
  ENABLE_CSTR = 6
  VALIDATE_CSTR = 7
  RELY_CSTR = 8

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName'},
    TABLE_DB => {:type => ::Thrift::Types::STRING, :name => 'table_db'},
    TABLE_NAME => {:type => ::Thrift::Types::STRING, :name => 'table_name'},
    COLUMN_NAME => {:type => ::Thrift::Types::STRING, :name => 'column_name'},
    NN_NAME => {:type => ::Thrift::Types::STRING, :name => 'nn_name'},
    ENABLE_CSTR => {:type => ::Thrift::Types::BOOL, :name => 'enable_cstr'},
    VALIDATE_CSTR => {:type => ::Thrift::Types::BOOL, :name => 'validate_cstr'},
    RELY_CSTR => {:type => ::Thrift::Types::BOOL, :name => 'rely_cstr'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class SQLDefaultConstraint
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  TABLE_DB = 2
  TABLE_NAME = 3
  COLUMN_NAME = 4
  DEFAULT_VALUE = 5
  DC_NAME = 6
  ENABLE_CSTR = 7
  VALIDATE_CSTR = 8
  RELY_CSTR = 9

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName'},
    TABLE_DB => {:type => ::Thrift::Types::STRING, :name => 'table_db'},
    TABLE_NAME => {:type => ::Thrift::Types::STRING, :name => 'table_name'},
    COLUMN_NAME => {:type => ::Thrift::Types::STRING, :name => 'column_name'},
    DEFAULT_VALUE => {:type => ::Thrift::Types::STRING, :name => 'default_value'},
    DC_NAME => {:type => ::Thrift::Types::STRING, :name => 'dc_name'},
    ENABLE_CSTR => {:type => ::Thrift::Types::BOOL, :name => 'enable_cstr'},
    VALIDATE_CSTR => {:type => ::Thrift::Types::BOOL, :name => 'validate_cstr'},
    RELY_CSTR => {:type => ::Thrift::Types::BOOL, :name => 'rely_cstr'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class SQLCheckConstraint
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  TABLE_DB = 2
  TABLE_NAME = 3
  COLUMN_NAME = 4
  CHECK_EXPRESSION = 5
  DC_NAME = 6
  ENABLE_CSTR = 7
  VALIDATE_CSTR = 8
  RELY_CSTR = 9

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName'},
    TABLE_DB => {:type => ::Thrift::Types::STRING, :name => 'table_db'},
    TABLE_NAME => {:type => ::Thrift::Types::STRING, :name => 'table_name'},
    COLUMN_NAME => {:type => ::Thrift::Types::STRING, :name => 'column_name'},
    CHECK_EXPRESSION => {:type => ::Thrift::Types::STRING, :name => 'check_expression'},
    DC_NAME => {:type => ::Thrift::Types::STRING, :name => 'dc_name'},
    ENABLE_CSTR => {:type => ::Thrift::Types::BOOL, :name => 'enable_cstr'},
    VALIDATE_CSTR => {:type => ::Thrift::Types::BOOL, :name => 'validate_cstr'},
    RELY_CSTR => {:type => ::Thrift::Types::BOOL, :name => 'rely_cstr'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class SQLAllTableConstraints
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PRIMARYKEYS = 1
  FOREIGNKEYS = 2
  UNIQUECONSTRAINTS = 3
  NOTNULLCONSTRAINTS = 4
  DEFAULTCONSTRAINTS = 5
  CHECKCONSTRAINTS = 6

  FIELDS = {
    PRIMARYKEYS => {:type => ::Thrift::Types::LIST, :name => 'primaryKeys', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLPrimaryKey}, :optional => true},
    FOREIGNKEYS => {:type => ::Thrift::Types::LIST, :name => 'foreignKeys', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLForeignKey}, :optional => true},
    UNIQUECONSTRAINTS => {:type => ::Thrift::Types::LIST, :name => 'uniqueConstraints', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLUniqueConstraint}, :optional => true},
    NOTNULLCONSTRAINTS => {:type => ::Thrift::Types::LIST, :name => 'notNullConstraints', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLNotNullConstraint}, :optional => true},
    DEFAULTCONSTRAINTS => {:type => ::Thrift::Types::LIST, :name => 'defaultConstraints', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLDefaultConstraint}, :optional => true},
    CHECKCONSTRAINTS => {:type => ::Thrift::Types::LIST, :name => 'checkConstraints', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLCheckConstraint}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class Type
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NAME = 1
  TYPE1 = 2
  TYPE2 = 3
  FIELDS = 4

  FIELDS = {
    NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
    TYPE1 => {:type => ::Thrift::Types::STRING, :name => 'type1', :optional => true},
    TYPE2 => {:type => ::Thrift::Types::STRING, :name => 'type2', :optional => true},
    FIELDS => {:type => ::Thrift::Types::LIST, :name => 'fields', :element => {:type => ::Thrift::Types::STRUCT, :class => ::FieldSchema}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class HiveObjectRef
  include ::Thrift::Struct, ::Thrift::Struct_Union
  OBJECTTYPE = 1
  DBNAME = 2
  OBJECTNAME = 3
  PARTVALUES = 4
  COLUMNNAME = 5
  CATNAME = 6

  FIELDS = {
    OBJECTTYPE => {:type => ::Thrift::Types::I32, :name => 'objectType', :enum_class => ::HiveObjectType},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    OBJECTNAME => {:type => ::Thrift::Types::STRING, :name => 'objectName'},
    PARTVALUES => {:type => ::Thrift::Types::LIST, :name => 'partValues', :element => {:type => ::Thrift::Types::STRING}},
    COLUMNNAME => {:type => ::Thrift::Types::STRING, :name => 'columnName'},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    unless @objectType.nil? || ::HiveObjectType::VALID_VALUES.include?(@objectType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field objectType!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class PrivilegeGrantInfo
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PRIVILEGE = 1
  CREATETIME = 2
  GRANTOR = 3
  GRANTORTYPE = 4
  GRANTOPTION = 5

  FIELDS = {
    PRIVILEGE => {:type => ::Thrift::Types::STRING, :name => 'privilege'},
    CREATETIME => {:type => ::Thrift::Types::I32, :name => 'createTime'},
    GRANTOR => {:type => ::Thrift::Types::STRING, :name => 'grantor'},
    GRANTORTYPE => {:type => ::Thrift::Types::I32, :name => 'grantorType', :enum_class => ::PrincipalType},
    GRANTOPTION => {:type => ::Thrift::Types::BOOL, :name => 'grantOption'}
  }

  def struct_fields; FIELDS; end

  def validate
    unless @grantorType.nil? || ::PrincipalType::VALID_VALUES.include?(@grantorType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field grantorType!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class HiveObjectPrivilege
  include ::Thrift::Struct, ::Thrift::Struct_Union
  HIVEOBJECT = 1
  PRINCIPALNAME = 2
  PRINCIPALTYPE = 3
  GRANTINFO = 4
  AUTHORIZER = 5

  FIELDS = {
    HIVEOBJECT => {:type => ::Thrift::Types::STRUCT, :name => 'hiveObject', :class => ::HiveObjectRef},
    PRINCIPALNAME => {:type => ::Thrift::Types::STRING, :name => 'principalName'},
    PRINCIPALTYPE => {:type => ::Thrift::Types::I32, :name => 'principalType', :enum_class => ::PrincipalType},
    GRANTINFO => {:type => ::Thrift::Types::STRUCT, :name => 'grantInfo', :class => ::PrivilegeGrantInfo},
    AUTHORIZER => {:type => ::Thrift::Types::STRING, :name => 'authorizer'}
  }

  def struct_fields; FIELDS; end

  def validate
    unless @principalType.nil? || ::PrincipalType::VALID_VALUES.include?(@principalType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field principalType!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class PrivilegeBag
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PRIVILEGES = 1

  FIELDS = {
    PRIVILEGES => {:type => ::Thrift::Types::LIST, :name => 'privileges', :element => {:type => ::Thrift::Types::STRUCT, :class => ::HiveObjectPrivilege}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class PrincipalPrivilegeSet
  include ::Thrift::Struct, ::Thrift::Struct_Union
  USERPRIVILEGES = 1
  GROUPPRIVILEGES = 2
  ROLEPRIVILEGES = 3

  FIELDS = {
    USERPRIVILEGES => {:type => ::Thrift::Types::MAP, :name => 'userPrivileges', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::LIST, :element => {:type => ::Thrift::Types::STRUCT, :class => ::PrivilegeGrantInfo}}},
    GROUPPRIVILEGES => {:type => ::Thrift::Types::MAP, :name => 'groupPrivileges', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::LIST, :element => {:type => ::Thrift::Types::STRUCT, :class => ::PrivilegeGrantInfo}}},
    ROLEPRIVILEGES => {:type => ::Thrift::Types::MAP, :name => 'rolePrivileges', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::LIST, :element => {:type => ::Thrift::Types::STRUCT, :class => ::PrivilegeGrantInfo}}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class GrantRevokePrivilegeRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  REQUESTTYPE = 1
  PRIVILEGES = 2
  REVOKEGRANTOPTION = 3

  FIELDS = {
    REQUESTTYPE => {:type => ::Thrift::Types::I32, :name => 'requestType', :enum_class => ::GrantRevokeType},
    PRIVILEGES => {:type => ::Thrift::Types::STRUCT, :name => 'privileges', :class => ::PrivilegeBag},
    REVOKEGRANTOPTION => {:type => ::Thrift::Types::BOOL, :name => 'revokeGrantOption', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    unless @requestType.nil? || ::GrantRevokeType::VALID_VALUES.include?(@requestType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field requestType!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class GrantRevokePrivilegeResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SUCCESS = 1

  FIELDS = {
    SUCCESS => {:type => ::Thrift::Types::BOOL, :name => 'success', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class TruncateTableRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DBNAME = 1
  TABLENAME = 2
  PARTNAMES = 3
  WRITEID = 4
  VALIDWRITEIDLIST = 5

  FIELDS = {
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName'},
    PARTNAMES => {:type => ::Thrift::Types::LIST, :name => 'partNames', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    WRITEID => {:type => ::Thrift::Types::I64, :name => 'writeId', :default => -1, :optional => true},
    VALIDWRITEIDLIST => {:type => ::Thrift::Types::STRING, :name => 'validWriteIdList', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tableName is unset!') unless @tableName
  end

  ::Thrift::Struct.generate_accessors self
end

class TruncateTableResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class Role
  include ::Thrift::Struct, ::Thrift::Struct_Union
  ROLENAME = 1
  CREATETIME = 2
  OWNERNAME = 3

  FIELDS = {
    ROLENAME => {:type => ::Thrift::Types::STRING, :name => 'roleName'},
    CREATETIME => {:type => ::Thrift::Types::I32, :name => 'createTime'},
    OWNERNAME => {:type => ::Thrift::Types::STRING, :name => 'ownerName'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class RolePrincipalGrant
  include ::Thrift::Struct, ::Thrift::Struct_Union
  ROLENAME = 1
  PRINCIPALNAME = 2
  PRINCIPALTYPE = 3
  GRANTOPTION = 4
  GRANTTIME = 5
  GRANTORNAME = 6
  GRANTORPRINCIPALTYPE = 7

  FIELDS = {
    ROLENAME => {:type => ::Thrift::Types::STRING, :name => 'roleName'},
    PRINCIPALNAME => {:type => ::Thrift::Types::STRING, :name => 'principalName'},
    PRINCIPALTYPE => {:type => ::Thrift::Types::I32, :name => 'principalType', :enum_class => ::PrincipalType},
    GRANTOPTION => {:type => ::Thrift::Types::BOOL, :name => 'grantOption'},
    GRANTTIME => {:type => ::Thrift::Types::I32, :name => 'grantTime'},
    GRANTORNAME => {:type => ::Thrift::Types::STRING, :name => 'grantorName'},
    GRANTORPRINCIPALTYPE => {:type => ::Thrift::Types::I32, :name => 'grantorPrincipalType', :enum_class => ::PrincipalType}
  }

  def struct_fields; FIELDS; end

  def validate
    unless @principalType.nil? || ::PrincipalType::VALID_VALUES.include?(@principalType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field principalType!')
    end
    unless @grantorPrincipalType.nil? || ::PrincipalType::VALID_VALUES.include?(@grantorPrincipalType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field grantorPrincipalType!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class GetRoleGrantsForPrincipalRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PRINCIPAL_NAME = 1
  PRINCIPAL_TYPE = 2

  FIELDS = {
    PRINCIPAL_NAME => {:type => ::Thrift::Types::STRING, :name => 'principal_name'},
    PRINCIPAL_TYPE => {:type => ::Thrift::Types::I32, :name => 'principal_type', :enum_class => ::PrincipalType}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field principal_name is unset!') unless @principal_name
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field principal_type is unset!') unless @principal_type
    unless @principal_type.nil? || ::PrincipalType::VALID_VALUES.include?(@principal_type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field principal_type!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class GetRoleGrantsForPrincipalResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PRINCIPALGRANTS = 1

  FIELDS = {
    PRINCIPALGRANTS => {:type => ::Thrift::Types::LIST, :name => 'principalGrants', :element => {:type => ::Thrift::Types::STRUCT, :class => ::RolePrincipalGrant}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field principalGrants is unset!') unless @principalGrants
  end

  ::Thrift::Struct.generate_accessors self
end

class GetPrincipalsInRoleRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  ROLENAME = 1

  FIELDS = {
    ROLENAME => {:type => ::Thrift::Types::STRING, :name => 'roleName'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field roleName is unset!') unless @roleName
  end

  ::Thrift::Struct.generate_accessors self
end

class GetPrincipalsInRoleResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PRINCIPALGRANTS = 1

  FIELDS = {
    PRINCIPALGRANTS => {:type => ::Thrift::Types::LIST, :name => 'principalGrants', :element => {:type => ::Thrift::Types::STRUCT, :class => ::RolePrincipalGrant}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field principalGrants is unset!') unless @principalGrants
  end

  ::Thrift::Struct.generate_accessors self
end

class GrantRevokeRoleRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  REQUESTTYPE = 1
  ROLENAME = 2
  PRINCIPALNAME = 3
  PRINCIPALTYPE = 4
  GRANTOR = 5
  GRANTORTYPE = 6
  GRANTOPTION = 7

  FIELDS = {
    REQUESTTYPE => {:type => ::Thrift::Types::I32, :name => 'requestType', :enum_class => ::GrantRevokeType},
    ROLENAME => {:type => ::Thrift::Types::STRING, :name => 'roleName'},
    PRINCIPALNAME => {:type => ::Thrift::Types::STRING, :name => 'principalName'},
    PRINCIPALTYPE => {:type => ::Thrift::Types::I32, :name => 'principalType', :enum_class => ::PrincipalType},
    GRANTOR => {:type => ::Thrift::Types::STRING, :name => 'grantor', :optional => true},
    GRANTORTYPE => {:type => ::Thrift::Types::I32, :name => 'grantorType', :optional => true, :enum_class => ::PrincipalType},
    GRANTOPTION => {:type => ::Thrift::Types::BOOL, :name => 'grantOption', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    unless @requestType.nil? || ::GrantRevokeType::VALID_VALUES.include?(@requestType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field requestType!')
    end
    unless @principalType.nil? || ::PrincipalType::VALID_VALUES.include?(@principalType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field principalType!')
    end
    unless @grantorType.nil? || ::PrincipalType::VALID_VALUES.include?(@grantorType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field grantorType!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class GrantRevokeRoleResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SUCCESS = 1

  FIELDS = {
    SUCCESS => {:type => ::Thrift::Types::BOOL, :name => 'success', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class Catalog
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NAME = 1
  DESCRIPTION = 2
  LOCATIONURI = 3
  CREATETIME = 4

  FIELDS = {
    NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
    DESCRIPTION => {:type => ::Thrift::Types::STRING, :name => 'description', :optional => true},
    LOCATIONURI => {:type => ::Thrift::Types::STRING, :name => 'locationUri'},
    CREATETIME => {:type => ::Thrift::Types::I32, :name => 'createTime', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class CreateCatalogRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATALOG = 1

  FIELDS = {
    CATALOG => {:type => ::Thrift::Types::STRUCT, :name => 'catalog', :class => ::Catalog}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class AlterCatalogRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NAME = 1
  NEWCAT = 2

  FIELDS = {
    NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
    NEWCAT => {:type => ::Thrift::Types::STRUCT, :name => 'newCat', :class => ::Catalog}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class GetCatalogRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NAME = 1

  FIELDS = {
    NAME => {:type => ::Thrift::Types::STRING, :name => 'name'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class GetCatalogResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATALOG = 1

  FIELDS = {
    CATALOG => {:type => ::Thrift::Types::STRUCT, :name => 'catalog', :class => ::Catalog}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class GetCatalogsResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NAMES = 1

  FIELDS = {
    NAMES => {:type => ::Thrift::Types::LIST, :name => 'names', :element => {:type => ::Thrift::Types::STRING}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class DropCatalogRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NAME = 1

  FIELDS = {
    NAME => {:type => ::Thrift::Types::STRING, :name => 'name'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class Database
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NAME = 1
  DESCRIPTION = 2
  LOCATIONURI = 3
  PARAMETERS = 4
  PRIVILEGES = 5
  OWNERNAME = 6
  OWNERTYPE = 7
  CATALOGNAME = 8
  CREATETIME = 9
  MANAGEDLOCATIONURI = 10

  FIELDS = {
    NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
    DESCRIPTION => {:type => ::Thrift::Types::STRING, :name => 'description'},
    LOCATIONURI => {:type => ::Thrift::Types::STRING, :name => 'locationUri'},
    PARAMETERS => {:type => ::Thrift::Types::MAP, :name => 'parameters', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}},
    PRIVILEGES => {:type => ::Thrift::Types::STRUCT, :name => 'privileges', :class => ::PrincipalPrivilegeSet, :optional => true},
    OWNERNAME => {:type => ::Thrift::Types::STRING, :name => 'ownerName', :optional => true},
    OWNERTYPE => {:type => ::Thrift::Types::I32, :name => 'ownerType', :optional => true, :enum_class => ::PrincipalType},
    CATALOGNAME => {:type => ::Thrift::Types::STRING, :name => 'catalogName', :optional => true},
    CREATETIME => {:type => ::Thrift::Types::I32, :name => 'createTime', :optional => true},
    MANAGEDLOCATIONURI => {:type => ::Thrift::Types::STRING, :name => 'managedLocationUri', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    unless @ownerType.nil? || ::PrincipalType::VALID_VALUES.include?(@ownerType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field ownerType!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class SerDeInfo
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NAME = 1
  SERIALIZATIONLIB = 2
  PARAMETERS = 3
  DESCRIPTION = 4
  SERIALIZERCLASS = 5
  DESERIALIZERCLASS = 6
  SERDETYPE = 7

  FIELDS = {
    NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
    SERIALIZATIONLIB => {:type => ::Thrift::Types::STRING, :name => 'serializationLib'},
    PARAMETERS => {:type => ::Thrift::Types::MAP, :name => 'parameters', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}},
    DESCRIPTION => {:type => ::Thrift::Types::STRING, :name => 'description', :optional => true},
    SERIALIZERCLASS => {:type => ::Thrift::Types::STRING, :name => 'serializerClass', :optional => true},
    DESERIALIZERCLASS => {:type => ::Thrift::Types::STRING, :name => 'deserializerClass', :optional => true},
    SERDETYPE => {:type => ::Thrift::Types::I32, :name => 'serdeType', :optional => true, :enum_class => ::SerdeType}
  }

  def struct_fields; FIELDS; end

  def validate
    unless @serdeType.nil? || ::SerdeType::VALID_VALUES.include?(@serdeType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field serdeType!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class Order
  include ::Thrift::Struct, ::Thrift::Struct_Union
  COL = 1
  ORDER = 2

  FIELDS = {
    COL => {:type => ::Thrift::Types::STRING, :name => 'col'},
    ORDER => {:type => ::Thrift::Types::I32, :name => 'order'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class SkewedInfo
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SKEWEDCOLNAMES = 1
  SKEWEDCOLVALUES = 2
  SKEWEDCOLVALUELOCATIONMAPS = 3

  FIELDS = {
    SKEWEDCOLNAMES => {:type => ::Thrift::Types::LIST, :name => 'skewedColNames', :element => {:type => ::Thrift::Types::STRING}},
    SKEWEDCOLVALUES => {:type => ::Thrift::Types::LIST, :name => 'skewedColValues', :element => {:type => ::Thrift::Types::LIST, :element => {:type => ::Thrift::Types::STRING}}},
    SKEWEDCOLVALUELOCATIONMAPS => {:type => ::Thrift::Types::MAP, :name => 'skewedColValueLocationMaps', :key => {:type => ::Thrift::Types::LIST, :element => {:type => ::Thrift::Types::STRING}}, :value => {:type => ::Thrift::Types::STRING}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class StorageDescriptor
  include ::Thrift::Struct, ::Thrift::Struct_Union
  COLS = 1
  LOCATION = 2
  INPUTFORMAT = 3
  OUTPUTFORMAT = 4
  COMPRESSED = 5
  NUMBUCKETS = 6
  SERDEINFO = 7
  BUCKETCOLS = 8
  SORTCOLS = 9
  PARAMETERS = 10
  SKEWEDINFO = 11
  STOREDASSUBDIRECTORIES = 12

  FIELDS = {
    COLS => {:type => ::Thrift::Types::LIST, :name => 'cols', :element => {:type => ::Thrift::Types::STRUCT, :class => ::FieldSchema}},
    LOCATION => {:type => ::Thrift::Types::STRING, :name => 'location'},
    INPUTFORMAT => {:type => ::Thrift::Types::STRING, :name => 'inputFormat'},
    OUTPUTFORMAT => {:type => ::Thrift::Types::STRING, :name => 'outputFormat'},
    COMPRESSED => {:type => ::Thrift::Types::BOOL, :name => 'compressed'},
    NUMBUCKETS => {:type => ::Thrift::Types::I32, :name => 'numBuckets'},
    SERDEINFO => {:type => ::Thrift::Types::STRUCT, :name => 'serdeInfo', :class => ::SerDeInfo},
    BUCKETCOLS => {:type => ::Thrift::Types::LIST, :name => 'bucketCols', :element => {:type => ::Thrift::Types::STRING}},
    SORTCOLS => {:type => ::Thrift::Types::LIST, :name => 'sortCols', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Order}},
    PARAMETERS => {:type => ::Thrift::Types::MAP, :name => 'parameters', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}},
    SKEWEDINFO => {:type => ::Thrift::Types::STRUCT, :name => 'skewedInfo', :class => ::SkewedInfo, :optional => true},
    STOREDASSUBDIRECTORIES => {:type => ::Thrift::Types::BOOL, :name => 'storedAsSubDirectories', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class CreationMetadata
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  DBNAME = 2
  TBLNAME = 3
  TABLESUSED = 4
  VALIDTXNLIST = 5
  MATERIALIZATIONTIME = 6

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName'},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TBLNAME => {:type => ::Thrift::Types::STRING, :name => 'tblName'},
    TABLESUSED => {:type => ::Thrift::Types::SET, :name => 'tablesUsed', :element => {:type => ::Thrift::Types::STRING}},
    VALIDTXNLIST => {:type => ::Thrift::Types::STRING, :name => 'validTxnList', :optional => true},
    MATERIALIZATIONTIME => {:type => ::Thrift::Types::I64, :name => 'materializationTime', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field catName is unset!') unless @catName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tblName is unset!') unless @tblName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tablesUsed is unset!') unless @tablesUsed
  end

  ::Thrift::Struct.generate_accessors self
end

class BooleanColumnStatsData
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NUMTRUES = 1
  NUMFALSES = 2
  NUMNULLS = 3
  BITVECTORS = 4

  FIELDS = {
    NUMTRUES => {:type => ::Thrift::Types::I64, :name => 'numTrues'},
    NUMFALSES => {:type => ::Thrift::Types::I64, :name => 'numFalses'},
    NUMNULLS => {:type => ::Thrift::Types::I64, :name => 'numNulls'},
    BITVECTORS => {:type => ::Thrift::Types::STRING, :name => 'bitVectors', :binary => true, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field numTrues is unset!') unless @numTrues
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field numFalses is unset!') unless @numFalses
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field numNulls is unset!') unless @numNulls
  end

  ::Thrift::Struct.generate_accessors self
end

class DoubleColumnStatsData
  include ::Thrift::Struct, ::Thrift::Struct_Union
  LOWVALUE = 1
  HIGHVALUE = 2
  NUMNULLS = 3
  NUMDVS = 4
  BITVECTORS = 5

  FIELDS = {
    LOWVALUE => {:type => ::Thrift::Types::DOUBLE, :name => 'lowValue', :optional => true},
    HIGHVALUE => {:type => ::Thrift::Types::DOUBLE, :name => 'highValue', :optional => true},
    NUMNULLS => {:type => ::Thrift::Types::I64, :name => 'numNulls'},
    NUMDVS => {:type => ::Thrift::Types::I64, :name => 'numDVs'},
    BITVECTORS => {:type => ::Thrift::Types::STRING, :name => 'bitVectors', :binary => true, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field numNulls is unset!') unless @numNulls
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field numDVs is unset!') unless @numDVs
  end

  ::Thrift::Struct.generate_accessors self
end

class LongColumnStatsData
  include ::Thrift::Struct, ::Thrift::Struct_Union
  LOWVALUE = 1
  HIGHVALUE = 2
  NUMNULLS = 3
  NUMDVS = 4
  BITVECTORS = 5

  FIELDS = {
    LOWVALUE => {:type => ::Thrift::Types::I64, :name => 'lowValue', :optional => true},
    HIGHVALUE => {:type => ::Thrift::Types::I64, :name => 'highValue', :optional => true},
    NUMNULLS => {:type => ::Thrift::Types::I64, :name => 'numNulls'},
    NUMDVS => {:type => ::Thrift::Types::I64, :name => 'numDVs'},
    BITVECTORS => {:type => ::Thrift::Types::STRING, :name => 'bitVectors', :binary => true, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field numNulls is unset!') unless @numNulls
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field numDVs is unset!') unless @numDVs
  end

  ::Thrift::Struct.generate_accessors self
end

class StringColumnStatsData
  include ::Thrift::Struct, ::Thrift::Struct_Union
  MAXCOLLEN = 1
  AVGCOLLEN = 2
  NUMNULLS = 3
  NUMDVS = 4
  BITVECTORS = 5

  FIELDS = {
    MAXCOLLEN => {:type => ::Thrift::Types::I64, :name => 'maxColLen'},
    AVGCOLLEN => {:type => ::Thrift::Types::DOUBLE, :name => 'avgColLen'},
    NUMNULLS => {:type => ::Thrift::Types::I64, :name => 'numNulls'},
    NUMDVS => {:type => ::Thrift::Types::I64, :name => 'numDVs'},
    BITVECTORS => {:type => ::Thrift::Types::STRING, :name => 'bitVectors', :binary => true, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field maxColLen is unset!') unless @maxColLen
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field avgColLen is unset!') unless @avgColLen
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field numNulls is unset!') unless @numNulls
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field numDVs is unset!') unless @numDVs
  end

  ::Thrift::Struct.generate_accessors self
end

class BinaryColumnStatsData
  include ::Thrift::Struct, ::Thrift::Struct_Union
  MAXCOLLEN = 1
  AVGCOLLEN = 2
  NUMNULLS = 3
  BITVECTORS = 4

  FIELDS = {
    MAXCOLLEN => {:type => ::Thrift::Types::I64, :name => 'maxColLen'},
    AVGCOLLEN => {:type => ::Thrift::Types::DOUBLE, :name => 'avgColLen'},
    NUMNULLS => {:type => ::Thrift::Types::I64, :name => 'numNulls'},
    BITVECTORS => {:type => ::Thrift::Types::STRING, :name => 'bitVectors', :binary => true, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field maxColLen is unset!') unless @maxColLen
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field avgColLen is unset!') unless @avgColLen
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field numNulls is unset!') unless @numNulls
  end

  ::Thrift::Struct.generate_accessors self
end

class Decimal
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SCALE = 3
  UNSCALED = 1

  FIELDS = {
    SCALE => {:type => ::Thrift::Types::I16, :name => 'scale'},
    UNSCALED => {:type => ::Thrift::Types::STRING, :name => 'unscaled', :binary => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field scale is unset!') unless @scale
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field unscaled is unset!') unless @unscaled
  end

  ::Thrift::Struct.generate_accessors self
end

class DecimalColumnStatsData
  include ::Thrift::Struct, ::Thrift::Struct_Union
  LOWVALUE = 1
  HIGHVALUE = 2
  NUMNULLS = 3
  NUMDVS = 4
  BITVECTORS = 5

  FIELDS = {
    LOWVALUE => {:type => ::Thrift::Types::STRUCT, :name => 'lowValue', :class => ::Decimal, :optional => true},
    HIGHVALUE => {:type => ::Thrift::Types::STRUCT, :name => 'highValue', :class => ::Decimal, :optional => true},
    NUMNULLS => {:type => ::Thrift::Types::I64, :name => 'numNulls'},
    NUMDVS => {:type => ::Thrift::Types::I64, :name => 'numDVs'},
    BITVECTORS => {:type => ::Thrift::Types::STRING, :name => 'bitVectors', :binary => true, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field numNulls is unset!') unless @numNulls
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field numDVs is unset!') unless @numDVs
  end

  ::Thrift::Struct.generate_accessors self
end

class Date
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DAYSSINCEEPOCH = 1

  FIELDS = {
    DAYSSINCEEPOCH => {:type => ::Thrift::Types::I64, :name => 'daysSinceEpoch'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field daysSinceEpoch is unset!') unless @daysSinceEpoch
  end

  ::Thrift::Struct.generate_accessors self
end

class DateColumnStatsData
  include ::Thrift::Struct, ::Thrift::Struct_Union
  LOWVALUE = 1
  HIGHVALUE = 2
  NUMNULLS = 3
  NUMDVS = 4
  BITVECTORS = 5

  FIELDS = {
    LOWVALUE => {:type => ::Thrift::Types::STRUCT, :name => 'lowValue', :class => ::Date, :optional => true},
    HIGHVALUE => {:type => ::Thrift::Types::STRUCT, :name => 'highValue', :class => ::Date, :optional => true},
    NUMNULLS => {:type => ::Thrift::Types::I64, :name => 'numNulls'},
    NUMDVS => {:type => ::Thrift::Types::I64, :name => 'numDVs'},
    BITVECTORS => {:type => ::Thrift::Types::STRING, :name => 'bitVectors', :binary => true, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field numNulls is unset!') unless @numNulls
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field numDVs is unset!') unless @numDVs
  end

  ::Thrift::Struct.generate_accessors self
end

class Timestamp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SECONDSSINCEEPOCH = 1

  FIELDS = {
    SECONDSSINCEEPOCH => {:type => ::Thrift::Types::I64, :name => 'secondsSinceEpoch'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field secondsSinceEpoch is unset!') unless @secondsSinceEpoch
  end

  ::Thrift::Struct.generate_accessors self
end

class TimestampColumnStatsData
  include ::Thrift::Struct, ::Thrift::Struct_Union
  LOWVALUE = 1
  HIGHVALUE = 2
  NUMNULLS = 3
  NUMDVS = 4
  BITVECTORS = 5

  FIELDS = {
    LOWVALUE => {:type => ::Thrift::Types::STRUCT, :name => 'lowValue', :class => ::Timestamp, :optional => true},
    HIGHVALUE => {:type => ::Thrift::Types::STRUCT, :name => 'highValue', :class => ::Timestamp, :optional => true},
    NUMNULLS => {:type => ::Thrift::Types::I64, :name => 'numNulls'},
    NUMDVS => {:type => ::Thrift::Types::I64, :name => 'numDVs'},
    BITVECTORS => {:type => ::Thrift::Types::STRING, :name => 'bitVectors', :binary => true, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field numNulls is unset!') unless @numNulls
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field numDVs is unset!') unless @numDVs
  end

  ::Thrift::Struct.generate_accessors self
end

class ColumnStatisticsData < ::Thrift::Union
  include ::Thrift::Struct_Union
  class << self
    def booleanStats(val)
      ColumnStatisticsData.new(:booleanStats, val)
    end

    def longStats(val)
      ColumnStatisticsData.new(:longStats, val)
    end

    def doubleStats(val)
      ColumnStatisticsData.new(:doubleStats, val)
    end

    def stringStats(val)
      ColumnStatisticsData.new(:stringStats, val)
    end

    def binaryStats(val)
      ColumnStatisticsData.new(:binaryStats, val)
    end

    def decimalStats(val)
      ColumnStatisticsData.new(:decimalStats, val)
    end

    def dateStats(val)
      ColumnStatisticsData.new(:dateStats, val)
    end

    def timestampStats(val)
      ColumnStatisticsData.new(:timestampStats, val)
    end
  end

  BOOLEANSTATS = 1
  LONGSTATS = 2
  DOUBLESTATS = 3
  STRINGSTATS = 4
  BINARYSTATS = 5
  DECIMALSTATS = 6
  DATESTATS = 7
  TIMESTAMPSTATS = 8

  FIELDS = {
    BOOLEANSTATS => {:type => ::Thrift::Types::STRUCT, :name => 'booleanStats', :class => ::BooleanColumnStatsData, :optional => true},
    LONGSTATS => {:type => ::Thrift::Types::STRUCT, :name => 'longStats', :class => ::LongColumnStatsData, :optional => true},
    DOUBLESTATS => {:type => ::Thrift::Types::STRUCT, :name => 'doubleStats', :class => ::DoubleColumnStatsData, :optional => true},
    STRINGSTATS => {:type => ::Thrift::Types::STRUCT, :name => 'stringStats', :class => ::StringColumnStatsData, :optional => true},
    BINARYSTATS => {:type => ::Thrift::Types::STRUCT, :name => 'binaryStats', :class => ::BinaryColumnStatsData, :optional => true},
    DECIMALSTATS => {:type => ::Thrift::Types::STRUCT, :name => 'decimalStats', :class => ::DecimalColumnStatsData, :optional => true},
    DATESTATS => {:type => ::Thrift::Types::STRUCT, :name => 'dateStats', :class => ::DateColumnStatsData, :optional => true},
    TIMESTAMPSTATS => {:type => ::Thrift::Types::STRUCT, :name => 'timestampStats', :class => ::TimestampColumnStatsData, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
  end

  ::Thrift::Union.generate_accessors self
end

class ColumnStatisticsObj
  include ::Thrift::Struct, ::Thrift::Struct_Union
  COLNAME = 1
  COLTYPE = 2
  STATSDATA = 3

  FIELDS = {
    COLNAME => {:type => ::Thrift::Types::STRING, :name => 'colName'},
    COLTYPE => {:type => ::Thrift::Types::STRING, :name => 'colType'},
    STATSDATA => {:type => ::Thrift::Types::STRUCT, :name => 'statsData', :class => ::ColumnStatisticsData}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field colName is unset!') unless @colName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field colType is unset!') unless @colType
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field statsData is unset!') unless @statsData
  end

  ::Thrift::Struct.generate_accessors self
end

class ColumnStatisticsDesc
  include ::Thrift::Struct, ::Thrift::Struct_Union
  ISTBLLEVEL = 1
  DBNAME = 2
  TABLENAME = 3
  PARTNAME = 4
  LASTANALYZED = 5
  CATNAME = 6

  FIELDS = {
    ISTBLLEVEL => {:type => ::Thrift::Types::BOOL, :name => 'isTblLevel'},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName'},
    PARTNAME => {:type => ::Thrift::Types::STRING, :name => 'partName', :optional => true},
    LASTANALYZED => {:type => ::Thrift::Types::I64, :name => 'lastAnalyzed', :optional => true},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field isTblLevel is unset!') if @isTblLevel.nil?
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tableName is unset!') unless @tableName
  end

  ::Thrift::Struct.generate_accessors self
end

class ColumnStatistics
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATSDESC = 1
  STATSOBJ = 2
  ISSTATSCOMPLIANT = 3
  ENGINE = 4

  FIELDS = {
    STATSDESC => {:type => ::Thrift::Types::STRUCT, :name => 'statsDesc', :class => ::ColumnStatisticsDesc},
    STATSOBJ => {:type => ::Thrift::Types::LIST, :name => 'statsObj', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ColumnStatisticsObj}},
    ISSTATSCOMPLIANT => {:type => ::Thrift::Types::BOOL, :name => 'isStatsCompliant', :optional => true},
    ENGINE => {:type => ::Thrift::Types::STRING, :name => 'engine', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field statsDesc is unset!') unless @statsDesc
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field statsObj is unset!') unless @statsObj
  end

  ::Thrift::Struct.generate_accessors self
end

class Table
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TABLENAME = 1
  DBNAME = 2
  OWNER = 3
  CREATETIME = 4
  LASTACCESSTIME = 5
  RETENTION = 6
  SD = 7
  PARTITIONKEYS = 8
  PARAMETERS = 9
  VIEWORIGINALTEXT = 10
  VIEWEXPANDEDTEXT = 11
  TABLETYPE = 12
  PRIVILEGES = 13
  TEMPORARY = 14
  REWRITEENABLED = 15
  CREATIONMETADATA = 16
  CATNAME = 17
  OWNERTYPE = 18
  WRITEID = 19
  ISSTATSCOMPLIANT = 20
  COLSTATS = 21
  ACCESSTYPE = 22
  REQUIREDREADCAPABILITIES = 23
  REQUIREDWRITECAPABILITIES = 24
  ID = 25

  FIELDS = {
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName'},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    OWNER => {:type => ::Thrift::Types::STRING, :name => 'owner'},
    CREATETIME => {:type => ::Thrift::Types::I32, :name => 'createTime'},
    LASTACCESSTIME => {:type => ::Thrift::Types::I32, :name => 'lastAccessTime'},
    RETENTION => {:type => ::Thrift::Types::I32, :name => 'retention'},
    SD => {:type => ::Thrift::Types::STRUCT, :name => 'sd', :class => ::StorageDescriptor},
    PARTITIONKEYS => {:type => ::Thrift::Types::LIST, :name => 'partitionKeys', :element => {:type => ::Thrift::Types::STRUCT, :class => ::FieldSchema}},
    PARAMETERS => {:type => ::Thrift::Types::MAP, :name => 'parameters', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}},
    VIEWORIGINALTEXT => {:type => ::Thrift::Types::STRING, :name => 'viewOriginalText'},
    VIEWEXPANDEDTEXT => {:type => ::Thrift::Types::STRING, :name => 'viewExpandedText'},
    TABLETYPE => {:type => ::Thrift::Types::STRING, :name => 'tableType'},
    PRIVILEGES => {:type => ::Thrift::Types::STRUCT, :name => 'privileges', :class => ::PrincipalPrivilegeSet, :optional => true},
    TEMPORARY => {:type => ::Thrift::Types::BOOL, :name => 'temporary', :default => false, :optional => true},
    REWRITEENABLED => {:type => ::Thrift::Types::BOOL, :name => 'rewriteEnabled', :optional => true},
    CREATIONMETADATA => {:type => ::Thrift::Types::STRUCT, :name => 'creationMetadata', :class => ::CreationMetadata, :optional => true},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true},
    OWNERTYPE => {:type => ::Thrift::Types::I32, :name => 'ownerType', :default =>     1, :optional => true, :enum_class => ::PrincipalType},
    WRITEID => {:type => ::Thrift::Types::I64, :name => 'writeId', :default => -1, :optional => true},
    ISSTATSCOMPLIANT => {:type => ::Thrift::Types::BOOL, :name => 'isStatsCompliant', :optional => true},
    COLSTATS => {:type => ::Thrift::Types::STRUCT, :name => 'colStats', :class => ::ColumnStatistics, :optional => true},
    ACCESSTYPE => {:type => ::Thrift::Types::BYTE, :name => 'accessType', :optional => true},
    REQUIREDREADCAPABILITIES => {:type => ::Thrift::Types::LIST, :name => 'requiredReadCapabilities', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    REQUIREDWRITECAPABILITIES => {:type => ::Thrift::Types::LIST, :name => 'requiredWriteCapabilities', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    ID => {:type => ::Thrift::Types::I64, :name => 'id', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    unless @ownerType.nil? || ::PrincipalType::VALID_VALUES.include?(@ownerType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field ownerType!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class Partition
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUES = 1
  DBNAME = 2
  TABLENAME = 3
  CREATETIME = 4
  LASTACCESSTIME = 5
  SD = 6
  PARAMETERS = 7
  PRIVILEGES = 8
  CATNAME = 9
  WRITEID = 10
  ISSTATSCOMPLIANT = 11
  COLSTATS = 12

  FIELDS = {
    VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::STRING}},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName'},
    CREATETIME => {:type => ::Thrift::Types::I32, :name => 'createTime'},
    LASTACCESSTIME => {:type => ::Thrift::Types::I32, :name => 'lastAccessTime'},
    SD => {:type => ::Thrift::Types::STRUCT, :name => 'sd', :class => ::StorageDescriptor},
    PARAMETERS => {:type => ::Thrift::Types::MAP, :name => 'parameters', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}},
    PRIVILEGES => {:type => ::Thrift::Types::STRUCT, :name => 'privileges', :class => ::PrincipalPrivilegeSet, :optional => true},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true},
    WRITEID => {:type => ::Thrift::Types::I64, :name => 'writeId', :default => -1, :optional => true},
    ISSTATSCOMPLIANT => {:type => ::Thrift::Types::BOOL, :name => 'isStatsCompliant', :optional => true},
    COLSTATS => {:type => ::Thrift::Types::STRUCT, :name => 'colStats', :class => ::ColumnStatistics, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class PartitionWithoutSD
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUES = 1
  CREATETIME = 2
  LASTACCESSTIME = 3
  RELATIVEPATH = 4
  PARAMETERS = 5
  PRIVILEGES = 6

  FIELDS = {
    VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::STRING}},
    CREATETIME => {:type => ::Thrift::Types::I32, :name => 'createTime'},
    LASTACCESSTIME => {:type => ::Thrift::Types::I32, :name => 'lastAccessTime'},
    RELATIVEPATH => {:type => ::Thrift::Types::STRING, :name => 'relativePath'},
    PARAMETERS => {:type => ::Thrift::Types::MAP, :name => 'parameters', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}},
    PRIVILEGES => {:type => ::Thrift::Types::STRUCT, :name => 'privileges', :class => ::PrincipalPrivilegeSet, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class PartitionSpecWithSharedSD
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PARTITIONS = 1
  SD = 2

  FIELDS = {
    PARTITIONS => {:type => ::Thrift::Types::LIST, :name => 'partitions', :element => {:type => ::Thrift::Types::STRUCT, :class => ::PartitionWithoutSD}},
    SD => {:type => ::Thrift::Types::STRUCT, :name => 'sd', :class => ::StorageDescriptor}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class PartitionListComposingSpec
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PARTITIONS = 1

  FIELDS = {
    PARTITIONS => {:type => ::Thrift::Types::LIST, :name => 'partitions', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Partition}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class PartitionSpec
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DBNAME = 1
  TABLENAME = 2
  ROOTPATH = 3
  SHAREDSDPARTITIONSPEC = 4
  PARTITIONLIST = 5
  CATNAME = 6
  WRITEID = 7
  ISSTATSCOMPLIANT = 8

  FIELDS = {
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName'},
    ROOTPATH => {:type => ::Thrift::Types::STRING, :name => 'rootPath'},
    SHAREDSDPARTITIONSPEC => {:type => ::Thrift::Types::STRUCT, :name => 'sharedSDPartitionSpec', :class => ::PartitionSpecWithSharedSD, :optional => true},
    PARTITIONLIST => {:type => ::Thrift::Types::STRUCT, :name => 'partitionList', :class => ::PartitionListComposingSpec, :optional => true},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true},
    WRITEID => {:type => ::Thrift::Types::I64, :name => 'writeId', :default => -1, :optional => true},
    ISSTATSCOMPLIANT => {:type => ::Thrift::Types::BOOL, :name => 'isStatsCompliant', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class AggrStats
  include ::Thrift::Struct, ::Thrift::Struct_Union
  COLSTATS = 1
  PARTSFOUND = 2
  ISSTATSCOMPLIANT = 3

  FIELDS = {
    COLSTATS => {:type => ::Thrift::Types::LIST, :name => 'colStats', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ColumnStatisticsObj}},
    PARTSFOUND => {:type => ::Thrift::Types::I64, :name => 'partsFound'},
    ISSTATSCOMPLIANT => {:type => ::Thrift::Types::BOOL, :name => 'isStatsCompliant', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field colStats is unset!') unless @colStats
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field partsFound is unset!') unless @partsFound
  end

  ::Thrift::Struct.generate_accessors self
end

class SetPartitionsStatsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  COLSTATS = 1
  NEEDMERGE = 2
  WRITEID = 3
  VALIDWRITEIDLIST = 4
  ENGINE = 5

  FIELDS = {
    COLSTATS => {:type => ::Thrift::Types::LIST, :name => 'colStats', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ColumnStatistics}},
    NEEDMERGE => {:type => ::Thrift::Types::BOOL, :name => 'needMerge', :optional => true},
    WRITEID => {:type => ::Thrift::Types::I64, :name => 'writeId', :default => -1, :optional => true},
    VALIDWRITEIDLIST => {:type => ::Thrift::Types::STRING, :name => 'validWriteIdList', :optional => true},
    ENGINE => {:type => ::Thrift::Types::STRING, :name => 'engine'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field colStats is unset!') unless @colStats
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field engine is unset!') unless @engine
  end

  ::Thrift::Struct.generate_accessors self
end

class SetPartitionsStatsResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RESULT = 1

  FIELDS = {
    RESULT => {:type => ::Thrift::Types::BOOL, :name => 'result'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field result is unset!') if @result.nil?
  end

  ::Thrift::Struct.generate_accessors self
end

class Schema
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FIELDSCHEMAS = 1
  PROPERTIES = 2

  FIELDS = {
    FIELDSCHEMAS => {:type => ::Thrift::Types::LIST, :name => 'fieldSchemas', :element => {:type => ::Thrift::Types::STRUCT, :class => ::FieldSchema}},
    PROPERTIES => {:type => ::Thrift::Types::MAP, :name => 'properties', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class EnvironmentContext
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PROPERTIES = 1

  FIELDS = {
    PROPERTIES => {:type => ::Thrift::Types::MAP, :name => 'properties', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class PrimaryKeysRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DB_NAME = 1
  TBL_NAME = 2
  CATNAME = 3

  FIELDS = {
    DB_NAME => {:type => ::Thrift::Types::STRING, :name => 'db_name'},
    TBL_NAME => {:type => ::Thrift::Types::STRING, :name => 'tbl_name'},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field db_name is unset!') unless @db_name
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tbl_name is unset!') unless @tbl_name
  end

  ::Thrift::Struct.generate_accessors self
end

class PrimaryKeysResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PRIMARYKEYS = 1

  FIELDS = {
    PRIMARYKEYS => {:type => ::Thrift::Types::LIST, :name => 'primaryKeys', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLPrimaryKey}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field primaryKeys is unset!') unless @primaryKeys
  end

  ::Thrift::Struct.generate_accessors self
end

class ForeignKeysRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PARENT_DB_NAME = 1
  PARENT_TBL_NAME = 2
  FOREIGN_DB_NAME = 3
  FOREIGN_TBL_NAME = 4
  CATNAME = 5

  FIELDS = {
    PARENT_DB_NAME => {:type => ::Thrift::Types::STRING, :name => 'parent_db_name'},
    PARENT_TBL_NAME => {:type => ::Thrift::Types::STRING, :name => 'parent_tbl_name'},
    FOREIGN_DB_NAME => {:type => ::Thrift::Types::STRING, :name => 'foreign_db_name'},
    FOREIGN_TBL_NAME => {:type => ::Thrift::Types::STRING, :name => 'foreign_tbl_name'},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class ForeignKeysResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FOREIGNKEYS = 1

  FIELDS = {
    FOREIGNKEYS => {:type => ::Thrift::Types::LIST, :name => 'foreignKeys', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLForeignKey}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field foreignKeys is unset!') unless @foreignKeys
  end

  ::Thrift::Struct.generate_accessors self
end

class UniqueConstraintsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  DB_NAME = 2
  TBL_NAME = 3

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName'},
    DB_NAME => {:type => ::Thrift::Types::STRING, :name => 'db_name'},
    TBL_NAME => {:type => ::Thrift::Types::STRING, :name => 'tbl_name'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field catName is unset!') unless @catName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field db_name is unset!') unless @db_name
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tbl_name is unset!') unless @tbl_name
  end

  ::Thrift::Struct.generate_accessors self
end

class UniqueConstraintsResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  UNIQUECONSTRAINTS = 1

  FIELDS = {
    UNIQUECONSTRAINTS => {:type => ::Thrift::Types::LIST, :name => 'uniqueConstraints', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLUniqueConstraint}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field uniqueConstraints is unset!') unless @uniqueConstraints
  end

  ::Thrift::Struct.generate_accessors self
end

class NotNullConstraintsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  DB_NAME = 2
  TBL_NAME = 3

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName'},
    DB_NAME => {:type => ::Thrift::Types::STRING, :name => 'db_name'},
    TBL_NAME => {:type => ::Thrift::Types::STRING, :name => 'tbl_name'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field catName is unset!') unless @catName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field db_name is unset!') unless @db_name
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tbl_name is unset!') unless @tbl_name
  end

  ::Thrift::Struct.generate_accessors self
end

class NotNullConstraintsResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NOTNULLCONSTRAINTS = 1

  FIELDS = {
    NOTNULLCONSTRAINTS => {:type => ::Thrift::Types::LIST, :name => 'notNullConstraints', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLNotNullConstraint}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field notNullConstraints is unset!') unless @notNullConstraints
  end

  ::Thrift::Struct.generate_accessors self
end

class DefaultConstraintsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  DB_NAME = 2
  TBL_NAME = 3

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName'},
    DB_NAME => {:type => ::Thrift::Types::STRING, :name => 'db_name'},
    TBL_NAME => {:type => ::Thrift::Types::STRING, :name => 'tbl_name'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field catName is unset!') unless @catName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field db_name is unset!') unless @db_name
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tbl_name is unset!') unless @tbl_name
  end

  ::Thrift::Struct.generate_accessors self
end

class DefaultConstraintsResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DEFAULTCONSTRAINTS = 1

  FIELDS = {
    DEFAULTCONSTRAINTS => {:type => ::Thrift::Types::LIST, :name => 'defaultConstraints', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLDefaultConstraint}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field defaultConstraints is unset!') unless @defaultConstraints
  end

  ::Thrift::Struct.generate_accessors self
end

class CheckConstraintsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  DB_NAME = 2
  TBL_NAME = 3

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName'},
    DB_NAME => {:type => ::Thrift::Types::STRING, :name => 'db_name'},
    TBL_NAME => {:type => ::Thrift::Types::STRING, :name => 'tbl_name'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field catName is unset!') unless @catName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field db_name is unset!') unless @db_name
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tbl_name is unset!') unless @tbl_name
  end

  ::Thrift::Struct.generate_accessors self
end

class CheckConstraintsResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CHECKCONSTRAINTS = 1

  FIELDS = {
    CHECKCONSTRAINTS => {:type => ::Thrift::Types::LIST, :name => 'checkConstraints', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLCheckConstraint}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field checkConstraints is unset!') unless @checkConstraints
  end

  ::Thrift::Struct.generate_accessors self
end

class AllTableConstraintsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DBNAME = 1
  TBLNAME = 2
  CATNAME = 3

  FIELDS = {
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TBLNAME => {:type => ::Thrift::Types::STRING, :name => 'tblName'},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tblName is unset!') unless @tblName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field catName is unset!') unless @catName
  end

  ::Thrift::Struct.generate_accessors self
end

class AllTableConstraintsResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  ALLTABLECONSTRAINTS = 1

  FIELDS = {
    ALLTABLECONSTRAINTS => {:type => ::Thrift::Types::STRUCT, :name => 'allTableConstraints', :class => ::SQLAllTableConstraints}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field allTableConstraints is unset!') unless @allTableConstraints
  end

  ::Thrift::Struct.generate_accessors self
end

class DropConstraintRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DBNAME = 1
  TABLENAME = 2
  CONSTRAINTNAME = 3
  CATNAME = 4

  FIELDS = {
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbname'},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tablename'},
    CONSTRAINTNAME => {:type => ::Thrift::Types::STRING, :name => 'constraintname'},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbname is unset!') unless @dbname
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tablename is unset!') unless @tablename
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field constraintname is unset!') unless @constraintname
  end

  ::Thrift::Struct.generate_accessors self
end

class AddPrimaryKeyRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PRIMARYKEYCOLS = 1

  FIELDS = {
    PRIMARYKEYCOLS => {:type => ::Thrift::Types::LIST, :name => 'primaryKeyCols', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLPrimaryKey}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field primaryKeyCols is unset!') unless @primaryKeyCols
  end

  ::Thrift::Struct.generate_accessors self
end

class AddForeignKeyRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FOREIGNKEYCOLS = 1

  FIELDS = {
    FOREIGNKEYCOLS => {:type => ::Thrift::Types::LIST, :name => 'foreignKeyCols', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLForeignKey}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field foreignKeyCols is unset!') unless @foreignKeyCols
  end

  ::Thrift::Struct.generate_accessors self
end

class AddUniqueConstraintRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  UNIQUECONSTRAINTCOLS = 1

  FIELDS = {
    UNIQUECONSTRAINTCOLS => {:type => ::Thrift::Types::LIST, :name => 'uniqueConstraintCols', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLUniqueConstraint}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field uniqueConstraintCols is unset!') unless @uniqueConstraintCols
  end

  ::Thrift::Struct.generate_accessors self
end

class AddNotNullConstraintRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NOTNULLCONSTRAINTCOLS = 1

  FIELDS = {
    NOTNULLCONSTRAINTCOLS => {:type => ::Thrift::Types::LIST, :name => 'notNullConstraintCols', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLNotNullConstraint}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field notNullConstraintCols is unset!') unless @notNullConstraintCols
  end

  ::Thrift::Struct.generate_accessors self
end

class AddDefaultConstraintRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DEFAULTCONSTRAINTCOLS = 1

  FIELDS = {
    DEFAULTCONSTRAINTCOLS => {:type => ::Thrift::Types::LIST, :name => 'defaultConstraintCols', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLDefaultConstraint}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field defaultConstraintCols is unset!') unless @defaultConstraintCols
  end

  ::Thrift::Struct.generate_accessors self
end

class AddCheckConstraintRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CHECKCONSTRAINTCOLS = 1

  FIELDS = {
    CHECKCONSTRAINTCOLS => {:type => ::Thrift::Types::LIST, :name => 'checkConstraintCols', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLCheckConstraint}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field checkConstraintCols is unset!') unless @checkConstraintCols
  end

  ::Thrift::Struct.generate_accessors self
end

class PartitionsByExprResult
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PARTITIONS = 1
  HASUNKNOWNPARTITIONS = 2

  FIELDS = {
    PARTITIONS => {:type => ::Thrift::Types::LIST, :name => 'partitions', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Partition}},
    HASUNKNOWNPARTITIONS => {:type => ::Thrift::Types::BOOL, :name => 'hasUnknownPartitions'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field partitions is unset!') unless @partitions
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field hasUnknownPartitions is unset!') if @hasUnknownPartitions.nil?
  end

  ::Thrift::Struct.generate_accessors self
end

class PartitionsSpecByExprResult
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PARTITIONSSPEC = 1
  HASUNKNOWNPARTITIONS = 2

  FIELDS = {
    PARTITIONSSPEC => {:type => ::Thrift::Types::LIST, :name => 'partitionsSpec', :element => {:type => ::Thrift::Types::STRUCT, :class => ::PartitionSpec}},
    HASUNKNOWNPARTITIONS => {:type => ::Thrift::Types::BOOL, :name => 'hasUnknownPartitions'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field partitionsSpec is unset!') unless @partitionsSpec
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field hasUnknownPartitions is unset!') if @hasUnknownPartitions.nil?
  end

  ::Thrift::Struct.generate_accessors self
end

class PartitionsByExprRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DBNAME = 1
  TBLNAME = 2
  EXPR = 3
  DEFAULTPARTITIONNAME = 4
  MAXPARTS = 5
  CATNAME = 6
  ORDER = 7
  VALIDWRITEIDLIST = 8
  ID = 9

  FIELDS = {
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TBLNAME => {:type => ::Thrift::Types::STRING, :name => 'tblName'},
    EXPR => {:type => ::Thrift::Types::STRING, :name => 'expr', :binary => true},
    DEFAULTPARTITIONNAME => {:type => ::Thrift::Types::STRING, :name => 'defaultPartitionName', :optional => true},
    MAXPARTS => {:type => ::Thrift::Types::I16, :name => 'maxParts', :default => -1, :optional => true},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true},
    ORDER => {:type => ::Thrift::Types::STRING, :name => 'order', :optional => true},
    VALIDWRITEIDLIST => {:type => ::Thrift::Types::STRING, :name => 'validWriteIdList', :optional => true},
    ID => {:type => ::Thrift::Types::I64, :name => 'id', :default => -1, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tblName is unset!') unless @tblName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field expr is unset!') unless @expr
  end

  ::Thrift::Struct.generate_accessors self
end

class TableStatsResult
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TABLESTATS = 1
  ISSTATSCOMPLIANT = 2

  FIELDS = {
    TABLESTATS => {:type => ::Thrift::Types::LIST, :name => 'tableStats', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ColumnStatisticsObj}},
    ISSTATSCOMPLIANT => {:type => ::Thrift::Types::BOOL, :name => 'isStatsCompliant', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tableStats is unset!') unless @tableStats
  end

  ::Thrift::Struct.generate_accessors self
end

class PartitionsStatsResult
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PARTSTATS = 1
  ISSTATSCOMPLIANT = 2

  FIELDS = {
    PARTSTATS => {:type => ::Thrift::Types::MAP, :name => 'partStats', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::LIST, :element => {:type => ::Thrift::Types::STRUCT, :class => ::ColumnStatisticsObj}}},
    ISSTATSCOMPLIANT => {:type => ::Thrift::Types::BOOL, :name => 'isStatsCompliant', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field partStats is unset!') unless @partStats
  end

  ::Thrift::Struct.generate_accessors self
end

class TableStatsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DBNAME = 1
  TBLNAME = 2
  COLNAMES = 3
  CATNAME = 4
  VALIDWRITEIDLIST = 5
  ENGINE = 6
  ID = 7

  FIELDS = {
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TBLNAME => {:type => ::Thrift::Types::STRING, :name => 'tblName'},
    COLNAMES => {:type => ::Thrift::Types::LIST, :name => 'colNames', :element => {:type => ::Thrift::Types::STRING}},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true},
    VALIDWRITEIDLIST => {:type => ::Thrift::Types::STRING, :name => 'validWriteIdList', :optional => true},
    ENGINE => {:type => ::Thrift::Types::STRING, :name => 'engine'},
    ID => {:type => ::Thrift::Types::I64, :name => 'id', :default => -1, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tblName is unset!') unless @tblName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field colNames is unset!') unless @colNames
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field engine is unset!') unless @engine
  end

  ::Thrift::Struct.generate_accessors self
end

class PartitionsStatsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DBNAME = 1
  TBLNAME = 2
  COLNAMES = 3
  PARTNAMES = 4
  CATNAME = 5
  VALIDWRITEIDLIST = 6
  ENGINE = 7

  FIELDS = {
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TBLNAME => {:type => ::Thrift::Types::STRING, :name => 'tblName'},
    COLNAMES => {:type => ::Thrift::Types::LIST, :name => 'colNames', :element => {:type => ::Thrift::Types::STRING}},
    PARTNAMES => {:type => ::Thrift::Types::LIST, :name => 'partNames', :element => {:type => ::Thrift::Types::STRING}},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true},
    VALIDWRITEIDLIST => {:type => ::Thrift::Types::STRING, :name => 'validWriteIdList', :optional => true},
    ENGINE => {:type => ::Thrift::Types::STRING, :name => 'engine'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tblName is unset!') unless @tblName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field colNames is unset!') unless @colNames
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field partNames is unset!') unless @partNames
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field engine is unset!') unless @engine
  end

  ::Thrift::Struct.generate_accessors self
end

class AddPartitionsResult
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PARTITIONS = 1
  ISSTATSCOMPLIANT = 2

  FIELDS = {
    PARTITIONS => {:type => ::Thrift::Types::LIST, :name => 'partitions', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Partition}, :optional => true},
    ISSTATSCOMPLIANT => {:type => ::Thrift::Types::BOOL, :name => 'isStatsCompliant', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class AddPartitionsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DBNAME = 1
  TBLNAME = 2
  PARTS = 3
  IFNOTEXISTS = 4
  NEEDRESULT = 5
  CATNAME = 6
  VALIDWRITEIDLIST = 7

  FIELDS = {
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TBLNAME => {:type => ::Thrift::Types::STRING, :name => 'tblName'},
    PARTS => {:type => ::Thrift::Types::LIST, :name => 'parts', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Partition}},
    IFNOTEXISTS => {:type => ::Thrift::Types::BOOL, :name => 'ifNotExists'},
    NEEDRESULT => {:type => ::Thrift::Types::BOOL, :name => 'needResult', :default => true, :optional => true},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true},
    VALIDWRITEIDLIST => {:type => ::Thrift::Types::STRING, :name => 'validWriteIdList', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tblName is unset!') unless @tblName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field parts is unset!') unless @parts
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ifNotExists is unset!') if @ifNotExists.nil?
  end

  ::Thrift::Struct.generate_accessors self
end

class DropPartitionsResult
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PARTITIONS = 1

  FIELDS = {
    PARTITIONS => {:type => ::Thrift::Types::LIST, :name => 'partitions', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Partition}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class DropPartitionsExpr
  include ::Thrift::Struct, ::Thrift::Struct_Union
  EXPR = 1
  PARTARCHIVELEVEL = 2

  FIELDS = {
    EXPR => {:type => ::Thrift::Types::STRING, :name => 'expr', :binary => true},
    PARTARCHIVELEVEL => {:type => ::Thrift::Types::I32, :name => 'partArchiveLevel', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field expr is unset!') unless @expr
  end

  ::Thrift::Struct.generate_accessors self
end

class RequestPartsSpec < ::Thrift::Union
  include ::Thrift::Struct_Union
  class << self
    def names(val)
      RequestPartsSpec.new(:names, val)
    end

    def exprs(val)
      RequestPartsSpec.new(:exprs, val)
    end
  end

  NAMES = 1
  EXPRS = 2

  FIELDS = {
    NAMES => {:type => ::Thrift::Types::LIST, :name => 'names', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    EXPRS => {:type => ::Thrift::Types::LIST, :name => 'exprs', :element => {:type => ::Thrift::Types::STRUCT, :class => ::DropPartitionsExpr}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
  end

  ::Thrift::Union.generate_accessors self
end

class DropPartitionsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DBNAME = 1
  TBLNAME = 2
  PARTS = 3
  DELETEDATA = 4
  IFEXISTS = 5
  IGNOREPROTECTION = 6
  ENVIRONMENTCONTEXT = 7
  NEEDRESULT = 8
  CATNAME = 9

  FIELDS = {
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TBLNAME => {:type => ::Thrift::Types::STRING, :name => 'tblName'},
    PARTS => {:type => ::Thrift::Types::STRUCT, :name => 'parts', :class => ::RequestPartsSpec},
    DELETEDATA => {:type => ::Thrift::Types::BOOL, :name => 'deleteData', :optional => true},
    IFEXISTS => {:type => ::Thrift::Types::BOOL, :name => 'ifExists', :default => true, :optional => true},
    IGNOREPROTECTION => {:type => ::Thrift::Types::BOOL, :name => 'ignoreProtection', :optional => true},
    ENVIRONMENTCONTEXT => {:type => ::Thrift::Types::STRUCT, :name => 'environmentContext', :class => ::EnvironmentContext, :optional => true},
    NEEDRESULT => {:type => ::Thrift::Types::BOOL, :name => 'needResult', :default => true, :optional => true},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tblName is unset!') unless @tblName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field parts is unset!') unless @parts
  end

  ::Thrift::Struct.generate_accessors self
end

class PartitionValuesRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DBNAME = 1
  TBLNAME = 2
  PARTITIONKEYS = 3
  APPLYDISTINCT = 4
  FILTER = 5
  PARTITIONORDER = 6
  ASCENDING = 7
  MAXPARTS = 8
  CATNAME = 9
  VALIDWRITEIDLIST = 10

  FIELDS = {
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TBLNAME => {:type => ::Thrift::Types::STRING, :name => 'tblName'},
    PARTITIONKEYS => {:type => ::Thrift::Types::LIST, :name => 'partitionKeys', :element => {:type => ::Thrift::Types::STRUCT, :class => ::FieldSchema}},
    APPLYDISTINCT => {:type => ::Thrift::Types::BOOL, :name => 'applyDistinct', :default => true, :optional => true},
    FILTER => {:type => ::Thrift::Types::STRING, :name => 'filter', :optional => true},
    PARTITIONORDER => {:type => ::Thrift::Types::LIST, :name => 'partitionOrder', :element => {:type => ::Thrift::Types::STRUCT, :class => ::FieldSchema}, :optional => true},
    ASCENDING => {:type => ::Thrift::Types::BOOL, :name => 'ascending', :default => true, :optional => true},
    MAXPARTS => {:type => ::Thrift::Types::I64, :name => 'maxParts', :default => -1, :optional => true},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true},
    VALIDWRITEIDLIST => {:type => ::Thrift::Types::STRING, :name => 'validWriteIdList', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tblName is unset!') unless @tblName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field partitionKeys is unset!') unless @partitionKeys
  end

  ::Thrift::Struct.generate_accessors self
end

class PartitionValuesRow
  include ::Thrift::Struct, ::Thrift::Struct_Union
  ROW = 1

  FIELDS = {
    ROW => {:type => ::Thrift::Types::LIST, :name => 'row', :element => {:type => ::Thrift::Types::STRING}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field row is unset!') unless @row
  end

  ::Thrift::Struct.generate_accessors self
end

class PartitionValuesResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PARTITIONVALUES = 1

  FIELDS = {
    PARTITIONVALUES => {:type => ::Thrift::Types::LIST, :name => 'partitionValues', :element => {:type => ::Thrift::Types::STRUCT, :class => ::PartitionValuesRow}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field partitionValues is unset!') unless @partitionValues
  end

  ::Thrift::Struct.generate_accessors self
end

class GetPartitionsByNamesRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DB_NAME = 1
  TBL_NAME = 2
  NAMES = 3
  GET_COL_STATS = 4
  PROCESSORCAPABILITIES = 5
  PROCESSORIDENTIFIER = 6
  ENGINE = 7
  VALIDWRITEIDLIST = 8

  FIELDS = {
    DB_NAME => {:type => ::Thrift::Types::STRING, :name => 'db_name'},
    TBL_NAME => {:type => ::Thrift::Types::STRING, :name => 'tbl_name'},
    NAMES => {:type => ::Thrift::Types::LIST, :name => 'names', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    GET_COL_STATS => {:type => ::Thrift::Types::BOOL, :name => 'get_col_stats', :optional => true},
    PROCESSORCAPABILITIES => {:type => ::Thrift::Types::LIST, :name => 'processorCapabilities', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    PROCESSORIDENTIFIER => {:type => ::Thrift::Types::STRING, :name => 'processorIdentifier', :optional => true},
    ENGINE => {:type => ::Thrift::Types::STRING, :name => 'engine', :optional => true},
    VALIDWRITEIDLIST => {:type => ::Thrift::Types::STRING, :name => 'validWriteIdList', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field db_name is unset!') unless @db_name
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tbl_name is unset!') unless @tbl_name
  end

  ::Thrift::Struct.generate_accessors self
end

class GetPartitionsByNamesResult
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PARTITIONS = 1

  FIELDS = {
    PARTITIONS => {:type => ::Thrift::Types::LIST, :name => 'partitions', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Partition}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field partitions is unset!') unless @partitions
  end

  ::Thrift::Struct.generate_accessors self
end

class ResourceUri
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RESOURCETYPE = 1
  URI = 2

  FIELDS = {
    RESOURCETYPE => {:type => ::Thrift::Types::I32, :name => 'resourceType', :enum_class => ::ResourceType},
    URI => {:type => ::Thrift::Types::STRING, :name => 'uri'}
  }

  def struct_fields; FIELDS; end

  def validate
    unless @resourceType.nil? || ::ResourceType::VALID_VALUES.include?(@resourceType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field resourceType!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class Function
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FUNCTIONNAME = 1
  DBNAME = 2
  CLASSNAME = 3
  OWNERNAME = 4
  OWNERTYPE = 5
  CREATETIME = 6
  FUNCTIONTYPE = 7
  RESOURCEURIS = 8
  CATNAME = 9

  FIELDS = {
    FUNCTIONNAME => {:type => ::Thrift::Types::STRING, :name => 'functionName'},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    CLASSNAME => {:type => ::Thrift::Types::STRING, :name => 'className'},
    OWNERNAME => {:type => ::Thrift::Types::STRING, :name => 'ownerName'},
    OWNERTYPE => {:type => ::Thrift::Types::I32, :name => 'ownerType', :enum_class => ::PrincipalType},
    CREATETIME => {:type => ::Thrift::Types::I32, :name => 'createTime'},
    FUNCTIONTYPE => {:type => ::Thrift::Types::I32, :name => 'functionType', :enum_class => ::FunctionType},
    RESOURCEURIS => {:type => ::Thrift::Types::LIST, :name => 'resourceUris', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ResourceUri}},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    unless @ownerType.nil? || ::PrincipalType::VALID_VALUES.include?(@ownerType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field ownerType!')
    end
    unless @functionType.nil? || ::FunctionType::VALID_VALUES.include?(@functionType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field functionType!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class TxnInfo
  include ::Thrift::Struct, ::Thrift::Struct_Union
  ID = 1
  STATE = 2
  USER = 3
  HOSTNAME = 4
  AGENTINFO = 5
  HEARTBEATCOUNT = 6
  METAINFO = 7
  STARTEDTIME = 8
  LASTHEARTBEATTIME = 9

  FIELDS = {
    ID => {:type => ::Thrift::Types::I64, :name => 'id'},
    STATE => {:type => ::Thrift::Types::I32, :name => 'state', :enum_class => ::TxnState},
    USER => {:type => ::Thrift::Types::STRING, :name => 'user'},
    HOSTNAME => {:type => ::Thrift::Types::STRING, :name => 'hostname'},
    AGENTINFO => {:type => ::Thrift::Types::STRING, :name => 'agentInfo', :default => %q"Unknown", :optional => true},
    HEARTBEATCOUNT => {:type => ::Thrift::Types::I32, :name => 'heartbeatCount', :default => 0, :optional => true},
    METAINFO => {:type => ::Thrift::Types::STRING, :name => 'metaInfo', :optional => true},
    STARTEDTIME => {:type => ::Thrift::Types::I64, :name => 'startedTime', :optional => true},
    LASTHEARTBEATTIME => {:type => ::Thrift::Types::I64, :name => 'lastHeartbeatTime', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id is unset!') unless @id
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field state is unset!') unless @state
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field user is unset!') unless @user
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field hostname is unset!') unless @hostname
    unless @state.nil? || ::TxnState::VALID_VALUES.include?(@state)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field state!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class GetOpenTxnsInfoResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TXN_HIGH_WATER_MARK = 1
  OPEN_TXNS = 2

  FIELDS = {
    TXN_HIGH_WATER_MARK => {:type => ::Thrift::Types::I64, :name => 'txn_high_water_mark'},
    OPEN_TXNS => {:type => ::Thrift::Types::LIST, :name => 'open_txns', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TxnInfo}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field txn_high_water_mark is unset!') unless @txn_high_water_mark
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field open_txns is unset!') unless @open_txns
  end

  ::Thrift::Struct.generate_accessors self
end

class GetOpenTxnsResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TXN_HIGH_WATER_MARK = 1
  OPEN_TXNS = 2
  MIN_OPEN_TXN = 3
  ABORTEDBITS = 4

  FIELDS = {
    TXN_HIGH_WATER_MARK => {:type => ::Thrift::Types::I64, :name => 'txn_high_water_mark'},
    OPEN_TXNS => {:type => ::Thrift::Types::LIST, :name => 'open_txns', :element => {:type => ::Thrift::Types::I64}},
    MIN_OPEN_TXN => {:type => ::Thrift::Types::I64, :name => 'min_open_txn', :optional => true},
    ABORTEDBITS => {:type => ::Thrift::Types::STRING, :name => 'abortedBits', :binary => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field txn_high_water_mark is unset!') unless @txn_high_water_mark
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field open_txns is unset!') unless @open_txns
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field abortedBits is unset!') unless @abortedBits
  end

  ::Thrift::Struct.generate_accessors self
end

class OpenTxnRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NUM_TXNS = 1
  USER = 2
  HOSTNAME = 3
  AGENTINFO = 4
  REPLPOLICY = 5
  REPLSRCTXNIDS = 6
  TXN_TYPE = 7

  FIELDS = {
    NUM_TXNS => {:type => ::Thrift::Types::I32, :name => 'num_txns'},
    USER => {:type => ::Thrift::Types::STRING, :name => 'user'},
    HOSTNAME => {:type => ::Thrift::Types::STRING, :name => 'hostname'},
    AGENTINFO => {:type => ::Thrift::Types::STRING, :name => 'agentInfo', :default => %q"Unknown", :optional => true},
    REPLPOLICY => {:type => ::Thrift::Types::STRING, :name => 'replPolicy', :optional => true},
    REPLSRCTXNIDS => {:type => ::Thrift::Types::LIST, :name => 'replSrcTxnIds', :element => {:type => ::Thrift::Types::I64}, :optional => true},
    TXN_TYPE => {:type => ::Thrift::Types::I32, :name => 'txn_type', :default =>     0, :optional => true, :enum_class => ::TxnType}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field num_txns is unset!') unless @num_txns
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field user is unset!') unless @user
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field hostname is unset!') unless @hostname
    unless @txn_type.nil? || ::TxnType::VALID_VALUES.include?(@txn_type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field txn_type!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class OpenTxnsResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TXN_IDS = 1

  FIELDS = {
    TXN_IDS => {:type => ::Thrift::Types::LIST, :name => 'txn_ids', :element => {:type => ::Thrift::Types::I64}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field txn_ids is unset!') unless @txn_ids
  end

  ::Thrift::Struct.generate_accessors self
end

class AbortTxnRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TXNID = 1
  REPLPOLICY = 2

  FIELDS = {
    TXNID => {:type => ::Thrift::Types::I64, :name => 'txnid'},
    REPLPOLICY => {:type => ::Thrift::Types::STRING, :name => 'replPolicy', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field txnid is unset!') unless @txnid
  end

  ::Thrift::Struct.generate_accessors self
end

class AbortTxnsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TXN_IDS = 1

  FIELDS = {
    TXN_IDS => {:type => ::Thrift::Types::LIST, :name => 'txn_ids', :element => {:type => ::Thrift::Types::I64}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field txn_ids is unset!') unless @txn_ids
  end

  ::Thrift::Struct.generate_accessors self
end

class CommitTxnKeyValue
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TABLEID = 1
  KEY = 2
  VALUE = 3

  FIELDS = {
    TABLEID => {:type => ::Thrift::Types::I64, :name => 'tableId'},
    KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
    VALUE => {:type => ::Thrift::Types::STRING, :name => 'value'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tableId is unset!') unless @tableId
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field key is unset!') unless @key
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field value is unset!') unless @value
  end

  ::Thrift::Struct.generate_accessors self
end

class WriteEventInfo
  include ::Thrift::Struct, ::Thrift::Struct_Union
  WRITEID = 1
  DATABASE = 2
  TABLE = 3
  FILES = 4
  PARTITION = 5
  TABLEOBJ = 6
  PARTITIONOBJ = 7

  FIELDS = {
    WRITEID => {:type => ::Thrift::Types::I64, :name => 'writeId'},
    DATABASE => {:type => ::Thrift::Types::STRING, :name => 'database'},
    TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
    FILES => {:type => ::Thrift::Types::STRING, :name => 'files'},
    PARTITION => {:type => ::Thrift::Types::STRING, :name => 'partition', :optional => true},
    TABLEOBJ => {:type => ::Thrift::Types::STRING, :name => 'tableObj', :optional => true},
    PARTITIONOBJ => {:type => ::Thrift::Types::STRING, :name => 'partitionObj', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field writeId is unset!') unless @writeId
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field database is unset!') unless @database
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field files is unset!') unless @files
  end

  ::Thrift::Struct.generate_accessors self
end

class ReplLastIdInfo
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DATABASE = 1
  LASTREPLID = 2
  TABLE = 3
  CATALOG = 4
  PARTITIONLIST = 5

  FIELDS = {
    DATABASE => {:type => ::Thrift::Types::STRING, :name => 'database'},
    LASTREPLID => {:type => ::Thrift::Types::I64, :name => 'lastReplId'},
    TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :optional => true},
    CATALOG => {:type => ::Thrift::Types::STRING, :name => 'catalog', :optional => true},
    PARTITIONLIST => {:type => ::Thrift::Types::LIST, :name => 'partitionList', :element => {:type => ::Thrift::Types::STRING}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field database is unset!') unless @database
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field lastReplId is unset!') unless @lastReplId
  end

  ::Thrift::Struct.generate_accessors self
end

class CommitTxnRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TXNID = 1
  REPLPOLICY = 2
  WRITEEVENTINFOS = 3
  REPLLASTIDINFO = 4
  KEYVALUE = 5
  EXCLWRITEENABLED = 6

  FIELDS = {
    TXNID => {:type => ::Thrift::Types::I64, :name => 'txnid'},
    REPLPOLICY => {:type => ::Thrift::Types::STRING, :name => 'replPolicy', :optional => true},
    WRITEEVENTINFOS => {:type => ::Thrift::Types::LIST, :name => 'writeEventInfos', :element => {:type => ::Thrift::Types::STRUCT, :class => ::WriteEventInfo}, :optional => true},
    REPLLASTIDINFO => {:type => ::Thrift::Types::STRUCT, :name => 'replLastIdInfo', :class => ::ReplLastIdInfo, :optional => true},
    KEYVALUE => {:type => ::Thrift::Types::STRUCT, :name => 'keyValue', :class => ::CommitTxnKeyValue, :optional => true},
    EXCLWRITEENABLED => {:type => ::Thrift::Types::BOOL, :name => 'exclWriteEnabled', :default => true, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field txnid is unset!') unless @txnid
  end

  ::Thrift::Struct.generate_accessors self
end

class ReplTblWriteIdStateRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALIDWRITEIDLIST = 1
  USER = 2
  HOSTNAME = 3
  DBNAME = 4
  TABLENAME = 5
  PARTNAMES = 6

  FIELDS = {
    VALIDWRITEIDLIST => {:type => ::Thrift::Types::STRING, :name => 'validWriteIdlist'},
    USER => {:type => ::Thrift::Types::STRING, :name => 'user'},
    HOSTNAME => {:type => ::Thrift::Types::STRING, :name => 'hostName'},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName'},
    PARTNAMES => {:type => ::Thrift::Types::LIST, :name => 'partNames', :element => {:type => ::Thrift::Types::STRING}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field validWriteIdlist is unset!') unless @validWriteIdlist
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field user is unset!') unless @user
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field hostName is unset!') unless @hostName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tableName is unset!') unless @tableName
  end

  ::Thrift::Struct.generate_accessors self
end

class GetValidWriteIdsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FULLTABLENAMES = 1
  VALIDTXNLIST = 2
  WRITEID = 3

  FIELDS = {
    FULLTABLENAMES => {:type => ::Thrift::Types::LIST, :name => 'fullTableNames', :element => {:type => ::Thrift::Types::STRING}},
    VALIDTXNLIST => {:type => ::Thrift::Types::STRING, :name => 'validTxnList', :optional => true},
    WRITEID => {:type => ::Thrift::Types::I64, :name => 'writeId', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field fullTableNames is unset!') unless @fullTableNames
  end

  ::Thrift::Struct.generate_accessors self
end

class TableValidWriteIds
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FULLTABLENAME = 1
  WRITEIDHIGHWATERMARK = 2
  INVALIDWRITEIDS = 3
  MINOPENWRITEID = 4
  ABORTEDBITS = 5

  FIELDS = {
    FULLTABLENAME => {:type => ::Thrift::Types::STRING, :name => 'fullTableName'},
    WRITEIDHIGHWATERMARK => {:type => ::Thrift::Types::I64, :name => 'writeIdHighWaterMark'},
    INVALIDWRITEIDS => {:type => ::Thrift::Types::LIST, :name => 'invalidWriteIds', :element => {:type => ::Thrift::Types::I64}},
    MINOPENWRITEID => {:type => ::Thrift::Types::I64, :name => 'minOpenWriteId', :optional => true},
    ABORTEDBITS => {:type => ::Thrift::Types::STRING, :name => 'abortedBits', :binary => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field fullTableName is unset!') unless @fullTableName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field writeIdHighWaterMark is unset!') unless @writeIdHighWaterMark
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field invalidWriteIds is unset!') unless @invalidWriteIds
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field abortedBits is unset!') unless @abortedBits
  end

  ::Thrift::Struct.generate_accessors self
end

class GetValidWriteIdsResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TBLVALIDWRITEIDS = 1

  FIELDS = {
    TBLVALIDWRITEIDS => {:type => ::Thrift::Types::LIST, :name => 'tblValidWriteIds', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TableValidWriteIds}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tblValidWriteIds is unset!') unless @tblValidWriteIds
  end

  ::Thrift::Struct.generate_accessors self
end

class TxnToWriteId
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TXNID = 1
  WRITEID = 2

  FIELDS = {
    TXNID => {:type => ::Thrift::Types::I64, :name => 'txnId'},
    WRITEID => {:type => ::Thrift::Types::I64, :name => 'writeId'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field txnId is unset!') unless @txnId
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field writeId is unset!') unless @writeId
  end

  ::Thrift::Struct.generate_accessors self
end

class AllocateTableWriteIdsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DBNAME = 1
  TABLENAME = 2
  TXNIDS = 3
  REPLPOLICY = 4
  SRCTXNTOWRITEIDLIST = 5

  FIELDS = {
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName'},
    TXNIDS => {:type => ::Thrift::Types::LIST, :name => 'txnIds', :element => {:type => ::Thrift::Types::I64}, :optional => true},
    REPLPOLICY => {:type => ::Thrift::Types::STRING, :name => 'replPolicy', :optional => true},
    SRCTXNTOWRITEIDLIST => {:type => ::Thrift::Types::LIST, :name => 'srcTxnToWriteIdList', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TxnToWriteId}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tableName is unset!') unless @tableName
  end

  ::Thrift::Struct.generate_accessors self
end

class AllocateTableWriteIdsResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TXNTOWRITEIDS = 1

  FIELDS = {
    TXNTOWRITEIDS => {:type => ::Thrift::Types::LIST, :name => 'txnToWriteIds', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TxnToWriteId}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field txnToWriteIds is unset!') unless @txnToWriteIds
  end

  ::Thrift::Struct.generate_accessors self
end

class MaxAllocatedTableWriteIdRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DBNAME = 1
  TABLENAME = 2

  FIELDS = {
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tableName is unset!') unless @tableName
  end

  ::Thrift::Struct.generate_accessors self
end

class MaxAllocatedTableWriteIdResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  MAXWRITEID = 1

  FIELDS = {
    MAXWRITEID => {:type => ::Thrift::Types::I64, :name => 'maxWriteId'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field maxWriteId is unset!') unless @maxWriteId
  end

  ::Thrift::Struct.generate_accessors self
end

class SeedTableWriteIdsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DBNAME = 1
  TABLENAME = 2
  SEEDWRITEID = 3

  FIELDS = {
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName'},
    SEEDWRITEID => {:type => ::Thrift::Types::I64, :name => 'seedWriteId'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tableName is unset!') unless @tableName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field seedWriteId is unset!') unless @seedWriteId
  end

  ::Thrift::Struct.generate_accessors self
end

class SeedTxnIdRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SEEDTXNID = 1

  FIELDS = {
    SEEDTXNID => {:type => ::Thrift::Types::I64, :name => 'seedTxnId'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field seedTxnId is unset!') unless @seedTxnId
  end

  ::Thrift::Struct.generate_accessors self
end

class LockComponent
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TYPE = 1
  LEVEL = 2
  DBNAME = 3
  TABLENAME = 4
  PARTITIONNAME = 5
  OPERATIONTYPE = 6
  ISTRANSACTIONAL = 7
  ISDYNAMICPARTITIONWRITE = 8

  FIELDS = {
    TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::LockType},
    LEVEL => {:type => ::Thrift::Types::I32, :name => 'level', :enum_class => ::LockLevel},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbname'},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tablename', :optional => true},
    PARTITIONNAME => {:type => ::Thrift::Types::STRING, :name => 'partitionname', :optional => true},
    OPERATIONTYPE => {:type => ::Thrift::Types::I32, :name => 'operationType', :default =>     5, :optional => true, :enum_class => ::DataOperationType},
    ISTRANSACTIONAL => {:type => ::Thrift::Types::BOOL, :name => 'isTransactional', :default => false, :optional => true},
    ISDYNAMICPARTITIONWRITE => {:type => ::Thrift::Types::BOOL, :name => 'isDynamicPartitionWrite', :default => false, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field type is unset!') unless @type
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field level is unset!') unless @level
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbname is unset!') unless @dbname
    unless @type.nil? || ::LockType::VALID_VALUES.include?(@type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
    end
    unless @level.nil? || ::LockLevel::VALID_VALUES.include?(@level)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field level!')
    end
    unless @operationType.nil? || ::DataOperationType::VALID_VALUES.include?(@operationType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field operationType!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class LockRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  COMPONENT = 1
  TXNID = 2
  USER = 3
  HOSTNAME = 4
  AGENTINFO = 5
  ZEROWAITREADENABLED = 6

  FIELDS = {
    COMPONENT => {:type => ::Thrift::Types::LIST, :name => 'component', :element => {:type => ::Thrift::Types::STRUCT, :class => ::LockComponent}},
    TXNID => {:type => ::Thrift::Types::I64, :name => 'txnid', :optional => true},
    USER => {:type => ::Thrift::Types::STRING, :name => 'user'},
    HOSTNAME => {:type => ::Thrift::Types::STRING, :name => 'hostname'},
    AGENTINFO => {:type => ::Thrift::Types::STRING, :name => 'agentInfo', :default => %q"Unknown", :optional => true},
    ZEROWAITREADENABLED => {:type => ::Thrift::Types::BOOL, :name => 'zeroWaitReadEnabled', :default => false, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field component is unset!') unless @component
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field user is unset!') unless @user
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field hostname is unset!') unless @hostname
  end

  ::Thrift::Struct.generate_accessors self
end

class LockResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  LOCKID = 1
  STATE = 2
  ERRORMESSAGE = 3

  FIELDS = {
    LOCKID => {:type => ::Thrift::Types::I64, :name => 'lockid'},
    STATE => {:type => ::Thrift::Types::I32, :name => 'state', :enum_class => ::LockState},
    ERRORMESSAGE => {:type => ::Thrift::Types::STRING, :name => 'errorMessage', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field lockid is unset!') unless @lockid
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field state is unset!') unless @state
    unless @state.nil? || ::LockState::VALID_VALUES.include?(@state)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field state!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class CheckLockRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  LOCKID = 1
  TXNID = 2
  ELAPSED_MS = 3

  FIELDS = {
    LOCKID => {:type => ::Thrift::Types::I64, :name => 'lockid'},
    TXNID => {:type => ::Thrift::Types::I64, :name => 'txnid', :optional => true},
    ELAPSED_MS => {:type => ::Thrift::Types::I64, :name => 'elapsed_ms', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field lockid is unset!') unless @lockid
  end

  ::Thrift::Struct.generate_accessors self
end

class UnlockRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  LOCKID = 1

  FIELDS = {
    LOCKID => {:type => ::Thrift::Types::I64, :name => 'lockid'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field lockid is unset!') unless @lockid
  end

  ::Thrift::Struct.generate_accessors self
end

class ShowLocksRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DBNAME = 1
  TABLENAME = 2
  PARTNAME = 3
  ISEXTENDED = 4
  TXNID = 5

  FIELDS = {
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbname', :optional => true},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tablename', :optional => true},
    PARTNAME => {:type => ::Thrift::Types::STRING, :name => 'partname', :optional => true},
    ISEXTENDED => {:type => ::Thrift::Types::BOOL, :name => 'isExtended', :default => false, :optional => true},
    TXNID => {:type => ::Thrift::Types::I64, :name => 'txnid', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class ShowLocksResponseElement
  include ::Thrift::Struct, ::Thrift::Struct_Union
  LOCKID = 1
  DBNAME = 2
  TABLENAME = 3
  PARTNAME = 4
  STATE = 5
  TYPE = 6
  TXNID = 7
  LASTHEARTBEAT = 8
  ACQUIREDAT = 9
  USER = 10
  HOSTNAME = 11
  HEARTBEATCOUNT = 12
  AGENTINFO = 13
  BLOCKEDBYEXTID = 14
  BLOCKEDBYINTID = 15
  LOCKIDINTERNAL = 16

  FIELDS = {
    LOCKID => {:type => ::Thrift::Types::I64, :name => 'lockid'},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbname'},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tablename', :optional => true},
    PARTNAME => {:type => ::Thrift::Types::STRING, :name => 'partname', :optional => true},
    STATE => {:type => ::Thrift::Types::I32, :name => 'state', :enum_class => ::LockState},
    TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::LockType},
    TXNID => {:type => ::Thrift::Types::I64, :name => 'txnid', :optional => true},
    LASTHEARTBEAT => {:type => ::Thrift::Types::I64, :name => 'lastheartbeat'},
    ACQUIREDAT => {:type => ::Thrift::Types::I64, :name => 'acquiredat', :optional => true},
    USER => {:type => ::Thrift::Types::STRING, :name => 'user'},
    HOSTNAME => {:type => ::Thrift::Types::STRING, :name => 'hostname'},
    HEARTBEATCOUNT => {:type => ::Thrift::Types::I32, :name => 'heartbeatCount', :default => 0, :optional => true},
    AGENTINFO => {:type => ::Thrift::Types::STRING, :name => 'agentInfo', :optional => true},
    BLOCKEDBYEXTID => {:type => ::Thrift::Types::I64, :name => 'blockedByExtId', :optional => true},
    BLOCKEDBYINTID => {:type => ::Thrift::Types::I64, :name => 'blockedByIntId', :optional => true},
    LOCKIDINTERNAL => {:type => ::Thrift::Types::I64, :name => 'lockIdInternal', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field lockid is unset!') unless @lockid
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbname is unset!') unless @dbname
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field state is unset!') unless @state
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field type is unset!') unless @type
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field lastheartbeat is unset!') unless @lastheartbeat
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field user is unset!') unless @user
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field hostname is unset!') unless @hostname
    unless @state.nil? || ::LockState::VALID_VALUES.include?(@state)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field state!')
    end
    unless @type.nil? || ::LockType::VALID_VALUES.include?(@type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class ShowLocksResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  LOCKS = 1

  FIELDS = {
    LOCKS => {:type => ::Thrift::Types::LIST, :name => 'locks', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ShowLocksResponseElement}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class HeartbeatRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  LOCKID = 1
  TXNID = 2

  FIELDS = {
    LOCKID => {:type => ::Thrift::Types::I64, :name => 'lockid', :optional => true},
    TXNID => {:type => ::Thrift::Types::I64, :name => 'txnid', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class HeartbeatTxnRangeRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  MIN = 1
  MAX = 2

  FIELDS = {
    MIN => {:type => ::Thrift::Types::I64, :name => 'min'},
    MAX => {:type => ::Thrift::Types::I64, :name => 'max'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field min is unset!') unless @min
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field max is unset!') unless @max
  end

  ::Thrift::Struct.generate_accessors self
end

class HeartbeatTxnRangeResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  ABORTED = 1
  NOSUCH = 2

  FIELDS = {
    ABORTED => {:type => ::Thrift::Types::SET, :name => 'aborted', :element => {:type => ::Thrift::Types::I64}},
    NOSUCH => {:type => ::Thrift::Types::SET, :name => 'nosuch', :element => {:type => ::Thrift::Types::I64}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field aborted is unset!') unless @aborted
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field nosuch is unset!') unless @nosuch
  end

  ::Thrift::Struct.generate_accessors self
end

class CompactionRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DBNAME = 1
  TABLENAME = 2
  PARTITIONNAME = 3
  TYPE = 4
  RUNAS = 5
  PROPERTIES = 6

  FIELDS = {
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbname'},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tablename'},
    PARTITIONNAME => {:type => ::Thrift::Types::STRING, :name => 'partitionname', :optional => true},
    TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::CompactionType},
    RUNAS => {:type => ::Thrift::Types::STRING, :name => 'runas', :optional => true},
    PROPERTIES => {:type => ::Thrift::Types::MAP, :name => 'properties', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbname is unset!') unless @dbname
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tablename is unset!') unless @tablename
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field type is unset!') unless @type
    unless @type.nil? || ::CompactionType::VALID_VALUES.include?(@type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class CompactionInfoStruct
  include ::Thrift::Struct, ::Thrift::Struct_Union
  ID = 1
  DBNAME = 2
  TABLENAME = 3
  PARTITIONNAME = 4
  TYPE = 5
  RUNAS = 6
  PROPERTIES = 7
  TOOMANYABORTS = 8
  STATE = 9
  WORKERID = 10
  START = 11
  HIGHESTWRITEID = 12
  ERRORMESSAGE = 13
  HASOLDABORT = 14
  ENQUEUETIME = 15

  FIELDS = {
    ID => {:type => ::Thrift::Types::I64, :name => 'id'},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbname'},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tablename'},
    PARTITIONNAME => {:type => ::Thrift::Types::STRING, :name => 'partitionname', :optional => true},
    TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::CompactionType},
    RUNAS => {:type => ::Thrift::Types::STRING, :name => 'runas', :optional => true},
    PROPERTIES => {:type => ::Thrift::Types::STRING, :name => 'properties', :optional => true},
    TOOMANYABORTS => {:type => ::Thrift::Types::BOOL, :name => 'toomanyaborts', :optional => true},
    STATE => {:type => ::Thrift::Types::STRING, :name => 'state', :optional => true},
    WORKERID => {:type => ::Thrift::Types::STRING, :name => 'workerId', :optional => true},
    START => {:type => ::Thrift::Types::I64, :name => 'start', :optional => true},
    HIGHESTWRITEID => {:type => ::Thrift::Types::I64, :name => 'highestWriteId', :optional => true},
    ERRORMESSAGE => {:type => ::Thrift::Types::STRING, :name => 'errorMessage', :optional => true},
    HASOLDABORT => {:type => ::Thrift::Types::BOOL, :name => 'hasoldabort', :optional => true},
    ENQUEUETIME => {:type => ::Thrift::Types::I64, :name => 'enqueueTime', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id is unset!') unless @id
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbname is unset!') unless @dbname
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tablename is unset!') unless @tablename
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field type is unset!') unless @type
    unless @type.nil? || ::CompactionType::VALID_VALUES.include?(@type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class OptionalCompactionInfoStruct
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CI = 1

  FIELDS = {
    CI => {:type => ::Thrift::Types::STRUCT, :name => 'ci', :class => ::CompactionInfoStruct, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class CompactionResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  ID = 1
  STATE = 2
  ACCEPTED = 3

  FIELDS = {
    ID => {:type => ::Thrift::Types::I64, :name => 'id'},
    STATE => {:type => ::Thrift::Types::STRING, :name => 'state'},
    ACCEPTED => {:type => ::Thrift::Types::BOOL, :name => 'accepted'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id is unset!') unless @id
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field state is unset!') unless @state
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field accepted is unset!') if @accepted.nil?
  end

  ::Thrift::Struct.generate_accessors self
end

class ShowCompactRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class ShowCompactResponseElement
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DBNAME = 1
  TABLENAME = 2
  PARTITIONNAME = 3
  TYPE = 4
  STATE = 5
  WORKERID = 6
  START = 7
  RUNAS = 8
  HIGHTESTTXNID = 9
  METAINFO = 10
  ENDTIME = 11
  HADOOPJOBID = 12
  ID = 13
  ERRORMESSAGE = 14
  ENQUEUETIME = 15

  FIELDS = {
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbname'},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tablename'},
    PARTITIONNAME => {:type => ::Thrift::Types::STRING, :name => 'partitionname', :optional => true},
    TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::CompactionType},
    STATE => {:type => ::Thrift::Types::STRING, :name => 'state'},
    WORKERID => {:type => ::Thrift::Types::STRING, :name => 'workerid', :optional => true},
    START => {:type => ::Thrift::Types::I64, :name => 'start', :optional => true},
    RUNAS => {:type => ::Thrift::Types::STRING, :name => 'runAs', :optional => true},
    HIGHTESTTXNID => {:type => ::Thrift::Types::I64, :name => 'hightestTxnId', :optional => true},
    METAINFO => {:type => ::Thrift::Types::STRING, :name => 'metaInfo', :optional => true},
    ENDTIME => {:type => ::Thrift::Types::I64, :name => 'endTime', :optional => true},
    HADOOPJOBID => {:type => ::Thrift::Types::STRING, :name => 'hadoopJobId', :default => %q"None", :optional => true},
    ID => {:type => ::Thrift::Types::I64, :name => 'id', :optional => true},
    ERRORMESSAGE => {:type => ::Thrift::Types::STRING, :name => 'errorMessage', :optional => true},
    ENQUEUETIME => {:type => ::Thrift::Types::I64, :name => 'enqueueTime', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbname is unset!') unless @dbname
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tablename is unset!') unless @tablename
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field type is unset!') unless @type
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field state is unset!') unless @state
    unless @type.nil? || ::CompactionType::VALID_VALUES.include?(@type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class ShowCompactResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  COMPACTS = 1

  FIELDS = {
    COMPACTS => {:type => ::Thrift::Types::LIST, :name => 'compacts', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ShowCompactResponseElement}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field compacts is unset!') unless @compacts
  end

  ::Thrift::Struct.generate_accessors self
end

class AddDynamicPartitions
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TXNID = 1
  WRITEID = 2
  DBNAME = 3
  TABLENAME = 4
  PARTITIONNAMES = 5
  OPERATIONTYPE = 6

  FIELDS = {
    TXNID => {:type => ::Thrift::Types::I64, :name => 'txnid'},
    WRITEID => {:type => ::Thrift::Types::I64, :name => 'writeid'},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbname'},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tablename'},
    PARTITIONNAMES => {:type => ::Thrift::Types::LIST, :name => 'partitionnames', :element => {:type => ::Thrift::Types::STRING}},
    OPERATIONTYPE => {:type => ::Thrift::Types::I32, :name => 'operationType', :default =>     5, :optional => true, :enum_class => ::DataOperationType}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field txnid is unset!') unless @txnid
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field writeid is unset!') unless @writeid
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbname is unset!') unless @dbname
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tablename is unset!') unless @tablename
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field partitionnames is unset!') unless @partitionnames
    unless @operationType.nil? || ::DataOperationType::VALID_VALUES.include?(@operationType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field operationType!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class BasicTxnInfo
  include ::Thrift::Struct, ::Thrift::Struct_Union
  ISNULL = 1
  TIME = 2
  TXNID = 3
  DBNAME = 4
  TABLENAME = 5
  PARTITIONNAME = 6

  FIELDS = {
    ISNULL => {:type => ::Thrift::Types::BOOL, :name => 'isnull'},
    TIME => {:type => ::Thrift::Types::I64, :name => 'time', :optional => true},
    TXNID => {:type => ::Thrift::Types::I64, :name => 'txnid', :optional => true},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbname', :optional => true},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tablename', :optional => true},
    PARTITIONNAME => {:type => ::Thrift::Types::STRING, :name => 'partitionname', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field isnull is unset!') if @isnull.nil?
  end

  ::Thrift::Struct.generate_accessors self
end

class NotificationEventRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  LASTEVENT = 1
  MAXEVENTS = 2
  EVENTTYPESKIPLIST = 3

  FIELDS = {
    LASTEVENT => {:type => ::Thrift::Types::I64, :name => 'lastEvent'},
    MAXEVENTS => {:type => ::Thrift::Types::I32, :name => 'maxEvents', :optional => true},
    EVENTTYPESKIPLIST => {:type => ::Thrift::Types::LIST, :name => 'eventTypeSkipList', :element => {:type => ::Thrift::Types::STRING}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field lastEvent is unset!') unless @lastEvent
  end

  ::Thrift::Struct.generate_accessors self
end

class NotificationEvent
  include ::Thrift::Struct, ::Thrift::Struct_Union
  EVENTID = 1
  EVENTTIME = 2
  EVENTTYPE = 3
  DBNAME = 4
  TABLENAME = 5
  MESSAGE = 6
  MESSAGEFORMAT = 7
  CATNAME = 8

  FIELDS = {
    EVENTID => {:type => ::Thrift::Types::I64, :name => 'eventId'},
    EVENTTIME => {:type => ::Thrift::Types::I32, :name => 'eventTime'},
    EVENTTYPE => {:type => ::Thrift::Types::STRING, :name => 'eventType'},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName', :optional => true},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :optional => true},
    MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'},
    MESSAGEFORMAT => {:type => ::Thrift::Types::STRING, :name => 'messageFormat', :optional => true},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field eventId is unset!') unless @eventId
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field eventTime is unset!') unless @eventTime
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field eventType is unset!') unless @eventType
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field message is unset!') unless @message
  end

  ::Thrift::Struct.generate_accessors self
end

class NotificationEventResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  EVENTS = 1

  FIELDS = {
    EVENTS => {:type => ::Thrift::Types::LIST, :name => 'events', :element => {:type => ::Thrift::Types::STRUCT, :class => ::NotificationEvent}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field events is unset!') unless @events
  end

  ::Thrift::Struct.generate_accessors self
end

class CurrentNotificationEventId
  include ::Thrift::Struct, ::Thrift::Struct_Union
  EVENTID = 1

  FIELDS = {
    EVENTID => {:type => ::Thrift::Types::I64, :name => 'eventId'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field eventId is unset!') unless @eventId
  end

  ::Thrift::Struct.generate_accessors self
end

class NotificationEventsCountRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FROMEVENTID = 1
  DBNAME = 2
  CATNAME = 3
  TOEVENTID = 4
  LIMIT = 5

  FIELDS = {
    FROMEVENTID => {:type => ::Thrift::Types::I64, :name => 'fromEventId'},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true},
    TOEVENTID => {:type => ::Thrift::Types::I64, :name => 'toEventId', :optional => true},
    LIMIT => {:type => ::Thrift::Types::I64, :name => 'limit', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field fromEventId is unset!') unless @fromEventId
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
  end

  ::Thrift::Struct.generate_accessors self
end

class NotificationEventsCountResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  EVENTSCOUNT = 1

  FIELDS = {
    EVENTSCOUNT => {:type => ::Thrift::Types::I64, :name => 'eventsCount'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field eventsCount is unset!') unless @eventsCount
  end

  ::Thrift::Struct.generate_accessors self
end

class InsertEventRequestData
  include ::Thrift::Struct, ::Thrift::Struct_Union
  REPLACE = 1
  FILESADDED = 2
  FILESADDEDCHECKSUM = 3
  SUBDIRECTORYLIST = 4
  PARTITIONVAL = 5

  FIELDS = {
    REPLACE => {:type => ::Thrift::Types::BOOL, :name => 'replace', :optional => true},
    FILESADDED => {:type => ::Thrift::Types::LIST, :name => 'filesAdded', :element => {:type => ::Thrift::Types::STRING}},
    FILESADDEDCHECKSUM => {:type => ::Thrift::Types::LIST, :name => 'filesAddedChecksum', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    SUBDIRECTORYLIST => {:type => ::Thrift::Types::LIST, :name => 'subDirectoryList', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    PARTITIONVAL => {:type => ::Thrift::Types::LIST, :name => 'partitionVal', :element => {:type => ::Thrift::Types::STRING}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field filesAdded is unset!') unless @filesAdded
  end

  ::Thrift::Struct.generate_accessors self
end

class FireEventRequestData < ::Thrift::Union
  include ::Thrift::Struct_Union
  class << self
    def insertData(val)
      FireEventRequestData.new(:insertData, val)
    end

    def insertDatas(val)
      FireEventRequestData.new(:insertDatas, val)
    end
  end

  INSERTDATA = 1
  INSERTDATAS = 2

  FIELDS = {
    INSERTDATA => {:type => ::Thrift::Types::STRUCT, :name => 'insertData', :class => ::InsertEventRequestData, :optional => true},
    INSERTDATAS => {:type => ::Thrift::Types::LIST, :name => 'insertDatas', :element => {:type => ::Thrift::Types::STRUCT, :class => ::InsertEventRequestData}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
  end

  ::Thrift::Union.generate_accessors self
end

class FireEventRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SUCCESSFUL = 1
  DATA = 2
  DBNAME = 3
  TABLENAME = 4
  PARTITIONVALS = 5
  CATNAME = 6

  FIELDS = {
    SUCCESSFUL => {:type => ::Thrift::Types::BOOL, :name => 'successful'},
    DATA => {:type => ::Thrift::Types::STRUCT, :name => 'data', :class => ::FireEventRequestData},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName', :optional => true},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :optional => true},
    PARTITIONVALS => {:type => ::Thrift::Types::LIST, :name => 'partitionVals', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field successful is unset!') if @successful.nil?
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field data is unset!') unless @data
  end

  ::Thrift::Struct.generate_accessors self
end

class FireEventResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  EVENTIDS = 1

  FIELDS = {
    EVENTIDS => {:type => ::Thrift::Types::LIST, :name => 'eventIds', :element => {:type => ::Thrift::Types::I64}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WriteNotificationLogRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TXNID = 1
  WRITEID = 2
  DB = 3
  TABLE = 4
  FILEINFO = 5
  PARTITIONVALS = 6

  FIELDS = {
    TXNID => {:type => ::Thrift::Types::I64, :name => 'txnId'},
    WRITEID => {:type => ::Thrift::Types::I64, :name => 'writeId'},
    DB => {:type => ::Thrift::Types::STRING, :name => 'db'},
    TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
    FILEINFO => {:type => ::Thrift::Types::STRUCT, :name => 'fileInfo', :class => ::InsertEventRequestData},
    PARTITIONVALS => {:type => ::Thrift::Types::LIST, :name => 'partitionVals', :element => {:type => ::Thrift::Types::STRING}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field txnId is unset!') unless @txnId
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field writeId is unset!') unless @writeId
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field db is unset!') unless @db
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field fileInfo is unset!') unless @fileInfo
  end

  ::Thrift::Struct.generate_accessors self
end

class WriteNotificationLogResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class MetadataPpdResult
  include ::Thrift::Struct, ::Thrift::Struct_Union
  METADATA = 1
  INCLUDEBITSET = 2

  FIELDS = {
    METADATA => {:type => ::Thrift::Types::STRING, :name => 'metadata', :binary => true, :optional => true},
    INCLUDEBITSET => {:type => ::Thrift::Types::STRING, :name => 'includeBitset', :binary => true, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class GetFileMetadataByExprResult
  include ::Thrift::Struct, ::Thrift::Struct_Union
  METADATA = 1
  ISSUPPORTED = 2

  FIELDS = {
    METADATA => {:type => ::Thrift::Types::MAP, :name => 'metadata', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::MetadataPpdResult}},
    ISSUPPORTED => {:type => ::Thrift::Types::BOOL, :name => 'isSupported'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field metadata is unset!') unless @metadata
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field isSupported is unset!') if @isSupported.nil?
  end

  ::Thrift::Struct.generate_accessors self
end

class GetFileMetadataByExprRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FILEIDS = 1
  EXPR = 2
  DOGETFOOTERS = 3
  TYPE = 4

  FIELDS = {
    FILEIDS => {:type => ::Thrift::Types::LIST, :name => 'fileIds', :element => {:type => ::Thrift::Types::I64}},
    EXPR => {:type => ::Thrift::Types::STRING, :name => 'expr', :binary => true},
    DOGETFOOTERS => {:type => ::Thrift::Types::BOOL, :name => 'doGetFooters', :optional => true},
    TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :optional => true, :enum_class => ::FileMetadataExprType}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field fileIds is unset!') unless @fileIds
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field expr is unset!') unless @expr
    unless @type.nil? || ::FileMetadataExprType::VALID_VALUES.include?(@type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class GetFileMetadataResult
  include ::Thrift::Struct, ::Thrift::Struct_Union
  METADATA = 1
  ISSUPPORTED = 2

  FIELDS = {
    METADATA => {:type => ::Thrift::Types::MAP, :name => 'metadata', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRING, :binary => true}},
    ISSUPPORTED => {:type => ::Thrift::Types::BOOL, :name => 'isSupported'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field metadata is unset!') unless @metadata
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field isSupported is unset!') if @isSupported.nil?
  end

  ::Thrift::Struct.generate_accessors self
end

class GetFileMetadataRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FILEIDS = 1

  FIELDS = {
    FILEIDS => {:type => ::Thrift::Types::LIST, :name => 'fileIds', :element => {:type => ::Thrift::Types::I64}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field fileIds is unset!') unless @fileIds
  end

  ::Thrift::Struct.generate_accessors self
end

class PutFileMetadataResult
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class PutFileMetadataRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FILEIDS = 1
  METADATA = 2
  TYPE = 3

  FIELDS = {
    FILEIDS => {:type => ::Thrift::Types::LIST, :name => 'fileIds', :element => {:type => ::Thrift::Types::I64}},
    METADATA => {:type => ::Thrift::Types::LIST, :name => 'metadata', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
    TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :optional => true, :enum_class => ::FileMetadataExprType}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field fileIds is unset!') unless @fileIds
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field metadata is unset!') unless @metadata
    unless @type.nil? || ::FileMetadataExprType::VALID_VALUES.include?(@type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class ClearFileMetadataResult
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class ClearFileMetadataRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FILEIDS = 1

  FIELDS = {
    FILEIDS => {:type => ::Thrift::Types::LIST, :name => 'fileIds', :element => {:type => ::Thrift::Types::I64}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field fileIds is unset!') unless @fileIds
  end

  ::Thrift::Struct.generate_accessors self
end

class CacheFileMetadataResult
  include ::Thrift::Struct, ::Thrift::Struct_Union
  ISSUPPORTED = 1

  FIELDS = {
    ISSUPPORTED => {:type => ::Thrift::Types::BOOL, :name => 'isSupported'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field isSupported is unset!') if @isSupported.nil?
  end

  ::Thrift::Struct.generate_accessors self
end

class CacheFileMetadataRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DBNAME = 1
  TBLNAME = 2
  PARTNAME = 3
  ISALLPARTS = 4

  FIELDS = {
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TBLNAME => {:type => ::Thrift::Types::STRING, :name => 'tblName'},
    PARTNAME => {:type => ::Thrift::Types::STRING, :name => 'partName', :optional => true},
    ISALLPARTS => {:type => ::Thrift::Types::BOOL, :name => 'isAllParts', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tblName is unset!') unless @tblName
  end

  ::Thrift::Struct.generate_accessors self
end

class GetAllFunctionsResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FUNCTIONS = 1

  FIELDS = {
    FUNCTIONS => {:type => ::Thrift::Types::LIST, :name => 'functions', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Function}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class ClientCapabilities
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUES = 1

  FIELDS = {
    VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::I32, :enum_class => ::ClientCapability}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field values is unset!') unless @values
  end

  ::Thrift::Struct.generate_accessors self
end

class GetProjectionsSpec
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FIELDLIST = 1
  INCLUDEPARAMKEYPATTERN = 2
  EXCLUDEPARAMKEYPATTERN = 3

  FIELDS = {
    FIELDLIST => {:type => ::Thrift::Types::LIST, :name => 'fieldList', :element => {:type => ::Thrift::Types::STRING}},
    INCLUDEPARAMKEYPATTERN => {:type => ::Thrift::Types::STRING, :name => 'includeParamKeyPattern'},
    EXCLUDEPARAMKEYPATTERN => {:type => ::Thrift::Types::STRING, :name => 'excludeParamKeyPattern'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class GetTableRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DBNAME = 1
  TBLNAME = 2
  CAPABILITIES = 3
  CATNAME = 4
  VALIDWRITEIDLIST = 6
  GETCOLUMNSTATS = 7
  PROCESSORCAPABILITIES = 8
  PROCESSORIDENTIFIER = 9
  ENGINE = 10
  ID = 11

  FIELDS = {
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TBLNAME => {:type => ::Thrift::Types::STRING, :name => 'tblName'},
    CAPABILITIES => {:type => ::Thrift::Types::STRUCT, :name => 'capabilities', :class => ::ClientCapabilities, :optional => true},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true},
    VALIDWRITEIDLIST => {:type => ::Thrift::Types::STRING, :name => 'validWriteIdList', :optional => true},
    GETCOLUMNSTATS => {:type => ::Thrift::Types::BOOL, :name => 'getColumnStats', :optional => true},
    PROCESSORCAPABILITIES => {:type => ::Thrift::Types::LIST, :name => 'processorCapabilities', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    PROCESSORIDENTIFIER => {:type => ::Thrift::Types::STRING, :name => 'processorIdentifier', :optional => true},
    ENGINE => {:type => ::Thrift::Types::STRING, :name => 'engine', :optional => true},
    ID => {:type => ::Thrift::Types::I64, :name => 'id', :default => -1, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tblName is unset!') unless @tblName
  end

  ::Thrift::Struct.generate_accessors self
end

class GetTableResult
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TABLE = 1
  ISSTATSCOMPLIANT = 2

  FIELDS = {
    TABLE => {:type => ::Thrift::Types::STRUCT, :name => 'table', :class => ::Table},
    ISSTATSCOMPLIANT => {:type => ::Thrift::Types::BOOL, :name => 'isStatsCompliant', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
  end

  ::Thrift::Struct.generate_accessors self
end

class GetTablesRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DBNAME = 1
  TBLNAMES = 2
  CAPABILITIES = 3
  CATNAME = 4
  PROCESSORCAPABILITIES = 5
  PROCESSORIDENTIFIER = 6
  PROJECTIONSPEC = 7

  FIELDS = {
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TBLNAMES => {:type => ::Thrift::Types::LIST, :name => 'tblNames', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    CAPABILITIES => {:type => ::Thrift::Types::STRUCT, :name => 'capabilities', :class => ::ClientCapabilities, :optional => true},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true},
    PROCESSORCAPABILITIES => {:type => ::Thrift::Types::LIST, :name => 'processorCapabilities', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    PROCESSORIDENTIFIER => {:type => ::Thrift::Types::STRING, :name => 'processorIdentifier', :optional => true},
    PROJECTIONSPEC => {:type => ::Thrift::Types::STRUCT, :name => 'projectionSpec', :class => ::GetProjectionsSpec, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
  end

  ::Thrift::Struct.generate_accessors self
end

class GetTablesResult
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TABLES = 1

  FIELDS = {
    TABLES => {:type => ::Thrift::Types::LIST, :name => 'tables', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Table}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tables is unset!') unless @tables
  end

  ::Thrift::Struct.generate_accessors self
end

class GetTablesExtRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATALOG = 1
  DATABASE = 2
  TABLENAMEPATTERN = 3
  REQUESTEDFIELDS = 4
  LIMIT = 5
  PROCESSORCAPABILITIES = 6
  PROCESSORIDENTIFIER = 7

  FIELDS = {
    CATALOG => {:type => ::Thrift::Types::STRING, :name => 'catalog'},
    DATABASE => {:type => ::Thrift::Types::STRING, :name => 'database'},
    TABLENAMEPATTERN => {:type => ::Thrift::Types::STRING, :name => 'tableNamePattern'},
    REQUESTEDFIELDS => {:type => ::Thrift::Types::I32, :name => 'requestedFields'},
    LIMIT => {:type => ::Thrift::Types::I32, :name => 'limit', :optional => true},
    PROCESSORCAPABILITIES => {:type => ::Thrift::Types::LIST, :name => 'processorCapabilities', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    PROCESSORIDENTIFIER => {:type => ::Thrift::Types::STRING, :name => 'processorIdentifier', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field catalog is unset!') unless @catalog
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field database is unset!') unless @database
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tableNamePattern is unset!') unless @tableNamePattern
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field requestedFields is unset!') unless @requestedFields
  end

  ::Thrift::Struct.generate_accessors self
end

class ExtendedTableInfo
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TBLNAME = 1
  ACCESSTYPE = 2
  REQUIREDREADCAPABILITIES = 3
  REQUIREDWRITECAPABILITIES = 4

  FIELDS = {
    TBLNAME => {:type => ::Thrift::Types::STRING, :name => 'tblName'},
    ACCESSTYPE => {:type => ::Thrift::Types::I32, :name => 'accessType', :optional => true},
    REQUIREDREADCAPABILITIES => {:type => ::Thrift::Types::LIST, :name => 'requiredReadCapabilities', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    REQUIREDWRITECAPABILITIES => {:type => ::Thrift::Types::LIST, :name => 'requiredWriteCapabilities', :element => {:type => ::Thrift::Types::STRING}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tblName is unset!') unless @tblName
  end

  ::Thrift::Struct.generate_accessors self
end

class GetDatabaseRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NAME = 1
  CATALOGNAME = 2
  PROCESSORCAPABILITIES = 3
  PROCESSORIDENTIFIER = 4

  FIELDS = {
    NAME => {:type => ::Thrift::Types::STRING, :name => 'name', :optional => true},
    CATALOGNAME => {:type => ::Thrift::Types::STRING, :name => 'catalogName', :optional => true},
    PROCESSORCAPABILITIES => {:type => ::Thrift::Types::LIST, :name => 'processorCapabilities', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    PROCESSORIDENTIFIER => {:type => ::Thrift::Types::STRING, :name => 'processorIdentifier', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class CmRecycleRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DATAPATH = 1
  PURGE = 2

  FIELDS = {
    DATAPATH => {:type => ::Thrift::Types::STRING, :name => 'dataPath'},
    PURGE => {:type => ::Thrift::Types::BOOL, :name => 'purge'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dataPath is unset!') unless @dataPath
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field purge is unset!') if @purge.nil?
  end

  ::Thrift::Struct.generate_accessors self
end

class CmRecycleResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class TableMeta
  include ::Thrift::Struct, ::Thrift::Struct_Union
  DBNAME = 1
  TABLENAME = 2
  TABLETYPE = 3
  COMMENTS = 4
  CATNAME = 5

  FIELDS = {
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName'},
    TABLETYPE => {:type => ::Thrift::Types::STRING, :name => 'tableType'},
    COMMENTS => {:type => ::Thrift::Types::STRING, :name => 'comments', :optional => true},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tableName is unset!') unless @tableName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tableType is unset!') unless @tableType
  end

  ::Thrift::Struct.generate_accessors self
end

class Materialization
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SOURCETABLESUPDATEDELETEMODIFIED = 1

  FIELDS = {
    SOURCETABLESUPDATEDELETEMODIFIED => {:type => ::Thrift::Types::BOOL, :name => 'sourceTablesUpdateDeleteModified'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sourceTablesUpdateDeleteModified is unset!') if @sourceTablesUpdateDeleteModified.nil?
  end

  ::Thrift::Struct.generate_accessors self
end

class WMResourcePlan
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NAME = 1
  STATUS = 2
  QUERYPARALLELISM = 3
  DEFAULTPOOLPATH = 4
  NS = 5

  FIELDS = {
    NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
    STATUS => {:type => ::Thrift::Types::I32, :name => 'status', :optional => true, :enum_class => ::WMResourcePlanStatus},
    QUERYPARALLELISM => {:type => ::Thrift::Types::I32, :name => 'queryParallelism', :optional => true},
    DEFAULTPOOLPATH => {:type => ::Thrift::Types::STRING, :name => 'defaultPoolPath', :optional => true},
    NS => {:type => ::Thrift::Types::STRING, :name => 'ns', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field name is unset!') unless @name
    unless @status.nil? || ::WMResourcePlanStatus::VALID_VALUES.include?(@status)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field status!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class WMNullableResourcePlan
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NAME = 1
  STATUS = 2
  QUERYPARALLELISM = 4
  ISSETQUERYPARALLELISM = 5
  DEFAULTPOOLPATH = 6
  ISSETDEFAULTPOOLPATH = 7
  NS = 8

  FIELDS = {
    NAME => {:type => ::Thrift::Types::STRING, :name => 'name', :optional => true},
    STATUS => {:type => ::Thrift::Types::I32, :name => 'status', :optional => true, :enum_class => ::WMResourcePlanStatus},
    QUERYPARALLELISM => {:type => ::Thrift::Types::I32, :name => 'queryParallelism', :optional => true},
    ISSETQUERYPARALLELISM => {:type => ::Thrift::Types::BOOL, :name => 'isSetQueryParallelism', :optional => true},
    DEFAULTPOOLPATH => {:type => ::Thrift::Types::STRING, :name => 'defaultPoolPath', :optional => true},
    ISSETDEFAULTPOOLPATH => {:type => ::Thrift::Types::BOOL, :name => 'isSetDefaultPoolPath', :optional => true},
    NS => {:type => ::Thrift::Types::STRING, :name => 'ns', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    unless @status.nil? || ::WMResourcePlanStatus::VALID_VALUES.include?(@status)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field status!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class WMPool
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RESOURCEPLANNAME = 1
  POOLPATH = 2
  ALLOCFRACTION = 3
  QUERYPARALLELISM = 4
  SCHEDULINGPOLICY = 5
  NS = 6

  FIELDS = {
    RESOURCEPLANNAME => {:type => ::Thrift::Types::STRING, :name => 'resourcePlanName'},
    POOLPATH => {:type => ::Thrift::Types::STRING, :name => 'poolPath'},
    ALLOCFRACTION => {:type => ::Thrift::Types::DOUBLE, :name => 'allocFraction', :optional => true},
    QUERYPARALLELISM => {:type => ::Thrift::Types::I32, :name => 'queryParallelism', :optional => true},
    SCHEDULINGPOLICY => {:type => ::Thrift::Types::STRING, :name => 'schedulingPolicy', :optional => true},
    NS => {:type => ::Thrift::Types::STRING, :name => 'ns', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field resourcePlanName is unset!') unless @resourcePlanName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field poolPath is unset!') unless @poolPath
  end

  ::Thrift::Struct.generate_accessors self
end

class WMNullablePool
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RESOURCEPLANNAME = 1
  POOLPATH = 2
  ALLOCFRACTION = 3
  QUERYPARALLELISM = 4
  SCHEDULINGPOLICY = 5
  ISSETSCHEDULINGPOLICY = 6
  NS = 7

  FIELDS = {
    RESOURCEPLANNAME => {:type => ::Thrift::Types::STRING, :name => 'resourcePlanName'},
    POOLPATH => {:type => ::Thrift::Types::STRING, :name => 'poolPath'},
    ALLOCFRACTION => {:type => ::Thrift::Types::DOUBLE, :name => 'allocFraction', :optional => true},
    QUERYPARALLELISM => {:type => ::Thrift::Types::I32, :name => 'queryParallelism', :optional => true},
    SCHEDULINGPOLICY => {:type => ::Thrift::Types::STRING, :name => 'schedulingPolicy', :optional => true},
    ISSETSCHEDULINGPOLICY => {:type => ::Thrift::Types::BOOL, :name => 'isSetSchedulingPolicy', :optional => true},
    NS => {:type => ::Thrift::Types::STRING, :name => 'ns', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field resourcePlanName is unset!') unless @resourcePlanName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field poolPath is unset!') unless @poolPath
  end

  ::Thrift::Struct.generate_accessors self
end

class WMTrigger
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RESOURCEPLANNAME = 1
  TRIGGERNAME = 2
  TRIGGEREXPRESSION = 3
  ACTIONEXPRESSION = 4
  ISINUNMANAGED = 5
  NS = 6

  FIELDS = {
    RESOURCEPLANNAME => {:type => ::Thrift::Types::STRING, :name => 'resourcePlanName'},
    TRIGGERNAME => {:type => ::Thrift::Types::STRING, :name => 'triggerName'},
    TRIGGEREXPRESSION => {:type => ::Thrift::Types::STRING, :name => 'triggerExpression', :optional => true},
    ACTIONEXPRESSION => {:type => ::Thrift::Types::STRING, :name => 'actionExpression', :optional => true},
    ISINUNMANAGED => {:type => ::Thrift::Types::BOOL, :name => 'isInUnmanaged', :optional => true},
    NS => {:type => ::Thrift::Types::STRING, :name => 'ns', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field resourcePlanName is unset!') unless @resourcePlanName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field triggerName is unset!') unless @triggerName
  end

  ::Thrift::Struct.generate_accessors self
end

class WMMapping
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RESOURCEPLANNAME = 1
  ENTITYTYPE = 2
  ENTITYNAME = 3
  POOLPATH = 4
  ORDERING = 5
  NS = 6

  FIELDS = {
    RESOURCEPLANNAME => {:type => ::Thrift::Types::STRING, :name => 'resourcePlanName'},
    ENTITYTYPE => {:type => ::Thrift::Types::STRING, :name => 'entityType'},
    ENTITYNAME => {:type => ::Thrift::Types::STRING, :name => 'entityName'},
    POOLPATH => {:type => ::Thrift::Types::STRING, :name => 'poolPath', :optional => true},
    ORDERING => {:type => ::Thrift::Types::I32, :name => 'ordering', :optional => true},
    NS => {:type => ::Thrift::Types::STRING, :name => 'ns', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field resourcePlanName is unset!') unless @resourcePlanName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field entityType is unset!') unless @entityType
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field entityName is unset!') unless @entityName
  end

  ::Thrift::Struct.generate_accessors self
end

class WMPoolTrigger
  include ::Thrift::Struct, ::Thrift::Struct_Union
  POOL = 1
  TRIGGER = 2
  NS = 3

  FIELDS = {
    POOL => {:type => ::Thrift::Types::STRING, :name => 'pool'},
    TRIGGER => {:type => ::Thrift::Types::STRING, :name => 'trigger'},
    NS => {:type => ::Thrift::Types::STRING, :name => 'ns', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pool is unset!') unless @pool
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field trigger is unset!') unless @trigger
  end

  ::Thrift::Struct.generate_accessors self
end

class WMFullResourcePlan
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PLAN = 1
  POOLS = 2
  MAPPINGS = 3
  TRIGGERS = 4
  POOLTRIGGERS = 5

  FIELDS = {
    PLAN => {:type => ::Thrift::Types::STRUCT, :name => 'plan', :class => ::WMResourcePlan},
    POOLS => {:type => ::Thrift::Types::LIST, :name => 'pools', :element => {:type => ::Thrift::Types::STRUCT, :class => ::WMPool}},
    MAPPINGS => {:type => ::Thrift::Types::LIST, :name => 'mappings', :element => {:type => ::Thrift::Types::STRUCT, :class => ::WMMapping}, :optional => true},
    TRIGGERS => {:type => ::Thrift::Types::LIST, :name => 'triggers', :element => {:type => ::Thrift::Types::STRUCT, :class => ::WMTrigger}, :optional => true},
    POOLTRIGGERS => {:type => ::Thrift::Types::LIST, :name => 'poolTriggers', :element => {:type => ::Thrift::Types::STRUCT, :class => ::WMPoolTrigger}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field plan is unset!') unless @plan
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pools is unset!') unless @pools
  end

  ::Thrift::Struct.generate_accessors self
end

class WMCreateResourcePlanRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RESOURCEPLAN = 1
  COPYFROM = 2

  FIELDS = {
    RESOURCEPLAN => {:type => ::Thrift::Types::STRUCT, :name => 'resourcePlan', :class => ::WMResourcePlan, :optional => true},
    COPYFROM => {:type => ::Thrift::Types::STRING, :name => 'copyFrom', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMCreateResourcePlanResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMGetActiveResourcePlanRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NS = 1

  FIELDS = {
    NS => {:type => ::Thrift::Types::STRING, :name => 'ns', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMGetActiveResourcePlanResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RESOURCEPLAN = 1

  FIELDS = {
    RESOURCEPLAN => {:type => ::Thrift::Types::STRUCT, :name => 'resourcePlan', :class => ::WMFullResourcePlan, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMGetResourcePlanRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RESOURCEPLANNAME = 1
  NS = 2

  FIELDS = {
    RESOURCEPLANNAME => {:type => ::Thrift::Types::STRING, :name => 'resourcePlanName', :optional => true},
    NS => {:type => ::Thrift::Types::STRING, :name => 'ns', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMGetResourcePlanResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RESOURCEPLAN = 1

  FIELDS = {
    RESOURCEPLAN => {:type => ::Thrift::Types::STRUCT, :name => 'resourcePlan', :class => ::WMFullResourcePlan, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMGetAllResourcePlanRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NS = 1

  FIELDS = {
    NS => {:type => ::Thrift::Types::STRING, :name => 'ns', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMGetAllResourcePlanResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RESOURCEPLANS = 1

  FIELDS = {
    RESOURCEPLANS => {:type => ::Thrift::Types::LIST, :name => 'resourcePlans', :element => {:type => ::Thrift::Types::STRUCT, :class => ::WMResourcePlan}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMAlterResourcePlanRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RESOURCEPLANNAME = 1
  RESOURCEPLAN = 2
  ISENABLEANDACTIVATE = 3
  ISFORCEDEACTIVATE = 4
  ISREPLACE = 5
  NS = 6

  FIELDS = {
    RESOURCEPLANNAME => {:type => ::Thrift::Types::STRING, :name => 'resourcePlanName', :optional => true},
    RESOURCEPLAN => {:type => ::Thrift::Types::STRUCT, :name => 'resourcePlan', :class => ::WMNullableResourcePlan, :optional => true},
    ISENABLEANDACTIVATE => {:type => ::Thrift::Types::BOOL, :name => 'isEnableAndActivate', :optional => true},
    ISFORCEDEACTIVATE => {:type => ::Thrift::Types::BOOL, :name => 'isForceDeactivate', :optional => true},
    ISREPLACE => {:type => ::Thrift::Types::BOOL, :name => 'isReplace', :optional => true},
    NS => {:type => ::Thrift::Types::STRING, :name => 'ns', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMAlterResourcePlanResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FULLRESOURCEPLAN = 1

  FIELDS = {
    FULLRESOURCEPLAN => {:type => ::Thrift::Types::STRUCT, :name => 'fullResourcePlan', :class => ::WMFullResourcePlan, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMValidateResourcePlanRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RESOURCEPLANNAME = 1
  NS = 2

  FIELDS = {
    RESOURCEPLANNAME => {:type => ::Thrift::Types::STRING, :name => 'resourcePlanName', :optional => true},
    NS => {:type => ::Thrift::Types::STRING, :name => 'ns', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMValidateResourcePlanResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  ERRORS = 1
  WARNINGS = 2

  FIELDS = {
    ERRORS => {:type => ::Thrift::Types::LIST, :name => 'errors', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    WARNINGS => {:type => ::Thrift::Types::LIST, :name => 'warnings', :element => {:type => ::Thrift::Types::STRING}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMDropResourcePlanRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RESOURCEPLANNAME = 1
  NS = 2

  FIELDS = {
    RESOURCEPLANNAME => {:type => ::Thrift::Types::STRING, :name => 'resourcePlanName', :optional => true},
    NS => {:type => ::Thrift::Types::STRING, :name => 'ns', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMDropResourcePlanResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMCreateTriggerRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TRIGGER = 1

  FIELDS = {
    TRIGGER => {:type => ::Thrift::Types::STRUCT, :name => 'trigger', :class => ::WMTrigger, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMCreateTriggerResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMAlterTriggerRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TRIGGER = 1

  FIELDS = {
    TRIGGER => {:type => ::Thrift::Types::STRUCT, :name => 'trigger', :class => ::WMTrigger, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMAlterTriggerResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMDropTriggerRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RESOURCEPLANNAME = 1
  TRIGGERNAME = 2
  NS = 3

  FIELDS = {
    RESOURCEPLANNAME => {:type => ::Thrift::Types::STRING, :name => 'resourcePlanName', :optional => true},
    TRIGGERNAME => {:type => ::Thrift::Types::STRING, :name => 'triggerName', :optional => true},
    NS => {:type => ::Thrift::Types::STRING, :name => 'ns', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMDropTriggerResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMGetTriggersForResourePlanRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RESOURCEPLANNAME = 1
  NS = 2

  FIELDS = {
    RESOURCEPLANNAME => {:type => ::Thrift::Types::STRING, :name => 'resourcePlanName', :optional => true},
    NS => {:type => ::Thrift::Types::STRING, :name => 'ns', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMGetTriggersForResourePlanResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TRIGGERS = 1

  FIELDS = {
    TRIGGERS => {:type => ::Thrift::Types::LIST, :name => 'triggers', :element => {:type => ::Thrift::Types::STRUCT, :class => ::WMTrigger}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMCreatePoolRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  POOL = 1

  FIELDS = {
    POOL => {:type => ::Thrift::Types::STRUCT, :name => 'pool', :class => ::WMPool, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMCreatePoolResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMAlterPoolRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  POOL = 1
  POOLPATH = 2

  FIELDS = {
    POOL => {:type => ::Thrift::Types::STRUCT, :name => 'pool', :class => ::WMNullablePool, :optional => true},
    POOLPATH => {:type => ::Thrift::Types::STRING, :name => 'poolPath', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMAlterPoolResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMDropPoolRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RESOURCEPLANNAME = 1
  POOLPATH = 2
  NS = 3

  FIELDS = {
    RESOURCEPLANNAME => {:type => ::Thrift::Types::STRING, :name => 'resourcePlanName', :optional => true},
    POOLPATH => {:type => ::Thrift::Types::STRING, :name => 'poolPath', :optional => true},
    NS => {:type => ::Thrift::Types::STRING, :name => 'ns', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMDropPoolResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMCreateOrUpdateMappingRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  MAPPING = 1
  UPDATE = 2

  FIELDS = {
    MAPPING => {:type => ::Thrift::Types::STRUCT, :name => 'mapping', :class => ::WMMapping, :optional => true},
    UPDATE => {:type => ::Thrift::Types::BOOL, :name => 'update', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMCreateOrUpdateMappingResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMDropMappingRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  MAPPING = 1

  FIELDS = {
    MAPPING => {:type => ::Thrift::Types::STRUCT, :name => 'mapping', :class => ::WMMapping, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMDropMappingResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMCreateOrDropTriggerToPoolMappingRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RESOURCEPLANNAME = 1
  TRIGGERNAME = 2
  POOLPATH = 3
  DROP = 4
  NS = 5

  FIELDS = {
    RESOURCEPLANNAME => {:type => ::Thrift::Types::STRING, :name => 'resourcePlanName', :optional => true},
    TRIGGERNAME => {:type => ::Thrift::Types::STRING, :name => 'triggerName', :optional => true},
    POOLPATH => {:type => ::Thrift::Types::STRING, :name => 'poolPath', :optional => true},
    DROP => {:type => ::Thrift::Types::BOOL, :name => 'drop', :optional => true},
    NS => {:type => ::Thrift::Types::STRING, :name => 'ns', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class WMCreateOrDropTriggerToPoolMappingResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class ISchema
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SCHEMATYPE = 1
  NAME = 2
  CATNAME = 3
  DBNAME = 4
  COMPATIBILITY = 5
  VALIDATIONLEVEL = 6
  CANEVOLVE = 7
  SCHEMAGROUP = 8
  DESCRIPTION = 9

  FIELDS = {
    SCHEMATYPE => {:type => ::Thrift::Types::I32, :name => 'schemaType', :enum_class => ::SchemaType},
    NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName'},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    COMPATIBILITY => {:type => ::Thrift::Types::I32, :name => 'compatibility', :enum_class => ::SchemaCompatibility},
    VALIDATIONLEVEL => {:type => ::Thrift::Types::I32, :name => 'validationLevel', :enum_class => ::SchemaValidation},
    CANEVOLVE => {:type => ::Thrift::Types::BOOL, :name => 'canEvolve'},
    SCHEMAGROUP => {:type => ::Thrift::Types::STRING, :name => 'schemaGroup', :optional => true},
    DESCRIPTION => {:type => ::Thrift::Types::STRING, :name => 'description', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    unless @schemaType.nil? || ::SchemaType::VALID_VALUES.include?(@schemaType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field schemaType!')
    end
    unless @compatibility.nil? || ::SchemaCompatibility::VALID_VALUES.include?(@compatibility)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field compatibility!')
    end
    unless @validationLevel.nil? || ::SchemaValidation::VALID_VALUES.include?(@validationLevel)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field validationLevel!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class ISchemaName
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  DBNAME = 2
  SCHEMANAME = 3

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName'},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    SCHEMANAME => {:type => ::Thrift::Types::STRING, :name => 'schemaName'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class AlterISchemaRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NAME = 1
  NEWSCHEMA = 3

  FIELDS = {
    NAME => {:type => ::Thrift::Types::STRUCT, :name => 'name', :class => ::ISchemaName},
    NEWSCHEMA => {:type => ::Thrift::Types::STRUCT, :name => 'newSchema', :class => ::ISchema}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class SchemaVersion
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SCHEMA = 1
  VERSION = 2
  CREATEDAT = 3
  COLS = 4
  STATE = 5
  DESCRIPTION = 6
  SCHEMATEXT = 7
  FINGERPRINT = 8
  NAME = 9
  SERDE = 10

  FIELDS = {
    SCHEMA => {:type => ::Thrift::Types::STRUCT, :name => 'schema', :class => ::ISchemaName},
    VERSION => {:type => ::Thrift::Types::I32, :name => 'version'},
    CREATEDAT => {:type => ::Thrift::Types::I64, :name => 'createdAt'},
    COLS => {:type => ::Thrift::Types::LIST, :name => 'cols', :element => {:type => ::Thrift::Types::STRUCT, :class => ::FieldSchema}},
    STATE => {:type => ::Thrift::Types::I32, :name => 'state', :optional => true, :enum_class => ::SchemaVersionState},
    DESCRIPTION => {:type => ::Thrift::Types::STRING, :name => 'description', :optional => true},
    SCHEMATEXT => {:type => ::Thrift::Types::STRING, :name => 'schemaText', :optional => true},
    FINGERPRINT => {:type => ::Thrift::Types::STRING, :name => 'fingerprint', :optional => true},
    NAME => {:type => ::Thrift::Types::STRING, :name => 'name', :optional => true},
    SERDE => {:type => ::Thrift::Types::STRUCT, :name => 'serDe', :class => ::SerDeInfo, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    unless @state.nil? || ::SchemaVersionState::VALID_VALUES.include?(@state)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field state!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class SchemaVersionDescriptor
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SCHEMA = 1
  VERSION = 2

  FIELDS = {
    SCHEMA => {:type => ::Thrift::Types::STRUCT, :name => 'schema', :class => ::ISchemaName},
    VERSION => {:type => ::Thrift::Types::I32, :name => 'version'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class FindSchemasByColsRqst
  include ::Thrift::Struct, ::Thrift::Struct_Union
  COLNAME = 1
  COLNAMESPACE = 2
  TYPE = 3

  FIELDS = {
    COLNAME => {:type => ::Thrift::Types::STRING, :name => 'colName', :optional => true},
    COLNAMESPACE => {:type => ::Thrift::Types::STRING, :name => 'colNamespace', :optional => true},
    TYPE => {:type => ::Thrift::Types::STRING, :name => 'type', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class FindSchemasByColsResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SCHEMAVERSIONS = 1

  FIELDS = {
    SCHEMAVERSIONS => {:type => ::Thrift::Types::LIST, :name => 'schemaVersions', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SchemaVersionDescriptor}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class MapSchemaVersionToSerdeRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SCHEMAVERSION = 1
  SERDENAME = 2

  FIELDS = {
    SCHEMAVERSION => {:type => ::Thrift::Types::STRUCT, :name => 'schemaVersion', :class => ::SchemaVersionDescriptor},
    SERDENAME => {:type => ::Thrift::Types::STRING, :name => 'serdeName'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class SetSchemaVersionStateRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SCHEMAVERSION = 1
  STATE = 2

  FIELDS = {
    SCHEMAVERSION => {:type => ::Thrift::Types::STRUCT, :name => 'schemaVersion', :class => ::SchemaVersionDescriptor},
    STATE => {:type => ::Thrift::Types::I32, :name => 'state', :enum_class => ::SchemaVersionState}
  }

  def struct_fields; FIELDS; end

  def validate
    unless @state.nil? || ::SchemaVersionState::VALID_VALUES.include?(@state)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field state!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class GetSerdeRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SERDENAME = 1

  FIELDS = {
    SERDENAME => {:type => ::Thrift::Types::STRING, :name => 'serdeName'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class RuntimeStat
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CREATETIME = 1
  WEIGHT = 2
  PAYLOAD = 3

  FIELDS = {
    CREATETIME => {:type => ::Thrift::Types::I32, :name => 'createTime', :optional => true},
    WEIGHT => {:type => ::Thrift::Types::I32, :name => 'weight'},
    PAYLOAD => {:type => ::Thrift::Types::STRING, :name => 'payload', :binary => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field weight is unset!') unless @weight
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field payload is unset!') unless @payload
  end

  ::Thrift::Struct.generate_accessors self
end

class GetRuntimeStatsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  MAXWEIGHT = 1
  MAXCREATETIME = 2

  FIELDS = {
    MAXWEIGHT => {:type => ::Thrift::Types::I32, :name => 'maxWeight'},
    MAXCREATETIME => {:type => ::Thrift::Types::I32, :name => 'maxCreateTime'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field maxWeight is unset!') unless @maxWeight
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field maxCreateTime is unset!') unless @maxCreateTime
  end

  ::Thrift::Struct.generate_accessors self
end

class CreateTableRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TABLE = 1
  ENVCONTEXT = 2
  PRIMARYKEYS = 3
  FOREIGNKEYS = 4
  UNIQUECONSTRAINTS = 5
  NOTNULLCONSTRAINTS = 6
  DEFAULTCONSTRAINTS = 7
  CHECKCONSTRAINTS = 8
  PROCESSORCAPABILITIES = 9
  PROCESSORIDENTIFIER = 10

  FIELDS = {
    TABLE => {:type => ::Thrift::Types::STRUCT, :name => 'table', :class => ::Table},
    ENVCONTEXT => {:type => ::Thrift::Types::STRUCT, :name => 'envContext', :class => ::EnvironmentContext, :optional => true},
    PRIMARYKEYS => {:type => ::Thrift::Types::LIST, :name => 'primaryKeys', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLPrimaryKey}, :optional => true},
    FOREIGNKEYS => {:type => ::Thrift::Types::LIST, :name => 'foreignKeys', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLForeignKey}, :optional => true},
    UNIQUECONSTRAINTS => {:type => ::Thrift::Types::LIST, :name => 'uniqueConstraints', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLUniqueConstraint}, :optional => true},
    NOTNULLCONSTRAINTS => {:type => ::Thrift::Types::LIST, :name => 'notNullConstraints', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLNotNullConstraint}, :optional => true},
    DEFAULTCONSTRAINTS => {:type => ::Thrift::Types::LIST, :name => 'defaultConstraints', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLDefaultConstraint}, :optional => true},
    CHECKCONSTRAINTS => {:type => ::Thrift::Types::LIST, :name => 'checkConstraints', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SQLCheckConstraint}, :optional => true},
    PROCESSORCAPABILITIES => {:type => ::Thrift::Types::LIST, :name => 'processorCapabilities', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    PROCESSORIDENTIFIER => {:type => ::Thrift::Types::STRING, :name => 'processorIdentifier', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
  end

  ::Thrift::Struct.generate_accessors self
end

class ScheduledQueryPollRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CLUSTERNAMESPACE = 1

  FIELDS = {
    CLUSTERNAMESPACE => {:type => ::Thrift::Types::STRING, :name => 'clusterNamespace'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field clusterNamespace is unset!') unless @clusterNamespace
  end

  ::Thrift::Struct.generate_accessors self
end

class ScheduledQueryKey
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SCHEDULENAME = 1
  CLUSTERNAMESPACE = 2

  FIELDS = {
    SCHEDULENAME => {:type => ::Thrift::Types::STRING, :name => 'scheduleName'},
    CLUSTERNAMESPACE => {:type => ::Thrift::Types::STRING, :name => 'clusterNamespace'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field scheduleName is unset!') unless @scheduleName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field clusterNamespace is unset!') unless @clusterNamespace
  end

  ::Thrift::Struct.generate_accessors self
end

class ScheduledQueryPollResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SCHEDULEKEY = 1
  EXECUTIONID = 2
  QUERY = 3
  USER = 4

  FIELDS = {
    SCHEDULEKEY => {:type => ::Thrift::Types::STRUCT, :name => 'scheduleKey', :class => ::ScheduledQueryKey, :optional => true},
    EXECUTIONID => {:type => ::Thrift::Types::I64, :name => 'executionId', :optional => true},
    QUERY => {:type => ::Thrift::Types::STRING, :name => 'query', :optional => true},
    USER => {:type => ::Thrift::Types::STRING, :name => 'user', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class ScheduledQuery
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SCHEDULEKEY = 1
  ENABLED = 2
  SCHEDULE = 4
  USER = 5
  QUERY = 6
  NEXTEXECUTION = 7

  FIELDS = {
    SCHEDULEKEY => {:type => ::Thrift::Types::STRUCT, :name => 'scheduleKey', :class => ::ScheduledQueryKey},
    ENABLED => {:type => ::Thrift::Types::BOOL, :name => 'enabled', :optional => true},
    SCHEDULE => {:type => ::Thrift::Types::STRING, :name => 'schedule', :optional => true},
    USER => {:type => ::Thrift::Types::STRING, :name => 'user', :optional => true},
    QUERY => {:type => ::Thrift::Types::STRING, :name => 'query', :optional => true},
    NEXTEXECUTION => {:type => ::Thrift::Types::I32, :name => 'nextExecution', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field scheduleKey is unset!') unless @scheduleKey
  end

  ::Thrift::Struct.generate_accessors self
end

class ScheduledQueryMaintenanceRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TYPE = 1
  SCHEDULEDQUERY = 2

  FIELDS = {
    TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::ScheduledQueryMaintenanceRequestType},
    SCHEDULEDQUERY => {:type => ::Thrift::Types::STRUCT, :name => 'scheduledQuery', :class => ::ScheduledQuery}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field type is unset!') unless @type
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field scheduledQuery is unset!') unless @scheduledQuery
    unless @type.nil? || ::ScheduledQueryMaintenanceRequestType::VALID_VALUES.include?(@type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class ScheduledQueryProgressInfo
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SCHEDULEDEXECUTIONID = 1
  STATE = 2
  EXECUTORQUERYID = 3
  ERRORMESSAGE = 4

  FIELDS = {
    SCHEDULEDEXECUTIONID => {:type => ::Thrift::Types::I64, :name => 'scheduledExecutionId'},
    STATE => {:type => ::Thrift::Types::I32, :name => 'state', :enum_class => ::QueryState},
    EXECUTORQUERYID => {:type => ::Thrift::Types::STRING, :name => 'executorQueryId'},
    ERRORMESSAGE => {:type => ::Thrift::Types::STRING, :name => 'errorMessage', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field scheduledExecutionId is unset!') unless @scheduledExecutionId
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field state is unset!') unless @state
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field executorQueryId is unset!') unless @executorQueryId
    unless @state.nil? || ::QueryState::VALID_VALUES.include?(@state)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field state!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class AlterPartitionsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  DBNAME = 2
  TABLENAME = 3
  PARTITIONS = 4
  ENVIRONMENTCONTEXT = 5
  WRITEID = 6
  VALIDWRITEIDLIST = 7

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName'},
    PARTITIONS => {:type => ::Thrift::Types::LIST, :name => 'partitions', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Partition}},
    ENVIRONMENTCONTEXT => {:type => ::Thrift::Types::STRUCT, :name => 'environmentContext', :class => ::EnvironmentContext, :optional => true},
    WRITEID => {:type => ::Thrift::Types::I64, :name => 'writeId', :default => -1, :optional => true},
    VALIDWRITEIDLIST => {:type => ::Thrift::Types::STRING, :name => 'validWriteIdList', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tableName is unset!') unless @tableName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field partitions is unset!') unless @partitions
  end

  ::Thrift::Struct.generate_accessors self
end

class AlterPartitionsResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class RenamePartitionRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  DBNAME = 2
  TABLENAME = 3
  PARTVALS = 4
  NEWPART = 5
  VALIDWRITEIDLIST = 6

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName'},
    PARTVALS => {:type => ::Thrift::Types::LIST, :name => 'partVals', :element => {:type => ::Thrift::Types::STRING}},
    NEWPART => {:type => ::Thrift::Types::STRUCT, :name => 'newPart', :class => ::Partition},
    VALIDWRITEIDLIST => {:type => ::Thrift::Types::STRING, :name => 'validWriteIdList', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tableName is unset!') unless @tableName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field partVals is unset!') unless @partVals
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field newPart is unset!') unless @newPart
  end

  ::Thrift::Struct.generate_accessors self
end

class RenamePartitionResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class AlterTableRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  DBNAME = 2
  TABLENAME = 3
  TABLE = 4
  ENVIRONMENTCONTEXT = 5
  WRITEID = 6
  VALIDWRITEIDLIST = 7
  PROCESSORCAPABILITIES = 8
  PROCESSORIDENTIFIER = 9

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName'},
    TABLE => {:type => ::Thrift::Types::STRUCT, :name => 'table', :class => ::Table},
    ENVIRONMENTCONTEXT => {:type => ::Thrift::Types::STRUCT, :name => 'environmentContext', :class => ::EnvironmentContext, :optional => true},
    WRITEID => {:type => ::Thrift::Types::I64, :name => 'writeId', :default => -1, :optional => true},
    VALIDWRITEIDLIST => {:type => ::Thrift::Types::STRING, :name => 'validWriteIdList', :optional => true},
    PROCESSORCAPABILITIES => {:type => ::Thrift::Types::LIST, :name => 'processorCapabilities', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    PROCESSORIDENTIFIER => {:type => ::Thrift::Types::STRING, :name => 'processorIdentifier', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tableName is unset!') unless @tableName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
  end

  ::Thrift::Struct.generate_accessors self
end

class AlterTableResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class GetPartitionsFilterSpec
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FILTERMODE = 7
  FILTERS = 8

  FIELDS = {
    FILTERMODE => {:type => ::Thrift::Types::I32, :name => 'filterMode', :optional => true, :enum_class => ::PartitionFilterMode},
    FILTERS => {:type => ::Thrift::Types::LIST, :name => 'filters', :element => {:type => ::Thrift::Types::STRING}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    unless @filterMode.nil? || ::PartitionFilterMode::VALID_VALUES.include?(@filterMode)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field filterMode!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class GetPartitionsResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PARTITIONSPEC = 1

  FIELDS = {
    PARTITIONSPEC => {:type => ::Thrift::Types::LIST, :name => 'partitionSpec', :element => {:type => ::Thrift::Types::STRUCT, :class => ::PartitionSpec}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class GetPartitionsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  DBNAME = 2
  TBLNAME = 3
  WITHAUTH = 4
  USER = 5
  GROUPNAMES = 6
  PROJECTIONSPEC = 7
  FILTERSPEC = 8
  PROCESSORCAPABILITIES = 9
  PROCESSORIDENTIFIER = 10
  VALIDWRITEIDLIST = 11

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TBLNAME => {:type => ::Thrift::Types::STRING, :name => 'tblName'},
    WITHAUTH => {:type => ::Thrift::Types::BOOL, :name => 'withAuth', :optional => true},
    USER => {:type => ::Thrift::Types::STRING, :name => 'user', :optional => true},
    GROUPNAMES => {:type => ::Thrift::Types::LIST, :name => 'groupNames', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    PROJECTIONSPEC => {:type => ::Thrift::Types::STRUCT, :name => 'projectionSpec', :class => ::GetProjectionsSpec},
    FILTERSPEC => {:type => ::Thrift::Types::STRUCT, :name => 'filterSpec', :class => ::GetPartitionsFilterSpec},
    PROCESSORCAPABILITIES => {:type => ::Thrift::Types::LIST, :name => 'processorCapabilities', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    PROCESSORIDENTIFIER => {:type => ::Thrift::Types::STRING, :name => 'processorIdentifier', :optional => true},
    VALIDWRITEIDLIST => {:type => ::Thrift::Types::STRING, :name => 'validWriteIdList', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class GetFieldsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  DBNAME = 2
  TBLNAME = 3
  ENVCONTEXT = 4
  VALIDWRITEIDLIST = 5
  ID = 6

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TBLNAME => {:type => ::Thrift::Types::STRING, :name => 'tblName'},
    ENVCONTEXT => {:type => ::Thrift::Types::STRUCT, :name => 'envContext', :class => ::EnvironmentContext, :optional => true},
    VALIDWRITEIDLIST => {:type => ::Thrift::Types::STRING, :name => 'validWriteIdList', :optional => true},
    ID => {:type => ::Thrift::Types::I64, :name => 'id', :default => -1, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tblName is unset!') unless @tblName
  end

  ::Thrift::Struct.generate_accessors self
end

class GetFieldsResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FIELDS = 1

  FIELDS = {
    FIELDS => {:type => ::Thrift::Types::LIST, :name => 'fields', :element => {:type => ::Thrift::Types::STRUCT, :class => ::FieldSchema}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field fields is unset!') unless @fields
  end

  ::Thrift::Struct.generate_accessors self
end

class GetSchemaRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  DBNAME = 2
  TBLNAME = 3
  ENVCONTEXT = 4
  VALIDWRITEIDLIST = 5
  ID = 6

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TBLNAME => {:type => ::Thrift::Types::STRING, :name => 'tblName'},
    ENVCONTEXT => {:type => ::Thrift::Types::STRUCT, :name => 'envContext', :class => ::EnvironmentContext, :optional => true},
    VALIDWRITEIDLIST => {:type => ::Thrift::Types::STRING, :name => 'validWriteIdList', :optional => true},
    ID => {:type => ::Thrift::Types::I64, :name => 'id', :default => -1, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tblName is unset!') unless @tblName
  end

  ::Thrift::Struct.generate_accessors self
end

class GetSchemaResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FIELDS = 1

  FIELDS = {
    FIELDS => {:type => ::Thrift::Types::LIST, :name => 'fields', :element => {:type => ::Thrift::Types::STRUCT, :class => ::FieldSchema}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field fields is unset!') unless @fields
  end

  ::Thrift::Struct.generate_accessors self
end

class GetPartitionRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  DBNAME = 2
  TBLNAME = 3
  PARTVALS = 4
  VALIDWRITEIDLIST = 5
  ID = 6

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TBLNAME => {:type => ::Thrift::Types::STRING, :name => 'tblName'},
    PARTVALS => {:type => ::Thrift::Types::LIST, :name => 'partVals', :element => {:type => ::Thrift::Types::STRING}},
    VALIDWRITEIDLIST => {:type => ::Thrift::Types::STRING, :name => 'validWriteIdList', :optional => true},
    ID => {:type => ::Thrift::Types::I64, :name => 'id', :default => -1, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tblName is unset!') unless @tblName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field partVals is unset!') unless @partVals
  end

  ::Thrift::Struct.generate_accessors self
end

class GetPartitionResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PARTITION = 1

  FIELDS = {
    PARTITION => {:type => ::Thrift::Types::STRUCT, :name => 'partition', :class => ::Partition}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field partition is unset!') unless @partition
  end

  ::Thrift::Struct.generate_accessors self
end

class PartitionsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  DBNAME = 2
  TBLNAME = 3
  MAXPARTS = 4
  VALIDWRITEIDLIST = 5
  ID = 6

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TBLNAME => {:type => ::Thrift::Types::STRING, :name => 'tblName'},
    MAXPARTS => {:type => ::Thrift::Types::I16, :name => 'maxParts', :default => -1, :optional => true},
    VALIDWRITEIDLIST => {:type => ::Thrift::Types::STRING, :name => 'validWriteIdList', :optional => true},
    ID => {:type => ::Thrift::Types::I64, :name => 'id', :default => -1, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tblName is unset!') unless @tblName
  end

  ::Thrift::Struct.generate_accessors self
end

class PartitionsResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PARTITIONS = 1

  FIELDS = {
    PARTITIONS => {:type => ::Thrift::Types::LIST, :name => 'partitions', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Partition}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field partitions is unset!') unless @partitions
  end

  ::Thrift::Struct.generate_accessors self
end

class GetPartitionNamesPsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  DBNAME = 2
  TBLNAME = 3
  PARTVALUES = 4
  MAXPARTS = 5
  VALIDWRITEIDLIST = 6
  ID = 7

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TBLNAME => {:type => ::Thrift::Types::STRING, :name => 'tblName'},
    PARTVALUES => {:type => ::Thrift::Types::LIST, :name => 'partValues', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    MAXPARTS => {:type => ::Thrift::Types::I16, :name => 'maxParts', :default => -1, :optional => true},
    VALIDWRITEIDLIST => {:type => ::Thrift::Types::STRING, :name => 'validWriteIdList', :optional => true},
    ID => {:type => ::Thrift::Types::I64, :name => 'id', :default => -1, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tblName is unset!') unless @tblName
  end

  ::Thrift::Struct.generate_accessors self
end

class GetPartitionNamesPsResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NAMES = 1

  FIELDS = {
    NAMES => {:type => ::Thrift::Types::LIST, :name => 'names', :element => {:type => ::Thrift::Types::STRING}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field names is unset!') unless @names
  end

  ::Thrift::Struct.generate_accessors self
end

class GetPartitionsPsWithAuthRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  DBNAME = 2
  TBLNAME = 3
  PARTVALS = 4
  MAXPARTS = 5
  USERNAME = 6
  GROUPNAMES = 7
  VALIDWRITEIDLIST = 8
  ID = 9

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName', :optional => true},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    TBLNAME => {:type => ::Thrift::Types::STRING, :name => 'tblName'},
    PARTVALS => {:type => ::Thrift::Types::LIST, :name => 'partVals', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    MAXPARTS => {:type => ::Thrift::Types::I16, :name => 'maxParts', :default => -1, :optional => true},
    USERNAME => {:type => ::Thrift::Types::STRING, :name => 'userName', :optional => true},
    GROUPNAMES => {:type => ::Thrift::Types::LIST, :name => 'groupNames', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    VALIDWRITEIDLIST => {:type => ::Thrift::Types::STRING, :name => 'validWriteIdList', :optional => true},
    ID => {:type => ::Thrift::Types::I64, :name => 'id', :default => -1, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tblName is unset!') unless @tblName
  end

  ::Thrift::Struct.generate_accessors self
end

class GetPartitionsPsWithAuthResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PARTITIONS = 1

  FIELDS = {
    PARTITIONS => {:type => ::Thrift::Types::LIST, :name => 'partitions', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Partition}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field partitions is unset!') unless @partitions
  end

  ::Thrift::Struct.generate_accessors self
end

class ReplicationMetrics
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SCHEDULEDEXECUTIONID = 1
  POLICY = 2
  DUMPEXECUTIONID = 3
  METADATA = 4
  PROGRESS = 5

  FIELDS = {
    SCHEDULEDEXECUTIONID => {:type => ::Thrift::Types::I64, :name => 'scheduledExecutionId'},
    POLICY => {:type => ::Thrift::Types::STRING, :name => 'policy'},
    DUMPEXECUTIONID => {:type => ::Thrift::Types::I64, :name => 'dumpExecutionId'},
    METADATA => {:type => ::Thrift::Types::STRING, :name => 'metadata', :optional => true},
    PROGRESS => {:type => ::Thrift::Types::STRING, :name => 'progress', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field scheduledExecutionId is unset!') unless @scheduledExecutionId
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field policy is unset!') unless @policy
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dumpExecutionId is unset!') unless @dumpExecutionId
  end

  ::Thrift::Struct.generate_accessors self
end

class ReplicationMetricList
  include ::Thrift::Struct, ::Thrift::Struct_Union
  REPLICATIONMETRICLIST = 1

  FIELDS = {
    REPLICATIONMETRICLIST => {:type => ::Thrift::Types::LIST, :name => 'replicationMetricList', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ReplicationMetrics}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field replicationMetricList is unset!') unless @replicationMetricList
  end

  ::Thrift::Struct.generate_accessors self
end

class GetReplicationMetricsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SCHEDULEDEXECUTIONID = 1
  POLICY = 2
  DUMPEXECUTIONID = 3

  FIELDS = {
    SCHEDULEDEXECUTIONID => {:type => ::Thrift::Types::I64, :name => 'scheduledExecutionId', :optional => true},
    POLICY => {:type => ::Thrift::Types::STRING, :name => 'policy', :optional => true},
    DUMPEXECUTIONID => {:type => ::Thrift::Types::I64, :name => 'dumpExecutionId', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class GetOpenTxnsRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  EXCLUDETXNTYPES = 1

  FIELDS = {
    EXCLUDETXNTYPES => {:type => ::Thrift::Types::LIST, :name => 'excludeTxnTypes', :element => {:type => ::Thrift::Types::I32, :enum_class => ::TxnType}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class StoredProcedureRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  DBNAME = 2
  PROCNAME = 3

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName'},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    PROCNAME => {:type => ::Thrift::Types::STRING, :name => 'procName'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field catName is unset!') unless @catName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field dbName is unset!') unless @dbName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field procName is unset!') unless @procName
  end

  ::Thrift::Struct.generate_accessors self
end

class ListStoredProcedureRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CATNAME = 1
  DBNAME = 2

  FIELDS = {
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName'},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field catName is unset!') unless @catName
  end

  ::Thrift::Struct.generate_accessors self
end

class StoredProcedure
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NAME = 1
  DBNAME = 2
  CATNAME = 3
  OWNERNAME = 4
  SOURCE = 5

  FIELDS = {
    NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
    DBNAME => {:type => ::Thrift::Types::STRING, :name => 'dbName'},
    CATNAME => {:type => ::Thrift::Types::STRING, :name => 'catName'},
    OWNERNAME => {:type => ::Thrift::Types::STRING, :name => 'ownerName'},
    SOURCE => {:type => ::Thrift::Types::STRING, :name => 'source'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class MetaException < ::Thrift::Exception
  include ::Thrift::Struct, ::Thrift::Struct_Union
  def initialize(message=nil)
    super()
    self.message = message
  end

  MESSAGE = 1

  FIELDS = {
    MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class UnknownTableException < ::Thrift::Exception
  include ::Thrift::Struct, ::Thrift::Struct_Union
  def initialize(message=nil)
    super()
    self.message = message
  end

  MESSAGE = 1

  FIELDS = {
    MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class UnknownDBException < ::Thrift::Exception
  include ::Thrift::Struct, ::Thrift::Struct_Union
  def initialize(message=nil)
    super()
    self.message = message
  end

  MESSAGE = 1

  FIELDS = {
    MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class AlreadyExistsException < ::Thrift::Exception
  include ::Thrift::Struct, ::Thrift::Struct_Union
  def initialize(message=nil)
    super()
    self.message = message
  end

  MESSAGE = 1

  FIELDS = {
    MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class InvalidPartitionException < ::Thrift::Exception
  include ::Thrift::Struct, ::Thrift::Struct_Union
  def initialize(message=nil)
    super()
    self.message = message
  end

  MESSAGE = 1

  FIELDS = {
    MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class UnknownPartitionException < ::Thrift::Exception
  include ::Thrift::Struct, ::Thrift::Struct_Union
  def initialize(message=nil)
    super()
    self.message = message
  end

  MESSAGE = 1

  FIELDS = {
    MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class InvalidObjectException < ::Thrift::Exception
  include ::Thrift::Struct, ::Thrift::Struct_Union
  def initialize(message=nil)
    super()
    self.message = message
  end

  MESSAGE = 1

  FIELDS = {
    MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class NoSuchObjectException < ::Thrift::Exception
  include ::Thrift::Struct, ::Thrift::Struct_Union
  def initialize(message=nil)
    super()
    self.message = message
  end

  MESSAGE = 1

  FIELDS = {
    MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class InvalidOperationException < ::Thrift::Exception
  include ::Thrift::Struct, ::Thrift::Struct_Union
  def initialize(message=nil)
    super()
    self.message = message
  end

  MESSAGE = 1

  FIELDS = {
    MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class ConfigValSecurityException < ::Thrift::Exception
  include ::Thrift::Struct, ::Thrift::Struct_Union
  def initialize(message=nil)
    super()
    self.message = message
  end

  MESSAGE = 1

  FIELDS = {
    MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class InvalidInputException < ::Thrift::Exception
  include ::Thrift::Struct, ::Thrift::Struct_Union
  def initialize(message=nil)
    super()
    self.message = message
  end

  MESSAGE = 1

  FIELDS = {
    MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class NoSuchTxnException < ::Thrift::Exception
  include ::Thrift::Struct, ::Thrift::Struct_Union
  def initialize(message=nil)
    super()
    self.message = message
  end

  MESSAGE = 1

  FIELDS = {
    MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class TxnAbortedException < ::Thrift::Exception
  include ::Thrift::Struct, ::Thrift::Struct_Union
  def initialize(message=nil)
    super()
    self.message = message
  end

  MESSAGE = 1

  FIELDS = {
    MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class TxnOpenException < ::Thrift::Exception
  include ::Thrift::Struct, ::Thrift::Struct_Union
  def initialize(message=nil)
    super()
    self.message = message
  end

  MESSAGE = 1

  FIELDS = {
    MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class NoSuchLockException < ::Thrift::Exception
  include ::Thrift::Struct, ::Thrift::Struct_Union
  def initialize(message=nil)
    super()
    self.message = message
  end

  MESSAGE = 1

  FIELDS = {
    MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

