<?php
namespace metastore;

/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


final class HiveObjectType {
  const GLOBAL = 1;
  const DATABASE = 2;
  const TABLE = 3;
  const PARTITION = 4;
  const COLUMN = 5;
  static public $__names = array(
    1 => 'GLOBAL',
    2 => 'DATABASE',
    3 => 'TABLE',
    4 => 'PARTITION',
    5 => 'COLUMN',
  );
}

final class PrincipalType {
  const USER = 1;
  const ROLE = 2;
  const GROUP = 3;
  static public $__names = array(
    1 => 'USER',
    2 => 'ROLE',
    3 => 'GROUP',
  );
}

final class PartitionEventType {
  const LOAD_DONE = 1;
  static public $__names = array(
    1 => 'LOAD_DONE',
  );
}

final class TxnState {
  const COMMITTED = 1;
  const ABORTED = 2;
  const OPEN = 3;
  static public $__names = array(
    1 => 'COMMITTED',
    2 => 'ABORTED',
    3 => 'OPEN',
  );
}

final class LockLevel {
  const DB = 1;
  const TABLE = 2;
  const PARTITION = 3;
  static public $__names = array(
    1 => 'DB',
    2 => 'TABLE',
    3 => 'PARTITION',
  );
}

final class LockState {
  const ACQUIRED = 1;
  const WAITING = 2;
  const ABORT = 3;
  const NOT_ACQUIRED = 4;
  static public $__names = array(
    1 => 'ACQUIRED',
    2 => 'WAITING',
    3 => 'ABORT',
    4 => 'NOT_ACQUIRED',
  );
}

final class LockType {
  const SHARED_READ = 1;
  const SHARED_WRITE = 2;
  const EXCLUSIVE = 3;
  static public $__names = array(
    1 => 'SHARED_READ',
    2 => 'SHARED_WRITE',
    3 => 'EXCLUSIVE',
  );
}

final class CompactionType {
  const MINOR = 1;
  const MAJOR = 2;
  static public $__names = array(
    1 => 'MINOR',
    2 => 'MAJOR',
  );
}

final class GrantRevokeType {
  const GRANT = 1;
  const REVOKE = 2;
  static public $__names = array(
    1 => 'GRANT',
    2 => 'REVOKE',
  );
}

final class DataOperationType {
  const SELECT = 1;
  const INSERT = 2;
  const UPDATE = 3;
  const DELETE = 4;
  const UNSET = 5;
  const NO_TXN = 6;
  static public $__names = array(
    1 => 'SELECT',
    2 => 'INSERT',
    3 => 'UPDATE',
    4 => 'DELETE',
    5 => 'UNSET',
    6 => 'NO_TXN',
  );
}

final class EventRequestType {
  const INSERT = 1;
  const UPDATE = 2;
  const DELETE = 3;
  static public $__names = array(
    1 => 'INSERT',
    2 => 'UPDATE',
    3 => 'DELETE',
  );
}

final class SerdeType {
  const HIVE = 1;
  const SCHEMA_REGISTRY = 2;
  static public $__names = array(
    1 => 'HIVE',
    2 => 'SCHEMA_REGISTRY',
  );
}

final class SchemaType {
  const HIVE = 1;
  const AVRO = 2;
  static public $__names = array(
    1 => 'HIVE',
    2 => 'AVRO',
  );
}

final class SchemaCompatibility {
  const NONE = 1;
  const BACKWARD = 2;
  const FORWARD = 3;
  const BOTH = 4;
  static public $__names = array(
    1 => 'NONE',
    2 => 'BACKWARD',
    3 => 'FORWARD',
    4 => 'BOTH',
  );
}

final class SchemaValidation {
  const LATEST = 1;
  const ALL = 2;
  static public $__names = array(
    1 => 'LATEST',
    2 => 'ALL',
  );
}

final class SchemaVersionState {
  const INITIATED = 1;
  const START_REVIEW = 2;
  const CHANGES_REQUIRED = 3;
  const REVIEWED = 4;
  const ENABLED = 5;
  const DISABLED = 6;
  const ARCHIVED = 7;
  const DELETED = 8;
  static public $__names = array(
    1 => 'INITIATED',
    2 => 'START_REVIEW',
    3 => 'CHANGES_REQUIRED',
    4 => 'REVIEWED',
    5 => 'ENABLED',
    6 => 'DISABLED',
    7 => 'ARCHIVED',
    8 => 'DELETED',
  );
}

final class FunctionType {
  const JAVA = 1;
  static public $__names = array(
    1 => 'JAVA',
  );
}

final class ResourceType {
  const JAR = 1;
  const FILE = 2;
  const ARCHIVE = 3;
  static public $__names = array(
    1 => 'JAR',
    2 => 'FILE',
    3 => 'ARCHIVE',
  );
}

final class FileMetadataExprType {
  const ORC_SARG = 1;
  static public $__names = array(
    1 => 'ORC_SARG',
  );
}

final class ClientCapability {
  const TEST_CAPABILITY = 1;
  const INSERT_ONLY_TABLES = 2;
  static public $__names = array(
    1 => 'TEST_CAPABILITY',
    2 => 'INSERT_ONLY_TABLES',
  );
}

final class WMResourcePlanStatus {
  const ACTIVE = 1;
  const ENABLED = 2;
  const DISABLED = 3;
  static public $__names = array(
    1 => 'ACTIVE',
    2 => 'ENABLED',
    3 => 'DISABLED',
  );
}

final class WMPoolSchedulingPolicy {
  const FAIR = 1;
  const FIFO = 2;
  static public $__names = array(
    1 => 'FAIR',
    2 => 'FIFO',
  );
}

class Version {
  static $_TSPEC;

  /**
   * @var string
   */
  public $version = null;
  /**
   * @var string
   */
  public $comments = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'version',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'comments',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['version'])) {
        $this->version = $vals['version'];
      }
      if (isset($vals['comments'])) {
        $this->comments = $vals['comments'];
      }
    }
  }

  public function getName() {
    return 'Version';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->version);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->comments);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Version');
    if ($this->version !== null) {
      $xfer += $output->writeFieldBegin('version', TType::STRING, 1);
      $xfer += $output->writeString($this->version);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->comments !== null) {
      $xfer += $output->writeFieldBegin('comments', TType::STRING, 2);
      $xfer += $output->writeString($this->comments);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class FieldSchema {
  static $_TSPEC;

  /**
   * @var string
   */
  public $name = null;
  /**
   * @var string
   */
  public $type = null;
  /**
   * @var string
   */
  public $comment = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'type',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'comment',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['comment'])) {
        $this->comment = $vals['comment'];
      }
    }
  }

  public function getName() {
    return 'FieldSchema';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->comment);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('FieldSchema');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::STRING, 2);
      $xfer += $output->writeString($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->comment !== null) {
      $xfer += $output->writeFieldBegin('comment', TType::STRING, 3);
      $xfer += $output->writeString($this->comment);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SQLPrimaryKey {
  static $_TSPEC;

  /**
   * @var string
   */
  public $table_db = null;
  /**
   * @var string
   */
  public $table_name = null;
  /**
   * @var string
   */
  public $column_name = null;
  /**
   * @var int
   */
  public $key_seq = null;
  /**
   * @var string
   */
  public $pk_name = null;
  /**
   * @var bool
   */
  public $enable_cstr = null;
  /**
   * @var bool
   */
  public $validate_cstr = null;
  /**
   * @var bool
   */
  public $rely_cstr = null;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'table_db',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'table_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'column_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'key_seq',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'pk_name',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'enable_cstr',
          'type' => TType::BOOL,
          ),
        7 => array(
          'var' => 'validate_cstr',
          'type' => TType::BOOL,
          ),
        8 => array(
          'var' => 'rely_cstr',
          'type' => TType::BOOL,
          ),
        9 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['table_db'])) {
        $this->table_db = $vals['table_db'];
      }
      if (isset($vals['table_name'])) {
        $this->table_name = $vals['table_name'];
      }
      if (isset($vals['column_name'])) {
        $this->column_name = $vals['column_name'];
      }
      if (isset($vals['key_seq'])) {
        $this->key_seq = $vals['key_seq'];
      }
      if (isset($vals['pk_name'])) {
        $this->pk_name = $vals['pk_name'];
      }
      if (isset($vals['enable_cstr'])) {
        $this->enable_cstr = $vals['enable_cstr'];
      }
      if (isset($vals['validate_cstr'])) {
        $this->validate_cstr = $vals['validate_cstr'];
      }
      if (isset($vals['rely_cstr'])) {
        $this->rely_cstr = $vals['rely_cstr'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'SQLPrimaryKey';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table_db);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->column_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->key_seq);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->pk_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->enable_cstr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->validate_cstr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->rely_cstr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SQLPrimaryKey');
    if ($this->table_db !== null) {
      $xfer += $output->writeFieldBegin('table_db', TType::STRING, 1);
      $xfer += $output->writeString($this->table_db);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->table_name !== null) {
      $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
      $xfer += $output->writeString($this->table_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->column_name !== null) {
      $xfer += $output->writeFieldBegin('column_name', TType::STRING, 3);
      $xfer += $output->writeString($this->column_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->key_seq !== null) {
      $xfer += $output->writeFieldBegin('key_seq', TType::I32, 4);
      $xfer += $output->writeI32($this->key_seq);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->pk_name !== null) {
      $xfer += $output->writeFieldBegin('pk_name', TType::STRING, 5);
      $xfer += $output->writeString($this->pk_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->enable_cstr !== null) {
      $xfer += $output->writeFieldBegin('enable_cstr', TType::BOOL, 6);
      $xfer += $output->writeBool($this->enable_cstr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->validate_cstr !== null) {
      $xfer += $output->writeFieldBegin('validate_cstr', TType::BOOL, 7);
      $xfer += $output->writeBool($this->validate_cstr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rely_cstr !== null) {
      $xfer += $output->writeFieldBegin('rely_cstr', TType::BOOL, 8);
      $xfer += $output->writeBool($this->rely_cstr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 9);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SQLForeignKey {
  static $_TSPEC;

  /**
   * @var string
   */
  public $pktable_db = null;
  /**
   * @var string
   */
  public $pktable_name = null;
  /**
   * @var string
   */
  public $pkcolumn_name = null;
  /**
   * @var string
   */
  public $fktable_db = null;
  /**
   * @var string
   */
  public $fktable_name = null;
  /**
   * @var string
   */
  public $fkcolumn_name = null;
  /**
   * @var int
   */
  public $key_seq = null;
  /**
   * @var int
   */
  public $update_rule = null;
  /**
   * @var int
   */
  public $delete_rule = null;
  /**
   * @var string
   */
  public $fk_name = null;
  /**
   * @var string
   */
  public $pk_name = null;
  /**
   * @var bool
   */
  public $enable_cstr = null;
  /**
   * @var bool
   */
  public $validate_cstr = null;
  /**
   * @var bool
   */
  public $rely_cstr = null;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'pktable_db',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'pktable_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'pkcolumn_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'fktable_db',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'fktable_name',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'fkcolumn_name',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'key_seq',
          'type' => TType::I32,
          ),
        8 => array(
          'var' => 'update_rule',
          'type' => TType::I32,
          ),
        9 => array(
          'var' => 'delete_rule',
          'type' => TType::I32,
          ),
        10 => array(
          'var' => 'fk_name',
          'type' => TType::STRING,
          ),
        11 => array(
          'var' => 'pk_name',
          'type' => TType::STRING,
          ),
        12 => array(
          'var' => 'enable_cstr',
          'type' => TType::BOOL,
          ),
        13 => array(
          'var' => 'validate_cstr',
          'type' => TType::BOOL,
          ),
        14 => array(
          'var' => 'rely_cstr',
          'type' => TType::BOOL,
          ),
        15 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['pktable_db'])) {
        $this->pktable_db = $vals['pktable_db'];
      }
      if (isset($vals['pktable_name'])) {
        $this->pktable_name = $vals['pktable_name'];
      }
      if (isset($vals['pkcolumn_name'])) {
        $this->pkcolumn_name = $vals['pkcolumn_name'];
      }
      if (isset($vals['fktable_db'])) {
        $this->fktable_db = $vals['fktable_db'];
      }
      if (isset($vals['fktable_name'])) {
        $this->fktable_name = $vals['fktable_name'];
      }
      if (isset($vals['fkcolumn_name'])) {
        $this->fkcolumn_name = $vals['fkcolumn_name'];
      }
      if (isset($vals['key_seq'])) {
        $this->key_seq = $vals['key_seq'];
      }
      if (isset($vals['update_rule'])) {
        $this->update_rule = $vals['update_rule'];
      }
      if (isset($vals['delete_rule'])) {
        $this->delete_rule = $vals['delete_rule'];
      }
      if (isset($vals['fk_name'])) {
        $this->fk_name = $vals['fk_name'];
      }
      if (isset($vals['pk_name'])) {
        $this->pk_name = $vals['pk_name'];
      }
      if (isset($vals['enable_cstr'])) {
        $this->enable_cstr = $vals['enable_cstr'];
      }
      if (isset($vals['validate_cstr'])) {
        $this->validate_cstr = $vals['validate_cstr'];
      }
      if (isset($vals['rely_cstr'])) {
        $this->rely_cstr = $vals['rely_cstr'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'SQLForeignKey';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->pktable_db);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->pktable_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->pkcolumn_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->fktable_db);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->fktable_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->fkcolumn_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->key_seq);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->update_rule);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->delete_rule);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->fk_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->pk_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->enable_cstr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 13:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->validate_cstr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 14:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->rely_cstr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 15:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SQLForeignKey');
    if ($this->pktable_db !== null) {
      $xfer += $output->writeFieldBegin('pktable_db', TType::STRING, 1);
      $xfer += $output->writeString($this->pktable_db);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->pktable_name !== null) {
      $xfer += $output->writeFieldBegin('pktable_name', TType::STRING, 2);
      $xfer += $output->writeString($this->pktable_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->pkcolumn_name !== null) {
      $xfer += $output->writeFieldBegin('pkcolumn_name', TType::STRING, 3);
      $xfer += $output->writeString($this->pkcolumn_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->fktable_db !== null) {
      $xfer += $output->writeFieldBegin('fktable_db', TType::STRING, 4);
      $xfer += $output->writeString($this->fktable_db);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->fktable_name !== null) {
      $xfer += $output->writeFieldBegin('fktable_name', TType::STRING, 5);
      $xfer += $output->writeString($this->fktable_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->fkcolumn_name !== null) {
      $xfer += $output->writeFieldBegin('fkcolumn_name', TType::STRING, 6);
      $xfer += $output->writeString($this->fkcolumn_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->key_seq !== null) {
      $xfer += $output->writeFieldBegin('key_seq', TType::I32, 7);
      $xfer += $output->writeI32($this->key_seq);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->update_rule !== null) {
      $xfer += $output->writeFieldBegin('update_rule', TType::I32, 8);
      $xfer += $output->writeI32($this->update_rule);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->delete_rule !== null) {
      $xfer += $output->writeFieldBegin('delete_rule', TType::I32, 9);
      $xfer += $output->writeI32($this->delete_rule);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->fk_name !== null) {
      $xfer += $output->writeFieldBegin('fk_name', TType::STRING, 10);
      $xfer += $output->writeString($this->fk_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->pk_name !== null) {
      $xfer += $output->writeFieldBegin('pk_name', TType::STRING, 11);
      $xfer += $output->writeString($this->pk_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->enable_cstr !== null) {
      $xfer += $output->writeFieldBegin('enable_cstr', TType::BOOL, 12);
      $xfer += $output->writeBool($this->enable_cstr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->validate_cstr !== null) {
      $xfer += $output->writeFieldBegin('validate_cstr', TType::BOOL, 13);
      $xfer += $output->writeBool($this->validate_cstr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rely_cstr !== null) {
      $xfer += $output->writeFieldBegin('rely_cstr', TType::BOOL, 14);
      $xfer += $output->writeBool($this->rely_cstr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 15);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SQLUniqueConstraint {
  static $_TSPEC;

  /**
   * @var string
   */
  public $catName = null;
  /**
   * @var string
   */
  public $table_db = null;
  /**
   * @var string
   */
  public $table_name = null;
  /**
   * @var string
   */
  public $column_name = null;
  /**
   * @var int
   */
  public $key_seq = null;
  /**
   * @var string
   */
  public $uk_name = null;
  /**
   * @var bool
   */
  public $enable_cstr = null;
  /**
   * @var bool
   */
  public $validate_cstr = null;
  /**
   * @var bool
   */
  public $rely_cstr = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'table_db',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'table_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'column_name',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'key_seq',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'uk_name',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'enable_cstr',
          'type' => TType::BOOL,
          ),
        8 => array(
          'var' => 'validate_cstr',
          'type' => TType::BOOL,
          ),
        9 => array(
          'var' => 'rely_cstr',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
      if (isset($vals['table_db'])) {
        $this->table_db = $vals['table_db'];
      }
      if (isset($vals['table_name'])) {
        $this->table_name = $vals['table_name'];
      }
      if (isset($vals['column_name'])) {
        $this->column_name = $vals['column_name'];
      }
      if (isset($vals['key_seq'])) {
        $this->key_seq = $vals['key_seq'];
      }
      if (isset($vals['uk_name'])) {
        $this->uk_name = $vals['uk_name'];
      }
      if (isset($vals['enable_cstr'])) {
        $this->enable_cstr = $vals['enable_cstr'];
      }
      if (isset($vals['validate_cstr'])) {
        $this->validate_cstr = $vals['validate_cstr'];
      }
      if (isset($vals['rely_cstr'])) {
        $this->rely_cstr = $vals['rely_cstr'];
      }
    }
  }

  public function getName() {
    return 'SQLUniqueConstraint';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table_db);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->column_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->key_seq);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->uk_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->enable_cstr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->validate_cstr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->rely_cstr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SQLUniqueConstraint');
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 1);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->table_db !== null) {
      $xfer += $output->writeFieldBegin('table_db', TType::STRING, 2);
      $xfer += $output->writeString($this->table_db);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->table_name !== null) {
      $xfer += $output->writeFieldBegin('table_name', TType::STRING, 3);
      $xfer += $output->writeString($this->table_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->column_name !== null) {
      $xfer += $output->writeFieldBegin('column_name', TType::STRING, 4);
      $xfer += $output->writeString($this->column_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->key_seq !== null) {
      $xfer += $output->writeFieldBegin('key_seq', TType::I32, 5);
      $xfer += $output->writeI32($this->key_seq);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->uk_name !== null) {
      $xfer += $output->writeFieldBegin('uk_name', TType::STRING, 6);
      $xfer += $output->writeString($this->uk_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->enable_cstr !== null) {
      $xfer += $output->writeFieldBegin('enable_cstr', TType::BOOL, 7);
      $xfer += $output->writeBool($this->enable_cstr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->validate_cstr !== null) {
      $xfer += $output->writeFieldBegin('validate_cstr', TType::BOOL, 8);
      $xfer += $output->writeBool($this->validate_cstr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rely_cstr !== null) {
      $xfer += $output->writeFieldBegin('rely_cstr', TType::BOOL, 9);
      $xfer += $output->writeBool($this->rely_cstr);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SQLNotNullConstraint {
  static $_TSPEC;

  /**
   * @var string
   */
  public $catName = null;
  /**
   * @var string
   */
  public $table_db = null;
  /**
   * @var string
   */
  public $table_name = null;
  /**
   * @var string
   */
  public $column_name = null;
  /**
   * @var string
   */
  public $nn_name = null;
  /**
   * @var bool
   */
  public $enable_cstr = null;
  /**
   * @var bool
   */
  public $validate_cstr = null;
  /**
   * @var bool
   */
  public $rely_cstr = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'table_db',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'table_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'column_name',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'nn_name',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'enable_cstr',
          'type' => TType::BOOL,
          ),
        7 => array(
          'var' => 'validate_cstr',
          'type' => TType::BOOL,
          ),
        8 => array(
          'var' => 'rely_cstr',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
      if (isset($vals['table_db'])) {
        $this->table_db = $vals['table_db'];
      }
      if (isset($vals['table_name'])) {
        $this->table_name = $vals['table_name'];
      }
      if (isset($vals['column_name'])) {
        $this->column_name = $vals['column_name'];
      }
      if (isset($vals['nn_name'])) {
        $this->nn_name = $vals['nn_name'];
      }
      if (isset($vals['enable_cstr'])) {
        $this->enable_cstr = $vals['enable_cstr'];
      }
      if (isset($vals['validate_cstr'])) {
        $this->validate_cstr = $vals['validate_cstr'];
      }
      if (isset($vals['rely_cstr'])) {
        $this->rely_cstr = $vals['rely_cstr'];
      }
    }
  }

  public function getName() {
    return 'SQLNotNullConstraint';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table_db);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->column_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->nn_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->enable_cstr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->validate_cstr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->rely_cstr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SQLNotNullConstraint');
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 1);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->table_db !== null) {
      $xfer += $output->writeFieldBegin('table_db', TType::STRING, 2);
      $xfer += $output->writeString($this->table_db);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->table_name !== null) {
      $xfer += $output->writeFieldBegin('table_name', TType::STRING, 3);
      $xfer += $output->writeString($this->table_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->column_name !== null) {
      $xfer += $output->writeFieldBegin('column_name', TType::STRING, 4);
      $xfer += $output->writeString($this->column_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nn_name !== null) {
      $xfer += $output->writeFieldBegin('nn_name', TType::STRING, 5);
      $xfer += $output->writeString($this->nn_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->enable_cstr !== null) {
      $xfer += $output->writeFieldBegin('enable_cstr', TType::BOOL, 6);
      $xfer += $output->writeBool($this->enable_cstr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->validate_cstr !== null) {
      $xfer += $output->writeFieldBegin('validate_cstr', TType::BOOL, 7);
      $xfer += $output->writeBool($this->validate_cstr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rely_cstr !== null) {
      $xfer += $output->writeFieldBegin('rely_cstr', TType::BOOL, 8);
      $xfer += $output->writeBool($this->rely_cstr);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SQLDefaultConstraint {
  static $_TSPEC;

  /**
   * @var string
   */
  public $catName = null;
  /**
   * @var string
   */
  public $table_db = null;
  /**
   * @var string
   */
  public $table_name = null;
  /**
   * @var string
   */
  public $column_name = null;
  /**
   * @var string
   */
  public $default_value = null;
  /**
   * @var string
   */
  public $dc_name = null;
  /**
   * @var bool
   */
  public $enable_cstr = null;
  /**
   * @var bool
   */
  public $validate_cstr = null;
  /**
   * @var bool
   */
  public $rely_cstr = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'table_db',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'table_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'column_name',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'default_value',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'dc_name',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'enable_cstr',
          'type' => TType::BOOL,
          ),
        8 => array(
          'var' => 'validate_cstr',
          'type' => TType::BOOL,
          ),
        9 => array(
          'var' => 'rely_cstr',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
      if (isset($vals['table_db'])) {
        $this->table_db = $vals['table_db'];
      }
      if (isset($vals['table_name'])) {
        $this->table_name = $vals['table_name'];
      }
      if (isset($vals['column_name'])) {
        $this->column_name = $vals['column_name'];
      }
      if (isset($vals['default_value'])) {
        $this->default_value = $vals['default_value'];
      }
      if (isset($vals['dc_name'])) {
        $this->dc_name = $vals['dc_name'];
      }
      if (isset($vals['enable_cstr'])) {
        $this->enable_cstr = $vals['enable_cstr'];
      }
      if (isset($vals['validate_cstr'])) {
        $this->validate_cstr = $vals['validate_cstr'];
      }
      if (isset($vals['rely_cstr'])) {
        $this->rely_cstr = $vals['rely_cstr'];
      }
    }
  }

  public function getName() {
    return 'SQLDefaultConstraint';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table_db);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->column_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->default_value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dc_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->enable_cstr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->validate_cstr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->rely_cstr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SQLDefaultConstraint');
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 1);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->table_db !== null) {
      $xfer += $output->writeFieldBegin('table_db', TType::STRING, 2);
      $xfer += $output->writeString($this->table_db);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->table_name !== null) {
      $xfer += $output->writeFieldBegin('table_name', TType::STRING, 3);
      $xfer += $output->writeString($this->table_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->column_name !== null) {
      $xfer += $output->writeFieldBegin('column_name', TType::STRING, 4);
      $xfer += $output->writeString($this->column_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->default_value !== null) {
      $xfer += $output->writeFieldBegin('default_value', TType::STRING, 5);
      $xfer += $output->writeString($this->default_value);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dc_name !== null) {
      $xfer += $output->writeFieldBegin('dc_name', TType::STRING, 6);
      $xfer += $output->writeString($this->dc_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->enable_cstr !== null) {
      $xfer += $output->writeFieldBegin('enable_cstr', TType::BOOL, 7);
      $xfer += $output->writeBool($this->enable_cstr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->validate_cstr !== null) {
      $xfer += $output->writeFieldBegin('validate_cstr', TType::BOOL, 8);
      $xfer += $output->writeBool($this->validate_cstr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rely_cstr !== null) {
      $xfer += $output->writeFieldBegin('rely_cstr', TType::BOOL, 9);
      $xfer += $output->writeBool($this->rely_cstr);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SQLCheckConstraint {
  static $_TSPEC;

  /**
   * @var string
   */
  public $catName = null;
  /**
   * @var string
   */
  public $table_db = null;
  /**
   * @var string
   */
  public $table_name = null;
  /**
   * @var string
   */
  public $column_name = null;
  /**
   * @var string
   */
  public $check_expression = null;
  /**
   * @var string
   */
  public $dc_name = null;
  /**
   * @var bool
   */
  public $enable_cstr = null;
  /**
   * @var bool
   */
  public $validate_cstr = null;
  /**
   * @var bool
   */
  public $rely_cstr = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'table_db',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'table_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'column_name',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'check_expression',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'dc_name',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'enable_cstr',
          'type' => TType::BOOL,
          ),
        8 => array(
          'var' => 'validate_cstr',
          'type' => TType::BOOL,
          ),
        9 => array(
          'var' => 'rely_cstr',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
      if (isset($vals['table_db'])) {
        $this->table_db = $vals['table_db'];
      }
      if (isset($vals['table_name'])) {
        $this->table_name = $vals['table_name'];
      }
      if (isset($vals['column_name'])) {
        $this->column_name = $vals['column_name'];
      }
      if (isset($vals['check_expression'])) {
        $this->check_expression = $vals['check_expression'];
      }
      if (isset($vals['dc_name'])) {
        $this->dc_name = $vals['dc_name'];
      }
      if (isset($vals['enable_cstr'])) {
        $this->enable_cstr = $vals['enable_cstr'];
      }
      if (isset($vals['validate_cstr'])) {
        $this->validate_cstr = $vals['validate_cstr'];
      }
      if (isset($vals['rely_cstr'])) {
        $this->rely_cstr = $vals['rely_cstr'];
      }
    }
  }

  public function getName() {
    return 'SQLCheckConstraint';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table_db);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->column_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->check_expression);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dc_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->enable_cstr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->validate_cstr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->rely_cstr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SQLCheckConstraint');
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 1);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->table_db !== null) {
      $xfer += $output->writeFieldBegin('table_db', TType::STRING, 2);
      $xfer += $output->writeString($this->table_db);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->table_name !== null) {
      $xfer += $output->writeFieldBegin('table_name', TType::STRING, 3);
      $xfer += $output->writeString($this->table_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->column_name !== null) {
      $xfer += $output->writeFieldBegin('column_name', TType::STRING, 4);
      $xfer += $output->writeString($this->column_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->check_expression !== null) {
      $xfer += $output->writeFieldBegin('check_expression', TType::STRING, 5);
      $xfer += $output->writeString($this->check_expression);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dc_name !== null) {
      $xfer += $output->writeFieldBegin('dc_name', TType::STRING, 6);
      $xfer += $output->writeString($this->dc_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->enable_cstr !== null) {
      $xfer += $output->writeFieldBegin('enable_cstr', TType::BOOL, 7);
      $xfer += $output->writeBool($this->enable_cstr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->validate_cstr !== null) {
      $xfer += $output->writeFieldBegin('validate_cstr', TType::BOOL, 8);
      $xfer += $output->writeBool($this->validate_cstr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rely_cstr !== null) {
      $xfer += $output->writeFieldBegin('rely_cstr', TType::BOOL, 9);
      $xfer += $output->writeBool($this->rely_cstr);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Type {
  static $_TSPEC;

  /**
   * @var string
   */
  public $name = null;
  /**
   * @var string
   */
  public $type1 = null;
  /**
   * @var string
   */
  public $type2 = null;
  /**
   * @var \metastore\FieldSchema[]
   */
  public $fields = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'type1',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'type2',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'fields',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\FieldSchema',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['type1'])) {
        $this->type1 = $vals['type1'];
      }
      if (isset($vals['type2'])) {
        $this->type2 = $vals['type2'];
      }
      if (isset($vals['fields'])) {
        $this->fields = $vals['fields'];
      }
    }
  }

  public function getName() {
    return 'Type';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->type1);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->type2);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->fields = array();
            $_size0 = 0;
            $_etype3 = 0;
            $xfer += $input->readListBegin($_etype3, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $elem5 = null;
              $elem5 = new \metastore\FieldSchema();
              $xfer += $elem5->read($input);
              $this->fields []= $elem5;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Type');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type1 !== null) {
      $xfer += $output->writeFieldBegin('type1', TType::STRING, 2);
      $xfer += $output->writeString($this->type1);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type2 !== null) {
      $xfer += $output->writeFieldBegin('type2', TType::STRING, 3);
      $xfer += $output->writeString($this->type2);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->fields !== null) {
      if (!is_array($this->fields)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('fields', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRUCT, count($this->fields));
        {
          foreach ($this->fields as $iter6)
          {
            $xfer += $iter6->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class HiveObjectRef {
  static $_TSPEC;

  /**
   * @var int
   */
  public $objectType = null;
  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $objectName = null;
  /**
   * @var string[]
   */
  public $partValues = null;
  /**
   * @var string
   */
  public $columnName = null;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'objectType',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'objectName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'partValues',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'columnName',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['objectType'])) {
        $this->objectType = $vals['objectType'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['objectName'])) {
        $this->objectName = $vals['objectName'];
      }
      if (isset($vals['partValues'])) {
        $this->partValues = $vals['partValues'];
      }
      if (isset($vals['columnName'])) {
        $this->columnName = $vals['columnName'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'HiveObjectRef';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->objectType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->objectName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->partValues = array();
            $_size7 = 0;
            $_etype10 = 0;
            $xfer += $input->readListBegin($_etype10, $_size7);
            for ($_i11 = 0; $_i11 < $_size7; ++$_i11)
            {
              $elem12 = null;
              $xfer += $input->readString($elem12);
              $this->partValues []= $elem12;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->columnName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('HiveObjectRef');
    if ($this->objectType !== null) {
      $xfer += $output->writeFieldBegin('objectType', TType::I32, 1);
      $xfer += $output->writeI32($this->objectType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->objectName !== null) {
      $xfer += $output->writeFieldBegin('objectName', TType::STRING, 3);
      $xfer += $output->writeString($this->objectName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partValues !== null) {
      if (!is_array($this->partValues)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partValues', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRING, count($this->partValues));
        {
          foreach ($this->partValues as $iter13)
          {
            $xfer += $output->writeString($iter13);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columnName !== null) {
      $xfer += $output->writeFieldBegin('columnName', TType::STRING, 5);
      $xfer += $output->writeString($this->columnName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 6);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PrivilegeGrantInfo {
  static $_TSPEC;

  /**
   * @var string
   */
  public $privilege = null;
  /**
   * @var int
   */
  public $createTime = null;
  /**
   * @var string
   */
  public $grantor = null;
  /**
   * @var int
   */
  public $grantorType = null;
  /**
   * @var bool
   */
  public $grantOption = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'privilege',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'createTime',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'grantor',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'grantorType',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'grantOption',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['privilege'])) {
        $this->privilege = $vals['privilege'];
      }
      if (isset($vals['createTime'])) {
        $this->createTime = $vals['createTime'];
      }
      if (isset($vals['grantor'])) {
        $this->grantor = $vals['grantor'];
      }
      if (isset($vals['grantorType'])) {
        $this->grantorType = $vals['grantorType'];
      }
      if (isset($vals['grantOption'])) {
        $this->grantOption = $vals['grantOption'];
      }
    }
  }

  public function getName() {
    return 'PrivilegeGrantInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->privilege);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->createTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->grantor);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->grantorType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->grantOption);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PrivilegeGrantInfo');
    if ($this->privilege !== null) {
      $xfer += $output->writeFieldBegin('privilege', TType::STRING, 1);
      $xfer += $output->writeString($this->privilege);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->createTime !== null) {
      $xfer += $output->writeFieldBegin('createTime', TType::I32, 2);
      $xfer += $output->writeI32($this->createTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->grantor !== null) {
      $xfer += $output->writeFieldBegin('grantor', TType::STRING, 3);
      $xfer += $output->writeString($this->grantor);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->grantorType !== null) {
      $xfer += $output->writeFieldBegin('grantorType', TType::I32, 4);
      $xfer += $output->writeI32($this->grantorType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->grantOption !== null) {
      $xfer += $output->writeFieldBegin('grantOption', TType::BOOL, 5);
      $xfer += $output->writeBool($this->grantOption);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class HiveObjectPrivilege {
  static $_TSPEC;

  /**
   * @var \metastore\HiveObjectRef
   */
  public $hiveObject = null;
  /**
   * @var string
   */
  public $principalName = null;
  /**
   * @var int
   */
  public $principalType = null;
  /**
   * @var \metastore\PrivilegeGrantInfo
   */
  public $grantInfo = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'hiveObject',
          'type' => TType::STRUCT,
          'class' => '\metastore\HiveObjectRef',
          ),
        2 => array(
          'var' => 'principalName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'principalType',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'grantInfo',
          'type' => TType::STRUCT,
          'class' => '\metastore\PrivilegeGrantInfo',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['hiveObject'])) {
        $this->hiveObject = $vals['hiveObject'];
      }
      if (isset($vals['principalName'])) {
        $this->principalName = $vals['principalName'];
      }
      if (isset($vals['principalType'])) {
        $this->principalType = $vals['principalType'];
      }
      if (isset($vals['grantInfo'])) {
        $this->grantInfo = $vals['grantInfo'];
      }
    }
  }

  public function getName() {
    return 'HiveObjectPrivilege';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->hiveObject = new \metastore\HiveObjectRef();
            $xfer += $this->hiveObject->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->principalName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->principalType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->grantInfo = new \metastore\PrivilegeGrantInfo();
            $xfer += $this->grantInfo->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('HiveObjectPrivilege');
    if ($this->hiveObject !== null) {
      if (!is_object($this->hiveObject)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('hiveObject', TType::STRUCT, 1);
      $xfer += $this->hiveObject->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->principalName !== null) {
      $xfer += $output->writeFieldBegin('principalName', TType::STRING, 2);
      $xfer += $output->writeString($this->principalName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->principalType !== null) {
      $xfer += $output->writeFieldBegin('principalType', TType::I32, 3);
      $xfer += $output->writeI32($this->principalType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->grantInfo !== null) {
      if (!is_object($this->grantInfo)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('grantInfo', TType::STRUCT, 4);
      $xfer += $this->grantInfo->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PrivilegeBag {
  static $_TSPEC;

  /**
   * @var \metastore\HiveObjectPrivilege[]
   */
  public $privileges = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'privileges',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\HiveObjectPrivilege',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['privileges'])) {
        $this->privileges = $vals['privileges'];
      }
    }
  }

  public function getName() {
    return 'PrivilegeBag';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->privileges = array();
            $_size14 = 0;
            $_etype17 = 0;
            $xfer += $input->readListBegin($_etype17, $_size14);
            for ($_i18 = 0; $_i18 < $_size14; ++$_i18)
            {
              $elem19 = null;
              $elem19 = new \metastore\HiveObjectPrivilege();
              $xfer += $elem19->read($input);
              $this->privileges []= $elem19;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PrivilegeBag');
    if ($this->privileges !== null) {
      if (!is_array($this->privileges)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('privileges', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->privileges));
        {
          foreach ($this->privileges as $iter20)
          {
            $xfer += $iter20->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PrincipalPrivilegeSet {
  static $_TSPEC;

  /**
   * @var array
   */
  public $userPrivileges = null;
  /**
   * @var array
   */
  public $groupPrivileges = null;
  /**
   * @var array
   */
  public $rolePrivileges = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'userPrivileges',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::LST,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
              'type' => TType::STRUCT,
              'class' => '\metastore\PrivilegeGrantInfo',
              ),
            ),
          ),
        2 => array(
          'var' => 'groupPrivileges',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::LST,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
              'type' => TType::STRUCT,
              'class' => '\metastore\PrivilegeGrantInfo',
              ),
            ),
          ),
        3 => array(
          'var' => 'rolePrivileges',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::LST,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
              'type' => TType::STRUCT,
              'class' => '\metastore\PrivilegeGrantInfo',
              ),
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['userPrivileges'])) {
        $this->userPrivileges = $vals['userPrivileges'];
      }
      if (isset($vals['groupPrivileges'])) {
        $this->groupPrivileges = $vals['groupPrivileges'];
      }
      if (isset($vals['rolePrivileges'])) {
        $this->rolePrivileges = $vals['rolePrivileges'];
      }
    }
  }

  public function getName() {
    return 'PrincipalPrivilegeSet';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->userPrivileges = array();
            $_size21 = 0;
            $_ktype22 = 0;
            $_vtype23 = 0;
            $xfer += $input->readMapBegin($_ktype22, $_vtype23, $_size21);
            for ($_i25 = 0; $_i25 < $_size21; ++$_i25)
            {
              $key26 = '';
              $val27 = array();
              $xfer += $input->readString($key26);
              $val27 = array();
              $_size28 = 0;
              $_etype31 = 0;
              $xfer += $input->readListBegin($_etype31, $_size28);
              for ($_i32 = 0; $_i32 < $_size28; ++$_i32)
              {
                $elem33 = null;
                $elem33 = new \metastore\PrivilegeGrantInfo();
                $xfer += $elem33->read($input);
                $val27 []= $elem33;
              }
              $xfer += $input->readListEnd();
              $this->userPrivileges[$key26] = $val27;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->groupPrivileges = array();
            $_size34 = 0;
            $_ktype35 = 0;
            $_vtype36 = 0;
            $xfer += $input->readMapBegin($_ktype35, $_vtype36, $_size34);
            for ($_i38 = 0; $_i38 < $_size34; ++$_i38)
            {
              $key39 = '';
              $val40 = array();
              $xfer += $input->readString($key39);
              $val40 = array();
              $_size41 = 0;
              $_etype44 = 0;
              $xfer += $input->readListBegin($_etype44, $_size41);
              for ($_i45 = 0; $_i45 < $_size41; ++$_i45)
              {
                $elem46 = null;
                $elem46 = new \metastore\PrivilegeGrantInfo();
                $xfer += $elem46->read($input);
                $val40 []= $elem46;
              }
              $xfer += $input->readListEnd();
              $this->groupPrivileges[$key39] = $val40;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::MAP) {
            $this->rolePrivileges = array();
            $_size47 = 0;
            $_ktype48 = 0;
            $_vtype49 = 0;
            $xfer += $input->readMapBegin($_ktype48, $_vtype49, $_size47);
            for ($_i51 = 0; $_i51 < $_size47; ++$_i51)
            {
              $key52 = '';
              $val53 = array();
              $xfer += $input->readString($key52);
              $val53 = array();
              $_size54 = 0;
              $_etype57 = 0;
              $xfer += $input->readListBegin($_etype57, $_size54);
              for ($_i58 = 0; $_i58 < $_size54; ++$_i58)
              {
                $elem59 = null;
                $elem59 = new \metastore\PrivilegeGrantInfo();
                $xfer += $elem59->read($input);
                $val53 []= $elem59;
              }
              $xfer += $input->readListEnd();
              $this->rolePrivileges[$key52] = $val53;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PrincipalPrivilegeSet');
    if ($this->userPrivileges !== null) {
      if (!is_array($this->userPrivileges)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('userPrivileges', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::LST, count($this->userPrivileges));
        {
          foreach ($this->userPrivileges as $kiter60 => $viter61)
          {
            $xfer += $output->writeString($kiter60);
            {
              $output->writeListBegin(TType::STRUCT, count($viter61));
              {
                foreach ($viter61 as $iter62)
                {
                  $xfer += $iter62->write($output);
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->groupPrivileges !== null) {
      if (!is_array($this->groupPrivileges)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('groupPrivileges', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::STRING, TType::LST, count($this->groupPrivileges));
        {
          foreach ($this->groupPrivileges as $kiter63 => $viter64)
          {
            $xfer += $output->writeString($kiter63);
            {
              $output->writeListBegin(TType::STRUCT, count($viter64));
              {
                foreach ($viter64 as $iter65)
                {
                  $xfer += $iter65->write($output);
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rolePrivileges !== null) {
      if (!is_array($this->rolePrivileges)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rolePrivileges', TType::MAP, 3);
      {
        $output->writeMapBegin(TType::STRING, TType::LST, count($this->rolePrivileges));
        {
          foreach ($this->rolePrivileges as $kiter66 => $viter67)
          {
            $xfer += $output->writeString($kiter66);
            {
              $output->writeListBegin(TType::STRUCT, count($viter67));
              {
                foreach ($viter67 as $iter68)
                {
                  $xfer += $iter68->write($output);
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GrantRevokePrivilegeRequest {
  static $_TSPEC;

  /**
   * @var int
   */
  public $requestType = null;
  /**
   * @var \metastore\PrivilegeBag
   */
  public $privileges = null;
  /**
   * @var bool
   */
  public $revokeGrantOption = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'requestType',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'privileges',
          'type' => TType::STRUCT,
          'class' => '\metastore\PrivilegeBag',
          ),
        3 => array(
          'var' => 'revokeGrantOption',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['requestType'])) {
        $this->requestType = $vals['requestType'];
      }
      if (isset($vals['privileges'])) {
        $this->privileges = $vals['privileges'];
      }
      if (isset($vals['revokeGrantOption'])) {
        $this->revokeGrantOption = $vals['revokeGrantOption'];
      }
    }
  }

  public function getName() {
    return 'GrantRevokePrivilegeRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->requestType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->privileges = new \metastore\PrivilegeBag();
            $xfer += $this->privileges->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->revokeGrantOption);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GrantRevokePrivilegeRequest');
    if ($this->requestType !== null) {
      $xfer += $output->writeFieldBegin('requestType', TType::I32, 1);
      $xfer += $output->writeI32($this->requestType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->privileges !== null) {
      if (!is_object($this->privileges)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('privileges', TType::STRUCT, 2);
      $xfer += $this->privileges->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->revokeGrantOption !== null) {
      $xfer += $output->writeFieldBegin('revokeGrantOption', TType::BOOL, 3);
      $xfer += $output->writeBool($this->revokeGrantOption);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GrantRevokePrivilegeResponse {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'GrantRevokePrivilegeResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GrantRevokePrivilegeResponse');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 1);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Role {
  static $_TSPEC;

  /**
   * @var string
   */
  public $roleName = null;
  /**
   * @var int
   */
  public $createTime = null;
  /**
   * @var string
   */
  public $ownerName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'roleName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'createTime',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'ownerName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['roleName'])) {
        $this->roleName = $vals['roleName'];
      }
      if (isset($vals['createTime'])) {
        $this->createTime = $vals['createTime'];
      }
      if (isset($vals['ownerName'])) {
        $this->ownerName = $vals['ownerName'];
      }
    }
  }

  public function getName() {
    return 'Role';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->roleName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->createTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->ownerName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Role');
    if ($this->roleName !== null) {
      $xfer += $output->writeFieldBegin('roleName', TType::STRING, 1);
      $xfer += $output->writeString($this->roleName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->createTime !== null) {
      $xfer += $output->writeFieldBegin('createTime', TType::I32, 2);
      $xfer += $output->writeI32($this->createTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ownerName !== null) {
      $xfer += $output->writeFieldBegin('ownerName', TType::STRING, 3);
      $xfer += $output->writeString($this->ownerName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class RolePrincipalGrant {
  static $_TSPEC;

  /**
   * @var string
   */
  public $roleName = null;
  /**
   * @var string
   */
  public $principalName = null;
  /**
   * @var int
   */
  public $principalType = null;
  /**
   * @var bool
   */
  public $grantOption = null;
  /**
   * @var int
   */
  public $grantTime = null;
  /**
   * @var string
   */
  public $grantorName = null;
  /**
   * @var int
   */
  public $grantorPrincipalType = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'roleName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'principalName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'principalType',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'grantOption',
          'type' => TType::BOOL,
          ),
        5 => array(
          'var' => 'grantTime',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'grantorName',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'grantorPrincipalType',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['roleName'])) {
        $this->roleName = $vals['roleName'];
      }
      if (isset($vals['principalName'])) {
        $this->principalName = $vals['principalName'];
      }
      if (isset($vals['principalType'])) {
        $this->principalType = $vals['principalType'];
      }
      if (isset($vals['grantOption'])) {
        $this->grantOption = $vals['grantOption'];
      }
      if (isset($vals['grantTime'])) {
        $this->grantTime = $vals['grantTime'];
      }
      if (isset($vals['grantorName'])) {
        $this->grantorName = $vals['grantorName'];
      }
      if (isset($vals['grantorPrincipalType'])) {
        $this->grantorPrincipalType = $vals['grantorPrincipalType'];
      }
    }
  }

  public function getName() {
    return 'RolePrincipalGrant';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->roleName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->principalName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->principalType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->grantOption);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->grantTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->grantorName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->grantorPrincipalType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('RolePrincipalGrant');
    if ($this->roleName !== null) {
      $xfer += $output->writeFieldBegin('roleName', TType::STRING, 1);
      $xfer += $output->writeString($this->roleName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->principalName !== null) {
      $xfer += $output->writeFieldBegin('principalName', TType::STRING, 2);
      $xfer += $output->writeString($this->principalName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->principalType !== null) {
      $xfer += $output->writeFieldBegin('principalType', TType::I32, 3);
      $xfer += $output->writeI32($this->principalType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->grantOption !== null) {
      $xfer += $output->writeFieldBegin('grantOption', TType::BOOL, 4);
      $xfer += $output->writeBool($this->grantOption);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->grantTime !== null) {
      $xfer += $output->writeFieldBegin('grantTime', TType::I32, 5);
      $xfer += $output->writeI32($this->grantTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->grantorName !== null) {
      $xfer += $output->writeFieldBegin('grantorName', TType::STRING, 6);
      $xfer += $output->writeString($this->grantorName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->grantorPrincipalType !== null) {
      $xfer += $output->writeFieldBegin('grantorPrincipalType', TType::I32, 7);
      $xfer += $output->writeI32($this->grantorPrincipalType);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetRoleGrantsForPrincipalRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $principal_name = null;
  /**
   * @var int
   */
  public $principal_type = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'principal_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'principal_type',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['principal_name'])) {
        $this->principal_name = $vals['principal_name'];
      }
      if (isset($vals['principal_type'])) {
        $this->principal_type = $vals['principal_type'];
      }
    }
  }

  public function getName() {
    return 'GetRoleGrantsForPrincipalRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->principal_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->principal_type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetRoleGrantsForPrincipalRequest');
    if ($this->principal_name !== null) {
      $xfer += $output->writeFieldBegin('principal_name', TType::STRING, 1);
      $xfer += $output->writeString($this->principal_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->principal_type !== null) {
      $xfer += $output->writeFieldBegin('principal_type', TType::I32, 2);
      $xfer += $output->writeI32($this->principal_type);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetRoleGrantsForPrincipalResponse {
  static $_TSPEC;

  /**
   * @var \metastore\RolePrincipalGrant[]
   */
  public $principalGrants = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'principalGrants',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\RolePrincipalGrant',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['principalGrants'])) {
        $this->principalGrants = $vals['principalGrants'];
      }
    }
  }

  public function getName() {
    return 'GetRoleGrantsForPrincipalResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->principalGrants = array();
            $_size69 = 0;
            $_etype72 = 0;
            $xfer += $input->readListBegin($_etype72, $_size69);
            for ($_i73 = 0; $_i73 < $_size69; ++$_i73)
            {
              $elem74 = null;
              $elem74 = new \metastore\RolePrincipalGrant();
              $xfer += $elem74->read($input);
              $this->principalGrants []= $elem74;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetRoleGrantsForPrincipalResponse');
    if ($this->principalGrants !== null) {
      if (!is_array($this->principalGrants)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('principalGrants', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->principalGrants));
        {
          foreach ($this->principalGrants as $iter75)
          {
            $xfer += $iter75->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetPrincipalsInRoleRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $roleName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'roleName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['roleName'])) {
        $this->roleName = $vals['roleName'];
      }
    }
  }

  public function getName() {
    return 'GetPrincipalsInRoleRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->roleName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetPrincipalsInRoleRequest');
    if ($this->roleName !== null) {
      $xfer += $output->writeFieldBegin('roleName', TType::STRING, 1);
      $xfer += $output->writeString($this->roleName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetPrincipalsInRoleResponse {
  static $_TSPEC;

  /**
   * @var \metastore\RolePrincipalGrant[]
   */
  public $principalGrants = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'principalGrants',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\RolePrincipalGrant',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['principalGrants'])) {
        $this->principalGrants = $vals['principalGrants'];
      }
    }
  }

  public function getName() {
    return 'GetPrincipalsInRoleResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->principalGrants = array();
            $_size76 = 0;
            $_etype79 = 0;
            $xfer += $input->readListBegin($_etype79, $_size76);
            for ($_i80 = 0; $_i80 < $_size76; ++$_i80)
            {
              $elem81 = null;
              $elem81 = new \metastore\RolePrincipalGrant();
              $xfer += $elem81->read($input);
              $this->principalGrants []= $elem81;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetPrincipalsInRoleResponse');
    if ($this->principalGrants !== null) {
      if (!is_array($this->principalGrants)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('principalGrants', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->principalGrants));
        {
          foreach ($this->principalGrants as $iter82)
          {
            $xfer += $iter82->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GrantRevokeRoleRequest {
  static $_TSPEC;

  /**
   * @var int
   */
  public $requestType = null;
  /**
   * @var string
   */
  public $roleName = null;
  /**
   * @var string
   */
  public $principalName = null;
  /**
   * @var int
   */
  public $principalType = null;
  /**
   * @var string
   */
  public $grantor = null;
  /**
   * @var int
   */
  public $grantorType = null;
  /**
   * @var bool
   */
  public $grantOption = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'requestType',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'roleName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'principalName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'principalType',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'grantor',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'grantorType',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'grantOption',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['requestType'])) {
        $this->requestType = $vals['requestType'];
      }
      if (isset($vals['roleName'])) {
        $this->roleName = $vals['roleName'];
      }
      if (isset($vals['principalName'])) {
        $this->principalName = $vals['principalName'];
      }
      if (isset($vals['principalType'])) {
        $this->principalType = $vals['principalType'];
      }
      if (isset($vals['grantor'])) {
        $this->grantor = $vals['grantor'];
      }
      if (isset($vals['grantorType'])) {
        $this->grantorType = $vals['grantorType'];
      }
      if (isset($vals['grantOption'])) {
        $this->grantOption = $vals['grantOption'];
      }
    }
  }

  public function getName() {
    return 'GrantRevokeRoleRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->requestType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->roleName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->principalName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->principalType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->grantor);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->grantorType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->grantOption);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GrantRevokeRoleRequest');
    if ($this->requestType !== null) {
      $xfer += $output->writeFieldBegin('requestType', TType::I32, 1);
      $xfer += $output->writeI32($this->requestType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->roleName !== null) {
      $xfer += $output->writeFieldBegin('roleName', TType::STRING, 2);
      $xfer += $output->writeString($this->roleName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->principalName !== null) {
      $xfer += $output->writeFieldBegin('principalName', TType::STRING, 3);
      $xfer += $output->writeString($this->principalName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->principalType !== null) {
      $xfer += $output->writeFieldBegin('principalType', TType::I32, 4);
      $xfer += $output->writeI32($this->principalType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->grantor !== null) {
      $xfer += $output->writeFieldBegin('grantor', TType::STRING, 5);
      $xfer += $output->writeString($this->grantor);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->grantorType !== null) {
      $xfer += $output->writeFieldBegin('grantorType', TType::I32, 6);
      $xfer += $output->writeI32($this->grantorType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->grantOption !== null) {
      $xfer += $output->writeFieldBegin('grantOption', TType::BOOL, 7);
      $xfer += $output->writeBool($this->grantOption);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GrantRevokeRoleResponse {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'GrantRevokeRoleResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GrantRevokeRoleResponse');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 1);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Catalog {
  static $_TSPEC;

  /**
   * @var string
   */
  public $name = null;
  /**
   * @var string
   */
  public $description = null;
  /**
   * @var string
   */
  public $locationUri = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'description',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'locationUri',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['description'])) {
        $this->description = $vals['description'];
      }
      if (isset($vals['locationUri'])) {
        $this->locationUri = $vals['locationUri'];
      }
    }
  }

  public function getName() {
    return 'Catalog';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->description);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->locationUri);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Catalog');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->description !== null) {
      $xfer += $output->writeFieldBegin('description', TType::STRING, 2);
      $xfer += $output->writeString($this->description);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->locationUri !== null) {
      $xfer += $output->writeFieldBegin('locationUri', TType::STRING, 3);
      $xfer += $output->writeString($this->locationUri);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CreateCatalogRequest {
  static $_TSPEC;

  /**
   * @var \metastore\Catalog
   */
  public $catalog = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'catalog',
          'type' => TType::STRUCT,
          'class' => '\metastore\Catalog',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['catalog'])) {
        $this->catalog = $vals['catalog'];
      }
    }
  }

  public function getName() {
    return 'CreateCatalogRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->catalog = new \metastore\Catalog();
            $xfer += $this->catalog->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CreateCatalogRequest');
    if ($this->catalog !== null) {
      if (!is_object($this->catalog)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('catalog', TType::STRUCT, 1);
      $xfer += $this->catalog->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetCatalogRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
    }
  }

  public function getName() {
    return 'GetCatalogRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetCatalogRequest');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetCatalogResponse {
  static $_TSPEC;

  /**
   * @var \metastore\Catalog
   */
  public $catalog = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'catalog',
          'type' => TType::STRUCT,
          'class' => '\metastore\Catalog',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['catalog'])) {
        $this->catalog = $vals['catalog'];
      }
    }
  }

  public function getName() {
    return 'GetCatalogResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->catalog = new \metastore\Catalog();
            $xfer += $this->catalog->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetCatalogResponse');
    if ($this->catalog !== null) {
      if (!is_object($this->catalog)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('catalog', TType::STRUCT, 1);
      $xfer += $this->catalog->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetCatalogsResponse {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $names = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'names',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['names'])) {
        $this->names = $vals['names'];
      }
    }
  }

  public function getName() {
    return 'GetCatalogsResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->names = array();
            $_size83 = 0;
            $_etype86 = 0;
            $xfer += $input->readListBegin($_etype86, $_size83);
            for ($_i87 = 0; $_i87 < $_size83; ++$_i87)
            {
              $elem88 = null;
              $xfer += $input->readString($elem88);
              $this->names []= $elem88;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetCatalogsResponse');
    if ($this->names !== null) {
      if (!is_array($this->names)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('names', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->names));
        {
          foreach ($this->names as $iter89)
          {
            $xfer += $output->writeString($iter89);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DropCatalogRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
    }
  }

  public function getName() {
    return 'DropCatalogRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DropCatalogRequest');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Database {
  static $_TSPEC;

  /**
   * @var string
   */
  public $name = null;
  /**
   * @var string
   */
  public $description = null;
  /**
   * @var string
   */
  public $locationUri = null;
  /**
   * @var array
   */
  public $parameters = null;
  /**
   * @var \metastore\PrincipalPrivilegeSet
   */
  public $privileges = null;
  /**
   * @var string
   */
  public $ownerName = null;
  /**
   * @var int
   */
  public $ownerType = null;
  /**
   * @var string
   */
  public $catalogName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'description',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'locationUri',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'parameters',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'privileges',
          'type' => TType::STRUCT,
          'class' => '\metastore\PrincipalPrivilegeSet',
          ),
        6 => array(
          'var' => 'ownerName',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'ownerType',
          'type' => TType::I32,
          ),
        8 => array(
          'var' => 'catalogName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['description'])) {
        $this->description = $vals['description'];
      }
      if (isset($vals['locationUri'])) {
        $this->locationUri = $vals['locationUri'];
      }
      if (isset($vals['parameters'])) {
        $this->parameters = $vals['parameters'];
      }
      if (isset($vals['privileges'])) {
        $this->privileges = $vals['privileges'];
      }
      if (isset($vals['ownerName'])) {
        $this->ownerName = $vals['ownerName'];
      }
      if (isset($vals['ownerType'])) {
        $this->ownerType = $vals['ownerType'];
      }
      if (isset($vals['catalogName'])) {
        $this->catalogName = $vals['catalogName'];
      }
    }
  }

  public function getName() {
    return 'Database';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->description);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->locationUri);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::MAP) {
            $this->parameters = array();
            $_size90 = 0;
            $_ktype91 = 0;
            $_vtype92 = 0;
            $xfer += $input->readMapBegin($_ktype91, $_vtype92, $_size90);
            for ($_i94 = 0; $_i94 < $_size90; ++$_i94)
            {
              $key95 = '';
              $val96 = '';
              $xfer += $input->readString($key95);
              $xfer += $input->readString($val96);
              $this->parameters[$key95] = $val96;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->privileges = new \metastore\PrincipalPrivilegeSet();
            $xfer += $this->privileges->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->ownerName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->ownerType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catalogName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Database');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->description !== null) {
      $xfer += $output->writeFieldBegin('description', TType::STRING, 2);
      $xfer += $output->writeString($this->description);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->locationUri !== null) {
      $xfer += $output->writeFieldBegin('locationUri', TType::STRING, 3);
      $xfer += $output->writeString($this->locationUri);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parameters !== null) {
      if (!is_array($this->parameters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('parameters', TType::MAP, 4);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->parameters));
        {
          foreach ($this->parameters as $kiter97 => $viter98)
          {
            $xfer += $output->writeString($kiter97);
            $xfer += $output->writeString($viter98);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->privileges !== null) {
      if (!is_object($this->privileges)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('privileges', TType::STRUCT, 5);
      $xfer += $this->privileges->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ownerName !== null) {
      $xfer += $output->writeFieldBegin('ownerName', TType::STRING, 6);
      $xfer += $output->writeString($this->ownerName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ownerType !== null) {
      $xfer += $output->writeFieldBegin('ownerType', TType::I32, 7);
      $xfer += $output->writeI32($this->ownerType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catalogName !== null) {
      $xfer += $output->writeFieldBegin('catalogName', TType::STRING, 8);
      $xfer += $output->writeString($this->catalogName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SerDeInfo {
  static $_TSPEC;

  /**
   * @var string
   */
  public $name = null;
  /**
   * @var string
   */
  public $serializationLib = null;
  /**
   * @var array
   */
  public $parameters = null;
  /**
   * @var string
   */
  public $description = null;
  /**
   * @var string
   */
  public $serializerClass = null;
  /**
   * @var string
   */
  public $deserializerClass = null;
  /**
   * @var int
   */
  public $serdeType = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'serializationLib',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'parameters',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'description',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'serializerClass',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'deserializerClass',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'serdeType',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['serializationLib'])) {
        $this->serializationLib = $vals['serializationLib'];
      }
      if (isset($vals['parameters'])) {
        $this->parameters = $vals['parameters'];
      }
      if (isset($vals['description'])) {
        $this->description = $vals['description'];
      }
      if (isset($vals['serializerClass'])) {
        $this->serializerClass = $vals['serializerClass'];
      }
      if (isset($vals['deserializerClass'])) {
        $this->deserializerClass = $vals['deserializerClass'];
      }
      if (isset($vals['serdeType'])) {
        $this->serdeType = $vals['serdeType'];
      }
    }
  }

  public function getName() {
    return 'SerDeInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->serializationLib);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::MAP) {
            $this->parameters = array();
            $_size99 = 0;
            $_ktype100 = 0;
            $_vtype101 = 0;
            $xfer += $input->readMapBegin($_ktype100, $_vtype101, $_size99);
            for ($_i103 = 0; $_i103 < $_size99; ++$_i103)
            {
              $key104 = '';
              $val105 = '';
              $xfer += $input->readString($key104);
              $xfer += $input->readString($val105);
              $this->parameters[$key104] = $val105;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->description);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->serializerClass);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->deserializerClass);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->serdeType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SerDeInfo');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->serializationLib !== null) {
      $xfer += $output->writeFieldBegin('serializationLib', TType::STRING, 2);
      $xfer += $output->writeString($this->serializationLib);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parameters !== null) {
      if (!is_array($this->parameters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('parameters', TType::MAP, 3);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->parameters));
        {
          foreach ($this->parameters as $kiter106 => $viter107)
          {
            $xfer += $output->writeString($kiter106);
            $xfer += $output->writeString($viter107);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->description !== null) {
      $xfer += $output->writeFieldBegin('description', TType::STRING, 4);
      $xfer += $output->writeString($this->description);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->serializerClass !== null) {
      $xfer += $output->writeFieldBegin('serializerClass', TType::STRING, 5);
      $xfer += $output->writeString($this->serializerClass);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deserializerClass !== null) {
      $xfer += $output->writeFieldBegin('deserializerClass', TType::STRING, 6);
      $xfer += $output->writeString($this->deserializerClass);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->serdeType !== null) {
      $xfer += $output->writeFieldBegin('serdeType', TType::I32, 7);
      $xfer += $output->writeI32($this->serdeType);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Order {
  static $_TSPEC;

  /**
   * @var string
   */
  public $col = null;
  /**
   * @var int
   */
  public $order = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'col',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'order',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['col'])) {
        $this->col = $vals['col'];
      }
      if (isset($vals['order'])) {
        $this->order = $vals['order'];
      }
    }
  }

  public function getName() {
    return 'Order';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->col);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->order);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Order');
    if ($this->col !== null) {
      $xfer += $output->writeFieldBegin('col', TType::STRING, 1);
      $xfer += $output->writeString($this->col);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->order !== null) {
      $xfer += $output->writeFieldBegin('order', TType::I32, 2);
      $xfer += $output->writeI32($this->order);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SkewedInfo {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $skewedColNames = null;
  /**
   * @var (string[])[]
   */
  public $skewedColValues = null;
  /**
   * @var array
   */
  public $skewedColValueLocationMaps = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'skewedColNames',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'skewedColValues',
          'type' => TType::LST,
          'etype' => TType::LST,
          'elem' => array(
            'type' => TType::LST,
            'etype' => TType::STRING,
            'elem' => array(
              'type' => TType::STRING,
              ),
            ),
          ),
        3 => array(
          'var' => 'skewedColValueLocationMaps',
          'type' => TType::MAP,
          'ktype' => TType::LST,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::LST,
            'etype' => TType::STRING,
            'elem' => array(
              'type' => TType::STRING,
              ),
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['skewedColNames'])) {
        $this->skewedColNames = $vals['skewedColNames'];
      }
      if (isset($vals['skewedColValues'])) {
        $this->skewedColValues = $vals['skewedColValues'];
      }
      if (isset($vals['skewedColValueLocationMaps'])) {
        $this->skewedColValueLocationMaps = $vals['skewedColValueLocationMaps'];
      }
    }
  }

  public function getName() {
    return 'SkewedInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->skewedColNames = array();
            $_size108 = 0;
            $_etype111 = 0;
            $xfer += $input->readListBegin($_etype111, $_size108);
            for ($_i112 = 0; $_i112 < $_size108; ++$_i112)
            {
              $elem113 = null;
              $xfer += $input->readString($elem113);
              $this->skewedColNames []= $elem113;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->skewedColValues = array();
            $_size114 = 0;
            $_etype117 = 0;
            $xfer += $input->readListBegin($_etype117, $_size114);
            for ($_i118 = 0; $_i118 < $_size114; ++$_i118)
            {
              $elem119 = null;
              $elem119 = array();
              $_size120 = 0;
              $_etype123 = 0;
              $xfer += $input->readListBegin($_etype123, $_size120);
              for ($_i124 = 0; $_i124 < $_size120; ++$_i124)
              {
                $elem125 = null;
                $xfer += $input->readString($elem125);
                $elem119 []= $elem125;
              }
              $xfer += $input->readListEnd();
              $this->skewedColValues []= $elem119;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::MAP) {
            $this->skewedColValueLocationMaps = array();
            $_size126 = 0;
            $_ktype127 = 0;
            $_vtype128 = 0;
            $xfer += $input->readMapBegin($_ktype127, $_vtype128, $_size126);
            for ($_i130 = 0; $_i130 < $_size126; ++$_i130)
            {
              $key131 = array();
              $val132 = '';
              $key131 = array();
              $_size133 = 0;
              $_etype136 = 0;
              $xfer += $input->readListBegin($_etype136, $_size133);
              for ($_i137 = 0; $_i137 < $_size133; ++$_i137)
              {
                $elem138 = null;
                $xfer += $input->readString($elem138);
                $key131 []= $elem138;
              }
              $xfer += $input->readListEnd();
              $xfer += $input->readString($val132);
              $this->skewedColValueLocationMaps[$key131] = $val132;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SkewedInfo');
    if ($this->skewedColNames !== null) {
      if (!is_array($this->skewedColNames)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('skewedColNames', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->skewedColNames));
        {
          foreach ($this->skewedColNames as $iter139)
          {
            $xfer += $output->writeString($iter139);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->skewedColValues !== null) {
      if (!is_array($this->skewedColValues)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('skewedColValues', TType::LST, 2);
      {
        $output->writeListBegin(TType::LST, count($this->skewedColValues));
        {
          foreach ($this->skewedColValues as $iter140)
          {
            {
              $output->writeListBegin(TType::STRING, count($iter140));
              {
                foreach ($iter140 as $iter141)
                {
                  $xfer += $output->writeString($iter141);
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->skewedColValueLocationMaps !== null) {
      if (!is_array($this->skewedColValueLocationMaps)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('skewedColValueLocationMaps', TType::MAP, 3);
      {
        $output->writeMapBegin(TType::LST, TType::STRING, count($this->skewedColValueLocationMaps));
        {
          foreach ($this->skewedColValueLocationMaps as $kiter142 => $viter143)
          {
            {
              $output->writeListBegin(TType::STRING, count($kiter142));
              {
                foreach ($kiter142 as $iter144)
                {
                  $xfer += $output->writeString($iter144);
                }
              }
              $output->writeListEnd();
            }
            $xfer += $output->writeString($viter143);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class StorageDescriptor {
  static $_TSPEC;

  /**
   * @var \metastore\FieldSchema[]
   */
  public $cols = null;
  /**
   * @var string
   */
  public $location = null;
  /**
   * @var string
   */
  public $inputFormat = null;
  /**
   * @var string
   */
  public $outputFormat = null;
  /**
   * @var bool
   */
  public $compressed = null;
  /**
   * @var int
   */
  public $numBuckets = null;
  /**
   * @var \metastore\SerDeInfo
   */
  public $serdeInfo = null;
  /**
   * @var string[]
   */
  public $bucketCols = null;
  /**
   * @var \metastore\Order[]
   */
  public $sortCols = null;
  /**
   * @var array
   */
  public $parameters = null;
  /**
   * @var \metastore\SkewedInfo
   */
  public $skewedInfo = null;
  /**
   * @var bool
   */
  public $storedAsSubDirectories = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'cols',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\FieldSchema',
            ),
          ),
        2 => array(
          'var' => 'location',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'inputFormat',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'outputFormat',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'compressed',
          'type' => TType::BOOL,
          ),
        6 => array(
          'var' => 'numBuckets',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'serdeInfo',
          'type' => TType::STRUCT,
          'class' => '\metastore\SerDeInfo',
          ),
        8 => array(
          'var' => 'bucketCols',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        9 => array(
          'var' => 'sortCols',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Order',
            ),
          ),
        10 => array(
          'var' => 'parameters',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        11 => array(
          'var' => 'skewedInfo',
          'type' => TType::STRUCT,
          'class' => '\metastore\SkewedInfo',
          ),
        12 => array(
          'var' => 'storedAsSubDirectories',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['cols'])) {
        $this->cols = $vals['cols'];
      }
      if (isset($vals['location'])) {
        $this->location = $vals['location'];
      }
      if (isset($vals['inputFormat'])) {
        $this->inputFormat = $vals['inputFormat'];
      }
      if (isset($vals['outputFormat'])) {
        $this->outputFormat = $vals['outputFormat'];
      }
      if (isset($vals['compressed'])) {
        $this->compressed = $vals['compressed'];
      }
      if (isset($vals['numBuckets'])) {
        $this->numBuckets = $vals['numBuckets'];
      }
      if (isset($vals['serdeInfo'])) {
        $this->serdeInfo = $vals['serdeInfo'];
      }
      if (isset($vals['bucketCols'])) {
        $this->bucketCols = $vals['bucketCols'];
      }
      if (isset($vals['sortCols'])) {
        $this->sortCols = $vals['sortCols'];
      }
      if (isset($vals['parameters'])) {
        $this->parameters = $vals['parameters'];
      }
      if (isset($vals['skewedInfo'])) {
        $this->skewedInfo = $vals['skewedInfo'];
      }
      if (isset($vals['storedAsSubDirectories'])) {
        $this->storedAsSubDirectories = $vals['storedAsSubDirectories'];
      }
    }
  }

  public function getName() {
    return 'StorageDescriptor';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->cols = array();
            $_size145 = 0;
            $_etype148 = 0;
            $xfer += $input->readListBegin($_etype148, $_size145);
            for ($_i149 = 0; $_i149 < $_size145; ++$_i149)
            {
              $elem150 = null;
              $elem150 = new \metastore\FieldSchema();
              $xfer += $elem150->read($input);
              $this->cols []= $elem150;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->location);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->inputFormat);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->outputFormat);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->compressed);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->numBuckets);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->serdeInfo = new \metastore\SerDeInfo();
            $xfer += $this->serdeInfo->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::LST) {
            $this->bucketCols = array();
            $_size151 = 0;
            $_etype154 = 0;
            $xfer += $input->readListBegin($_etype154, $_size151);
            for ($_i155 = 0; $_i155 < $_size151; ++$_i155)
            {
              $elem156 = null;
              $xfer += $input->readString($elem156);
              $this->bucketCols []= $elem156;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::LST) {
            $this->sortCols = array();
            $_size157 = 0;
            $_etype160 = 0;
            $xfer += $input->readListBegin($_etype160, $_size157);
            for ($_i161 = 0; $_i161 < $_size157; ++$_i161)
            {
              $elem162 = null;
              $elem162 = new \metastore\Order();
              $xfer += $elem162->read($input);
              $this->sortCols []= $elem162;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::MAP) {
            $this->parameters = array();
            $_size163 = 0;
            $_ktype164 = 0;
            $_vtype165 = 0;
            $xfer += $input->readMapBegin($_ktype164, $_vtype165, $_size163);
            for ($_i167 = 0; $_i167 < $_size163; ++$_i167)
            {
              $key168 = '';
              $val169 = '';
              $xfer += $input->readString($key168);
              $xfer += $input->readString($val169);
              $this->parameters[$key168] = $val169;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::STRUCT) {
            $this->skewedInfo = new \metastore\SkewedInfo();
            $xfer += $this->skewedInfo->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->storedAsSubDirectories);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('StorageDescriptor');
    if ($this->cols !== null) {
      if (!is_array($this->cols)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('cols', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->cols));
        {
          foreach ($this->cols as $iter170)
          {
            $xfer += $iter170->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->location !== null) {
      $xfer += $output->writeFieldBegin('location', TType::STRING, 2);
      $xfer += $output->writeString($this->location);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->inputFormat !== null) {
      $xfer += $output->writeFieldBegin('inputFormat', TType::STRING, 3);
      $xfer += $output->writeString($this->inputFormat);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->outputFormat !== null) {
      $xfer += $output->writeFieldBegin('outputFormat', TType::STRING, 4);
      $xfer += $output->writeString($this->outputFormat);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->compressed !== null) {
      $xfer += $output->writeFieldBegin('compressed', TType::BOOL, 5);
      $xfer += $output->writeBool($this->compressed);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numBuckets !== null) {
      $xfer += $output->writeFieldBegin('numBuckets', TType::I32, 6);
      $xfer += $output->writeI32($this->numBuckets);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->serdeInfo !== null) {
      if (!is_object($this->serdeInfo)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('serdeInfo', TType::STRUCT, 7);
      $xfer += $this->serdeInfo->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bucketCols !== null) {
      if (!is_array($this->bucketCols)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('bucketCols', TType::LST, 8);
      {
        $output->writeListBegin(TType::STRING, count($this->bucketCols));
        {
          foreach ($this->bucketCols as $iter171)
          {
            $xfer += $output->writeString($iter171);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sortCols !== null) {
      if (!is_array($this->sortCols)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sortCols', TType::LST, 9);
      {
        $output->writeListBegin(TType::STRUCT, count($this->sortCols));
        {
          foreach ($this->sortCols as $iter172)
          {
            $xfer += $iter172->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parameters !== null) {
      if (!is_array($this->parameters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('parameters', TType::MAP, 10);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->parameters));
        {
          foreach ($this->parameters as $kiter173 => $viter174)
          {
            $xfer += $output->writeString($kiter173);
            $xfer += $output->writeString($viter174);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->skewedInfo !== null) {
      if (!is_object($this->skewedInfo)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('skewedInfo', TType::STRUCT, 11);
      $xfer += $this->skewedInfo->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->storedAsSubDirectories !== null) {
      $xfer += $output->writeFieldBegin('storedAsSubDirectories', TType::BOOL, 12);
      $xfer += $output->writeBool($this->storedAsSubDirectories);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Table {
  static $_TSPEC;

  /**
   * @var string
   */
  public $tableName = null;
  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $owner = null;
  /**
   * @var int
   */
  public $createTime = null;
  /**
   * @var int
   */
  public $lastAccessTime = null;
  /**
   * @var int
   */
  public $retention = null;
  /**
   * @var \metastore\StorageDescriptor
   */
  public $sd = null;
  /**
   * @var \metastore\FieldSchema[]
   */
  public $partitionKeys = null;
  /**
   * @var array
   */
  public $parameters = null;
  /**
   * @var string
   */
  public $viewOriginalText = null;
  /**
   * @var string
   */
  public $viewExpandedText = null;
  /**
   * @var string
   */
  public $tableType = null;
  /**
   * @var \metastore\PrincipalPrivilegeSet
   */
  public $privileges = null;
  /**
   * @var bool
   */
  public $temporary = false;
  /**
   * @var bool
   */
  public $rewriteEnabled = null;
  /**
   * @var \metastore\CreationMetadata
   */
  public $creationMetadata = null;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'owner',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'createTime',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'lastAccessTime',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'retention',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'sd',
          'type' => TType::STRUCT,
          'class' => '\metastore\StorageDescriptor',
          ),
        8 => array(
          'var' => 'partitionKeys',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\FieldSchema',
            ),
          ),
        9 => array(
          'var' => 'parameters',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        10 => array(
          'var' => 'viewOriginalText',
          'type' => TType::STRING,
          ),
        11 => array(
          'var' => 'viewExpandedText',
          'type' => TType::STRING,
          ),
        12 => array(
          'var' => 'tableType',
          'type' => TType::STRING,
          ),
        13 => array(
          'var' => 'privileges',
          'type' => TType::STRUCT,
          'class' => '\metastore\PrincipalPrivilegeSet',
          ),
        14 => array(
          'var' => 'temporary',
          'type' => TType::BOOL,
          ),
        15 => array(
          'var' => 'rewriteEnabled',
          'type' => TType::BOOL,
          ),
        16 => array(
          'var' => 'creationMetadata',
          'type' => TType::STRUCT,
          'class' => '\metastore\CreationMetadata',
          ),
        17 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['owner'])) {
        $this->owner = $vals['owner'];
      }
      if (isset($vals['createTime'])) {
        $this->createTime = $vals['createTime'];
      }
      if (isset($vals['lastAccessTime'])) {
        $this->lastAccessTime = $vals['lastAccessTime'];
      }
      if (isset($vals['retention'])) {
        $this->retention = $vals['retention'];
      }
      if (isset($vals['sd'])) {
        $this->sd = $vals['sd'];
      }
      if (isset($vals['partitionKeys'])) {
        $this->partitionKeys = $vals['partitionKeys'];
      }
      if (isset($vals['parameters'])) {
        $this->parameters = $vals['parameters'];
      }
      if (isset($vals['viewOriginalText'])) {
        $this->viewOriginalText = $vals['viewOriginalText'];
      }
      if (isset($vals['viewExpandedText'])) {
        $this->viewExpandedText = $vals['viewExpandedText'];
      }
      if (isset($vals['tableType'])) {
        $this->tableType = $vals['tableType'];
      }
      if (isset($vals['privileges'])) {
        $this->privileges = $vals['privileges'];
      }
      if (isset($vals['temporary'])) {
        $this->temporary = $vals['temporary'];
      }
      if (isset($vals['rewriteEnabled'])) {
        $this->rewriteEnabled = $vals['rewriteEnabled'];
      }
      if (isset($vals['creationMetadata'])) {
        $this->creationMetadata = $vals['creationMetadata'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'Table';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->owner);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->createTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->lastAccessTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->retention);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->sd = new \metastore\StorageDescriptor();
            $xfer += $this->sd->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::LST) {
            $this->partitionKeys = array();
            $_size175 = 0;
            $_etype178 = 0;
            $xfer += $input->readListBegin($_etype178, $_size175);
            for ($_i179 = 0; $_i179 < $_size175; ++$_i179)
            {
              $elem180 = null;
              $elem180 = new \metastore\FieldSchema();
              $xfer += $elem180->read($input);
              $this->partitionKeys []= $elem180;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::MAP) {
            $this->parameters = array();
            $_size181 = 0;
            $_ktype182 = 0;
            $_vtype183 = 0;
            $xfer += $input->readMapBegin($_ktype182, $_vtype183, $_size181);
            for ($_i185 = 0; $_i185 < $_size181; ++$_i185)
            {
              $key186 = '';
              $val187 = '';
              $xfer += $input->readString($key186);
              $xfer += $input->readString($val187);
              $this->parameters[$key186] = $val187;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->viewOriginalText);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->viewExpandedText);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 13:
          if ($ftype == TType::STRUCT) {
            $this->privileges = new \metastore\PrincipalPrivilegeSet();
            $xfer += $this->privileges->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 14:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->temporary);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 15:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->rewriteEnabled);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 16:
          if ($ftype == TType::STRUCT) {
            $this->creationMetadata = new \metastore\CreationMetadata();
            $xfer += $this->creationMetadata->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 17:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Table');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->owner !== null) {
      $xfer += $output->writeFieldBegin('owner', TType::STRING, 3);
      $xfer += $output->writeString($this->owner);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->createTime !== null) {
      $xfer += $output->writeFieldBegin('createTime', TType::I32, 4);
      $xfer += $output->writeI32($this->createTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->lastAccessTime !== null) {
      $xfer += $output->writeFieldBegin('lastAccessTime', TType::I32, 5);
      $xfer += $output->writeI32($this->lastAccessTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->retention !== null) {
      $xfer += $output->writeFieldBegin('retention', TType::I32, 6);
      $xfer += $output->writeI32($this->retention);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sd !== null) {
      if (!is_object($this->sd)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sd', TType::STRUCT, 7);
      $xfer += $this->sd->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partitionKeys !== null) {
      if (!is_array($this->partitionKeys)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partitionKeys', TType::LST, 8);
      {
        $output->writeListBegin(TType::STRUCT, count($this->partitionKeys));
        {
          foreach ($this->partitionKeys as $iter188)
          {
            $xfer += $iter188->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parameters !== null) {
      if (!is_array($this->parameters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('parameters', TType::MAP, 9);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->parameters));
        {
          foreach ($this->parameters as $kiter189 => $viter190)
          {
            $xfer += $output->writeString($kiter189);
            $xfer += $output->writeString($viter190);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->viewOriginalText !== null) {
      $xfer += $output->writeFieldBegin('viewOriginalText', TType::STRING, 10);
      $xfer += $output->writeString($this->viewOriginalText);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->viewExpandedText !== null) {
      $xfer += $output->writeFieldBegin('viewExpandedText', TType::STRING, 11);
      $xfer += $output->writeString($this->viewExpandedText);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableType !== null) {
      $xfer += $output->writeFieldBegin('tableType', TType::STRING, 12);
      $xfer += $output->writeString($this->tableType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->privileges !== null) {
      if (!is_object($this->privileges)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('privileges', TType::STRUCT, 13);
      $xfer += $this->privileges->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->temporary !== null) {
      $xfer += $output->writeFieldBegin('temporary', TType::BOOL, 14);
      $xfer += $output->writeBool($this->temporary);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rewriteEnabled !== null) {
      $xfer += $output->writeFieldBegin('rewriteEnabled', TType::BOOL, 15);
      $xfer += $output->writeBool($this->rewriteEnabled);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->creationMetadata !== null) {
      if (!is_object($this->creationMetadata)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('creationMetadata', TType::STRUCT, 16);
      $xfer += $this->creationMetadata->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 17);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Partition {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $values = null;
  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $tableName = null;
  /**
   * @var int
   */
  public $createTime = null;
  /**
   * @var int
   */
  public $lastAccessTime = null;
  /**
   * @var \metastore\StorageDescriptor
   */
  public $sd = null;
  /**
   * @var array
   */
  public $parameters = null;
  /**
   * @var \metastore\PrincipalPrivilegeSet
   */
  public $privileges = null;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'createTime',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'lastAccessTime',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'sd',
          'type' => TType::STRUCT,
          'class' => '\metastore\StorageDescriptor',
          ),
        7 => array(
          'var' => 'parameters',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        8 => array(
          'var' => 'privileges',
          'type' => TType::STRUCT,
          'class' => '\metastore\PrincipalPrivilegeSet',
          ),
        9 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['createTime'])) {
        $this->createTime = $vals['createTime'];
      }
      if (isset($vals['lastAccessTime'])) {
        $this->lastAccessTime = $vals['lastAccessTime'];
      }
      if (isset($vals['sd'])) {
        $this->sd = $vals['sd'];
      }
      if (isset($vals['parameters'])) {
        $this->parameters = $vals['parameters'];
      }
      if (isset($vals['privileges'])) {
        $this->privileges = $vals['privileges'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'Partition';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->values = array();
            $_size191 = 0;
            $_etype194 = 0;
            $xfer += $input->readListBegin($_etype194, $_size191);
            for ($_i195 = 0; $_i195 < $_size191; ++$_i195)
            {
              $elem196 = null;
              $xfer += $input->readString($elem196);
              $this->values []= $elem196;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->createTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->lastAccessTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->sd = new \metastore\StorageDescriptor();
            $xfer += $this->sd->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::MAP) {
            $this->parameters = array();
            $_size197 = 0;
            $_ktype198 = 0;
            $_vtype199 = 0;
            $xfer += $input->readMapBegin($_ktype198, $_vtype199, $_size197);
            for ($_i201 = 0; $_i201 < $_size197; ++$_i201)
            {
              $key202 = '';
              $val203 = '';
              $xfer += $input->readString($key202);
              $xfer += $input->readString($val203);
              $this->parameters[$key202] = $val203;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRUCT) {
            $this->privileges = new \metastore\PrincipalPrivilegeSet();
            $xfer += $this->privileges->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Partition');
    if ($this->values !== null) {
      if (!is_array($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->values));
        {
          foreach ($this->values as $iter204)
          {
            $xfer += $output->writeString($iter204);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 3);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->createTime !== null) {
      $xfer += $output->writeFieldBegin('createTime', TType::I32, 4);
      $xfer += $output->writeI32($this->createTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->lastAccessTime !== null) {
      $xfer += $output->writeFieldBegin('lastAccessTime', TType::I32, 5);
      $xfer += $output->writeI32($this->lastAccessTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sd !== null) {
      if (!is_object($this->sd)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sd', TType::STRUCT, 6);
      $xfer += $this->sd->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parameters !== null) {
      if (!is_array($this->parameters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('parameters', TType::MAP, 7);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->parameters));
        {
          foreach ($this->parameters as $kiter205 => $viter206)
          {
            $xfer += $output->writeString($kiter205);
            $xfer += $output->writeString($viter206);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->privileges !== null) {
      if (!is_object($this->privileges)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('privileges', TType::STRUCT, 8);
      $xfer += $this->privileges->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 9);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PartitionWithoutSD {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $values = null;
  /**
   * @var int
   */
  public $createTime = null;
  /**
   * @var int
   */
  public $lastAccessTime = null;
  /**
   * @var string
   */
  public $relativePath = null;
  /**
   * @var array
   */
  public $parameters = null;
  /**
   * @var \metastore\PrincipalPrivilegeSet
   */
  public $privileges = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'createTime',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'lastAccessTime',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'relativePath',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'parameters',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        6 => array(
          'var' => 'privileges',
          'type' => TType::STRUCT,
          'class' => '\metastore\PrincipalPrivilegeSet',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
      if (isset($vals['createTime'])) {
        $this->createTime = $vals['createTime'];
      }
      if (isset($vals['lastAccessTime'])) {
        $this->lastAccessTime = $vals['lastAccessTime'];
      }
      if (isset($vals['relativePath'])) {
        $this->relativePath = $vals['relativePath'];
      }
      if (isset($vals['parameters'])) {
        $this->parameters = $vals['parameters'];
      }
      if (isset($vals['privileges'])) {
        $this->privileges = $vals['privileges'];
      }
    }
  }

  public function getName() {
    return 'PartitionWithoutSD';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->values = array();
            $_size207 = 0;
            $_etype210 = 0;
            $xfer += $input->readListBegin($_etype210, $_size207);
            for ($_i211 = 0; $_i211 < $_size207; ++$_i211)
            {
              $elem212 = null;
              $xfer += $input->readString($elem212);
              $this->values []= $elem212;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->createTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->lastAccessTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->relativePath);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::MAP) {
            $this->parameters = array();
            $_size213 = 0;
            $_ktype214 = 0;
            $_vtype215 = 0;
            $xfer += $input->readMapBegin($_ktype214, $_vtype215, $_size213);
            for ($_i217 = 0; $_i217 < $_size213; ++$_i217)
            {
              $key218 = '';
              $val219 = '';
              $xfer += $input->readString($key218);
              $xfer += $input->readString($val219);
              $this->parameters[$key218] = $val219;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->privileges = new \metastore\PrincipalPrivilegeSet();
            $xfer += $this->privileges->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PartitionWithoutSD');
    if ($this->values !== null) {
      if (!is_array($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->values));
        {
          foreach ($this->values as $iter220)
          {
            $xfer += $output->writeString($iter220);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->createTime !== null) {
      $xfer += $output->writeFieldBegin('createTime', TType::I32, 2);
      $xfer += $output->writeI32($this->createTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->lastAccessTime !== null) {
      $xfer += $output->writeFieldBegin('lastAccessTime', TType::I32, 3);
      $xfer += $output->writeI32($this->lastAccessTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->relativePath !== null) {
      $xfer += $output->writeFieldBegin('relativePath', TType::STRING, 4);
      $xfer += $output->writeString($this->relativePath);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parameters !== null) {
      if (!is_array($this->parameters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('parameters', TType::MAP, 5);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->parameters));
        {
          foreach ($this->parameters as $kiter221 => $viter222)
          {
            $xfer += $output->writeString($kiter221);
            $xfer += $output->writeString($viter222);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->privileges !== null) {
      if (!is_object($this->privileges)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('privileges', TType::STRUCT, 6);
      $xfer += $this->privileges->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PartitionSpecWithSharedSD {
  static $_TSPEC;

  /**
   * @var \metastore\PartitionWithoutSD[]
   */
  public $partitions = null;
  /**
   * @var \metastore\StorageDescriptor
   */
  public $sd = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'partitions',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\PartitionWithoutSD',
            ),
          ),
        2 => array(
          'var' => 'sd',
          'type' => TType::STRUCT,
          'class' => '\metastore\StorageDescriptor',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['partitions'])) {
        $this->partitions = $vals['partitions'];
      }
      if (isset($vals['sd'])) {
        $this->sd = $vals['sd'];
      }
    }
  }

  public function getName() {
    return 'PartitionSpecWithSharedSD';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->partitions = array();
            $_size223 = 0;
            $_etype226 = 0;
            $xfer += $input->readListBegin($_etype226, $_size223);
            for ($_i227 = 0; $_i227 < $_size223; ++$_i227)
            {
              $elem228 = null;
              $elem228 = new \metastore\PartitionWithoutSD();
              $xfer += $elem228->read($input);
              $this->partitions []= $elem228;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->sd = new \metastore\StorageDescriptor();
            $xfer += $this->sd->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PartitionSpecWithSharedSD');
    if ($this->partitions !== null) {
      if (!is_array($this->partitions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partitions', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->partitions));
        {
          foreach ($this->partitions as $iter229)
          {
            $xfer += $iter229->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sd !== null) {
      if (!is_object($this->sd)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sd', TType::STRUCT, 2);
      $xfer += $this->sd->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PartitionListComposingSpec {
  static $_TSPEC;

  /**
   * @var \metastore\Partition[]
   */
  public $partitions = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'partitions',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['partitions'])) {
        $this->partitions = $vals['partitions'];
      }
    }
  }

  public function getName() {
    return 'PartitionListComposingSpec';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->partitions = array();
            $_size230 = 0;
            $_etype233 = 0;
            $xfer += $input->readListBegin($_etype233, $_size230);
            for ($_i234 = 0; $_i234 < $_size230; ++$_i234)
            {
              $elem235 = null;
              $elem235 = new \metastore\Partition();
              $xfer += $elem235->read($input);
              $this->partitions []= $elem235;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PartitionListComposingSpec');
    if ($this->partitions !== null) {
      if (!is_array($this->partitions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partitions', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->partitions));
        {
          foreach ($this->partitions as $iter236)
          {
            $xfer += $iter236->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PartitionSpec {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $tableName = null;
  /**
   * @var string
   */
  public $rootPath = null;
  /**
   * @var \metastore\PartitionSpecWithSharedSD
   */
  public $sharedSDPartitionSpec = null;
  /**
   * @var \metastore\PartitionListComposingSpec
   */
  public $partitionList = null;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'rootPath',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'sharedSDPartitionSpec',
          'type' => TType::STRUCT,
          'class' => '\metastore\PartitionSpecWithSharedSD',
          ),
        5 => array(
          'var' => 'partitionList',
          'type' => TType::STRUCT,
          'class' => '\metastore\PartitionListComposingSpec',
          ),
        6 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['rootPath'])) {
        $this->rootPath = $vals['rootPath'];
      }
      if (isset($vals['sharedSDPartitionSpec'])) {
        $this->sharedSDPartitionSpec = $vals['sharedSDPartitionSpec'];
      }
      if (isset($vals['partitionList'])) {
        $this->partitionList = $vals['partitionList'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'PartitionSpec';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->rootPath);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->sharedSDPartitionSpec = new \metastore\PartitionSpecWithSharedSD();
            $xfer += $this->sharedSDPartitionSpec->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->partitionList = new \metastore\PartitionListComposingSpec();
            $xfer += $this->partitionList->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PartitionSpec');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 2);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rootPath !== null) {
      $xfer += $output->writeFieldBegin('rootPath', TType::STRING, 3);
      $xfer += $output->writeString($this->rootPath);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sharedSDPartitionSpec !== null) {
      if (!is_object($this->sharedSDPartitionSpec)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sharedSDPartitionSpec', TType::STRUCT, 4);
      $xfer += $this->sharedSDPartitionSpec->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partitionList !== null) {
      if (!is_object($this->partitionList)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partitionList', TType::STRUCT, 5);
      $xfer += $this->partitionList->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 6);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BooleanColumnStatsData {
  static $_TSPEC;

  /**
   * @var int
   */
  public $numTrues = null;
  /**
   * @var int
   */
  public $numFalses = null;
  /**
   * @var int
   */
  public $numNulls = null;
  /**
   * @var string
   */
  public $bitVectors = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'numTrues',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'numFalses',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'numNulls',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'bitVectors',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['numTrues'])) {
        $this->numTrues = $vals['numTrues'];
      }
      if (isset($vals['numFalses'])) {
        $this->numFalses = $vals['numFalses'];
      }
      if (isset($vals['numNulls'])) {
        $this->numNulls = $vals['numNulls'];
      }
      if (isset($vals['bitVectors'])) {
        $this->bitVectors = $vals['bitVectors'];
      }
    }
  }

  public function getName() {
    return 'BooleanColumnStatsData';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->numTrues);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->numFalses);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->numNulls);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->bitVectors);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BooleanColumnStatsData');
    if ($this->numTrues !== null) {
      $xfer += $output->writeFieldBegin('numTrues', TType::I64, 1);
      $xfer += $output->writeI64($this->numTrues);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numFalses !== null) {
      $xfer += $output->writeFieldBegin('numFalses', TType::I64, 2);
      $xfer += $output->writeI64($this->numFalses);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numNulls !== null) {
      $xfer += $output->writeFieldBegin('numNulls', TType::I64, 3);
      $xfer += $output->writeI64($this->numNulls);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bitVectors !== null) {
      $xfer += $output->writeFieldBegin('bitVectors', TType::STRING, 4);
      $xfer += $output->writeString($this->bitVectors);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DoubleColumnStatsData {
  static $_TSPEC;

  /**
   * @var double
   */
  public $lowValue = null;
  /**
   * @var double
   */
  public $highValue = null;
  /**
   * @var int
   */
  public $numNulls = null;
  /**
   * @var int
   */
  public $numDVs = null;
  /**
   * @var string
   */
  public $bitVectors = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'lowValue',
          'type' => TType::DOUBLE,
          ),
        2 => array(
          'var' => 'highValue',
          'type' => TType::DOUBLE,
          ),
        3 => array(
          'var' => 'numNulls',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'numDVs',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'bitVectors',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['lowValue'])) {
        $this->lowValue = $vals['lowValue'];
      }
      if (isset($vals['highValue'])) {
        $this->highValue = $vals['highValue'];
      }
      if (isset($vals['numNulls'])) {
        $this->numNulls = $vals['numNulls'];
      }
      if (isset($vals['numDVs'])) {
        $this->numDVs = $vals['numDVs'];
      }
      if (isset($vals['bitVectors'])) {
        $this->bitVectors = $vals['bitVectors'];
      }
    }
  }

  public function getName() {
    return 'DoubleColumnStatsData';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->lowValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->highValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->numNulls);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->numDVs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->bitVectors);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DoubleColumnStatsData');
    if ($this->lowValue !== null) {
      $xfer += $output->writeFieldBegin('lowValue', TType::DOUBLE, 1);
      $xfer += $output->writeDouble($this->lowValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->highValue !== null) {
      $xfer += $output->writeFieldBegin('highValue', TType::DOUBLE, 2);
      $xfer += $output->writeDouble($this->highValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numNulls !== null) {
      $xfer += $output->writeFieldBegin('numNulls', TType::I64, 3);
      $xfer += $output->writeI64($this->numNulls);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numDVs !== null) {
      $xfer += $output->writeFieldBegin('numDVs', TType::I64, 4);
      $xfer += $output->writeI64($this->numDVs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bitVectors !== null) {
      $xfer += $output->writeFieldBegin('bitVectors', TType::STRING, 5);
      $xfer += $output->writeString($this->bitVectors);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class LongColumnStatsData {
  static $_TSPEC;

  /**
   * @var int
   */
  public $lowValue = null;
  /**
   * @var int
   */
  public $highValue = null;
  /**
   * @var int
   */
  public $numNulls = null;
  /**
   * @var int
   */
  public $numDVs = null;
  /**
   * @var string
   */
  public $bitVectors = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'lowValue',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'highValue',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'numNulls',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'numDVs',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'bitVectors',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['lowValue'])) {
        $this->lowValue = $vals['lowValue'];
      }
      if (isset($vals['highValue'])) {
        $this->highValue = $vals['highValue'];
      }
      if (isset($vals['numNulls'])) {
        $this->numNulls = $vals['numNulls'];
      }
      if (isset($vals['numDVs'])) {
        $this->numDVs = $vals['numDVs'];
      }
      if (isset($vals['bitVectors'])) {
        $this->bitVectors = $vals['bitVectors'];
      }
    }
  }

  public function getName() {
    return 'LongColumnStatsData';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->lowValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->highValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->numNulls);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->numDVs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->bitVectors);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('LongColumnStatsData');
    if ($this->lowValue !== null) {
      $xfer += $output->writeFieldBegin('lowValue', TType::I64, 1);
      $xfer += $output->writeI64($this->lowValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->highValue !== null) {
      $xfer += $output->writeFieldBegin('highValue', TType::I64, 2);
      $xfer += $output->writeI64($this->highValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numNulls !== null) {
      $xfer += $output->writeFieldBegin('numNulls', TType::I64, 3);
      $xfer += $output->writeI64($this->numNulls);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numDVs !== null) {
      $xfer += $output->writeFieldBegin('numDVs', TType::I64, 4);
      $xfer += $output->writeI64($this->numDVs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bitVectors !== null) {
      $xfer += $output->writeFieldBegin('bitVectors', TType::STRING, 5);
      $xfer += $output->writeString($this->bitVectors);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class StringColumnStatsData {
  static $_TSPEC;

  /**
   * @var int
   */
  public $maxColLen = null;
  /**
   * @var double
   */
  public $avgColLen = null;
  /**
   * @var int
   */
  public $numNulls = null;
  /**
   * @var int
   */
  public $numDVs = null;
  /**
   * @var string
   */
  public $bitVectors = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'maxColLen',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'avgColLen',
          'type' => TType::DOUBLE,
          ),
        3 => array(
          'var' => 'numNulls',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'numDVs',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'bitVectors',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['maxColLen'])) {
        $this->maxColLen = $vals['maxColLen'];
      }
      if (isset($vals['avgColLen'])) {
        $this->avgColLen = $vals['avgColLen'];
      }
      if (isset($vals['numNulls'])) {
        $this->numNulls = $vals['numNulls'];
      }
      if (isset($vals['numDVs'])) {
        $this->numDVs = $vals['numDVs'];
      }
      if (isset($vals['bitVectors'])) {
        $this->bitVectors = $vals['bitVectors'];
      }
    }
  }

  public function getName() {
    return 'StringColumnStatsData';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->maxColLen);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->avgColLen);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->numNulls);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->numDVs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->bitVectors);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('StringColumnStatsData');
    if ($this->maxColLen !== null) {
      $xfer += $output->writeFieldBegin('maxColLen', TType::I64, 1);
      $xfer += $output->writeI64($this->maxColLen);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->avgColLen !== null) {
      $xfer += $output->writeFieldBegin('avgColLen', TType::DOUBLE, 2);
      $xfer += $output->writeDouble($this->avgColLen);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numNulls !== null) {
      $xfer += $output->writeFieldBegin('numNulls', TType::I64, 3);
      $xfer += $output->writeI64($this->numNulls);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numDVs !== null) {
      $xfer += $output->writeFieldBegin('numDVs', TType::I64, 4);
      $xfer += $output->writeI64($this->numDVs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bitVectors !== null) {
      $xfer += $output->writeFieldBegin('bitVectors', TType::STRING, 5);
      $xfer += $output->writeString($this->bitVectors);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BinaryColumnStatsData {
  static $_TSPEC;

  /**
   * @var int
   */
  public $maxColLen = null;
  /**
   * @var double
   */
  public $avgColLen = null;
  /**
   * @var int
   */
  public $numNulls = null;
  /**
   * @var string
   */
  public $bitVectors = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'maxColLen',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'avgColLen',
          'type' => TType::DOUBLE,
          ),
        3 => array(
          'var' => 'numNulls',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'bitVectors',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['maxColLen'])) {
        $this->maxColLen = $vals['maxColLen'];
      }
      if (isset($vals['avgColLen'])) {
        $this->avgColLen = $vals['avgColLen'];
      }
      if (isset($vals['numNulls'])) {
        $this->numNulls = $vals['numNulls'];
      }
      if (isset($vals['bitVectors'])) {
        $this->bitVectors = $vals['bitVectors'];
      }
    }
  }

  public function getName() {
    return 'BinaryColumnStatsData';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->maxColLen);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->avgColLen);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->numNulls);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->bitVectors);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BinaryColumnStatsData');
    if ($this->maxColLen !== null) {
      $xfer += $output->writeFieldBegin('maxColLen', TType::I64, 1);
      $xfer += $output->writeI64($this->maxColLen);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->avgColLen !== null) {
      $xfer += $output->writeFieldBegin('avgColLen', TType::DOUBLE, 2);
      $xfer += $output->writeDouble($this->avgColLen);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numNulls !== null) {
      $xfer += $output->writeFieldBegin('numNulls', TType::I64, 3);
      $xfer += $output->writeI64($this->numNulls);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bitVectors !== null) {
      $xfer += $output->writeFieldBegin('bitVectors', TType::STRING, 4);
      $xfer += $output->writeString($this->bitVectors);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Decimal {
  static $_TSPEC;

  /**
   * @var int
   */
  public $scale = null;
  /**
   * @var string
   */
  public $unscaled = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        3 => array(
          'var' => 'scale',
          'type' => TType::I16,
          ),
        1 => array(
          'var' => 'unscaled',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['scale'])) {
        $this->scale = $vals['scale'];
      }
      if (isset($vals['unscaled'])) {
        $this->unscaled = $vals['unscaled'];
      }
    }
  }

  public function getName() {
    return 'Decimal';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 3:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->scale);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->unscaled);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Decimal');
    if ($this->unscaled !== null) {
      $xfer += $output->writeFieldBegin('unscaled', TType::STRING, 1);
      $xfer += $output->writeString($this->unscaled);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->scale !== null) {
      $xfer += $output->writeFieldBegin('scale', TType::I16, 3);
      $xfer += $output->writeI16($this->scale);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DecimalColumnStatsData {
  static $_TSPEC;

  /**
   * @var \metastore\Decimal
   */
  public $lowValue = null;
  /**
   * @var \metastore\Decimal
   */
  public $highValue = null;
  /**
   * @var int
   */
  public $numNulls = null;
  /**
   * @var int
   */
  public $numDVs = null;
  /**
   * @var string
   */
  public $bitVectors = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'lowValue',
          'type' => TType::STRUCT,
          'class' => '\metastore\Decimal',
          ),
        2 => array(
          'var' => 'highValue',
          'type' => TType::STRUCT,
          'class' => '\metastore\Decimal',
          ),
        3 => array(
          'var' => 'numNulls',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'numDVs',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'bitVectors',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['lowValue'])) {
        $this->lowValue = $vals['lowValue'];
      }
      if (isset($vals['highValue'])) {
        $this->highValue = $vals['highValue'];
      }
      if (isset($vals['numNulls'])) {
        $this->numNulls = $vals['numNulls'];
      }
      if (isset($vals['numDVs'])) {
        $this->numDVs = $vals['numDVs'];
      }
      if (isset($vals['bitVectors'])) {
        $this->bitVectors = $vals['bitVectors'];
      }
    }
  }

  public function getName() {
    return 'DecimalColumnStatsData';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->lowValue = new \metastore\Decimal();
            $xfer += $this->lowValue->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->highValue = new \metastore\Decimal();
            $xfer += $this->highValue->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->numNulls);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->numDVs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->bitVectors);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DecimalColumnStatsData');
    if ($this->lowValue !== null) {
      if (!is_object($this->lowValue)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('lowValue', TType::STRUCT, 1);
      $xfer += $this->lowValue->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->highValue !== null) {
      if (!is_object($this->highValue)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('highValue', TType::STRUCT, 2);
      $xfer += $this->highValue->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numNulls !== null) {
      $xfer += $output->writeFieldBegin('numNulls', TType::I64, 3);
      $xfer += $output->writeI64($this->numNulls);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numDVs !== null) {
      $xfer += $output->writeFieldBegin('numDVs', TType::I64, 4);
      $xfer += $output->writeI64($this->numDVs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bitVectors !== null) {
      $xfer += $output->writeFieldBegin('bitVectors', TType::STRING, 5);
      $xfer += $output->writeString($this->bitVectors);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Date {
  static $_TSPEC;

  /**
   * @var int
   */
  public $daysSinceEpoch = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'daysSinceEpoch',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['daysSinceEpoch'])) {
        $this->daysSinceEpoch = $vals['daysSinceEpoch'];
      }
    }
  }

  public function getName() {
    return 'Date';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->daysSinceEpoch);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Date');
    if ($this->daysSinceEpoch !== null) {
      $xfer += $output->writeFieldBegin('daysSinceEpoch', TType::I64, 1);
      $xfer += $output->writeI64($this->daysSinceEpoch);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DateColumnStatsData {
  static $_TSPEC;

  /**
   * @var \metastore\Date
   */
  public $lowValue = null;
  /**
   * @var \metastore\Date
   */
  public $highValue = null;
  /**
   * @var int
   */
  public $numNulls = null;
  /**
   * @var int
   */
  public $numDVs = null;
  /**
   * @var string
   */
  public $bitVectors = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'lowValue',
          'type' => TType::STRUCT,
          'class' => '\metastore\Date',
          ),
        2 => array(
          'var' => 'highValue',
          'type' => TType::STRUCT,
          'class' => '\metastore\Date',
          ),
        3 => array(
          'var' => 'numNulls',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'numDVs',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'bitVectors',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['lowValue'])) {
        $this->lowValue = $vals['lowValue'];
      }
      if (isset($vals['highValue'])) {
        $this->highValue = $vals['highValue'];
      }
      if (isset($vals['numNulls'])) {
        $this->numNulls = $vals['numNulls'];
      }
      if (isset($vals['numDVs'])) {
        $this->numDVs = $vals['numDVs'];
      }
      if (isset($vals['bitVectors'])) {
        $this->bitVectors = $vals['bitVectors'];
      }
    }
  }

  public function getName() {
    return 'DateColumnStatsData';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->lowValue = new \metastore\Date();
            $xfer += $this->lowValue->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->highValue = new \metastore\Date();
            $xfer += $this->highValue->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->numNulls);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->numDVs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->bitVectors);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DateColumnStatsData');
    if ($this->lowValue !== null) {
      if (!is_object($this->lowValue)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('lowValue', TType::STRUCT, 1);
      $xfer += $this->lowValue->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->highValue !== null) {
      if (!is_object($this->highValue)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('highValue', TType::STRUCT, 2);
      $xfer += $this->highValue->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numNulls !== null) {
      $xfer += $output->writeFieldBegin('numNulls', TType::I64, 3);
      $xfer += $output->writeI64($this->numNulls);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numDVs !== null) {
      $xfer += $output->writeFieldBegin('numDVs', TType::I64, 4);
      $xfer += $output->writeI64($this->numDVs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bitVectors !== null) {
      $xfer += $output->writeFieldBegin('bitVectors', TType::STRING, 5);
      $xfer += $output->writeString($this->bitVectors);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ColumnStatisticsData {
  static $_TSPEC;

  /**
   * @var \metastore\BooleanColumnStatsData
   */
  public $booleanStats = null;
  /**
   * @var \metastore\LongColumnStatsData
   */
  public $longStats = null;
  /**
   * @var \metastore\DoubleColumnStatsData
   */
  public $doubleStats = null;
  /**
   * @var \metastore\StringColumnStatsData
   */
  public $stringStats = null;
  /**
   * @var \metastore\BinaryColumnStatsData
   */
  public $binaryStats = null;
  /**
   * @var \metastore\DecimalColumnStatsData
   */
  public $decimalStats = null;
  /**
   * @var \metastore\DateColumnStatsData
   */
  public $dateStats = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'booleanStats',
          'type' => TType::STRUCT,
          'class' => '\metastore\BooleanColumnStatsData',
          ),
        2 => array(
          'var' => 'longStats',
          'type' => TType::STRUCT,
          'class' => '\metastore\LongColumnStatsData',
          ),
        3 => array(
          'var' => 'doubleStats',
          'type' => TType::STRUCT,
          'class' => '\metastore\DoubleColumnStatsData',
          ),
        4 => array(
          'var' => 'stringStats',
          'type' => TType::STRUCT,
          'class' => '\metastore\StringColumnStatsData',
          ),
        5 => array(
          'var' => 'binaryStats',
          'type' => TType::STRUCT,
          'class' => '\metastore\BinaryColumnStatsData',
          ),
        6 => array(
          'var' => 'decimalStats',
          'type' => TType::STRUCT,
          'class' => '\metastore\DecimalColumnStatsData',
          ),
        7 => array(
          'var' => 'dateStats',
          'type' => TType::STRUCT,
          'class' => '\metastore\DateColumnStatsData',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['booleanStats'])) {
        $this->booleanStats = $vals['booleanStats'];
      }
      if (isset($vals['longStats'])) {
        $this->longStats = $vals['longStats'];
      }
      if (isset($vals['doubleStats'])) {
        $this->doubleStats = $vals['doubleStats'];
      }
      if (isset($vals['stringStats'])) {
        $this->stringStats = $vals['stringStats'];
      }
      if (isset($vals['binaryStats'])) {
        $this->binaryStats = $vals['binaryStats'];
      }
      if (isset($vals['decimalStats'])) {
        $this->decimalStats = $vals['decimalStats'];
      }
      if (isset($vals['dateStats'])) {
        $this->dateStats = $vals['dateStats'];
      }
    }
  }

  public function getName() {
    return 'ColumnStatisticsData';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->booleanStats = new \metastore\BooleanColumnStatsData();
            $xfer += $this->booleanStats->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->longStats = new \metastore\LongColumnStatsData();
            $xfer += $this->longStats->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->doubleStats = new \metastore\DoubleColumnStatsData();
            $xfer += $this->doubleStats->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->stringStats = new \metastore\StringColumnStatsData();
            $xfer += $this->stringStats->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->binaryStats = new \metastore\BinaryColumnStatsData();
            $xfer += $this->binaryStats->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->decimalStats = new \metastore\DecimalColumnStatsData();
            $xfer += $this->decimalStats->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->dateStats = new \metastore\DateColumnStatsData();
            $xfer += $this->dateStats->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ColumnStatisticsData');
    if ($this->booleanStats !== null) {
      if (!is_object($this->booleanStats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('booleanStats', TType::STRUCT, 1);
      $xfer += $this->booleanStats->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->longStats !== null) {
      if (!is_object($this->longStats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('longStats', TType::STRUCT, 2);
      $xfer += $this->longStats->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->doubleStats !== null) {
      if (!is_object($this->doubleStats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('doubleStats', TType::STRUCT, 3);
      $xfer += $this->doubleStats->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stringStats !== null) {
      if (!is_object($this->stringStats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('stringStats', TType::STRUCT, 4);
      $xfer += $this->stringStats->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->binaryStats !== null) {
      if (!is_object($this->binaryStats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('binaryStats', TType::STRUCT, 5);
      $xfer += $this->binaryStats->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->decimalStats !== null) {
      if (!is_object($this->decimalStats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('decimalStats', TType::STRUCT, 6);
      $xfer += $this->decimalStats->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dateStats !== null) {
      if (!is_object($this->dateStats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('dateStats', TType::STRUCT, 7);
      $xfer += $this->dateStats->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ColumnStatisticsObj {
  static $_TSPEC;

  /**
   * @var string
   */
  public $colName = null;
  /**
   * @var string
   */
  public $colType = null;
  /**
   * @var \metastore\ColumnStatisticsData
   */
  public $statsData = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'colName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'colType',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'statsData',
          'type' => TType::STRUCT,
          'class' => '\metastore\ColumnStatisticsData',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['colName'])) {
        $this->colName = $vals['colName'];
      }
      if (isset($vals['colType'])) {
        $this->colType = $vals['colType'];
      }
      if (isset($vals['statsData'])) {
        $this->statsData = $vals['statsData'];
      }
    }
  }

  public function getName() {
    return 'ColumnStatisticsObj';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->colName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->colType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->statsData = new \metastore\ColumnStatisticsData();
            $xfer += $this->statsData->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ColumnStatisticsObj');
    if ($this->colName !== null) {
      $xfer += $output->writeFieldBegin('colName', TType::STRING, 1);
      $xfer += $output->writeString($this->colName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->colType !== null) {
      $xfer += $output->writeFieldBegin('colType', TType::STRING, 2);
      $xfer += $output->writeString($this->colType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->statsData !== null) {
      if (!is_object($this->statsData)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('statsData', TType::STRUCT, 3);
      $xfer += $this->statsData->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ColumnStatisticsDesc {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $isTblLevel = null;
  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $tableName = null;
  /**
   * @var string
   */
  public $partName = null;
  /**
   * @var int
   */
  public $lastAnalyzed = null;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'isTblLevel',
          'type' => TType::BOOL,
          ),
        2 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'partName',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'lastAnalyzed',
          'type' => TType::I64,
          ),
        6 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['isTblLevel'])) {
        $this->isTblLevel = $vals['isTblLevel'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['partName'])) {
        $this->partName = $vals['partName'];
      }
      if (isset($vals['lastAnalyzed'])) {
        $this->lastAnalyzed = $vals['lastAnalyzed'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'ColumnStatisticsDesc';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isTblLevel);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->partName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->lastAnalyzed);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ColumnStatisticsDesc');
    if ($this->isTblLevel !== null) {
      $xfer += $output->writeFieldBegin('isTblLevel', TType::BOOL, 1);
      $xfer += $output->writeBool($this->isTblLevel);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 3);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partName !== null) {
      $xfer += $output->writeFieldBegin('partName', TType::STRING, 4);
      $xfer += $output->writeString($this->partName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->lastAnalyzed !== null) {
      $xfer += $output->writeFieldBegin('lastAnalyzed', TType::I64, 5);
      $xfer += $output->writeI64($this->lastAnalyzed);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 6);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ColumnStatistics {
  static $_TSPEC;

  /**
   * @var \metastore\ColumnStatisticsDesc
   */
  public $statsDesc = null;
  /**
   * @var \metastore\ColumnStatisticsObj[]
   */
  public $statsObj = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'statsDesc',
          'type' => TType::STRUCT,
          'class' => '\metastore\ColumnStatisticsDesc',
          ),
        2 => array(
          'var' => 'statsObj',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\ColumnStatisticsObj',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['statsDesc'])) {
        $this->statsDesc = $vals['statsDesc'];
      }
      if (isset($vals['statsObj'])) {
        $this->statsObj = $vals['statsObj'];
      }
    }
  }

  public function getName() {
    return 'ColumnStatistics';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->statsDesc = new \metastore\ColumnStatisticsDesc();
            $xfer += $this->statsDesc->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->statsObj = array();
            $_size237 = 0;
            $_etype240 = 0;
            $xfer += $input->readListBegin($_etype240, $_size237);
            for ($_i241 = 0; $_i241 < $_size237; ++$_i241)
            {
              $elem242 = null;
              $elem242 = new \metastore\ColumnStatisticsObj();
              $xfer += $elem242->read($input);
              $this->statsObj []= $elem242;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ColumnStatistics');
    if ($this->statsDesc !== null) {
      if (!is_object($this->statsDesc)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('statsDesc', TType::STRUCT, 1);
      $xfer += $this->statsDesc->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->statsObj !== null) {
      if (!is_array($this->statsObj)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('statsObj', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->statsObj));
        {
          foreach ($this->statsObj as $iter243)
          {
            $xfer += $iter243->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AggrStats {
  static $_TSPEC;

  /**
   * @var \metastore\ColumnStatisticsObj[]
   */
  public $colStats = null;
  /**
   * @var int
   */
  public $partsFound = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'colStats',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\ColumnStatisticsObj',
            ),
          ),
        2 => array(
          'var' => 'partsFound',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['colStats'])) {
        $this->colStats = $vals['colStats'];
      }
      if (isset($vals['partsFound'])) {
        $this->partsFound = $vals['partsFound'];
      }
    }
  }

  public function getName() {
    return 'AggrStats';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->colStats = array();
            $_size244 = 0;
            $_etype247 = 0;
            $xfer += $input->readListBegin($_etype247, $_size244);
            for ($_i248 = 0; $_i248 < $_size244; ++$_i248)
            {
              $elem249 = null;
              $elem249 = new \metastore\ColumnStatisticsObj();
              $xfer += $elem249->read($input);
              $this->colStats []= $elem249;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->partsFound);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AggrStats');
    if ($this->colStats !== null) {
      if (!is_array($this->colStats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('colStats', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->colStats));
        {
          foreach ($this->colStats as $iter250)
          {
            $xfer += $iter250->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partsFound !== null) {
      $xfer += $output->writeFieldBegin('partsFound', TType::I64, 2);
      $xfer += $output->writeI64($this->partsFound);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SetPartitionsStatsRequest {
  static $_TSPEC;

  /**
   * @var \metastore\ColumnStatistics[]
   */
  public $colStats = null;
  /**
   * @var bool
   */
  public $needMerge = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'colStats',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\ColumnStatistics',
            ),
          ),
        2 => array(
          'var' => 'needMerge',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['colStats'])) {
        $this->colStats = $vals['colStats'];
      }
      if (isset($vals['needMerge'])) {
        $this->needMerge = $vals['needMerge'];
      }
    }
  }

  public function getName() {
    return 'SetPartitionsStatsRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->colStats = array();
            $_size251 = 0;
            $_etype254 = 0;
            $xfer += $input->readListBegin($_etype254, $_size251);
            for ($_i255 = 0; $_i255 < $_size251; ++$_i255)
            {
              $elem256 = null;
              $elem256 = new \metastore\ColumnStatistics();
              $xfer += $elem256->read($input);
              $this->colStats []= $elem256;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->needMerge);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SetPartitionsStatsRequest');
    if ($this->colStats !== null) {
      if (!is_array($this->colStats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('colStats', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->colStats));
        {
          foreach ($this->colStats as $iter257)
          {
            $xfer += $iter257->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->needMerge !== null) {
      $xfer += $output->writeFieldBegin('needMerge', TType::BOOL, 2);
      $xfer += $output->writeBool($this->needMerge);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Schema {
  static $_TSPEC;

  /**
   * @var \metastore\FieldSchema[]
   */
  public $fieldSchemas = null;
  /**
   * @var array
   */
  public $properties = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'fieldSchemas',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\FieldSchema',
            ),
          ),
        2 => array(
          'var' => 'properties',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['fieldSchemas'])) {
        $this->fieldSchemas = $vals['fieldSchemas'];
      }
      if (isset($vals['properties'])) {
        $this->properties = $vals['properties'];
      }
    }
  }

  public function getName() {
    return 'Schema';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->fieldSchemas = array();
            $_size258 = 0;
            $_etype261 = 0;
            $xfer += $input->readListBegin($_etype261, $_size258);
            for ($_i262 = 0; $_i262 < $_size258; ++$_i262)
            {
              $elem263 = null;
              $elem263 = new \metastore\FieldSchema();
              $xfer += $elem263->read($input);
              $this->fieldSchemas []= $elem263;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->properties = array();
            $_size264 = 0;
            $_ktype265 = 0;
            $_vtype266 = 0;
            $xfer += $input->readMapBegin($_ktype265, $_vtype266, $_size264);
            for ($_i268 = 0; $_i268 < $_size264; ++$_i268)
            {
              $key269 = '';
              $val270 = '';
              $xfer += $input->readString($key269);
              $xfer += $input->readString($val270);
              $this->properties[$key269] = $val270;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Schema');
    if ($this->fieldSchemas !== null) {
      if (!is_array($this->fieldSchemas)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('fieldSchemas', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->fieldSchemas));
        {
          foreach ($this->fieldSchemas as $iter271)
          {
            $xfer += $iter271->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->properties !== null) {
      if (!is_array($this->properties)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('properties', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->properties));
        {
          foreach ($this->properties as $kiter272 => $viter273)
          {
            $xfer += $output->writeString($kiter272);
            $xfer += $output->writeString($viter273);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class EnvironmentContext {
  static $_TSPEC;

  /**
   * @var array
   */
  public $properties = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'properties',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['properties'])) {
        $this->properties = $vals['properties'];
      }
    }
  }

  public function getName() {
    return 'EnvironmentContext';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->properties = array();
            $_size274 = 0;
            $_ktype275 = 0;
            $_vtype276 = 0;
            $xfer += $input->readMapBegin($_ktype275, $_vtype276, $_size274);
            for ($_i278 = 0; $_i278 < $_size274; ++$_i278)
            {
              $key279 = '';
              $val280 = '';
              $xfer += $input->readString($key279);
              $xfer += $input->readString($val280);
              $this->properties[$key279] = $val280;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('EnvironmentContext');
    if ($this->properties !== null) {
      if (!is_array($this->properties)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('properties', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->properties));
        {
          foreach ($this->properties as $kiter281 => $viter282)
          {
            $xfer += $output->writeString($kiter281);
            $xfer += $output->writeString($viter282);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PrimaryKeysRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'PrimaryKeysRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PrimaryKeysRequest');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 3);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PrimaryKeysResponse {
  static $_TSPEC;

  /**
   * @var \metastore\SQLPrimaryKey[]
   */
  public $primaryKeys = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'primaryKeys',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SQLPrimaryKey',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['primaryKeys'])) {
        $this->primaryKeys = $vals['primaryKeys'];
      }
    }
  }

  public function getName() {
    return 'PrimaryKeysResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->primaryKeys = array();
            $_size283 = 0;
            $_etype286 = 0;
            $xfer += $input->readListBegin($_etype286, $_size283);
            for ($_i287 = 0; $_i287 < $_size283; ++$_i287)
            {
              $elem288 = null;
              $elem288 = new \metastore\SQLPrimaryKey();
              $xfer += $elem288->read($input);
              $this->primaryKeys []= $elem288;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PrimaryKeysResponse');
    if ($this->primaryKeys !== null) {
      if (!is_array($this->primaryKeys)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('primaryKeys', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->primaryKeys));
        {
          foreach ($this->primaryKeys as $iter289)
          {
            $xfer += $iter289->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ForeignKeysRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $parent_db_name = null;
  /**
   * @var string
   */
  public $parent_tbl_name = null;
  /**
   * @var string
   */
  public $foreign_db_name = null;
  /**
   * @var string
   */
  public $foreign_tbl_name = null;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'parent_db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'parent_tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'foreign_db_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'foreign_tbl_name',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['parent_db_name'])) {
        $this->parent_db_name = $vals['parent_db_name'];
      }
      if (isset($vals['parent_tbl_name'])) {
        $this->parent_tbl_name = $vals['parent_tbl_name'];
      }
      if (isset($vals['foreign_db_name'])) {
        $this->foreign_db_name = $vals['foreign_db_name'];
      }
      if (isset($vals['foreign_tbl_name'])) {
        $this->foreign_tbl_name = $vals['foreign_tbl_name'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'ForeignKeysRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->parent_db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->parent_tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->foreign_db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->foreign_tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ForeignKeysRequest');
    if ($this->parent_db_name !== null) {
      $xfer += $output->writeFieldBegin('parent_db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->parent_db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parent_tbl_name !== null) {
      $xfer += $output->writeFieldBegin('parent_tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->parent_tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->foreign_db_name !== null) {
      $xfer += $output->writeFieldBegin('foreign_db_name', TType::STRING, 3);
      $xfer += $output->writeString($this->foreign_db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->foreign_tbl_name !== null) {
      $xfer += $output->writeFieldBegin('foreign_tbl_name', TType::STRING, 4);
      $xfer += $output->writeString($this->foreign_tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 5);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ForeignKeysResponse {
  static $_TSPEC;

  /**
   * @var \metastore\SQLForeignKey[]
   */
  public $foreignKeys = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'foreignKeys',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SQLForeignKey',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['foreignKeys'])) {
        $this->foreignKeys = $vals['foreignKeys'];
      }
    }
  }

  public function getName() {
    return 'ForeignKeysResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->foreignKeys = array();
            $_size290 = 0;
            $_etype293 = 0;
            $xfer += $input->readListBegin($_etype293, $_size290);
            for ($_i294 = 0; $_i294 < $_size290; ++$_i294)
            {
              $elem295 = null;
              $elem295 = new \metastore\SQLForeignKey();
              $xfer += $elem295->read($input);
              $this->foreignKeys []= $elem295;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ForeignKeysResponse');
    if ($this->foreignKeys !== null) {
      if (!is_array($this->foreignKeys)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('foreignKeys', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->foreignKeys));
        {
          foreach ($this->foreignKeys as $iter296)
          {
            $xfer += $iter296->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class UniqueConstraintsRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $catName = null;
  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
    }
  }

  public function getName() {
    return 'UniqueConstraintsRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('UniqueConstraintsRequest');
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 1);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 2);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 3);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class UniqueConstraintsResponse {
  static $_TSPEC;

  /**
   * @var \metastore\SQLUniqueConstraint[]
   */
  public $uniqueConstraints = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'uniqueConstraints',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SQLUniqueConstraint',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['uniqueConstraints'])) {
        $this->uniqueConstraints = $vals['uniqueConstraints'];
      }
    }
  }

  public function getName() {
    return 'UniqueConstraintsResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->uniqueConstraints = array();
            $_size297 = 0;
            $_etype300 = 0;
            $xfer += $input->readListBegin($_etype300, $_size297);
            for ($_i301 = 0; $_i301 < $_size297; ++$_i301)
            {
              $elem302 = null;
              $elem302 = new \metastore\SQLUniqueConstraint();
              $xfer += $elem302->read($input);
              $this->uniqueConstraints []= $elem302;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('UniqueConstraintsResponse');
    if ($this->uniqueConstraints !== null) {
      if (!is_array($this->uniqueConstraints)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('uniqueConstraints', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->uniqueConstraints));
        {
          foreach ($this->uniqueConstraints as $iter303)
          {
            $xfer += $iter303->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NotNullConstraintsRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $catName = null;
  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
    }
  }

  public function getName() {
    return 'NotNullConstraintsRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NotNullConstraintsRequest');
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 1);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 2);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 3);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NotNullConstraintsResponse {
  static $_TSPEC;

  /**
   * @var \metastore\SQLNotNullConstraint[]
   */
  public $notNullConstraints = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'notNullConstraints',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SQLNotNullConstraint',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['notNullConstraints'])) {
        $this->notNullConstraints = $vals['notNullConstraints'];
      }
    }
  }

  public function getName() {
    return 'NotNullConstraintsResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->notNullConstraints = array();
            $_size304 = 0;
            $_etype307 = 0;
            $xfer += $input->readListBegin($_etype307, $_size304);
            for ($_i308 = 0; $_i308 < $_size304; ++$_i308)
            {
              $elem309 = null;
              $elem309 = new \metastore\SQLNotNullConstraint();
              $xfer += $elem309->read($input);
              $this->notNullConstraints []= $elem309;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NotNullConstraintsResponse');
    if ($this->notNullConstraints !== null) {
      if (!is_array($this->notNullConstraints)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('notNullConstraints', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->notNullConstraints));
        {
          foreach ($this->notNullConstraints as $iter310)
          {
            $xfer += $iter310->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DefaultConstraintsRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $catName = null;
  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
    }
  }

  public function getName() {
    return 'DefaultConstraintsRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DefaultConstraintsRequest');
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 1);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 2);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 3);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DefaultConstraintsResponse {
  static $_TSPEC;

  /**
   * @var \metastore\SQLDefaultConstraint[]
   */
  public $defaultConstraints = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'defaultConstraints',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SQLDefaultConstraint',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['defaultConstraints'])) {
        $this->defaultConstraints = $vals['defaultConstraints'];
      }
    }
  }

  public function getName() {
    return 'DefaultConstraintsResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->defaultConstraints = array();
            $_size311 = 0;
            $_etype314 = 0;
            $xfer += $input->readListBegin($_etype314, $_size311);
            for ($_i315 = 0; $_i315 < $_size311; ++$_i315)
            {
              $elem316 = null;
              $elem316 = new \metastore\SQLDefaultConstraint();
              $xfer += $elem316->read($input);
              $this->defaultConstraints []= $elem316;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DefaultConstraintsResponse');
    if ($this->defaultConstraints !== null) {
      if (!is_array($this->defaultConstraints)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('defaultConstraints', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->defaultConstraints));
        {
          foreach ($this->defaultConstraints as $iter317)
          {
            $xfer += $iter317->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CheckConstraintsRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $catName = null;
  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
    }
  }

  public function getName() {
    return 'CheckConstraintsRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CheckConstraintsRequest');
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 1);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 2);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 3);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CheckConstraintsResponse {
  static $_TSPEC;

  /**
   * @var \metastore\SQLCheckConstraint[]
   */
  public $checkConstraints = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'checkConstraints',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SQLCheckConstraint',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['checkConstraints'])) {
        $this->checkConstraints = $vals['checkConstraints'];
      }
    }
  }

  public function getName() {
    return 'CheckConstraintsResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->checkConstraints = array();
            $_size318 = 0;
            $_etype321 = 0;
            $xfer += $input->readListBegin($_etype321, $_size318);
            for ($_i322 = 0; $_i322 < $_size318; ++$_i322)
            {
              $elem323 = null;
              $elem323 = new \metastore\SQLCheckConstraint();
              $xfer += $elem323->read($input);
              $this->checkConstraints []= $elem323;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CheckConstraintsResponse');
    if ($this->checkConstraints !== null) {
      if (!is_array($this->checkConstraints)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('checkConstraints', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->checkConstraints));
        {
          foreach ($this->checkConstraints as $iter324)
          {
            $xfer += $iter324->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DropConstraintRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbname = null;
  /**
   * @var string
   */
  public $tablename = null;
  /**
   * @var string
   */
  public $constraintname = null;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tablename',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'constraintname',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['tablename'])) {
        $this->tablename = $vals['tablename'];
      }
      if (isset($vals['constraintname'])) {
        $this->constraintname = $vals['constraintname'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'DropConstraintRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tablename);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->constraintname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DropConstraintRequest');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tablename !== null) {
      $xfer += $output->writeFieldBegin('tablename', TType::STRING, 2);
      $xfer += $output->writeString($this->tablename);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->constraintname !== null) {
      $xfer += $output->writeFieldBegin('constraintname', TType::STRING, 3);
      $xfer += $output->writeString($this->constraintname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 4);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AddPrimaryKeyRequest {
  static $_TSPEC;

  /**
   * @var \metastore\SQLPrimaryKey[]
   */
  public $primaryKeyCols = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'primaryKeyCols',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SQLPrimaryKey',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['primaryKeyCols'])) {
        $this->primaryKeyCols = $vals['primaryKeyCols'];
      }
    }
  }

  public function getName() {
    return 'AddPrimaryKeyRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->primaryKeyCols = array();
            $_size325 = 0;
            $_etype328 = 0;
            $xfer += $input->readListBegin($_etype328, $_size325);
            for ($_i329 = 0; $_i329 < $_size325; ++$_i329)
            {
              $elem330 = null;
              $elem330 = new \metastore\SQLPrimaryKey();
              $xfer += $elem330->read($input);
              $this->primaryKeyCols []= $elem330;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AddPrimaryKeyRequest');
    if ($this->primaryKeyCols !== null) {
      if (!is_array($this->primaryKeyCols)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('primaryKeyCols', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->primaryKeyCols));
        {
          foreach ($this->primaryKeyCols as $iter331)
          {
            $xfer += $iter331->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AddForeignKeyRequest {
  static $_TSPEC;

  /**
   * @var \metastore\SQLForeignKey[]
   */
  public $foreignKeyCols = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'foreignKeyCols',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SQLForeignKey',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['foreignKeyCols'])) {
        $this->foreignKeyCols = $vals['foreignKeyCols'];
      }
    }
  }

  public function getName() {
    return 'AddForeignKeyRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->foreignKeyCols = array();
            $_size332 = 0;
            $_etype335 = 0;
            $xfer += $input->readListBegin($_etype335, $_size332);
            for ($_i336 = 0; $_i336 < $_size332; ++$_i336)
            {
              $elem337 = null;
              $elem337 = new \metastore\SQLForeignKey();
              $xfer += $elem337->read($input);
              $this->foreignKeyCols []= $elem337;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AddForeignKeyRequest');
    if ($this->foreignKeyCols !== null) {
      if (!is_array($this->foreignKeyCols)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('foreignKeyCols', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->foreignKeyCols));
        {
          foreach ($this->foreignKeyCols as $iter338)
          {
            $xfer += $iter338->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AddUniqueConstraintRequest {
  static $_TSPEC;

  /**
   * @var \metastore\SQLUniqueConstraint[]
   */
  public $uniqueConstraintCols = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'uniqueConstraintCols',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SQLUniqueConstraint',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['uniqueConstraintCols'])) {
        $this->uniqueConstraintCols = $vals['uniqueConstraintCols'];
      }
    }
  }

  public function getName() {
    return 'AddUniqueConstraintRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->uniqueConstraintCols = array();
            $_size339 = 0;
            $_etype342 = 0;
            $xfer += $input->readListBegin($_etype342, $_size339);
            for ($_i343 = 0; $_i343 < $_size339; ++$_i343)
            {
              $elem344 = null;
              $elem344 = new \metastore\SQLUniqueConstraint();
              $xfer += $elem344->read($input);
              $this->uniqueConstraintCols []= $elem344;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AddUniqueConstraintRequest');
    if ($this->uniqueConstraintCols !== null) {
      if (!is_array($this->uniqueConstraintCols)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('uniqueConstraintCols', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->uniqueConstraintCols));
        {
          foreach ($this->uniqueConstraintCols as $iter345)
          {
            $xfer += $iter345->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AddNotNullConstraintRequest {
  static $_TSPEC;

  /**
   * @var \metastore\SQLNotNullConstraint[]
   */
  public $notNullConstraintCols = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'notNullConstraintCols',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SQLNotNullConstraint',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['notNullConstraintCols'])) {
        $this->notNullConstraintCols = $vals['notNullConstraintCols'];
      }
    }
  }

  public function getName() {
    return 'AddNotNullConstraintRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->notNullConstraintCols = array();
            $_size346 = 0;
            $_etype349 = 0;
            $xfer += $input->readListBegin($_etype349, $_size346);
            for ($_i350 = 0; $_i350 < $_size346; ++$_i350)
            {
              $elem351 = null;
              $elem351 = new \metastore\SQLNotNullConstraint();
              $xfer += $elem351->read($input);
              $this->notNullConstraintCols []= $elem351;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AddNotNullConstraintRequest');
    if ($this->notNullConstraintCols !== null) {
      if (!is_array($this->notNullConstraintCols)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('notNullConstraintCols', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->notNullConstraintCols));
        {
          foreach ($this->notNullConstraintCols as $iter352)
          {
            $xfer += $iter352->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AddDefaultConstraintRequest {
  static $_TSPEC;

  /**
   * @var \metastore\SQLDefaultConstraint[]
   */
  public $defaultConstraintCols = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'defaultConstraintCols',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SQLDefaultConstraint',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['defaultConstraintCols'])) {
        $this->defaultConstraintCols = $vals['defaultConstraintCols'];
      }
    }
  }

  public function getName() {
    return 'AddDefaultConstraintRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->defaultConstraintCols = array();
            $_size353 = 0;
            $_etype356 = 0;
            $xfer += $input->readListBegin($_etype356, $_size353);
            for ($_i357 = 0; $_i357 < $_size353; ++$_i357)
            {
              $elem358 = null;
              $elem358 = new \metastore\SQLDefaultConstraint();
              $xfer += $elem358->read($input);
              $this->defaultConstraintCols []= $elem358;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AddDefaultConstraintRequest');
    if ($this->defaultConstraintCols !== null) {
      if (!is_array($this->defaultConstraintCols)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('defaultConstraintCols', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->defaultConstraintCols));
        {
          foreach ($this->defaultConstraintCols as $iter359)
          {
            $xfer += $iter359->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AddCheckConstraintRequest {
  static $_TSPEC;

  /**
   * @var \metastore\SQLCheckConstraint[]
   */
  public $checkConstraintCols = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'checkConstraintCols',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SQLCheckConstraint',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['checkConstraintCols'])) {
        $this->checkConstraintCols = $vals['checkConstraintCols'];
      }
    }
  }

  public function getName() {
    return 'AddCheckConstraintRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->checkConstraintCols = array();
            $_size360 = 0;
            $_etype363 = 0;
            $xfer += $input->readListBegin($_etype363, $_size360);
            for ($_i364 = 0; $_i364 < $_size360; ++$_i364)
            {
              $elem365 = null;
              $elem365 = new \metastore\SQLCheckConstraint();
              $xfer += $elem365->read($input);
              $this->checkConstraintCols []= $elem365;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AddCheckConstraintRequest');
    if ($this->checkConstraintCols !== null) {
      if (!is_array($this->checkConstraintCols)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('checkConstraintCols', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->checkConstraintCols));
        {
          foreach ($this->checkConstraintCols as $iter366)
          {
            $xfer += $iter366->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PartitionsByExprResult {
  static $_TSPEC;

  /**
   * @var \metastore\Partition[]
   */
  public $partitions = null;
  /**
   * @var bool
   */
  public $hasUnknownPartitions = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'partitions',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        2 => array(
          'var' => 'hasUnknownPartitions',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['partitions'])) {
        $this->partitions = $vals['partitions'];
      }
      if (isset($vals['hasUnknownPartitions'])) {
        $this->hasUnknownPartitions = $vals['hasUnknownPartitions'];
      }
    }
  }

  public function getName() {
    return 'PartitionsByExprResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->partitions = array();
            $_size367 = 0;
            $_etype370 = 0;
            $xfer += $input->readListBegin($_etype370, $_size367);
            for ($_i371 = 0; $_i371 < $_size367; ++$_i371)
            {
              $elem372 = null;
              $elem372 = new \metastore\Partition();
              $xfer += $elem372->read($input);
              $this->partitions []= $elem372;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->hasUnknownPartitions);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PartitionsByExprResult');
    if ($this->partitions !== null) {
      if (!is_array($this->partitions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partitions', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->partitions));
        {
          foreach ($this->partitions as $iter373)
          {
            $xfer += $iter373->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hasUnknownPartitions !== null) {
      $xfer += $output->writeFieldBegin('hasUnknownPartitions', TType::BOOL, 2);
      $xfer += $output->writeBool($this->hasUnknownPartitions);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PartitionsByExprRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $tblName = null;
  /**
   * @var string
   */
  public $expr = null;
  /**
   * @var string
   */
  public $defaultPartitionName = null;
  /**
   * @var int
   */
  public $maxParts = -1;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tblName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'expr',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'defaultPartitionName',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'maxParts',
          'type' => TType::I16,
          ),
        6 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tblName'])) {
        $this->tblName = $vals['tblName'];
      }
      if (isset($vals['expr'])) {
        $this->expr = $vals['expr'];
      }
      if (isset($vals['defaultPartitionName'])) {
        $this->defaultPartitionName = $vals['defaultPartitionName'];
      }
      if (isset($vals['maxParts'])) {
        $this->maxParts = $vals['maxParts'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'PartitionsByExprRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tblName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->expr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->defaultPartitionName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->maxParts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PartitionsByExprRequest');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tblName !== null) {
      $xfer += $output->writeFieldBegin('tblName', TType::STRING, 2);
      $xfer += $output->writeString($this->tblName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expr !== null) {
      $xfer += $output->writeFieldBegin('expr', TType::STRING, 3);
      $xfer += $output->writeString($this->expr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->defaultPartitionName !== null) {
      $xfer += $output->writeFieldBegin('defaultPartitionName', TType::STRING, 4);
      $xfer += $output->writeString($this->defaultPartitionName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxParts !== null) {
      $xfer += $output->writeFieldBegin('maxParts', TType::I16, 5);
      $xfer += $output->writeI16($this->maxParts);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 6);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TableStatsResult {
  static $_TSPEC;

  /**
   * @var \metastore\ColumnStatisticsObj[]
   */
  public $tableStats = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableStats',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\ColumnStatisticsObj',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableStats'])) {
        $this->tableStats = $vals['tableStats'];
      }
    }
  }

  public function getName() {
    return 'TableStatsResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->tableStats = array();
            $_size374 = 0;
            $_etype377 = 0;
            $xfer += $input->readListBegin($_etype377, $_size374);
            for ($_i378 = 0; $_i378 < $_size374; ++$_i378)
            {
              $elem379 = null;
              $elem379 = new \metastore\ColumnStatisticsObj();
              $xfer += $elem379->read($input);
              $this->tableStats []= $elem379;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TableStatsResult');
    if ($this->tableStats !== null) {
      if (!is_array($this->tableStats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tableStats', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->tableStats));
        {
          foreach ($this->tableStats as $iter380)
          {
            $xfer += $iter380->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PartitionsStatsResult {
  static $_TSPEC;

  /**
   * @var array
   */
  public $partStats = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'partStats',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::LST,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
              'type' => TType::STRUCT,
              'class' => '\metastore\ColumnStatisticsObj',
              ),
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['partStats'])) {
        $this->partStats = $vals['partStats'];
      }
    }
  }

  public function getName() {
    return 'PartitionsStatsResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->partStats = array();
            $_size381 = 0;
            $_ktype382 = 0;
            $_vtype383 = 0;
            $xfer += $input->readMapBegin($_ktype382, $_vtype383, $_size381);
            for ($_i385 = 0; $_i385 < $_size381; ++$_i385)
            {
              $key386 = '';
              $val387 = array();
              $xfer += $input->readString($key386);
              $val387 = array();
              $_size388 = 0;
              $_etype391 = 0;
              $xfer += $input->readListBegin($_etype391, $_size388);
              for ($_i392 = 0; $_i392 < $_size388; ++$_i392)
              {
                $elem393 = null;
                $elem393 = new \metastore\ColumnStatisticsObj();
                $xfer += $elem393->read($input);
                $val387 []= $elem393;
              }
              $xfer += $input->readListEnd();
              $this->partStats[$key386] = $val387;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PartitionsStatsResult');
    if ($this->partStats !== null) {
      if (!is_array($this->partStats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partStats', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::LST, count($this->partStats));
        {
          foreach ($this->partStats as $kiter394 => $viter395)
          {
            $xfer += $output->writeString($kiter394);
            {
              $output->writeListBegin(TType::STRUCT, count($viter395));
              {
                foreach ($viter395 as $iter396)
                {
                  $xfer += $iter396->write($output);
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TableStatsRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $tblName = null;
  /**
   * @var string[]
   */
  public $colNames = null;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tblName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'colNames',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tblName'])) {
        $this->tblName = $vals['tblName'];
      }
      if (isset($vals['colNames'])) {
        $this->colNames = $vals['colNames'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'TableStatsRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tblName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->colNames = array();
            $_size397 = 0;
            $_etype400 = 0;
            $xfer += $input->readListBegin($_etype400, $_size397);
            for ($_i401 = 0; $_i401 < $_size397; ++$_i401)
            {
              $elem402 = null;
              $xfer += $input->readString($elem402);
              $this->colNames []= $elem402;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TableStatsRequest');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tblName !== null) {
      $xfer += $output->writeFieldBegin('tblName', TType::STRING, 2);
      $xfer += $output->writeString($this->tblName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->colNames !== null) {
      if (!is_array($this->colNames)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('colNames', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->colNames));
        {
          foreach ($this->colNames as $iter403)
          {
            $xfer += $output->writeString($iter403);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 4);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PartitionsStatsRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $tblName = null;
  /**
   * @var string[]
   */
  public $colNames = null;
  /**
   * @var string[]
   */
  public $partNames = null;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tblName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'colNames',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'partNames',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tblName'])) {
        $this->tblName = $vals['tblName'];
      }
      if (isset($vals['colNames'])) {
        $this->colNames = $vals['colNames'];
      }
      if (isset($vals['partNames'])) {
        $this->partNames = $vals['partNames'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'PartitionsStatsRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tblName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->colNames = array();
            $_size404 = 0;
            $_etype407 = 0;
            $xfer += $input->readListBegin($_etype407, $_size404);
            for ($_i408 = 0; $_i408 < $_size404; ++$_i408)
            {
              $elem409 = null;
              $xfer += $input->readString($elem409);
              $this->colNames []= $elem409;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->partNames = array();
            $_size410 = 0;
            $_etype413 = 0;
            $xfer += $input->readListBegin($_etype413, $_size410);
            for ($_i414 = 0; $_i414 < $_size410; ++$_i414)
            {
              $elem415 = null;
              $xfer += $input->readString($elem415);
              $this->partNames []= $elem415;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PartitionsStatsRequest');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tblName !== null) {
      $xfer += $output->writeFieldBegin('tblName', TType::STRING, 2);
      $xfer += $output->writeString($this->tblName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->colNames !== null) {
      if (!is_array($this->colNames)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('colNames', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->colNames));
        {
          foreach ($this->colNames as $iter416)
          {
            $xfer += $output->writeString($iter416);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partNames !== null) {
      if (!is_array($this->partNames)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partNames', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRING, count($this->partNames));
        {
          foreach ($this->partNames as $iter417)
          {
            $xfer += $output->writeString($iter417);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 5);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AddPartitionsResult {
  static $_TSPEC;

  /**
   * @var \metastore\Partition[]
   */
  public $partitions = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'partitions',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['partitions'])) {
        $this->partitions = $vals['partitions'];
      }
    }
  }

  public function getName() {
    return 'AddPartitionsResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->partitions = array();
            $_size418 = 0;
            $_etype421 = 0;
            $xfer += $input->readListBegin($_etype421, $_size418);
            for ($_i422 = 0; $_i422 < $_size418; ++$_i422)
            {
              $elem423 = null;
              $elem423 = new \metastore\Partition();
              $xfer += $elem423->read($input);
              $this->partitions []= $elem423;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AddPartitionsResult');
    if ($this->partitions !== null) {
      if (!is_array($this->partitions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partitions', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->partitions));
        {
          foreach ($this->partitions as $iter424)
          {
            $xfer += $iter424->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AddPartitionsRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $tblName = null;
  /**
   * @var \metastore\Partition[]
   */
  public $parts = null;
  /**
   * @var bool
   */
  public $ifNotExists = null;
  /**
   * @var bool
   */
  public $needResult = true;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tblName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'parts',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        4 => array(
          'var' => 'ifNotExists',
          'type' => TType::BOOL,
          ),
        5 => array(
          'var' => 'needResult',
          'type' => TType::BOOL,
          ),
        6 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tblName'])) {
        $this->tblName = $vals['tblName'];
      }
      if (isset($vals['parts'])) {
        $this->parts = $vals['parts'];
      }
      if (isset($vals['ifNotExists'])) {
        $this->ifNotExists = $vals['ifNotExists'];
      }
      if (isset($vals['needResult'])) {
        $this->needResult = $vals['needResult'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'AddPartitionsRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tblName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->parts = array();
            $_size425 = 0;
            $_etype428 = 0;
            $xfer += $input->readListBegin($_etype428, $_size425);
            for ($_i429 = 0; $_i429 < $_size425; ++$_i429)
            {
              $elem430 = null;
              $elem430 = new \metastore\Partition();
              $xfer += $elem430->read($input);
              $this->parts []= $elem430;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->ifNotExists);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->needResult);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AddPartitionsRequest');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tblName !== null) {
      $xfer += $output->writeFieldBegin('tblName', TType::STRING, 2);
      $xfer += $output->writeString($this->tblName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parts !== null) {
      if (!is_array($this->parts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('parts', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->parts));
        {
          foreach ($this->parts as $iter431)
          {
            $xfer += $iter431->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ifNotExists !== null) {
      $xfer += $output->writeFieldBegin('ifNotExists', TType::BOOL, 4);
      $xfer += $output->writeBool($this->ifNotExists);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->needResult !== null) {
      $xfer += $output->writeFieldBegin('needResult', TType::BOOL, 5);
      $xfer += $output->writeBool($this->needResult);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 6);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DropPartitionsResult {
  static $_TSPEC;

  /**
   * @var \metastore\Partition[]
   */
  public $partitions = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'partitions',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['partitions'])) {
        $this->partitions = $vals['partitions'];
      }
    }
  }

  public function getName() {
    return 'DropPartitionsResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->partitions = array();
            $_size432 = 0;
            $_etype435 = 0;
            $xfer += $input->readListBegin($_etype435, $_size432);
            for ($_i436 = 0; $_i436 < $_size432; ++$_i436)
            {
              $elem437 = null;
              $elem437 = new \metastore\Partition();
              $xfer += $elem437->read($input);
              $this->partitions []= $elem437;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DropPartitionsResult');
    if ($this->partitions !== null) {
      if (!is_array($this->partitions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partitions', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->partitions));
        {
          foreach ($this->partitions as $iter438)
          {
            $xfer += $iter438->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DropPartitionsExpr {
  static $_TSPEC;

  /**
   * @var string
   */
  public $expr = null;
  /**
   * @var int
   */
  public $partArchiveLevel = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'expr',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'partArchiveLevel',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['expr'])) {
        $this->expr = $vals['expr'];
      }
      if (isset($vals['partArchiveLevel'])) {
        $this->partArchiveLevel = $vals['partArchiveLevel'];
      }
    }
  }

  public function getName() {
    return 'DropPartitionsExpr';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->expr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->partArchiveLevel);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DropPartitionsExpr');
    if ($this->expr !== null) {
      $xfer += $output->writeFieldBegin('expr', TType::STRING, 1);
      $xfer += $output->writeString($this->expr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partArchiveLevel !== null) {
      $xfer += $output->writeFieldBegin('partArchiveLevel', TType::I32, 2);
      $xfer += $output->writeI32($this->partArchiveLevel);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class RequestPartsSpec {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $names = null;
  /**
   * @var \metastore\DropPartitionsExpr[]
   */
  public $exprs = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'names',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'exprs',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\DropPartitionsExpr',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['names'])) {
        $this->names = $vals['names'];
      }
      if (isset($vals['exprs'])) {
        $this->exprs = $vals['exprs'];
      }
    }
  }

  public function getName() {
    return 'RequestPartsSpec';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->names = array();
            $_size439 = 0;
            $_etype442 = 0;
            $xfer += $input->readListBegin($_etype442, $_size439);
            for ($_i443 = 0; $_i443 < $_size439; ++$_i443)
            {
              $elem444 = null;
              $xfer += $input->readString($elem444);
              $this->names []= $elem444;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->exprs = array();
            $_size445 = 0;
            $_etype448 = 0;
            $xfer += $input->readListBegin($_etype448, $_size445);
            for ($_i449 = 0; $_i449 < $_size445; ++$_i449)
            {
              $elem450 = null;
              $elem450 = new \metastore\DropPartitionsExpr();
              $xfer += $elem450->read($input);
              $this->exprs []= $elem450;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('RequestPartsSpec');
    if ($this->names !== null) {
      if (!is_array($this->names)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('names', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->names));
        {
          foreach ($this->names as $iter451)
          {
            $xfer += $output->writeString($iter451);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->exprs !== null) {
      if (!is_array($this->exprs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('exprs', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->exprs));
        {
          foreach ($this->exprs as $iter452)
          {
            $xfer += $iter452->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DropPartitionsRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $tblName = null;
  /**
   * @var \metastore\RequestPartsSpec
   */
  public $parts = null;
  /**
   * @var bool
   */
  public $deleteData = null;
  /**
   * @var bool
   */
  public $ifExists = true;
  /**
   * @var bool
   */
  public $ignoreProtection = null;
  /**
   * @var \metastore\EnvironmentContext
   */
  public $environmentContext = null;
  /**
   * @var bool
   */
  public $needResult = true;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tblName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'parts',
          'type' => TType::STRUCT,
          'class' => '\metastore\RequestPartsSpec',
          ),
        4 => array(
          'var' => 'deleteData',
          'type' => TType::BOOL,
          ),
        5 => array(
          'var' => 'ifExists',
          'type' => TType::BOOL,
          ),
        6 => array(
          'var' => 'ignoreProtection',
          'type' => TType::BOOL,
          ),
        7 => array(
          'var' => 'environmentContext',
          'type' => TType::STRUCT,
          'class' => '\metastore\EnvironmentContext',
          ),
        8 => array(
          'var' => 'needResult',
          'type' => TType::BOOL,
          ),
        9 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tblName'])) {
        $this->tblName = $vals['tblName'];
      }
      if (isset($vals['parts'])) {
        $this->parts = $vals['parts'];
      }
      if (isset($vals['deleteData'])) {
        $this->deleteData = $vals['deleteData'];
      }
      if (isset($vals['ifExists'])) {
        $this->ifExists = $vals['ifExists'];
      }
      if (isset($vals['ignoreProtection'])) {
        $this->ignoreProtection = $vals['ignoreProtection'];
      }
      if (isset($vals['environmentContext'])) {
        $this->environmentContext = $vals['environmentContext'];
      }
      if (isset($vals['needResult'])) {
        $this->needResult = $vals['needResult'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'DropPartitionsRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tblName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->parts = new \metastore\RequestPartsSpec();
            $xfer += $this->parts->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->deleteData);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->ifExists);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->ignoreProtection);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->environmentContext = new \metastore\EnvironmentContext();
            $xfer += $this->environmentContext->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->needResult);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DropPartitionsRequest');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tblName !== null) {
      $xfer += $output->writeFieldBegin('tblName', TType::STRING, 2);
      $xfer += $output->writeString($this->tblName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parts !== null) {
      if (!is_object($this->parts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('parts', TType::STRUCT, 3);
      $xfer += $this->parts->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteData !== null) {
      $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 4);
      $xfer += $output->writeBool($this->deleteData);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ifExists !== null) {
      $xfer += $output->writeFieldBegin('ifExists', TType::BOOL, 5);
      $xfer += $output->writeBool($this->ifExists);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ignoreProtection !== null) {
      $xfer += $output->writeFieldBegin('ignoreProtection', TType::BOOL, 6);
      $xfer += $output->writeBool($this->ignoreProtection);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->environmentContext !== null) {
      if (!is_object($this->environmentContext)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('environmentContext', TType::STRUCT, 7);
      $xfer += $this->environmentContext->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->needResult !== null) {
      $xfer += $output->writeFieldBegin('needResult', TType::BOOL, 8);
      $xfer += $output->writeBool($this->needResult);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 9);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PartitionValuesRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $tblName = null;
  /**
   * @var \metastore\FieldSchema[]
   */
  public $partitionKeys = null;
  /**
   * @var bool
   */
  public $applyDistinct = true;
  /**
   * @var string
   */
  public $filter = null;
  /**
   * @var \metastore\FieldSchema[]
   */
  public $partitionOrder = null;
  /**
   * @var bool
   */
  public $ascending = true;
  /**
   * @var int
   */
  public $maxParts = -1;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tblName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'partitionKeys',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\FieldSchema',
            ),
          ),
        4 => array(
          'var' => 'applyDistinct',
          'type' => TType::BOOL,
          ),
        5 => array(
          'var' => 'filter',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'partitionOrder',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\FieldSchema',
            ),
          ),
        7 => array(
          'var' => 'ascending',
          'type' => TType::BOOL,
          ),
        8 => array(
          'var' => 'maxParts',
          'type' => TType::I64,
          ),
        9 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tblName'])) {
        $this->tblName = $vals['tblName'];
      }
      if (isset($vals['partitionKeys'])) {
        $this->partitionKeys = $vals['partitionKeys'];
      }
      if (isset($vals['applyDistinct'])) {
        $this->applyDistinct = $vals['applyDistinct'];
      }
      if (isset($vals['filter'])) {
        $this->filter = $vals['filter'];
      }
      if (isset($vals['partitionOrder'])) {
        $this->partitionOrder = $vals['partitionOrder'];
      }
      if (isset($vals['ascending'])) {
        $this->ascending = $vals['ascending'];
      }
      if (isset($vals['maxParts'])) {
        $this->maxParts = $vals['maxParts'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'PartitionValuesRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tblName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->partitionKeys = array();
            $_size453 = 0;
            $_etype456 = 0;
            $xfer += $input->readListBegin($_etype456, $_size453);
            for ($_i457 = 0; $_i457 < $_size453; ++$_i457)
            {
              $elem458 = null;
              $elem458 = new \metastore\FieldSchema();
              $xfer += $elem458->read($input);
              $this->partitionKeys []= $elem458;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->applyDistinct);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->filter);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::LST) {
            $this->partitionOrder = array();
            $_size459 = 0;
            $_etype462 = 0;
            $xfer += $input->readListBegin($_etype462, $_size459);
            for ($_i463 = 0; $_i463 < $_size459; ++$_i463)
            {
              $elem464 = null;
              $elem464 = new \metastore\FieldSchema();
              $xfer += $elem464->read($input);
              $this->partitionOrder []= $elem464;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->ascending);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->maxParts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PartitionValuesRequest');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tblName !== null) {
      $xfer += $output->writeFieldBegin('tblName', TType::STRING, 2);
      $xfer += $output->writeString($this->tblName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partitionKeys !== null) {
      if (!is_array($this->partitionKeys)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partitionKeys', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->partitionKeys));
        {
          foreach ($this->partitionKeys as $iter465)
          {
            $xfer += $iter465->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->applyDistinct !== null) {
      $xfer += $output->writeFieldBegin('applyDistinct', TType::BOOL, 4);
      $xfer += $output->writeBool($this->applyDistinct);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filter !== null) {
      $xfer += $output->writeFieldBegin('filter', TType::STRING, 5);
      $xfer += $output->writeString($this->filter);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partitionOrder !== null) {
      if (!is_array($this->partitionOrder)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partitionOrder', TType::LST, 6);
      {
        $output->writeListBegin(TType::STRUCT, count($this->partitionOrder));
        {
          foreach ($this->partitionOrder as $iter466)
          {
            $xfer += $iter466->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ascending !== null) {
      $xfer += $output->writeFieldBegin('ascending', TType::BOOL, 7);
      $xfer += $output->writeBool($this->ascending);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxParts !== null) {
      $xfer += $output->writeFieldBegin('maxParts', TType::I64, 8);
      $xfer += $output->writeI64($this->maxParts);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 9);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PartitionValuesRow {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $row = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'row',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
    }
  }

  public function getName() {
    return 'PartitionValuesRow';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->row = array();
            $_size467 = 0;
            $_etype470 = 0;
            $xfer += $input->readListBegin($_etype470, $_size467);
            for ($_i471 = 0; $_i471 < $_size467; ++$_i471)
            {
              $elem472 = null;
              $xfer += $input->readString($elem472);
              $this->row []= $elem472;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PartitionValuesRow');
    if ($this->row !== null) {
      if (!is_array($this->row)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('row', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->row));
        {
          foreach ($this->row as $iter473)
          {
            $xfer += $output->writeString($iter473);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PartitionValuesResponse {
  static $_TSPEC;

  /**
   * @var \metastore\PartitionValuesRow[]
   */
  public $partitionValues = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'partitionValues',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\PartitionValuesRow',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['partitionValues'])) {
        $this->partitionValues = $vals['partitionValues'];
      }
    }
  }

  public function getName() {
    return 'PartitionValuesResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->partitionValues = array();
            $_size474 = 0;
            $_etype477 = 0;
            $xfer += $input->readListBegin($_etype477, $_size474);
            for ($_i478 = 0; $_i478 < $_size474; ++$_i478)
            {
              $elem479 = null;
              $elem479 = new \metastore\PartitionValuesRow();
              $xfer += $elem479->read($input);
              $this->partitionValues []= $elem479;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PartitionValuesResponse');
    if ($this->partitionValues !== null) {
      if (!is_array($this->partitionValues)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partitionValues', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->partitionValues));
        {
          foreach ($this->partitionValues as $iter480)
          {
            $xfer += $iter480->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ResourceUri {
  static $_TSPEC;

  /**
   * @var int
   */
  public $resourceType = null;
  /**
   * @var string
   */
  public $uri = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'resourceType',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'uri',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['resourceType'])) {
        $this->resourceType = $vals['resourceType'];
      }
      if (isset($vals['uri'])) {
        $this->uri = $vals['uri'];
      }
    }
  }

  public function getName() {
    return 'ResourceUri';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->resourceType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->uri);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ResourceUri');
    if ($this->resourceType !== null) {
      $xfer += $output->writeFieldBegin('resourceType', TType::I32, 1);
      $xfer += $output->writeI32($this->resourceType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->uri !== null) {
      $xfer += $output->writeFieldBegin('uri', TType::STRING, 2);
      $xfer += $output->writeString($this->uri);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Function {
  static $_TSPEC;

  /**
   * @var string
   */
  public $functionName = null;
  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $className = null;
  /**
   * @var string
   */
  public $ownerName = null;
  /**
   * @var int
   */
  public $ownerType = null;
  /**
   * @var int
   */
  public $createTime = null;
  /**
   * @var int
   */
  public $functionType = null;
  /**
   * @var \metastore\ResourceUri[]
   */
  public $resourceUris = null;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'functionName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'className',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'ownerName',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'ownerType',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'createTime',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'functionType',
          'type' => TType::I32,
          ),
        8 => array(
          'var' => 'resourceUris',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\ResourceUri',
            ),
          ),
        9 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['functionName'])) {
        $this->functionName = $vals['functionName'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['className'])) {
        $this->className = $vals['className'];
      }
      if (isset($vals['ownerName'])) {
        $this->ownerName = $vals['ownerName'];
      }
      if (isset($vals['ownerType'])) {
        $this->ownerType = $vals['ownerType'];
      }
      if (isset($vals['createTime'])) {
        $this->createTime = $vals['createTime'];
      }
      if (isset($vals['functionType'])) {
        $this->functionType = $vals['functionType'];
      }
      if (isset($vals['resourceUris'])) {
        $this->resourceUris = $vals['resourceUris'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'Function';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->functionName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->className);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->ownerName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->ownerType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->createTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->functionType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::LST) {
            $this->resourceUris = array();
            $_size481 = 0;
            $_etype484 = 0;
            $xfer += $input->readListBegin($_etype484, $_size481);
            for ($_i485 = 0; $_i485 < $_size481; ++$_i485)
            {
              $elem486 = null;
              $elem486 = new \metastore\ResourceUri();
              $xfer += $elem486->read($input);
              $this->resourceUris []= $elem486;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Function');
    if ($this->functionName !== null) {
      $xfer += $output->writeFieldBegin('functionName', TType::STRING, 1);
      $xfer += $output->writeString($this->functionName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->className !== null) {
      $xfer += $output->writeFieldBegin('className', TType::STRING, 3);
      $xfer += $output->writeString($this->className);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ownerName !== null) {
      $xfer += $output->writeFieldBegin('ownerName', TType::STRING, 4);
      $xfer += $output->writeString($this->ownerName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ownerType !== null) {
      $xfer += $output->writeFieldBegin('ownerType', TType::I32, 5);
      $xfer += $output->writeI32($this->ownerType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->createTime !== null) {
      $xfer += $output->writeFieldBegin('createTime', TType::I32, 6);
      $xfer += $output->writeI32($this->createTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->functionType !== null) {
      $xfer += $output->writeFieldBegin('functionType', TType::I32, 7);
      $xfer += $output->writeI32($this->functionType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->resourceUris !== null) {
      if (!is_array($this->resourceUris)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('resourceUris', TType::LST, 8);
      {
        $output->writeListBegin(TType::STRUCT, count($this->resourceUris));
        {
          foreach ($this->resourceUris as $iter487)
          {
            $xfer += $iter487->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 9);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TxnInfo {
  static $_TSPEC;

  /**
   * @var int
   */
  public $id = null;
  /**
   * @var int
   */
  public $state = null;
  /**
   * @var string
   */
  public $user = null;
  /**
   * @var string
   */
  public $hostname = null;
  /**
   * @var string
   */
  public $agentInfo = "Unknown";
  /**
   * @var int
   */
  public $heartbeatCount = 0;
  /**
   * @var string
   */
  public $metaInfo = null;
  /**
   * @var int
   */
  public $startedTime = null;
  /**
   * @var int
   */
  public $lastHeartbeatTime = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'state',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'user',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'hostname',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'agentInfo',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'heartbeatCount',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'metaInfo',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'startedTime',
          'type' => TType::I64,
          ),
        9 => array(
          'var' => 'lastHeartbeatTime',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['state'])) {
        $this->state = $vals['state'];
      }
      if (isset($vals['user'])) {
        $this->user = $vals['user'];
      }
      if (isset($vals['hostname'])) {
        $this->hostname = $vals['hostname'];
      }
      if (isset($vals['agentInfo'])) {
        $this->agentInfo = $vals['agentInfo'];
      }
      if (isset($vals['heartbeatCount'])) {
        $this->heartbeatCount = $vals['heartbeatCount'];
      }
      if (isset($vals['metaInfo'])) {
        $this->metaInfo = $vals['metaInfo'];
      }
      if (isset($vals['startedTime'])) {
        $this->startedTime = $vals['startedTime'];
      }
      if (isset($vals['lastHeartbeatTime'])) {
        $this->lastHeartbeatTime = $vals['lastHeartbeatTime'];
      }
    }
  }

  public function getName() {
    return 'TxnInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->state);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->user);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->hostname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->agentInfo);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->heartbeatCount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->metaInfo);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->startedTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->lastHeartbeatTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TxnInfo');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::I64, 1);
      $xfer += $output->writeI64($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->state !== null) {
      $xfer += $output->writeFieldBegin('state', TType::I32, 2);
      $xfer += $output->writeI32($this->state);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->user !== null) {
      $xfer += $output->writeFieldBegin('user', TType::STRING, 3);
      $xfer += $output->writeString($this->user);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hostname !== null) {
      $xfer += $output->writeFieldBegin('hostname', TType::STRING, 4);
      $xfer += $output->writeString($this->hostname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->agentInfo !== null) {
      $xfer += $output->writeFieldBegin('agentInfo', TType::STRING, 5);
      $xfer += $output->writeString($this->agentInfo);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->heartbeatCount !== null) {
      $xfer += $output->writeFieldBegin('heartbeatCount', TType::I32, 6);
      $xfer += $output->writeI32($this->heartbeatCount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->metaInfo !== null) {
      $xfer += $output->writeFieldBegin('metaInfo', TType::STRING, 7);
      $xfer += $output->writeString($this->metaInfo);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startedTime !== null) {
      $xfer += $output->writeFieldBegin('startedTime', TType::I64, 8);
      $xfer += $output->writeI64($this->startedTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->lastHeartbeatTime !== null) {
      $xfer += $output->writeFieldBegin('lastHeartbeatTime', TType::I64, 9);
      $xfer += $output->writeI64($this->lastHeartbeatTime);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetOpenTxnsInfoResponse {
  static $_TSPEC;

  /**
   * @var int
   */
  public $txn_high_water_mark = null;
  /**
   * @var \metastore\TxnInfo[]
   */
  public $open_txns = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'txn_high_water_mark',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'open_txns',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\TxnInfo',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['txn_high_water_mark'])) {
        $this->txn_high_water_mark = $vals['txn_high_water_mark'];
      }
      if (isset($vals['open_txns'])) {
        $this->open_txns = $vals['open_txns'];
      }
    }
  }

  public function getName() {
    return 'GetOpenTxnsInfoResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->txn_high_water_mark);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->open_txns = array();
            $_size488 = 0;
            $_etype491 = 0;
            $xfer += $input->readListBegin($_etype491, $_size488);
            for ($_i492 = 0; $_i492 < $_size488; ++$_i492)
            {
              $elem493 = null;
              $elem493 = new \metastore\TxnInfo();
              $xfer += $elem493->read($input);
              $this->open_txns []= $elem493;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetOpenTxnsInfoResponse');
    if ($this->txn_high_water_mark !== null) {
      $xfer += $output->writeFieldBegin('txn_high_water_mark', TType::I64, 1);
      $xfer += $output->writeI64($this->txn_high_water_mark);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->open_txns !== null) {
      if (!is_array($this->open_txns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('open_txns', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->open_txns));
        {
          foreach ($this->open_txns as $iter494)
          {
            $xfer += $iter494->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetOpenTxnsResponse {
  static $_TSPEC;

  /**
   * @var int
   */
  public $txn_high_water_mark = null;
  /**
   * @var int[]
   */
  public $open_txns = null;
  /**
   * @var int
   */
  public $min_open_txn = null;
  /**
   * @var string
   */
  public $abortedBits = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'txn_high_water_mark',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'open_txns',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        3 => array(
          'var' => 'min_open_txn',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'abortedBits',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['txn_high_water_mark'])) {
        $this->txn_high_water_mark = $vals['txn_high_water_mark'];
      }
      if (isset($vals['open_txns'])) {
        $this->open_txns = $vals['open_txns'];
      }
      if (isset($vals['min_open_txn'])) {
        $this->min_open_txn = $vals['min_open_txn'];
      }
      if (isset($vals['abortedBits'])) {
        $this->abortedBits = $vals['abortedBits'];
      }
    }
  }

  public function getName() {
    return 'GetOpenTxnsResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->txn_high_water_mark);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->open_txns = array();
            $_size495 = 0;
            $_etype498 = 0;
            $xfer += $input->readListBegin($_etype498, $_size495);
            for ($_i499 = 0; $_i499 < $_size495; ++$_i499)
            {
              $elem500 = null;
              $xfer += $input->readI64($elem500);
              $this->open_txns []= $elem500;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->min_open_txn);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->abortedBits);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetOpenTxnsResponse');
    if ($this->txn_high_water_mark !== null) {
      $xfer += $output->writeFieldBegin('txn_high_water_mark', TType::I64, 1);
      $xfer += $output->writeI64($this->txn_high_water_mark);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->open_txns !== null) {
      if (!is_array($this->open_txns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('open_txns', TType::LST, 2);
      {
        $output->writeListBegin(TType::I64, count($this->open_txns));
        {
          foreach ($this->open_txns as $iter501)
          {
            $xfer += $output->writeI64($iter501);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->min_open_txn !== null) {
      $xfer += $output->writeFieldBegin('min_open_txn', TType::I64, 3);
      $xfer += $output->writeI64($this->min_open_txn);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->abortedBits !== null) {
      $xfer += $output->writeFieldBegin('abortedBits', TType::STRING, 4);
      $xfer += $output->writeString($this->abortedBits);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OpenTxnRequest {
  static $_TSPEC;

  /**
   * @var int
   */
  public $num_txns = null;
  /**
   * @var string
   */
  public $user = null;
  /**
   * @var string
   */
  public $hostname = null;
  /**
   * @var string
   */
  public $agentInfo = "Unknown";
  /**
   * @var string
   */
  public $replPolicy = null;
  /**
   * @var int[]
   */
  public $replSrcTxnIds = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'num_txns',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'user',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'hostname',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'agentInfo',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'replPolicy',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'replSrcTxnIds',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['num_txns'])) {
        $this->num_txns = $vals['num_txns'];
      }
      if (isset($vals['user'])) {
        $this->user = $vals['user'];
      }
      if (isset($vals['hostname'])) {
        $this->hostname = $vals['hostname'];
      }
      if (isset($vals['agentInfo'])) {
        $this->agentInfo = $vals['agentInfo'];
      }
      if (isset($vals['replPolicy'])) {
        $this->replPolicy = $vals['replPolicy'];
      }
      if (isset($vals['replSrcTxnIds'])) {
        $this->replSrcTxnIds = $vals['replSrcTxnIds'];
      }
    }
  }

  public function getName() {
    return 'OpenTxnRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->num_txns);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->user);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->hostname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->agentInfo);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->replPolicy);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::LST) {
            $this->replSrcTxnIds = array();
            $_size502 = 0;
            $_etype505 = 0;
            $xfer += $input->readListBegin($_etype505, $_size502);
            for ($_i506 = 0; $_i506 < $_size502; ++$_i506)
            {
              $elem507 = null;
              $xfer += $input->readI64($elem507);
              $this->replSrcTxnIds []= $elem507;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OpenTxnRequest');
    if ($this->num_txns !== null) {
      $xfer += $output->writeFieldBegin('num_txns', TType::I32, 1);
      $xfer += $output->writeI32($this->num_txns);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->user !== null) {
      $xfer += $output->writeFieldBegin('user', TType::STRING, 2);
      $xfer += $output->writeString($this->user);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hostname !== null) {
      $xfer += $output->writeFieldBegin('hostname', TType::STRING, 3);
      $xfer += $output->writeString($this->hostname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->agentInfo !== null) {
      $xfer += $output->writeFieldBegin('agentInfo', TType::STRING, 4);
      $xfer += $output->writeString($this->agentInfo);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->replPolicy !== null) {
      $xfer += $output->writeFieldBegin('replPolicy', TType::STRING, 5);
      $xfer += $output->writeString($this->replPolicy);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->replSrcTxnIds !== null) {
      if (!is_array($this->replSrcTxnIds)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('replSrcTxnIds', TType::LST, 6);
      {
        $output->writeListBegin(TType::I64, count($this->replSrcTxnIds));
        {
          foreach ($this->replSrcTxnIds as $iter508)
          {
            $xfer += $output->writeI64($iter508);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OpenTxnsResponse {
  static $_TSPEC;

  /**
   * @var int[]
   */
  public $txn_ids = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'txn_ids',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['txn_ids'])) {
        $this->txn_ids = $vals['txn_ids'];
      }
    }
  }

  public function getName() {
    return 'OpenTxnsResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->txn_ids = array();
            $_size509 = 0;
            $_etype512 = 0;
            $xfer += $input->readListBegin($_etype512, $_size509);
            for ($_i513 = 0; $_i513 < $_size509; ++$_i513)
            {
              $elem514 = null;
              $xfer += $input->readI64($elem514);
              $this->txn_ids []= $elem514;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OpenTxnsResponse');
    if ($this->txn_ids !== null) {
      if (!is_array($this->txn_ids)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('txn_ids', TType::LST, 1);
      {
        $output->writeListBegin(TType::I64, count($this->txn_ids));
        {
          foreach ($this->txn_ids as $iter515)
          {
            $xfer += $output->writeI64($iter515);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AbortTxnRequest {
  static $_TSPEC;

  /**
   * @var int
   */
  public $txnid = null;
  /**
   * @var string
   */
  public $replPolicy = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'txnid',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'replPolicy',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['txnid'])) {
        $this->txnid = $vals['txnid'];
      }
      if (isset($vals['replPolicy'])) {
        $this->replPolicy = $vals['replPolicy'];
      }
    }
  }

  public function getName() {
    return 'AbortTxnRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->txnid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->replPolicy);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AbortTxnRequest');
    if ($this->txnid !== null) {
      $xfer += $output->writeFieldBegin('txnid', TType::I64, 1);
      $xfer += $output->writeI64($this->txnid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->replPolicy !== null) {
      $xfer += $output->writeFieldBegin('replPolicy', TType::STRING, 2);
      $xfer += $output->writeString($this->replPolicy);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AbortTxnsRequest {
  static $_TSPEC;

  /**
   * @var int[]
   */
  public $txn_ids = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'txn_ids',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['txn_ids'])) {
        $this->txn_ids = $vals['txn_ids'];
      }
    }
  }

  public function getName() {
    return 'AbortTxnsRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->txn_ids = array();
            $_size516 = 0;
            $_etype519 = 0;
            $xfer += $input->readListBegin($_etype519, $_size516);
            for ($_i520 = 0; $_i520 < $_size516; ++$_i520)
            {
              $elem521 = null;
              $xfer += $input->readI64($elem521);
              $this->txn_ids []= $elem521;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AbortTxnsRequest');
    if ($this->txn_ids !== null) {
      if (!is_array($this->txn_ids)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('txn_ids', TType::LST, 1);
      {
        $output->writeListBegin(TType::I64, count($this->txn_ids));
        {
          foreach ($this->txn_ids as $iter522)
          {
            $xfer += $output->writeI64($iter522);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CommitTxnRequest {
  static $_TSPEC;

  /**
   * @var int
   */
  public $txnid = null;
  /**
   * @var string
   */
  public $replPolicy = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'txnid',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'replPolicy',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['txnid'])) {
        $this->txnid = $vals['txnid'];
      }
      if (isset($vals['replPolicy'])) {
        $this->replPolicy = $vals['replPolicy'];
      }
    }
  }

  public function getName() {
    return 'CommitTxnRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->txnid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->replPolicy);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CommitTxnRequest');
    if ($this->txnid !== null) {
      $xfer += $output->writeFieldBegin('txnid', TType::I64, 1);
      $xfer += $output->writeI64($this->txnid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->replPolicy !== null) {
      $xfer += $output->writeFieldBegin('replPolicy', TType::STRING, 2);
      $xfer += $output->writeString($this->replPolicy);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetValidWriteIdsRequest {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $fullTableNames = null;
  /**
   * @var string
   */
  public $validTxnList = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'fullTableNames',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'validTxnList',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['fullTableNames'])) {
        $this->fullTableNames = $vals['fullTableNames'];
      }
      if (isset($vals['validTxnList'])) {
        $this->validTxnList = $vals['validTxnList'];
      }
    }
  }

  public function getName() {
    return 'GetValidWriteIdsRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->fullTableNames = array();
            $_size523 = 0;
            $_etype526 = 0;
            $xfer += $input->readListBegin($_etype526, $_size523);
            for ($_i527 = 0; $_i527 < $_size523; ++$_i527)
            {
              $elem528 = null;
              $xfer += $input->readString($elem528);
              $this->fullTableNames []= $elem528;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->validTxnList);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetValidWriteIdsRequest');
    if ($this->fullTableNames !== null) {
      if (!is_array($this->fullTableNames)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('fullTableNames', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->fullTableNames));
        {
          foreach ($this->fullTableNames as $iter529)
          {
            $xfer += $output->writeString($iter529);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->validTxnList !== null) {
      $xfer += $output->writeFieldBegin('validTxnList', TType::STRING, 2);
      $xfer += $output->writeString($this->validTxnList);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TableValidWriteIds {
  static $_TSPEC;

  /**
   * @var string
   */
  public $fullTableName = null;
  /**
   * @var int
   */
  public $writeIdHighWaterMark = null;
  /**
   * @var int[]
   */
  public $invalidWriteIds = null;
  /**
   * @var int
   */
  public $minOpenWriteId = null;
  /**
   * @var string
   */
  public $abortedBits = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'fullTableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'writeIdHighWaterMark',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'invalidWriteIds',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        4 => array(
          'var' => 'minOpenWriteId',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'abortedBits',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['fullTableName'])) {
        $this->fullTableName = $vals['fullTableName'];
      }
      if (isset($vals['writeIdHighWaterMark'])) {
        $this->writeIdHighWaterMark = $vals['writeIdHighWaterMark'];
      }
      if (isset($vals['invalidWriteIds'])) {
        $this->invalidWriteIds = $vals['invalidWriteIds'];
      }
      if (isset($vals['minOpenWriteId'])) {
        $this->minOpenWriteId = $vals['minOpenWriteId'];
      }
      if (isset($vals['abortedBits'])) {
        $this->abortedBits = $vals['abortedBits'];
      }
    }
  }

  public function getName() {
    return 'TableValidWriteIds';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->fullTableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->writeIdHighWaterMark);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->invalidWriteIds = array();
            $_size530 = 0;
            $_etype533 = 0;
            $xfer += $input->readListBegin($_etype533, $_size530);
            for ($_i534 = 0; $_i534 < $_size530; ++$_i534)
            {
              $elem535 = null;
              $xfer += $input->readI64($elem535);
              $this->invalidWriteIds []= $elem535;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->minOpenWriteId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->abortedBits);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TableValidWriteIds');
    if ($this->fullTableName !== null) {
      $xfer += $output->writeFieldBegin('fullTableName', TType::STRING, 1);
      $xfer += $output->writeString($this->fullTableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->writeIdHighWaterMark !== null) {
      $xfer += $output->writeFieldBegin('writeIdHighWaterMark', TType::I64, 2);
      $xfer += $output->writeI64($this->writeIdHighWaterMark);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->invalidWriteIds !== null) {
      if (!is_array($this->invalidWriteIds)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('invalidWriteIds', TType::LST, 3);
      {
        $output->writeListBegin(TType::I64, count($this->invalidWriteIds));
        {
          foreach ($this->invalidWriteIds as $iter536)
          {
            $xfer += $output->writeI64($iter536);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->minOpenWriteId !== null) {
      $xfer += $output->writeFieldBegin('minOpenWriteId', TType::I64, 4);
      $xfer += $output->writeI64($this->minOpenWriteId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->abortedBits !== null) {
      $xfer += $output->writeFieldBegin('abortedBits', TType::STRING, 5);
      $xfer += $output->writeString($this->abortedBits);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetValidWriteIdsResponse {
  static $_TSPEC;

  /**
   * @var \metastore\TableValidWriteIds[]
   */
  public $tblValidWriteIds = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tblValidWriteIds',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\TableValidWriteIds',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tblValidWriteIds'])) {
        $this->tblValidWriteIds = $vals['tblValidWriteIds'];
      }
    }
  }

  public function getName() {
    return 'GetValidWriteIdsResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->tblValidWriteIds = array();
            $_size537 = 0;
            $_etype540 = 0;
            $xfer += $input->readListBegin($_etype540, $_size537);
            for ($_i541 = 0; $_i541 < $_size537; ++$_i541)
            {
              $elem542 = null;
              $elem542 = new \metastore\TableValidWriteIds();
              $xfer += $elem542->read($input);
              $this->tblValidWriteIds []= $elem542;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetValidWriteIdsResponse');
    if ($this->tblValidWriteIds !== null) {
      if (!is_array($this->tblValidWriteIds)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tblValidWriteIds', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->tblValidWriteIds));
        {
          foreach ($this->tblValidWriteIds as $iter543)
          {
            $xfer += $iter543->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AllocateTableWriteIdsRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $tableName = null;
  /**
   * @var int[]
   */
  public $txnIds = null;
  /**
   * @var string
   */
  public $replPolicy = null;
  /**
   * @var \metastore\TxnToWriteId[]
   */
  public $srcTxnToWriteIdList = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'txnIds',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        4 => array(
          'var' => 'replPolicy',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'srcTxnToWriteIdList',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\TxnToWriteId',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['txnIds'])) {
        $this->txnIds = $vals['txnIds'];
      }
      if (isset($vals['replPolicy'])) {
        $this->replPolicy = $vals['replPolicy'];
      }
      if (isset($vals['srcTxnToWriteIdList'])) {
        $this->srcTxnToWriteIdList = $vals['srcTxnToWriteIdList'];
      }
    }
  }

  public function getName() {
    return 'AllocateTableWriteIdsRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->txnIds = array();
            $_size544 = 0;
            $_etype547 = 0;
            $xfer += $input->readListBegin($_etype547, $_size544);
            for ($_i548 = 0; $_i548 < $_size544; ++$_i548)
            {
              $elem549 = null;
              $xfer += $input->readI64($elem549);
              $this->txnIds []= $elem549;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->replPolicy);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->srcTxnToWriteIdList = array();
            $_size550 = 0;
            $_etype553 = 0;
            $xfer += $input->readListBegin($_etype553, $_size550);
            for ($_i554 = 0; $_i554 < $_size550; ++$_i554)
            {
              $elem555 = null;
              $elem555 = new \metastore\TxnToWriteId();
              $xfer += $elem555->read($input);
              $this->srcTxnToWriteIdList []= $elem555;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AllocateTableWriteIdsRequest');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 2);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->txnIds !== null) {
      if (!is_array($this->txnIds)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('txnIds', TType::LST, 3);
      {
        $output->writeListBegin(TType::I64, count($this->txnIds));
        {
          foreach ($this->txnIds as $iter556)
          {
            $xfer += $output->writeI64($iter556);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->replPolicy !== null) {
      $xfer += $output->writeFieldBegin('replPolicy', TType::STRING, 4);
      $xfer += $output->writeString($this->replPolicy);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->srcTxnToWriteIdList !== null) {
      if (!is_array($this->srcTxnToWriteIdList)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('srcTxnToWriteIdList', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRUCT, count($this->srcTxnToWriteIdList));
        {
          foreach ($this->srcTxnToWriteIdList as $iter557)
          {
            $xfer += $iter557->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TxnToWriteId {
  static $_TSPEC;

  /**
   * @var int
   */
  public $txnId = null;
  /**
   * @var int
   */
  public $writeId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'txnId',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'writeId',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['txnId'])) {
        $this->txnId = $vals['txnId'];
      }
      if (isset($vals['writeId'])) {
        $this->writeId = $vals['writeId'];
      }
    }
  }

  public function getName() {
    return 'TxnToWriteId';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->txnId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->writeId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TxnToWriteId');
    if ($this->txnId !== null) {
      $xfer += $output->writeFieldBegin('txnId', TType::I64, 1);
      $xfer += $output->writeI64($this->txnId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->writeId !== null) {
      $xfer += $output->writeFieldBegin('writeId', TType::I64, 2);
      $xfer += $output->writeI64($this->writeId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AllocateTableWriteIdsResponse {
  static $_TSPEC;

  /**
   * @var \metastore\TxnToWriteId[]
   */
  public $txnToWriteIds = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'txnToWriteIds',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\TxnToWriteId',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['txnToWriteIds'])) {
        $this->txnToWriteIds = $vals['txnToWriteIds'];
      }
    }
  }

  public function getName() {
    return 'AllocateTableWriteIdsResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->txnToWriteIds = array();
            $_size558 = 0;
            $_etype561 = 0;
            $xfer += $input->readListBegin($_etype561, $_size558);
            for ($_i562 = 0; $_i562 < $_size558; ++$_i562)
            {
              $elem563 = null;
              $elem563 = new \metastore\TxnToWriteId();
              $xfer += $elem563->read($input);
              $this->txnToWriteIds []= $elem563;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AllocateTableWriteIdsResponse');
    if ($this->txnToWriteIds !== null) {
      if (!is_array($this->txnToWriteIds)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('txnToWriteIds', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->txnToWriteIds));
        {
          foreach ($this->txnToWriteIds as $iter564)
          {
            $xfer += $iter564->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class LockComponent {
  static $_TSPEC;

  /**
   * @var int
   */
  public $type = null;
  /**
   * @var int
   */
  public $level = null;
  /**
   * @var string
   */
  public $dbname = null;
  /**
   * @var string
   */
  public $tablename = null;
  /**
   * @var string
   */
  public $partitionname = null;
  /**
   * @var int
   */
  public $operationType =   5;
  /**
   * @var bool
   */
  public $isTransactional = false;
  /**
   * @var bool
   */
  public $isDynamicPartitionWrite = false;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'level',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'tablename',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'partitionname',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'operationType',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'isTransactional',
          'type' => TType::BOOL,
          ),
        8 => array(
          'var' => 'isDynamicPartitionWrite',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['level'])) {
        $this->level = $vals['level'];
      }
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['tablename'])) {
        $this->tablename = $vals['tablename'];
      }
      if (isset($vals['partitionname'])) {
        $this->partitionname = $vals['partitionname'];
      }
      if (isset($vals['operationType'])) {
        $this->operationType = $vals['operationType'];
      }
      if (isset($vals['isTransactional'])) {
        $this->isTransactional = $vals['isTransactional'];
      }
      if (isset($vals['isDynamicPartitionWrite'])) {
        $this->isDynamicPartitionWrite = $vals['isDynamicPartitionWrite'];
      }
    }
  }

  public function getName() {
    return 'LockComponent';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->level);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tablename);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->partitionname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->operationType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isTransactional);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isDynamicPartitionWrite);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('LockComponent');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 1);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->level !== null) {
      $xfer += $output->writeFieldBegin('level', TType::I32, 2);
      $xfer += $output->writeI32($this->level);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 3);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tablename !== null) {
      $xfer += $output->writeFieldBegin('tablename', TType::STRING, 4);
      $xfer += $output->writeString($this->tablename);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partitionname !== null) {
      $xfer += $output->writeFieldBegin('partitionname', TType::STRING, 5);
      $xfer += $output->writeString($this->partitionname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationType !== null) {
      $xfer += $output->writeFieldBegin('operationType', TType::I32, 6);
      $xfer += $output->writeI32($this->operationType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->isTransactional !== null) {
      $xfer += $output->writeFieldBegin('isTransactional', TType::BOOL, 7);
      $xfer += $output->writeBool($this->isTransactional);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->isDynamicPartitionWrite !== null) {
      $xfer += $output->writeFieldBegin('isDynamicPartitionWrite', TType::BOOL, 8);
      $xfer += $output->writeBool($this->isDynamicPartitionWrite);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class LockRequest {
  static $_TSPEC;

  /**
   * @var \metastore\LockComponent[]
   */
  public $component = null;
  /**
   * @var int
   */
  public $txnid = null;
  /**
   * @var string
   */
  public $user = null;
  /**
   * @var string
   */
  public $hostname = null;
  /**
   * @var string
   */
  public $agentInfo = "Unknown";

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'component',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\LockComponent',
            ),
          ),
        2 => array(
          'var' => 'txnid',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'user',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'hostname',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'agentInfo',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['component'])) {
        $this->component = $vals['component'];
      }
      if (isset($vals['txnid'])) {
        $this->txnid = $vals['txnid'];
      }
      if (isset($vals['user'])) {
        $this->user = $vals['user'];
      }
      if (isset($vals['hostname'])) {
        $this->hostname = $vals['hostname'];
      }
      if (isset($vals['agentInfo'])) {
        $this->agentInfo = $vals['agentInfo'];
      }
    }
  }

  public function getName() {
    return 'LockRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->component = array();
            $_size565 = 0;
            $_etype568 = 0;
            $xfer += $input->readListBegin($_etype568, $_size565);
            for ($_i569 = 0; $_i569 < $_size565; ++$_i569)
            {
              $elem570 = null;
              $elem570 = new \metastore\LockComponent();
              $xfer += $elem570->read($input);
              $this->component []= $elem570;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->txnid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->user);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->hostname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->agentInfo);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('LockRequest');
    if ($this->component !== null) {
      if (!is_array($this->component)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('component', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->component));
        {
          foreach ($this->component as $iter571)
          {
            $xfer += $iter571->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->txnid !== null) {
      $xfer += $output->writeFieldBegin('txnid', TType::I64, 2);
      $xfer += $output->writeI64($this->txnid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->user !== null) {
      $xfer += $output->writeFieldBegin('user', TType::STRING, 3);
      $xfer += $output->writeString($this->user);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hostname !== null) {
      $xfer += $output->writeFieldBegin('hostname', TType::STRING, 4);
      $xfer += $output->writeString($this->hostname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->agentInfo !== null) {
      $xfer += $output->writeFieldBegin('agentInfo', TType::STRING, 5);
      $xfer += $output->writeString($this->agentInfo);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class LockResponse {
  static $_TSPEC;

  /**
   * @var int
   */
  public $lockid = null;
  /**
   * @var int
   */
  public $state = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'lockid',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'state',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['lockid'])) {
        $this->lockid = $vals['lockid'];
      }
      if (isset($vals['state'])) {
        $this->state = $vals['state'];
      }
    }
  }

  public function getName() {
    return 'LockResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->lockid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->state);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('LockResponse');
    if ($this->lockid !== null) {
      $xfer += $output->writeFieldBegin('lockid', TType::I64, 1);
      $xfer += $output->writeI64($this->lockid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->state !== null) {
      $xfer += $output->writeFieldBegin('state', TType::I32, 2);
      $xfer += $output->writeI32($this->state);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CheckLockRequest {
  static $_TSPEC;

  /**
   * @var int
   */
  public $lockid = null;
  /**
   * @var int
   */
  public $txnid = null;
  /**
   * @var int
   */
  public $elapsed_ms = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'lockid',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'txnid',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'elapsed_ms',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['lockid'])) {
        $this->lockid = $vals['lockid'];
      }
      if (isset($vals['txnid'])) {
        $this->txnid = $vals['txnid'];
      }
      if (isset($vals['elapsed_ms'])) {
        $this->elapsed_ms = $vals['elapsed_ms'];
      }
    }
  }

  public function getName() {
    return 'CheckLockRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->lockid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->txnid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->elapsed_ms);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CheckLockRequest');
    if ($this->lockid !== null) {
      $xfer += $output->writeFieldBegin('lockid', TType::I64, 1);
      $xfer += $output->writeI64($this->lockid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->txnid !== null) {
      $xfer += $output->writeFieldBegin('txnid', TType::I64, 2);
      $xfer += $output->writeI64($this->txnid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->elapsed_ms !== null) {
      $xfer += $output->writeFieldBegin('elapsed_ms', TType::I64, 3);
      $xfer += $output->writeI64($this->elapsed_ms);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class UnlockRequest {
  static $_TSPEC;

  /**
   * @var int
   */
  public $lockid = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'lockid',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['lockid'])) {
        $this->lockid = $vals['lockid'];
      }
    }
  }

  public function getName() {
    return 'UnlockRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->lockid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('UnlockRequest');
    if ($this->lockid !== null) {
      $xfer += $output->writeFieldBegin('lockid', TType::I64, 1);
      $xfer += $output->writeI64($this->lockid);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ShowLocksRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbname = null;
  /**
   * @var string
   */
  public $tablename = null;
  /**
   * @var string
   */
  public $partname = null;
  /**
   * @var bool
   */
  public $isExtended = false;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tablename',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'partname',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'isExtended',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['tablename'])) {
        $this->tablename = $vals['tablename'];
      }
      if (isset($vals['partname'])) {
        $this->partname = $vals['partname'];
      }
      if (isset($vals['isExtended'])) {
        $this->isExtended = $vals['isExtended'];
      }
    }
  }

  public function getName() {
    return 'ShowLocksRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tablename);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->partname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isExtended);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ShowLocksRequest');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tablename !== null) {
      $xfer += $output->writeFieldBegin('tablename', TType::STRING, 2);
      $xfer += $output->writeString($this->tablename);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partname !== null) {
      $xfer += $output->writeFieldBegin('partname', TType::STRING, 3);
      $xfer += $output->writeString($this->partname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->isExtended !== null) {
      $xfer += $output->writeFieldBegin('isExtended', TType::BOOL, 4);
      $xfer += $output->writeBool($this->isExtended);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ShowLocksResponseElement {
  static $_TSPEC;

  /**
   * @var int
   */
  public $lockid = null;
  /**
   * @var string
   */
  public $dbname = null;
  /**
   * @var string
   */
  public $tablename = null;
  /**
   * @var string
   */
  public $partname = null;
  /**
   * @var int
   */
  public $state = null;
  /**
   * @var int
   */
  public $type = null;
  /**
   * @var int
   */
  public $txnid = null;
  /**
   * @var int
   */
  public $lastheartbeat = null;
  /**
   * @var int
   */
  public $acquiredat = null;
  /**
   * @var string
   */
  public $user = null;
  /**
   * @var string
   */
  public $hostname = null;
  /**
   * @var int
   */
  public $heartbeatCount = 0;
  /**
   * @var string
   */
  public $agentInfo = null;
  /**
   * @var int
   */
  public $blockedByExtId = null;
  /**
   * @var int
   */
  public $blockedByIntId = null;
  /**
   * @var int
   */
  public $lockIdInternal = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'lockid',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'tablename',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'partname',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'state',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'txnid',
          'type' => TType::I64,
          ),
        8 => array(
          'var' => 'lastheartbeat',
          'type' => TType::I64,
          ),
        9 => array(
          'var' => 'acquiredat',
          'type' => TType::I64,
          ),
        10 => array(
          'var' => 'user',
          'type' => TType::STRING,
          ),
        11 => array(
          'var' => 'hostname',
          'type' => TType::STRING,
          ),
        12 => array(
          'var' => 'heartbeatCount',
          'type' => TType::I32,
          ),
        13 => array(
          'var' => 'agentInfo',
          'type' => TType::STRING,
          ),
        14 => array(
          'var' => 'blockedByExtId',
          'type' => TType::I64,
          ),
        15 => array(
          'var' => 'blockedByIntId',
          'type' => TType::I64,
          ),
        16 => array(
          'var' => 'lockIdInternal',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['lockid'])) {
        $this->lockid = $vals['lockid'];
      }
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['tablename'])) {
        $this->tablename = $vals['tablename'];
      }
      if (isset($vals['partname'])) {
        $this->partname = $vals['partname'];
      }
      if (isset($vals['state'])) {
        $this->state = $vals['state'];
      }
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['txnid'])) {
        $this->txnid = $vals['txnid'];
      }
      if (isset($vals['lastheartbeat'])) {
        $this->lastheartbeat = $vals['lastheartbeat'];
      }
      if (isset($vals['acquiredat'])) {
        $this->acquiredat = $vals['acquiredat'];
      }
      if (isset($vals['user'])) {
        $this->user = $vals['user'];
      }
      if (isset($vals['hostname'])) {
        $this->hostname = $vals['hostname'];
      }
      if (isset($vals['heartbeatCount'])) {
        $this->heartbeatCount = $vals['heartbeatCount'];
      }
      if (isset($vals['agentInfo'])) {
        $this->agentInfo = $vals['agentInfo'];
      }
      if (isset($vals['blockedByExtId'])) {
        $this->blockedByExtId = $vals['blockedByExtId'];
      }
      if (isset($vals['blockedByIntId'])) {
        $this->blockedByIntId = $vals['blockedByIntId'];
      }
      if (isset($vals['lockIdInternal'])) {
        $this->lockIdInternal = $vals['lockIdInternal'];
      }
    }
  }

  public function getName() {
    return 'ShowLocksResponseElement';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->lockid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tablename);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->partname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->state);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->txnid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->lastheartbeat);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->acquiredat);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->user);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->hostname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->heartbeatCount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 13:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->agentInfo);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 14:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->blockedByExtId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 15:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->blockedByIntId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 16:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->lockIdInternal);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ShowLocksResponseElement');
    if ($this->lockid !== null) {
      $xfer += $output->writeFieldBegin('lockid', TType::I64, 1);
      $xfer += $output->writeI64($this->lockid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 2);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tablename !== null) {
      $xfer += $output->writeFieldBegin('tablename', TType::STRING, 3);
      $xfer += $output->writeString($this->tablename);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partname !== null) {
      $xfer += $output->writeFieldBegin('partname', TType::STRING, 4);
      $xfer += $output->writeString($this->partname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->state !== null) {
      $xfer += $output->writeFieldBegin('state', TType::I32, 5);
      $xfer += $output->writeI32($this->state);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 6);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->txnid !== null) {
      $xfer += $output->writeFieldBegin('txnid', TType::I64, 7);
      $xfer += $output->writeI64($this->txnid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->lastheartbeat !== null) {
      $xfer += $output->writeFieldBegin('lastheartbeat', TType::I64, 8);
      $xfer += $output->writeI64($this->lastheartbeat);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->acquiredat !== null) {
      $xfer += $output->writeFieldBegin('acquiredat', TType::I64, 9);
      $xfer += $output->writeI64($this->acquiredat);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->user !== null) {
      $xfer += $output->writeFieldBegin('user', TType::STRING, 10);
      $xfer += $output->writeString($this->user);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hostname !== null) {
      $xfer += $output->writeFieldBegin('hostname', TType::STRING, 11);
      $xfer += $output->writeString($this->hostname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->heartbeatCount !== null) {
      $xfer += $output->writeFieldBegin('heartbeatCount', TType::I32, 12);
      $xfer += $output->writeI32($this->heartbeatCount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->agentInfo !== null) {
      $xfer += $output->writeFieldBegin('agentInfo', TType::STRING, 13);
      $xfer += $output->writeString($this->agentInfo);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->blockedByExtId !== null) {
      $xfer += $output->writeFieldBegin('blockedByExtId', TType::I64, 14);
      $xfer += $output->writeI64($this->blockedByExtId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->blockedByIntId !== null) {
      $xfer += $output->writeFieldBegin('blockedByIntId', TType::I64, 15);
      $xfer += $output->writeI64($this->blockedByIntId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->lockIdInternal !== null) {
      $xfer += $output->writeFieldBegin('lockIdInternal', TType::I64, 16);
      $xfer += $output->writeI64($this->lockIdInternal);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ShowLocksResponse {
  static $_TSPEC;

  /**
   * @var \metastore\ShowLocksResponseElement[]
   */
  public $locks = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'locks',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\ShowLocksResponseElement',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['locks'])) {
        $this->locks = $vals['locks'];
      }
    }
  }

  public function getName() {
    return 'ShowLocksResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->locks = array();
            $_size572 = 0;
            $_etype575 = 0;
            $xfer += $input->readListBegin($_etype575, $_size572);
            for ($_i576 = 0; $_i576 < $_size572; ++$_i576)
            {
              $elem577 = null;
              $elem577 = new \metastore\ShowLocksResponseElement();
              $xfer += $elem577->read($input);
              $this->locks []= $elem577;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ShowLocksResponse');
    if ($this->locks !== null) {
      if (!is_array($this->locks)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('locks', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->locks));
        {
          foreach ($this->locks as $iter578)
          {
            $xfer += $iter578->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class HeartbeatRequest {
  static $_TSPEC;

  /**
   * @var int
   */
  public $lockid = null;
  /**
   * @var int
   */
  public $txnid = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'lockid',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'txnid',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['lockid'])) {
        $this->lockid = $vals['lockid'];
      }
      if (isset($vals['txnid'])) {
        $this->txnid = $vals['txnid'];
      }
    }
  }

  public function getName() {
    return 'HeartbeatRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->lockid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->txnid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('HeartbeatRequest');
    if ($this->lockid !== null) {
      $xfer += $output->writeFieldBegin('lockid', TType::I64, 1);
      $xfer += $output->writeI64($this->lockid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->txnid !== null) {
      $xfer += $output->writeFieldBegin('txnid', TType::I64, 2);
      $xfer += $output->writeI64($this->txnid);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class HeartbeatTxnRangeRequest {
  static $_TSPEC;

  /**
   * @var int
   */
  public $min = null;
  /**
   * @var int
   */
  public $max = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'min',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'max',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['min'])) {
        $this->min = $vals['min'];
      }
      if (isset($vals['max'])) {
        $this->max = $vals['max'];
      }
    }
  }

  public function getName() {
    return 'HeartbeatTxnRangeRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->min);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->max);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('HeartbeatTxnRangeRequest');
    if ($this->min !== null) {
      $xfer += $output->writeFieldBegin('min', TType::I64, 1);
      $xfer += $output->writeI64($this->min);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max !== null) {
      $xfer += $output->writeFieldBegin('max', TType::I64, 2);
      $xfer += $output->writeI64($this->max);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class HeartbeatTxnRangeResponse {
  static $_TSPEC;

  /**
   * @var int[]
   */
  public $aborted = null;
  /**
   * @var int[]
   */
  public $nosuch = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'aborted',
          'type' => TType::SET,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        2 => array(
          'var' => 'nosuch',
          'type' => TType::SET,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['aborted'])) {
        $this->aborted = $vals['aborted'];
      }
      if (isset($vals['nosuch'])) {
        $this->nosuch = $vals['nosuch'];
      }
    }
  }

  public function getName() {
    return 'HeartbeatTxnRangeResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::SET) {
            $this->aborted = array();
            $_size579 = 0;
            $_etype582 = 0;
            $xfer += $input->readSetBegin($_etype582, $_size579);
            for ($_i583 = 0; $_i583 < $_size579; ++$_i583)
            {
              $elem584 = null;
              $xfer += $input->readI64($elem584);
              if (is_scalar($elem584)) {
                $this->aborted[$elem584] = true;
              } else {
                $this->aborted []= $elem584;
              }
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::SET) {
            $this->nosuch = array();
            $_size585 = 0;
            $_etype588 = 0;
            $xfer += $input->readSetBegin($_etype588, $_size585);
            for ($_i589 = 0; $_i589 < $_size585; ++$_i589)
            {
              $elem590 = null;
              $xfer += $input->readI64($elem590);
              if (is_scalar($elem590)) {
                $this->nosuch[$elem590] = true;
              } else {
                $this->nosuch []= $elem590;
              }
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('HeartbeatTxnRangeResponse');
    if ($this->aborted !== null) {
      if (!is_array($this->aborted)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('aborted', TType::SET, 1);
      {
        $output->writeSetBegin(TType::I64, count($this->aborted));
        {
          foreach ($this->aborted as $iter591 => $iter592)
          {
            if (is_scalar($iter592)) {
            $xfer += $output->writeI64($iter591);
            } else {
            $xfer += $output->writeI64($iter592);
            }
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nosuch !== null) {
      if (!is_array($this->nosuch)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('nosuch', TType::SET, 2);
      {
        $output->writeSetBegin(TType::I64, count($this->nosuch));
        {
          foreach ($this->nosuch as $iter593 => $iter594)
          {
            if (is_scalar($iter594)) {
            $xfer += $output->writeI64($iter593);
            } else {
            $xfer += $output->writeI64($iter594);
            }
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CompactionRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbname = null;
  /**
   * @var string
   */
  public $tablename = null;
  /**
   * @var string
   */
  public $partitionname = null;
  /**
   * @var int
   */
  public $type = null;
  /**
   * @var string
   */
  public $runas = null;
  /**
   * @var array
   */
  public $properties = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tablename',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'partitionname',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'runas',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'properties',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['tablename'])) {
        $this->tablename = $vals['tablename'];
      }
      if (isset($vals['partitionname'])) {
        $this->partitionname = $vals['partitionname'];
      }
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['runas'])) {
        $this->runas = $vals['runas'];
      }
      if (isset($vals['properties'])) {
        $this->properties = $vals['properties'];
      }
    }
  }

  public function getName() {
    return 'CompactionRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tablename);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->partitionname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->runas);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::MAP) {
            $this->properties = array();
            $_size595 = 0;
            $_ktype596 = 0;
            $_vtype597 = 0;
            $xfer += $input->readMapBegin($_ktype596, $_vtype597, $_size595);
            for ($_i599 = 0; $_i599 < $_size595; ++$_i599)
            {
              $key600 = '';
              $val601 = '';
              $xfer += $input->readString($key600);
              $xfer += $input->readString($val601);
              $this->properties[$key600] = $val601;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CompactionRequest');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tablename !== null) {
      $xfer += $output->writeFieldBegin('tablename', TType::STRING, 2);
      $xfer += $output->writeString($this->tablename);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partitionname !== null) {
      $xfer += $output->writeFieldBegin('partitionname', TType::STRING, 3);
      $xfer += $output->writeString($this->partitionname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 4);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->runas !== null) {
      $xfer += $output->writeFieldBegin('runas', TType::STRING, 5);
      $xfer += $output->writeString($this->runas);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->properties !== null) {
      if (!is_array($this->properties)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('properties', TType::MAP, 6);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->properties));
        {
          foreach ($this->properties as $kiter602 => $viter603)
          {
            $xfer += $output->writeString($kiter602);
            $xfer += $output->writeString($viter603);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CompactionResponse {
  static $_TSPEC;

  /**
   * @var int
   */
  public $id = null;
  /**
   * @var string
   */
  public $state = null;
  /**
   * @var bool
   */
  public $accepted = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'state',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'accepted',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['state'])) {
        $this->state = $vals['state'];
      }
      if (isset($vals['accepted'])) {
        $this->accepted = $vals['accepted'];
      }
    }
  }

  public function getName() {
    return 'CompactionResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->state);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->accepted);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CompactionResponse');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::I64, 1);
      $xfer += $output->writeI64($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->state !== null) {
      $xfer += $output->writeFieldBegin('state', TType::STRING, 2);
      $xfer += $output->writeString($this->state);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->accepted !== null) {
      $xfer += $output->writeFieldBegin('accepted', TType::BOOL, 3);
      $xfer += $output->writeBool($this->accepted);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ShowCompactRequest {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ShowCompactRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ShowCompactRequest');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ShowCompactResponseElement {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbname = null;
  /**
   * @var string
   */
  public $tablename = null;
  /**
   * @var string
   */
  public $partitionname = null;
  /**
   * @var int
   */
  public $type = null;
  /**
   * @var string
   */
  public $state = null;
  /**
   * @var string
   */
  public $workerid = null;
  /**
   * @var int
   */
  public $start = null;
  /**
   * @var string
   */
  public $runAs = null;
  /**
   * @var int
   */
  public $hightestTxnId = null;
  /**
   * @var string
   */
  public $metaInfo = null;
  /**
   * @var int
   */
  public $endTime = null;
  /**
   * @var string
   */
  public $hadoopJobId = "None";
  /**
   * @var int
   */
  public $id = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tablename',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'partitionname',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'state',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'workerid',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'start',
          'type' => TType::I64,
          ),
        8 => array(
          'var' => 'runAs',
          'type' => TType::STRING,
          ),
        9 => array(
          'var' => 'hightestTxnId',
          'type' => TType::I64,
          ),
        10 => array(
          'var' => 'metaInfo',
          'type' => TType::STRING,
          ),
        11 => array(
          'var' => 'endTime',
          'type' => TType::I64,
          ),
        12 => array(
          'var' => 'hadoopJobId',
          'type' => TType::STRING,
          ),
        13 => array(
          'var' => 'id',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['tablename'])) {
        $this->tablename = $vals['tablename'];
      }
      if (isset($vals['partitionname'])) {
        $this->partitionname = $vals['partitionname'];
      }
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['state'])) {
        $this->state = $vals['state'];
      }
      if (isset($vals['workerid'])) {
        $this->workerid = $vals['workerid'];
      }
      if (isset($vals['start'])) {
        $this->start = $vals['start'];
      }
      if (isset($vals['runAs'])) {
        $this->runAs = $vals['runAs'];
      }
      if (isset($vals['hightestTxnId'])) {
        $this->hightestTxnId = $vals['hightestTxnId'];
      }
      if (isset($vals['metaInfo'])) {
        $this->metaInfo = $vals['metaInfo'];
      }
      if (isset($vals['endTime'])) {
        $this->endTime = $vals['endTime'];
      }
      if (isset($vals['hadoopJobId'])) {
        $this->hadoopJobId = $vals['hadoopJobId'];
      }
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
    }
  }

  public function getName() {
    return 'ShowCompactResponseElement';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tablename);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->partitionname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->state);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->workerid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->start);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->runAs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->hightestTxnId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->metaInfo);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->endTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->hadoopJobId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 13:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ShowCompactResponseElement');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tablename !== null) {
      $xfer += $output->writeFieldBegin('tablename', TType::STRING, 2);
      $xfer += $output->writeString($this->tablename);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partitionname !== null) {
      $xfer += $output->writeFieldBegin('partitionname', TType::STRING, 3);
      $xfer += $output->writeString($this->partitionname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 4);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->state !== null) {
      $xfer += $output->writeFieldBegin('state', TType::STRING, 5);
      $xfer += $output->writeString($this->state);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->workerid !== null) {
      $xfer += $output->writeFieldBegin('workerid', TType::STRING, 6);
      $xfer += $output->writeString($this->workerid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->start !== null) {
      $xfer += $output->writeFieldBegin('start', TType::I64, 7);
      $xfer += $output->writeI64($this->start);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->runAs !== null) {
      $xfer += $output->writeFieldBegin('runAs', TType::STRING, 8);
      $xfer += $output->writeString($this->runAs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hightestTxnId !== null) {
      $xfer += $output->writeFieldBegin('hightestTxnId', TType::I64, 9);
      $xfer += $output->writeI64($this->hightestTxnId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->metaInfo !== null) {
      $xfer += $output->writeFieldBegin('metaInfo', TType::STRING, 10);
      $xfer += $output->writeString($this->metaInfo);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->endTime !== null) {
      $xfer += $output->writeFieldBegin('endTime', TType::I64, 11);
      $xfer += $output->writeI64($this->endTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hadoopJobId !== null) {
      $xfer += $output->writeFieldBegin('hadoopJobId', TType::STRING, 12);
      $xfer += $output->writeString($this->hadoopJobId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::I64, 13);
      $xfer += $output->writeI64($this->id);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ShowCompactResponse {
  static $_TSPEC;

  /**
   * @var \metastore\ShowCompactResponseElement[]
   */
  public $compacts = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'compacts',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\ShowCompactResponseElement',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['compacts'])) {
        $this->compacts = $vals['compacts'];
      }
    }
  }

  public function getName() {
    return 'ShowCompactResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->compacts = array();
            $_size604 = 0;
            $_etype607 = 0;
            $xfer += $input->readListBegin($_etype607, $_size604);
            for ($_i608 = 0; $_i608 < $_size604; ++$_i608)
            {
              $elem609 = null;
              $elem609 = new \metastore\ShowCompactResponseElement();
              $xfer += $elem609->read($input);
              $this->compacts []= $elem609;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ShowCompactResponse');
    if ($this->compacts !== null) {
      if (!is_array($this->compacts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('compacts', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->compacts));
        {
          foreach ($this->compacts as $iter610)
          {
            $xfer += $iter610->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AddDynamicPartitions {
  static $_TSPEC;

  /**
   * @var int
   */
  public $txnid = null;
  /**
   * @var int
   */
  public $writeid = null;
  /**
   * @var string
   */
  public $dbname = null;
  /**
   * @var string
   */
  public $tablename = null;
  /**
   * @var string[]
   */
  public $partitionnames = null;
  /**
   * @var int
   */
  public $operationType =   5;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'txnid',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'writeid',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'tablename',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'partitionnames',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        6 => array(
          'var' => 'operationType',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['txnid'])) {
        $this->txnid = $vals['txnid'];
      }
      if (isset($vals['writeid'])) {
        $this->writeid = $vals['writeid'];
      }
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['tablename'])) {
        $this->tablename = $vals['tablename'];
      }
      if (isset($vals['partitionnames'])) {
        $this->partitionnames = $vals['partitionnames'];
      }
      if (isset($vals['operationType'])) {
        $this->operationType = $vals['operationType'];
      }
    }
  }

  public function getName() {
    return 'AddDynamicPartitions';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->txnid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->writeid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tablename);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->partitionnames = array();
            $_size611 = 0;
            $_etype614 = 0;
            $xfer += $input->readListBegin($_etype614, $_size611);
            for ($_i615 = 0; $_i615 < $_size611; ++$_i615)
            {
              $elem616 = null;
              $xfer += $input->readString($elem616);
              $this->partitionnames []= $elem616;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->operationType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AddDynamicPartitions');
    if ($this->txnid !== null) {
      $xfer += $output->writeFieldBegin('txnid', TType::I64, 1);
      $xfer += $output->writeI64($this->txnid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->writeid !== null) {
      $xfer += $output->writeFieldBegin('writeid', TType::I64, 2);
      $xfer += $output->writeI64($this->writeid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 3);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tablename !== null) {
      $xfer += $output->writeFieldBegin('tablename', TType::STRING, 4);
      $xfer += $output->writeString($this->tablename);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partitionnames !== null) {
      if (!is_array($this->partitionnames)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partitionnames', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRING, count($this->partitionnames));
        {
          foreach ($this->partitionnames as $iter617)
          {
            $xfer += $output->writeString($iter617);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationType !== null) {
      $xfer += $output->writeFieldBegin('operationType', TType::I32, 6);
      $xfer += $output->writeI32($this->operationType);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BasicTxnInfo {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $isnull = null;
  /**
   * @var int
   */
  public $time = null;
  /**
   * @var int
   */
  public $txnid = null;
  /**
   * @var string
   */
  public $dbname = null;
  /**
   * @var string
   */
  public $tablename = null;
  /**
   * @var string
   */
  public $partitionname = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'isnull',
          'type' => TType::BOOL,
          ),
        2 => array(
          'var' => 'time',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'txnid',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'tablename',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'partitionname',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['isnull'])) {
        $this->isnull = $vals['isnull'];
      }
      if (isset($vals['time'])) {
        $this->time = $vals['time'];
      }
      if (isset($vals['txnid'])) {
        $this->txnid = $vals['txnid'];
      }
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['tablename'])) {
        $this->tablename = $vals['tablename'];
      }
      if (isset($vals['partitionname'])) {
        $this->partitionname = $vals['partitionname'];
      }
    }
  }

  public function getName() {
    return 'BasicTxnInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isnull);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->time);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->txnid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tablename);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->partitionname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BasicTxnInfo');
    if ($this->isnull !== null) {
      $xfer += $output->writeFieldBegin('isnull', TType::BOOL, 1);
      $xfer += $output->writeBool($this->isnull);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->time !== null) {
      $xfer += $output->writeFieldBegin('time', TType::I64, 2);
      $xfer += $output->writeI64($this->time);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->txnid !== null) {
      $xfer += $output->writeFieldBegin('txnid', TType::I64, 3);
      $xfer += $output->writeI64($this->txnid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 4);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tablename !== null) {
      $xfer += $output->writeFieldBegin('tablename', TType::STRING, 5);
      $xfer += $output->writeString($this->tablename);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partitionname !== null) {
      $xfer += $output->writeFieldBegin('partitionname', TType::STRING, 6);
      $xfer += $output->writeString($this->partitionname);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CreationMetadata {
  static $_TSPEC;

  /**
   * @var string
   */
  public $catName = null;
  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $tblName = null;
  /**
   * @var string[]
   */
  public $tablesUsed = null;
  /**
   * @var string
   */
  public $validTxnList = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'tblName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'tablesUsed',
          'type' => TType::SET,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'validTxnList',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tblName'])) {
        $this->tblName = $vals['tblName'];
      }
      if (isset($vals['tablesUsed'])) {
        $this->tablesUsed = $vals['tablesUsed'];
      }
      if (isset($vals['validTxnList'])) {
        $this->validTxnList = $vals['validTxnList'];
      }
    }
  }

  public function getName() {
    return 'CreationMetadata';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tblName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::SET) {
            $this->tablesUsed = array();
            $_size618 = 0;
            $_etype621 = 0;
            $xfer += $input->readSetBegin($_etype621, $_size618);
            for ($_i622 = 0; $_i622 < $_size618; ++$_i622)
            {
              $elem623 = null;
              $xfer += $input->readString($elem623);
              if (is_scalar($elem623)) {
                $this->tablesUsed[$elem623] = true;
              } else {
                $this->tablesUsed []= $elem623;
              }
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->validTxnList);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CreationMetadata');
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 1);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tblName !== null) {
      $xfer += $output->writeFieldBegin('tblName', TType::STRING, 3);
      $xfer += $output->writeString($this->tblName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tablesUsed !== null) {
      if (!is_array($this->tablesUsed)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tablesUsed', TType::SET, 4);
      {
        $output->writeSetBegin(TType::STRING, count($this->tablesUsed));
        {
          foreach ($this->tablesUsed as $iter624 => $iter625)
          {
            if (is_scalar($iter625)) {
            $xfer += $output->writeString($iter624);
            } else {
            $xfer += $output->writeString($iter625);
            }
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->validTxnList !== null) {
      $xfer += $output->writeFieldBegin('validTxnList', TType::STRING, 5);
      $xfer += $output->writeString($this->validTxnList);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NotificationEventRequest {
  static $_TSPEC;

  /**
   * @var int
   */
  public $lastEvent = null;
  /**
   * @var int
   */
  public $maxEvents = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'lastEvent',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'maxEvents',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['lastEvent'])) {
        $this->lastEvent = $vals['lastEvent'];
      }
      if (isset($vals['maxEvents'])) {
        $this->maxEvents = $vals['maxEvents'];
      }
    }
  }

  public function getName() {
    return 'NotificationEventRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->lastEvent);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->maxEvents);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NotificationEventRequest');
    if ($this->lastEvent !== null) {
      $xfer += $output->writeFieldBegin('lastEvent', TType::I64, 1);
      $xfer += $output->writeI64($this->lastEvent);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxEvents !== null) {
      $xfer += $output->writeFieldBegin('maxEvents', TType::I32, 2);
      $xfer += $output->writeI32($this->maxEvents);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NotificationEvent {
  static $_TSPEC;

  /**
   * @var int
   */
  public $eventId = null;
  /**
   * @var int
   */
  public $eventTime = null;
  /**
   * @var string
   */
  public $eventType = null;
  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $tableName = null;
  /**
   * @var string
   */
  public $message = null;
  /**
   * @var string
   */
  public $messageFormat = null;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'eventId',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'eventTime',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'eventType',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'messageFormat',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['eventId'])) {
        $this->eventId = $vals['eventId'];
      }
      if (isset($vals['eventTime'])) {
        $this->eventTime = $vals['eventTime'];
      }
      if (isset($vals['eventType'])) {
        $this->eventType = $vals['eventType'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
      if (isset($vals['messageFormat'])) {
        $this->messageFormat = $vals['messageFormat'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'NotificationEvent';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->eventId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->eventTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->eventType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->messageFormat);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NotificationEvent');
    if ($this->eventId !== null) {
      $xfer += $output->writeFieldBegin('eventId', TType::I64, 1);
      $xfer += $output->writeI64($this->eventId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->eventTime !== null) {
      $xfer += $output->writeFieldBegin('eventTime', TType::I32, 2);
      $xfer += $output->writeI32($this->eventTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->eventType !== null) {
      $xfer += $output->writeFieldBegin('eventType', TType::STRING, 3);
      $xfer += $output->writeString($this->eventType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 4);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 5);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 6);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->messageFormat !== null) {
      $xfer += $output->writeFieldBegin('messageFormat', TType::STRING, 7);
      $xfer += $output->writeString($this->messageFormat);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 8);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NotificationEventResponse {
  static $_TSPEC;

  /**
   * @var \metastore\NotificationEvent[]
   */
  public $events = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'events',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\NotificationEvent',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['events'])) {
        $this->events = $vals['events'];
      }
    }
  }

  public function getName() {
    return 'NotificationEventResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->events = array();
            $_size626 = 0;
            $_etype629 = 0;
            $xfer += $input->readListBegin($_etype629, $_size626);
            for ($_i630 = 0; $_i630 < $_size626; ++$_i630)
            {
              $elem631 = null;
              $elem631 = new \metastore\NotificationEvent();
              $xfer += $elem631->read($input);
              $this->events []= $elem631;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NotificationEventResponse');
    if ($this->events !== null) {
      if (!is_array($this->events)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('events', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->events));
        {
          foreach ($this->events as $iter632)
          {
            $xfer += $iter632->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CurrentNotificationEventId {
  static $_TSPEC;

  /**
   * @var int
   */
  public $eventId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'eventId',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['eventId'])) {
        $this->eventId = $vals['eventId'];
      }
    }
  }

  public function getName() {
    return 'CurrentNotificationEventId';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->eventId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CurrentNotificationEventId');
    if ($this->eventId !== null) {
      $xfer += $output->writeFieldBegin('eventId', TType::I64, 1);
      $xfer += $output->writeI64($this->eventId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NotificationEventsCountRequest {
  static $_TSPEC;

  /**
   * @var int
   */
  public $fromEventId = null;
  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'fromEventId',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['fromEventId'])) {
        $this->fromEventId = $vals['fromEventId'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'NotificationEventsCountRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->fromEventId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NotificationEventsCountRequest');
    if ($this->fromEventId !== null) {
      $xfer += $output->writeFieldBegin('fromEventId', TType::I64, 1);
      $xfer += $output->writeI64($this->fromEventId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 3);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NotificationEventsCountResponse {
  static $_TSPEC;

  /**
   * @var int
   */
  public $eventsCount = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'eventsCount',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['eventsCount'])) {
        $this->eventsCount = $vals['eventsCount'];
      }
    }
  }

  public function getName() {
    return 'NotificationEventsCountResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->eventsCount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NotificationEventsCountResponse');
    if ($this->eventsCount !== null) {
      $xfer += $output->writeFieldBegin('eventsCount', TType::I64, 1);
      $xfer += $output->writeI64($this->eventsCount);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class InsertEventRequestData {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $replace = null;
  /**
   * @var string[]
   */
  public $filesAdded = null;
  /**
   * @var string[]
   */
  public $filesAddedChecksum = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'replace',
          'type' => TType::BOOL,
          ),
        2 => array(
          'var' => 'filesAdded',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'filesAddedChecksum',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['replace'])) {
        $this->replace = $vals['replace'];
      }
      if (isset($vals['filesAdded'])) {
        $this->filesAdded = $vals['filesAdded'];
      }
      if (isset($vals['filesAddedChecksum'])) {
        $this->filesAddedChecksum = $vals['filesAddedChecksum'];
      }
    }
  }

  public function getName() {
    return 'InsertEventRequestData';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->replace);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->filesAdded = array();
            $_size633 = 0;
            $_etype636 = 0;
            $xfer += $input->readListBegin($_etype636, $_size633);
            for ($_i637 = 0; $_i637 < $_size633; ++$_i637)
            {
              $elem638 = null;
              $xfer += $input->readString($elem638);
              $this->filesAdded []= $elem638;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->filesAddedChecksum = array();
            $_size639 = 0;
            $_etype642 = 0;
            $xfer += $input->readListBegin($_etype642, $_size639);
            for ($_i643 = 0; $_i643 < $_size639; ++$_i643)
            {
              $elem644 = null;
              $xfer += $input->readString($elem644);
              $this->filesAddedChecksum []= $elem644;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('InsertEventRequestData');
    if ($this->replace !== null) {
      $xfer += $output->writeFieldBegin('replace', TType::BOOL, 1);
      $xfer += $output->writeBool($this->replace);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filesAdded !== null) {
      if (!is_array($this->filesAdded)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('filesAdded', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->filesAdded));
        {
          foreach ($this->filesAdded as $iter645)
          {
            $xfer += $output->writeString($iter645);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filesAddedChecksum !== null) {
      if (!is_array($this->filesAddedChecksum)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('filesAddedChecksum', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->filesAddedChecksum));
        {
          foreach ($this->filesAddedChecksum as $iter646)
          {
            $xfer += $output->writeString($iter646);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class FireEventRequestData {
  static $_TSPEC;

  /**
   * @var \metastore\InsertEventRequestData
   */
  public $insertData = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'insertData',
          'type' => TType::STRUCT,
          'class' => '\metastore\InsertEventRequestData',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['insertData'])) {
        $this->insertData = $vals['insertData'];
      }
    }
  }

  public function getName() {
    return 'FireEventRequestData';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->insertData = new \metastore\InsertEventRequestData();
            $xfer += $this->insertData->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('FireEventRequestData');
    if ($this->insertData !== null) {
      if (!is_object($this->insertData)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('insertData', TType::STRUCT, 1);
      $xfer += $this->insertData->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class FireEventRequest {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $successful = null;
  /**
   * @var \metastore\FireEventRequestData
   */
  public $data = null;
  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $tableName = null;
  /**
   * @var string[]
   */
  public $partitionVals = null;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'successful',
          'type' => TType::BOOL,
          ),
        2 => array(
          'var' => 'data',
          'type' => TType::STRUCT,
          'class' => '\metastore\FireEventRequestData',
          ),
        3 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'partitionVals',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        6 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['successful'])) {
        $this->successful = $vals['successful'];
      }
      if (isset($vals['data'])) {
        $this->data = $vals['data'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['partitionVals'])) {
        $this->partitionVals = $vals['partitionVals'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'FireEventRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->successful);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->data = new \metastore\FireEventRequestData();
            $xfer += $this->data->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->partitionVals = array();
            $_size647 = 0;
            $_etype650 = 0;
            $xfer += $input->readListBegin($_etype650, $_size647);
            for ($_i651 = 0; $_i651 < $_size647; ++$_i651)
            {
              $elem652 = null;
              $xfer += $input->readString($elem652);
              $this->partitionVals []= $elem652;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('FireEventRequest');
    if ($this->successful !== null) {
      $xfer += $output->writeFieldBegin('successful', TType::BOOL, 1);
      $xfer += $output->writeBool($this->successful);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->data !== null) {
      if (!is_object($this->data)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('data', TType::STRUCT, 2);
      $xfer += $this->data->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 3);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 4);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partitionVals !== null) {
      if (!is_array($this->partitionVals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partitionVals', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRING, count($this->partitionVals));
        {
          foreach ($this->partitionVals as $iter653)
          {
            $xfer += $output->writeString($iter653);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 6);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class FireEventResponse {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'FireEventResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('FireEventResponse');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MetadataPpdResult {
  static $_TSPEC;

  /**
   * @var string
   */
  public $metadata = null;
  /**
   * @var string
   */
  public $includeBitset = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'metadata',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'includeBitset',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['metadata'])) {
        $this->metadata = $vals['metadata'];
      }
      if (isset($vals['includeBitset'])) {
        $this->includeBitset = $vals['includeBitset'];
      }
    }
  }

  public function getName() {
    return 'MetadataPpdResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->metadata);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->includeBitset);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MetadataPpdResult');
    if ($this->metadata !== null) {
      $xfer += $output->writeFieldBegin('metadata', TType::STRING, 1);
      $xfer += $output->writeString($this->metadata);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->includeBitset !== null) {
      $xfer += $output->writeFieldBegin('includeBitset', TType::STRING, 2);
      $xfer += $output->writeString($this->includeBitset);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetFileMetadataByExprResult {
  static $_TSPEC;

  /**
   * @var array
   */
  public $metadata = null;
  /**
   * @var bool
   */
  public $isSupported = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'metadata',
          'type' => TType::MAP,
          'ktype' => TType::I64,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::I64,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\MetadataPpdResult',
            ),
          ),
        2 => array(
          'var' => 'isSupported',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['metadata'])) {
        $this->metadata = $vals['metadata'];
      }
      if (isset($vals['isSupported'])) {
        $this->isSupported = $vals['isSupported'];
      }
    }
  }

  public function getName() {
    return 'GetFileMetadataByExprResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->metadata = array();
            $_size654 = 0;
            $_ktype655 = 0;
            $_vtype656 = 0;
            $xfer += $input->readMapBegin($_ktype655, $_vtype656, $_size654);
            for ($_i658 = 0; $_i658 < $_size654; ++$_i658)
            {
              $key659 = 0;
              $val660 = new \metastore\MetadataPpdResult();
              $xfer += $input->readI64($key659);
              $val660 = new \metastore\MetadataPpdResult();
              $xfer += $val660->read($input);
              $this->metadata[$key659] = $val660;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isSupported);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetFileMetadataByExprResult');
    if ($this->metadata !== null) {
      if (!is_array($this->metadata)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('metadata', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::I64, TType::STRUCT, count($this->metadata));
        {
          foreach ($this->metadata as $kiter661 => $viter662)
          {
            $xfer += $output->writeI64($kiter661);
            $xfer += $viter662->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->isSupported !== null) {
      $xfer += $output->writeFieldBegin('isSupported', TType::BOOL, 2);
      $xfer += $output->writeBool($this->isSupported);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetFileMetadataByExprRequest {
  static $_TSPEC;

  /**
   * @var int[]
   */
  public $fileIds = null;
  /**
   * @var string
   */
  public $expr = null;
  /**
   * @var bool
   */
  public $doGetFooters = null;
  /**
   * @var int
   */
  public $type = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'fileIds',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        2 => array(
          'var' => 'expr',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'doGetFooters',
          'type' => TType::BOOL,
          ),
        4 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['fileIds'])) {
        $this->fileIds = $vals['fileIds'];
      }
      if (isset($vals['expr'])) {
        $this->expr = $vals['expr'];
      }
      if (isset($vals['doGetFooters'])) {
        $this->doGetFooters = $vals['doGetFooters'];
      }
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
    }
  }

  public function getName() {
    return 'GetFileMetadataByExprRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->fileIds = array();
            $_size663 = 0;
            $_etype666 = 0;
            $xfer += $input->readListBegin($_etype666, $_size663);
            for ($_i667 = 0; $_i667 < $_size663; ++$_i667)
            {
              $elem668 = null;
              $xfer += $input->readI64($elem668);
              $this->fileIds []= $elem668;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->expr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->doGetFooters);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetFileMetadataByExprRequest');
    if ($this->fileIds !== null) {
      if (!is_array($this->fileIds)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('fileIds', TType::LST, 1);
      {
        $output->writeListBegin(TType::I64, count($this->fileIds));
        {
          foreach ($this->fileIds as $iter669)
          {
            $xfer += $output->writeI64($iter669);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expr !== null) {
      $xfer += $output->writeFieldBegin('expr', TType::STRING, 2);
      $xfer += $output->writeString($this->expr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->doGetFooters !== null) {
      $xfer += $output->writeFieldBegin('doGetFooters', TType::BOOL, 3);
      $xfer += $output->writeBool($this->doGetFooters);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 4);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetFileMetadataResult {
  static $_TSPEC;

  /**
   * @var array
   */
  public $metadata = null;
  /**
   * @var bool
   */
  public $isSupported = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'metadata',
          'type' => TType::MAP,
          'ktype' => TType::I64,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::I64,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'isSupported',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['metadata'])) {
        $this->metadata = $vals['metadata'];
      }
      if (isset($vals['isSupported'])) {
        $this->isSupported = $vals['isSupported'];
      }
    }
  }

  public function getName() {
    return 'GetFileMetadataResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->metadata = array();
            $_size670 = 0;
            $_ktype671 = 0;
            $_vtype672 = 0;
            $xfer += $input->readMapBegin($_ktype671, $_vtype672, $_size670);
            for ($_i674 = 0; $_i674 < $_size670; ++$_i674)
            {
              $key675 = 0;
              $val676 = '';
              $xfer += $input->readI64($key675);
              $xfer += $input->readString($val676);
              $this->metadata[$key675] = $val676;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isSupported);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetFileMetadataResult');
    if ($this->metadata !== null) {
      if (!is_array($this->metadata)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('metadata', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::I64, TType::STRING, count($this->metadata));
        {
          foreach ($this->metadata as $kiter677 => $viter678)
          {
            $xfer += $output->writeI64($kiter677);
            $xfer += $output->writeString($viter678);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->isSupported !== null) {
      $xfer += $output->writeFieldBegin('isSupported', TType::BOOL, 2);
      $xfer += $output->writeBool($this->isSupported);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetFileMetadataRequest {
  static $_TSPEC;

  /**
   * @var int[]
   */
  public $fileIds = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'fileIds',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['fileIds'])) {
        $this->fileIds = $vals['fileIds'];
      }
    }
  }

  public function getName() {
    return 'GetFileMetadataRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->fileIds = array();
            $_size679 = 0;
            $_etype682 = 0;
            $xfer += $input->readListBegin($_etype682, $_size679);
            for ($_i683 = 0; $_i683 < $_size679; ++$_i683)
            {
              $elem684 = null;
              $xfer += $input->readI64($elem684);
              $this->fileIds []= $elem684;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetFileMetadataRequest');
    if ($this->fileIds !== null) {
      if (!is_array($this->fileIds)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('fileIds', TType::LST, 1);
      {
        $output->writeListBegin(TType::I64, count($this->fileIds));
        {
          foreach ($this->fileIds as $iter685)
          {
            $xfer += $output->writeI64($iter685);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PutFileMetadataResult {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'PutFileMetadataResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PutFileMetadataResult');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PutFileMetadataRequest {
  static $_TSPEC;

  /**
   * @var int[]
   */
  public $fileIds = null;
  /**
   * @var string[]
   */
  public $metadata = null;
  /**
   * @var int
   */
  public $type = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'fileIds',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        2 => array(
          'var' => 'metadata',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['fileIds'])) {
        $this->fileIds = $vals['fileIds'];
      }
      if (isset($vals['metadata'])) {
        $this->metadata = $vals['metadata'];
      }
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
    }
  }

  public function getName() {
    return 'PutFileMetadataRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->fileIds = array();
            $_size686 = 0;
            $_etype689 = 0;
            $xfer += $input->readListBegin($_etype689, $_size686);
            for ($_i690 = 0; $_i690 < $_size686; ++$_i690)
            {
              $elem691 = null;
              $xfer += $input->readI64($elem691);
              $this->fileIds []= $elem691;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->metadata = array();
            $_size692 = 0;
            $_etype695 = 0;
            $xfer += $input->readListBegin($_etype695, $_size692);
            for ($_i696 = 0; $_i696 < $_size692; ++$_i696)
            {
              $elem697 = null;
              $xfer += $input->readString($elem697);
              $this->metadata []= $elem697;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PutFileMetadataRequest');
    if ($this->fileIds !== null) {
      if (!is_array($this->fileIds)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('fileIds', TType::LST, 1);
      {
        $output->writeListBegin(TType::I64, count($this->fileIds));
        {
          foreach ($this->fileIds as $iter698)
          {
            $xfer += $output->writeI64($iter698);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->metadata !== null) {
      if (!is_array($this->metadata)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('metadata', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->metadata));
        {
          foreach ($this->metadata as $iter699)
          {
            $xfer += $output->writeString($iter699);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 3);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ClearFileMetadataResult {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ClearFileMetadataResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ClearFileMetadataResult');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ClearFileMetadataRequest {
  static $_TSPEC;

  /**
   * @var int[]
   */
  public $fileIds = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'fileIds',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['fileIds'])) {
        $this->fileIds = $vals['fileIds'];
      }
    }
  }

  public function getName() {
    return 'ClearFileMetadataRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->fileIds = array();
            $_size700 = 0;
            $_etype703 = 0;
            $xfer += $input->readListBegin($_etype703, $_size700);
            for ($_i704 = 0; $_i704 < $_size700; ++$_i704)
            {
              $elem705 = null;
              $xfer += $input->readI64($elem705);
              $this->fileIds []= $elem705;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ClearFileMetadataRequest');
    if ($this->fileIds !== null) {
      if (!is_array($this->fileIds)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('fileIds', TType::LST, 1);
      {
        $output->writeListBegin(TType::I64, count($this->fileIds));
        {
          foreach ($this->fileIds as $iter706)
          {
            $xfer += $output->writeI64($iter706);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CacheFileMetadataResult {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $isSupported = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'isSupported',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['isSupported'])) {
        $this->isSupported = $vals['isSupported'];
      }
    }
  }

  public function getName() {
    return 'CacheFileMetadataResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isSupported);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CacheFileMetadataResult');
    if ($this->isSupported !== null) {
      $xfer += $output->writeFieldBegin('isSupported', TType::BOOL, 1);
      $xfer += $output->writeBool($this->isSupported);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CacheFileMetadataRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $tblName = null;
  /**
   * @var string
   */
  public $partName = null;
  /**
   * @var bool
   */
  public $isAllParts = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tblName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'partName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'isAllParts',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tblName'])) {
        $this->tblName = $vals['tblName'];
      }
      if (isset($vals['partName'])) {
        $this->partName = $vals['partName'];
      }
      if (isset($vals['isAllParts'])) {
        $this->isAllParts = $vals['isAllParts'];
      }
    }
  }

  public function getName() {
    return 'CacheFileMetadataRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tblName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->partName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isAllParts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CacheFileMetadataRequest');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tblName !== null) {
      $xfer += $output->writeFieldBegin('tblName', TType::STRING, 2);
      $xfer += $output->writeString($this->tblName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partName !== null) {
      $xfer += $output->writeFieldBegin('partName', TType::STRING, 3);
      $xfer += $output->writeString($this->partName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->isAllParts !== null) {
      $xfer += $output->writeFieldBegin('isAllParts', TType::BOOL, 4);
      $xfer += $output->writeBool($this->isAllParts);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetAllFunctionsResponse {
  static $_TSPEC;

  /**
   * @var \metastore\Function[]
   */
  public $functions = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'functions',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Function',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['functions'])) {
        $this->functions = $vals['functions'];
      }
    }
  }

  public function getName() {
    return 'GetAllFunctionsResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->functions = array();
            $_size707 = 0;
            $_etype710 = 0;
            $xfer += $input->readListBegin($_etype710, $_size707);
            for ($_i711 = 0; $_i711 < $_size707; ++$_i711)
            {
              $elem712 = null;
              $elem712 = new \metastore\Function();
              $xfer += $elem712->read($input);
              $this->functions []= $elem712;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetAllFunctionsResponse');
    if ($this->functions !== null) {
      if (!is_array($this->functions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('functions', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->functions));
        {
          foreach ($this->functions as $iter713)
          {
            $xfer += $iter713->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ClientCapabilities {
  static $_TSPEC;

  /**
   * @var int[]
   */
  public $values = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
    }
  }

  public function getName() {
    return 'ClientCapabilities';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->values = array();
            $_size714 = 0;
            $_etype717 = 0;
            $xfer += $input->readListBegin($_etype717, $_size714);
            for ($_i718 = 0; $_i718 < $_size714; ++$_i718)
            {
              $elem719 = null;
              $xfer += $input->readI32($elem719);
              $this->values []= $elem719;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ClientCapabilities');
    if ($this->values !== null) {
      if (!is_array($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::LST, 1);
      {
        $output->writeListBegin(TType::I32, count($this->values));
        {
          foreach ($this->values as $iter720)
          {
            $xfer += $output->writeI32($iter720);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetTableRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $tblName = null;
  /**
   * @var \metastore\ClientCapabilities
   */
  public $capabilities = null;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tblName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'capabilities',
          'type' => TType::STRUCT,
          'class' => '\metastore\ClientCapabilities',
          ),
        4 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tblName'])) {
        $this->tblName = $vals['tblName'];
      }
      if (isset($vals['capabilities'])) {
        $this->capabilities = $vals['capabilities'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'GetTableRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tblName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->capabilities = new \metastore\ClientCapabilities();
            $xfer += $this->capabilities->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetTableRequest');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tblName !== null) {
      $xfer += $output->writeFieldBegin('tblName', TType::STRING, 2);
      $xfer += $output->writeString($this->tblName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->capabilities !== null) {
      if (!is_object($this->capabilities)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('capabilities', TType::STRUCT, 3);
      $xfer += $this->capabilities->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 4);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetTableResult {
  static $_TSPEC;

  /**
   * @var \metastore\Table
   */
  public $table = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'table',
          'type' => TType::STRUCT,
          'class' => '\metastore\Table',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['table'])) {
        $this->table = $vals['table'];
      }
    }
  }

  public function getName() {
    return 'GetTableResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->table = new \metastore\Table();
            $xfer += $this->table->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetTableResult');
    if ($this->table !== null) {
      if (!is_object($this->table)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('table', TType::STRUCT, 1);
      $xfer += $this->table->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetTablesRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string[]
   */
  public $tblNames = null;
  /**
   * @var \metastore\ClientCapabilities
   */
  public $capabilities = null;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tblNames',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'capabilities',
          'type' => TType::STRUCT,
          'class' => '\metastore\ClientCapabilities',
          ),
        4 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tblNames'])) {
        $this->tblNames = $vals['tblNames'];
      }
      if (isset($vals['capabilities'])) {
        $this->capabilities = $vals['capabilities'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'GetTablesRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->tblNames = array();
            $_size721 = 0;
            $_etype724 = 0;
            $xfer += $input->readListBegin($_etype724, $_size721);
            for ($_i725 = 0; $_i725 < $_size721; ++$_i725)
            {
              $elem726 = null;
              $xfer += $input->readString($elem726);
              $this->tblNames []= $elem726;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->capabilities = new \metastore\ClientCapabilities();
            $xfer += $this->capabilities->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetTablesRequest');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tblNames !== null) {
      if (!is_array($this->tblNames)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tblNames', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->tblNames));
        {
          foreach ($this->tblNames as $iter727)
          {
            $xfer += $output->writeString($iter727);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->capabilities !== null) {
      if (!is_object($this->capabilities)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('capabilities', TType::STRUCT, 3);
      $xfer += $this->capabilities->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 4);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetTablesResult {
  static $_TSPEC;

  /**
   * @var \metastore\Table[]
   */
  public $tables = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tables',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Table',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tables'])) {
        $this->tables = $vals['tables'];
      }
    }
  }

  public function getName() {
    return 'GetTablesResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->tables = array();
            $_size728 = 0;
            $_etype731 = 0;
            $xfer += $input->readListBegin($_etype731, $_size728);
            for ($_i732 = 0; $_i732 < $_size728; ++$_i732)
            {
              $elem733 = null;
              $elem733 = new \metastore\Table();
              $xfer += $elem733->read($input);
              $this->tables []= $elem733;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetTablesResult');
    if ($this->tables !== null) {
      if (!is_array($this->tables)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tables', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->tables));
        {
          foreach ($this->tables as $iter734)
          {
            $xfer += $iter734->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CmRecycleRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dataPath = null;
  /**
   * @var bool
   */
  public $purge = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dataPath',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'purge',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dataPath'])) {
        $this->dataPath = $vals['dataPath'];
      }
      if (isset($vals['purge'])) {
        $this->purge = $vals['purge'];
      }
    }
  }

  public function getName() {
    return 'CmRecycleRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dataPath);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->purge);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CmRecycleRequest');
    if ($this->dataPath !== null) {
      $xfer += $output->writeFieldBegin('dataPath', TType::STRING, 1);
      $xfer += $output->writeString($this->dataPath);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->purge !== null) {
      $xfer += $output->writeFieldBegin('purge', TType::BOOL, 2);
      $xfer += $output->writeBool($this->purge);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CmRecycleResponse {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'CmRecycleResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CmRecycleResponse');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TableMeta {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $tableName = null;
  /**
   * @var string
   */
  public $tableType = null;
  /**
   * @var string
   */
  public $comments = null;
  /**
   * @var string
   */
  public $catName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'tableType',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'comments',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['tableType'])) {
        $this->tableType = $vals['tableType'];
      }
      if (isset($vals['comments'])) {
        $this->comments = $vals['comments'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
    }
  }

  public function getName() {
    return 'TableMeta';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->comments);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TableMeta');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 2);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableType !== null) {
      $xfer += $output->writeFieldBegin('tableType', TType::STRING, 3);
      $xfer += $output->writeString($this->tableType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->comments !== null) {
      $xfer += $output->writeFieldBegin('comments', TType::STRING, 4);
      $xfer += $output->writeString($this->comments);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 5);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Materialization {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $tablesUsed = null;
  /**
   * @var string
   */
  public $validTxnList = null;
  /**
   * @var int
   */
  public $invalidationTime = null;
  /**
   * @var bool
   */
  public $sourceTablesUpdateDeleteModified = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tablesUsed',
          'type' => TType::SET,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'validTxnList',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'invalidationTime',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'sourceTablesUpdateDeleteModified',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tablesUsed'])) {
        $this->tablesUsed = $vals['tablesUsed'];
      }
      if (isset($vals['validTxnList'])) {
        $this->validTxnList = $vals['validTxnList'];
      }
      if (isset($vals['invalidationTime'])) {
        $this->invalidationTime = $vals['invalidationTime'];
      }
      if (isset($vals['sourceTablesUpdateDeleteModified'])) {
        $this->sourceTablesUpdateDeleteModified = $vals['sourceTablesUpdateDeleteModified'];
      }
    }
  }

  public function getName() {
    return 'Materialization';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::SET) {
            $this->tablesUsed = array();
            $_size735 = 0;
            $_etype738 = 0;
            $xfer += $input->readSetBegin($_etype738, $_size735);
            for ($_i739 = 0; $_i739 < $_size735; ++$_i739)
            {
              $elem740 = null;
              $xfer += $input->readString($elem740);
              if (is_scalar($elem740)) {
                $this->tablesUsed[$elem740] = true;
              } else {
                $this->tablesUsed []= $elem740;
              }
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->validTxnList);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->invalidationTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->sourceTablesUpdateDeleteModified);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Materialization');
    if ($this->tablesUsed !== null) {
      if (!is_array($this->tablesUsed)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tablesUsed', TType::SET, 1);
      {
        $output->writeSetBegin(TType::STRING, count($this->tablesUsed));
        {
          foreach ($this->tablesUsed as $iter741 => $iter742)
          {
            if (is_scalar($iter742)) {
            $xfer += $output->writeString($iter741);
            } else {
            $xfer += $output->writeString($iter742);
            }
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->validTxnList !== null) {
      $xfer += $output->writeFieldBegin('validTxnList', TType::STRING, 2);
      $xfer += $output->writeString($this->validTxnList);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->invalidationTime !== null) {
      $xfer += $output->writeFieldBegin('invalidationTime', TType::I64, 3);
      $xfer += $output->writeI64($this->invalidationTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sourceTablesUpdateDeleteModified !== null) {
      $xfer += $output->writeFieldBegin('sourceTablesUpdateDeleteModified', TType::BOOL, 4);
      $xfer += $output->writeBool($this->sourceTablesUpdateDeleteModified);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMResourcePlan {
  static $_TSPEC;

  /**
   * @var string
   */
  public $name = null;
  /**
   * @var int
   */
  public $status = null;
  /**
   * @var int
   */
  public $queryParallelism = null;
  /**
   * @var string
   */
  public $defaultPoolPath = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'status',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'queryParallelism',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'defaultPoolPath',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['queryParallelism'])) {
        $this->queryParallelism = $vals['queryParallelism'];
      }
      if (isset($vals['defaultPoolPath'])) {
        $this->defaultPoolPath = $vals['defaultPoolPath'];
      }
    }
  }

  public function getName() {
    return 'WMResourcePlan';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->status);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->queryParallelism);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->defaultPoolPath);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMResourcePlan');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->status !== null) {
      $xfer += $output->writeFieldBegin('status', TType::I32, 2);
      $xfer += $output->writeI32($this->status);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queryParallelism !== null) {
      $xfer += $output->writeFieldBegin('queryParallelism', TType::I32, 3);
      $xfer += $output->writeI32($this->queryParallelism);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->defaultPoolPath !== null) {
      $xfer += $output->writeFieldBegin('defaultPoolPath', TType::STRING, 4);
      $xfer += $output->writeString($this->defaultPoolPath);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMNullableResourcePlan {
  static $_TSPEC;

  /**
   * @var string
   */
  public $name = null;
  /**
   * @var int
   */
  public $status = null;
  /**
   * @var int
   */
  public $queryParallelism = null;
  /**
   * @var bool
   */
  public $isSetQueryParallelism = null;
  /**
   * @var string
   */
  public $defaultPoolPath = null;
  /**
   * @var bool
   */
  public $isSetDefaultPoolPath = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'status',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'queryParallelism',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'isSetQueryParallelism',
          'type' => TType::BOOL,
          ),
        6 => array(
          'var' => 'defaultPoolPath',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'isSetDefaultPoolPath',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['queryParallelism'])) {
        $this->queryParallelism = $vals['queryParallelism'];
      }
      if (isset($vals['isSetQueryParallelism'])) {
        $this->isSetQueryParallelism = $vals['isSetQueryParallelism'];
      }
      if (isset($vals['defaultPoolPath'])) {
        $this->defaultPoolPath = $vals['defaultPoolPath'];
      }
      if (isset($vals['isSetDefaultPoolPath'])) {
        $this->isSetDefaultPoolPath = $vals['isSetDefaultPoolPath'];
      }
    }
  }

  public function getName() {
    return 'WMNullableResourcePlan';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->status);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->queryParallelism);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isSetQueryParallelism);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->defaultPoolPath);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isSetDefaultPoolPath);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMNullableResourcePlan');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->status !== null) {
      $xfer += $output->writeFieldBegin('status', TType::I32, 2);
      $xfer += $output->writeI32($this->status);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queryParallelism !== null) {
      $xfer += $output->writeFieldBegin('queryParallelism', TType::I32, 4);
      $xfer += $output->writeI32($this->queryParallelism);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->isSetQueryParallelism !== null) {
      $xfer += $output->writeFieldBegin('isSetQueryParallelism', TType::BOOL, 5);
      $xfer += $output->writeBool($this->isSetQueryParallelism);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->defaultPoolPath !== null) {
      $xfer += $output->writeFieldBegin('defaultPoolPath', TType::STRING, 6);
      $xfer += $output->writeString($this->defaultPoolPath);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->isSetDefaultPoolPath !== null) {
      $xfer += $output->writeFieldBegin('isSetDefaultPoolPath', TType::BOOL, 7);
      $xfer += $output->writeBool($this->isSetDefaultPoolPath);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMPool {
  static $_TSPEC;

  /**
   * @var string
   */
  public $resourcePlanName = null;
  /**
   * @var string
   */
  public $poolPath = null;
  /**
   * @var double
   */
  public $allocFraction = null;
  /**
   * @var int
   */
  public $queryParallelism = null;
  /**
   * @var string
   */
  public $schedulingPolicy = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'resourcePlanName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'poolPath',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'allocFraction',
          'type' => TType::DOUBLE,
          ),
        4 => array(
          'var' => 'queryParallelism',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'schedulingPolicy',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['resourcePlanName'])) {
        $this->resourcePlanName = $vals['resourcePlanName'];
      }
      if (isset($vals['poolPath'])) {
        $this->poolPath = $vals['poolPath'];
      }
      if (isset($vals['allocFraction'])) {
        $this->allocFraction = $vals['allocFraction'];
      }
      if (isset($vals['queryParallelism'])) {
        $this->queryParallelism = $vals['queryParallelism'];
      }
      if (isset($vals['schedulingPolicy'])) {
        $this->schedulingPolicy = $vals['schedulingPolicy'];
      }
    }
  }

  public function getName() {
    return 'WMPool';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->resourcePlanName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->poolPath);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->allocFraction);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->queryParallelism);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schedulingPolicy);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMPool');
    if ($this->resourcePlanName !== null) {
      $xfer += $output->writeFieldBegin('resourcePlanName', TType::STRING, 1);
      $xfer += $output->writeString($this->resourcePlanName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->poolPath !== null) {
      $xfer += $output->writeFieldBegin('poolPath', TType::STRING, 2);
      $xfer += $output->writeString($this->poolPath);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->allocFraction !== null) {
      $xfer += $output->writeFieldBegin('allocFraction', TType::DOUBLE, 3);
      $xfer += $output->writeDouble($this->allocFraction);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queryParallelism !== null) {
      $xfer += $output->writeFieldBegin('queryParallelism', TType::I32, 4);
      $xfer += $output->writeI32($this->queryParallelism);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->schedulingPolicy !== null) {
      $xfer += $output->writeFieldBegin('schedulingPolicy', TType::STRING, 5);
      $xfer += $output->writeString($this->schedulingPolicy);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMNullablePool {
  static $_TSPEC;

  /**
   * @var string
   */
  public $resourcePlanName = null;
  /**
   * @var string
   */
  public $poolPath = null;
  /**
   * @var double
   */
  public $allocFraction = null;
  /**
   * @var int
   */
  public $queryParallelism = null;
  /**
   * @var string
   */
  public $schedulingPolicy = null;
  /**
   * @var bool
   */
  public $isSetSchedulingPolicy = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'resourcePlanName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'poolPath',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'allocFraction',
          'type' => TType::DOUBLE,
          ),
        4 => array(
          'var' => 'queryParallelism',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'schedulingPolicy',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'isSetSchedulingPolicy',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['resourcePlanName'])) {
        $this->resourcePlanName = $vals['resourcePlanName'];
      }
      if (isset($vals['poolPath'])) {
        $this->poolPath = $vals['poolPath'];
      }
      if (isset($vals['allocFraction'])) {
        $this->allocFraction = $vals['allocFraction'];
      }
      if (isset($vals['queryParallelism'])) {
        $this->queryParallelism = $vals['queryParallelism'];
      }
      if (isset($vals['schedulingPolicy'])) {
        $this->schedulingPolicy = $vals['schedulingPolicy'];
      }
      if (isset($vals['isSetSchedulingPolicy'])) {
        $this->isSetSchedulingPolicy = $vals['isSetSchedulingPolicy'];
      }
    }
  }

  public function getName() {
    return 'WMNullablePool';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->resourcePlanName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->poolPath);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->allocFraction);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->queryParallelism);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schedulingPolicy);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isSetSchedulingPolicy);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMNullablePool');
    if ($this->resourcePlanName !== null) {
      $xfer += $output->writeFieldBegin('resourcePlanName', TType::STRING, 1);
      $xfer += $output->writeString($this->resourcePlanName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->poolPath !== null) {
      $xfer += $output->writeFieldBegin('poolPath', TType::STRING, 2);
      $xfer += $output->writeString($this->poolPath);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->allocFraction !== null) {
      $xfer += $output->writeFieldBegin('allocFraction', TType::DOUBLE, 3);
      $xfer += $output->writeDouble($this->allocFraction);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queryParallelism !== null) {
      $xfer += $output->writeFieldBegin('queryParallelism', TType::I32, 4);
      $xfer += $output->writeI32($this->queryParallelism);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->schedulingPolicy !== null) {
      $xfer += $output->writeFieldBegin('schedulingPolicy', TType::STRING, 5);
      $xfer += $output->writeString($this->schedulingPolicy);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->isSetSchedulingPolicy !== null) {
      $xfer += $output->writeFieldBegin('isSetSchedulingPolicy', TType::BOOL, 6);
      $xfer += $output->writeBool($this->isSetSchedulingPolicy);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMTrigger {
  static $_TSPEC;

  /**
   * @var string
   */
  public $resourcePlanName = null;
  /**
   * @var string
   */
  public $triggerName = null;
  /**
   * @var string
   */
  public $triggerExpression = null;
  /**
   * @var string
   */
  public $actionExpression = null;
  /**
   * @var bool
   */
  public $isInUnmanaged = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'resourcePlanName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'triggerName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'triggerExpression',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'actionExpression',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'isInUnmanaged',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['resourcePlanName'])) {
        $this->resourcePlanName = $vals['resourcePlanName'];
      }
      if (isset($vals['triggerName'])) {
        $this->triggerName = $vals['triggerName'];
      }
      if (isset($vals['triggerExpression'])) {
        $this->triggerExpression = $vals['triggerExpression'];
      }
      if (isset($vals['actionExpression'])) {
        $this->actionExpression = $vals['actionExpression'];
      }
      if (isset($vals['isInUnmanaged'])) {
        $this->isInUnmanaged = $vals['isInUnmanaged'];
      }
    }
  }

  public function getName() {
    return 'WMTrigger';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->resourcePlanName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->triggerName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->triggerExpression);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->actionExpression);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isInUnmanaged);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMTrigger');
    if ($this->resourcePlanName !== null) {
      $xfer += $output->writeFieldBegin('resourcePlanName', TType::STRING, 1);
      $xfer += $output->writeString($this->resourcePlanName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->triggerName !== null) {
      $xfer += $output->writeFieldBegin('triggerName', TType::STRING, 2);
      $xfer += $output->writeString($this->triggerName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->triggerExpression !== null) {
      $xfer += $output->writeFieldBegin('triggerExpression', TType::STRING, 3);
      $xfer += $output->writeString($this->triggerExpression);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->actionExpression !== null) {
      $xfer += $output->writeFieldBegin('actionExpression', TType::STRING, 4);
      $xfer += $output->writeString($this->actionExpression);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->isInUnmanaged !== null) {
      $xfer += $output->writeFieldBegin('isInUnmanaged', TType::BOOL, 5);
      $xfer += $output->writeBool($this->isInUnmanaged);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMMapping {
  static $_TSPEC;

  /**
   * @var string
   */
  public $resourcePlanName = null;
  /**
   * @var string
   */
  public $entityType = null;
  /**
   * @var string
   */
  public $entityName = null;
  /**
   * @var string
   */
  public $poolPath = null;
  /**
   * @var int
   */
  public $ordering = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'resourcePlanName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'entityType',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'entityName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'poolPath',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'ordering',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['resourcePlanName'])) {
        $this->resourcePlanName = $vals['resourcePlanName'];
      }
      if (isset($vals['entityType'])) {
        $this->entityType = $vals['entityType'];
      }
      if (isset($vals['entityName'])) {
        $this->entityName = $vals['entityName'];
      }
      if (isset($vals['poolPath'])) {
        $this->poolPath = $vals['poolPath'];
      }
      if (isset($vals['ordering'])) {
        $this->ordering = $vals['ordering'];
      }
    }
  }

  public function getName() {
    return 'WMMapping';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->resourcePlanName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->entityType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->entityName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->poolPath);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->ordering);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMMapping');
    if ($this->resourcePlanName !== null) {
      $xfer += $output->writeFieldBegin('resourcePlanName', TType::STRING, 1);
      $xfer += $output->writeString($this->resourcePlanName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->entityType !== null) {
      $xfer += $output->writeFieldBegin('entityType', TType::STRING, 2);
      $xfer += $output->writeString($this->entityType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->entityName !== null) {
      $xfer += $output->writeFieldBegin('entityName', TType::STRING, 3);
      $xfer += $output->writeString($this->entityName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->poolPath !== null) {
      $xfer += $output->writeFieldBegin('poolPath', TType::STRING, 4);
      $xfer += $output->writeString($this->poolPath);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ordering !== null) {
      $xfer += $output->writeFieldBegin('ordering', TType::I32, 5);
      $xfer += $output->writeI32($this->ordering);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMPoolTrigger {
  static $_TSPEC;

  /**
   * @var string
   */
  public $pool = null;
  /**
   * @var string
   */
  public $trigger = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'pool',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'trigger',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['pool'])) {
        $this->pool = $vals['pool'];
      }
      if (isset($vals['trigger'])) {
        $this->trigger = $vals['trigger'];
      }
    }
  }

  public function getName() {
    return 'WMPoolTrigger';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->pool);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->trigger);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMPoolTrigger');
    if ($this->pool !== null) {
      $xfer += $output->writeFieldBegin('pool', TType::STRING, 1);
      $xfer += $output->writeString($this->pool);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->trigger !== null) {
      $xfer += $output->writeFieldBegin('trigger', TType::STRING, 2);
      $xfer += $output->writeString($this->trigger);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMFullResourcePlan {
  static $_TSPEC;

  /**
   * @var \metastore\WMResourcePlan
   */
  public $plan = null;
  /**
   * @var \metastore\WMPool[]
   */
  public $pools = null;
  /**
   * @var \metastore\WMMapping[]
   */
  public $mappings = null;
  /**
   * @var \metastore\WMTrigger[]
   */
  public $triggers = null;
  /**
   * @var \metastore\WMPoolTrigger[]
   */
  public $poolTriggers = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'plan',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMResourcePlan',
          ),
        2 => array(
          'var' => 'pools',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\WMPool',
            ),
          ),
        3 => array(
          'var' => 'mappings',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\WMMapping',
            ),
          ),
        4 => array(
          'var' => 'triggers',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\WMTrigger',
            ),
          ),
        5 => array(
          'var' => 'poolTriggers',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\WMPoolTrigger',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['plan'])) {
        $this->plan = $vals['plan'];
      }
      if (isset($vals['pools'])) {
        $this->pools = $vals['pools'];
      }
      if (isset($vals['mappings'])) {
        $this->mappings = $vals['mappings'];
      }
      if (isset($vals['triggers'])) {
        $this->triggers = $vals['triggers'];
      }
      if (isset($vals['poolTriggers'])) {
        $this->poolTriggers = $vals['poolTriggers'];
      }
    }
  }

  public function getName() {
    return 'WMFullResourcePlan';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->plan = new \metastore\WMResourcePlan();
            $xfer += $this->plan->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->pools = array();
            $_size743 = 0;
            $_etype746 = 0;
            $xfer += $input->readListBegin($_etype746, $_size743);
            for ($_i747 = 0; $_i747 < $_size743; ++$_i747)
            {
              $elem748 = null;
              $elem748 = new \metastore\WMPool();
              $xfer += $elem748->read($input);
              $this->pools []= $elem748;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->mappings = array();
            $_size749 = 0;
            $_etype752 = 0;
            $xfer += $input->readListBegin($_etype752, $_size749);
            for ($_i753 = 0; $_i753 < $_size749; ++$_i753)
            {
              $elem754 = null;
              $elem754 = new \metastore\WMMapping();
              $xfer += $elem754->read($input);
              $this->mappings []= $elem754;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->triggers = array();
            $_size755 = 0;
            $_etype758 = 0;
            $xfer += $input->readListBegin($_etype758, $_size755);
            for ($_i759 = 0; $_i759 < $_size755; ++$_i759)
            {
              $elem760 = null;
              $elem760 = new \metastore\WMTrigger();
              $xfer += $elem760->read($input);
              $this->triggers []= $elem760;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->poolTriggers = array();
            $_size761 = 0;
            $_etype764 = 0;
            $xfer += $input->readListBegin($_etype764, $_size761);
            for ($_i765 = 0; $_i765 < $_size761; ++$_i765)
            {
              $elem766 = null;
              $elem766 = new \metastore\WMPoolTrigger();
              $xfer += $elem766->read($input);
              $this->poolTriggers []= $elem766;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMFullResourcePlan');
    if ($this->plan !== null) {
      if (!is_object($this->plan)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('plan', TType::STRUCT, 1);
      $xfer += $this->plan->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->pools !== null) {
      if (!is_array($this->pools)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('pools', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->pools));
        {
          foreach ($this->pools as $iter767)
          {
            $xfer += $iter767->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mappings !== null) {
      if (!is_array($this->mappings)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('mappings', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->mappings));
        {
          foreach ($this->mappings as $iter768)
          {
            $xfer += $iter768->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->triggers !== null) {
      if (!is_array($this->triggers)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('triggers', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRUCT, count($this->triggers));
        {
          foreach ($this->triggers as $iter769)
          {
            $xfer += $iter769->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->poolTriggers !== null) {
      if (!is_array($this->poolTriggers)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('poolTriggers', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRUCT, count($this->poolTriggers));
        {
          foreach ($this->poolTriggers as $iter770)
          {
            $xfer += $iter770->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMCreateResourcePlanRequest {
  static $_TSPEC;

  /**
   * @var \metastore\WMResourcePlan
   */
  public $resourcePlan = null;
  /**
   * @var string
   */
  public $copyFrom = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'resourcePlan',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMResourcePlan',
          ),
        2 => array(
          'var' => 'copyFrom',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['resourcePlan'])) {
        $this->resourcePlan = $vals['resourcePlan'];
      }
      if (isset($vals['copyFrom'])) {
        $this->copyFrom = $vals['copyFrom'];
      }
    }
  }

  public function getName() {
    return 'WMCreateResourcePlanRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->resourcePlan = new \metastore\WMResourcePlan();
            $xfer += $this->resourcePlan->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->copyFrom);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMCreateResourcePlanRequest');
    if ($this->resourcePlan !== null) {
      if (!is_object($this->resourcePlan)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('resourcePlan', TType::STRUCT, 1);
      $xfer += $this->resourcePlan->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->copyFrom !== null) {
      $xfer += $output->writeFieldBegin('copyFrom', TType::STRING, 2);
      $xfer += $output->writeString($this->copyFrom);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMCreateResourcePlanResponse {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'WMCreateResourcePlanResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMCreateResourcePlanResponse');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMGetActiveResourcePlanRequest {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'WMGetActiveResourcePlanRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMGetActiveResourcePlanRequest');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMGetActiveResourcePlanResponse {
  static $_TSPEC;

  /**
   * @var \metastore\WMFullResourcePlan
   */
  public $resourcePlan = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'resourcePlan',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMFullResourcePlan',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['resourcePlan'])) {
        $this->resourcePlan = $vals['resourcePlan'];
      }
    }
  }

  public function getName() {
    return 'WMGetActiveResourcePlanResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->resourcePlan = new \metastore\WMFullResourcePlan();
            $xfer += $this->resourcePlan->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMGetActiveResourcePlanResponse');
    if ($this->resourcePlan !== null) {
      if (!is_object($this->resourcePlan)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('resourcePlan', TType::STRUCT, 1);
      $xfer += $this->resourcePlan->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMGetResourcePlanRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $resourcePlanName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'resourcePlanName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['resourcePlanName'])) {
        $this->resourcePlanName = $vals['resourcePlanName'];
      }
    }
  }

  public function getName() {
    return 'WMGetResourcePlanRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->resourcePlanName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMGetResourcePlanRequest');
    if ($this->resourcePlanName !== null) {
      $xfer += $output->writeFieldBegin('resourcePlanName', TType::STRING, 1);
      $xfer += $output->writeString($this->resourcePlanName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMGetResourcePlanResponse {
  static $_TSPEC;

  /**
   * @var \metastore\WMFullResourcePlan
   */
  public $resourcePlan = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'resourcePlan',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMFullResourcePlan',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['resourcePlan'])) {
        $this->resourcePlan = $vals['resourcePlan'];
      }
    }
  }

  public function getName() {
    return 'WMGetResourcePlanResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->resourcePlan = new \metastore\WMFullResourcePlan();
            $xfer += $this->resourcePlan->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMGetResourcePlanResponse');
    if ($this->resourcePlan !== null) {
      if (!is_object($this->resourcePlan)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('resourcePlan', TType::STRUCT, 1);
      $xfer += $this->resourcePlan->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMGetAllResourcePlanRequest {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'WMGetAllResourcePlanRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMGetAllResourcePlanRequest');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMGetAllResourcePlanResponse {
  static $_TSPEC;

  /**
   * @var \metastore\WMResourcePlan[]
   */
  public $resourcePlans = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'resourcePlans',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\WMResourcePlan',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['resourcePlans'])) {
        $this->resourcePlans = $vals['resourcePlans'];
      }
    }
  }

  public function getName() {
    return 'WMGetAllResourcePlanResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->resourcePlans = array();
            $_size771 = 0;
            $_etype774 = 0;
            $xfer += $input->readListBegin($_etype774, $_size771);
            for ($_i775 = 0; $_i775 < $_size771; ++$_i775)
            {
              $elem776 = null;
              $elem776 = new \metastore\WMResourcePlan();
              $xfer += $elem776->read($input);
              $this->resourcePlans []= $elem776;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMGetAllResourcePlanResponse');
    if ($this->resourcePlans !== null) {
      if (!is_array($this->resourcePlans)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('resourcePlans', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->resourcePlans));
        {
          foreach ($this->resourcePlans as $iter777)
          {
            $xfer += $iter777->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMAlterResourcePlanRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $resourcePlanName = null;
  /**
   * @var \metastore\WMNullableResourcePlan
   */
  public $resourcePlan = null;
  /**
   * @var bool
   */
  public $isEnableAndActivate = null;
  /**
   * @var bool
   */
  public $isForceDeactivate = null;
  /**
   * @var bool
   */
  public $isReplace = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'resourcePlanName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'resourcePlan',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMNullableResourcePlan',
          ),
        3 => array(
          'var' => 'isEnableAndActivate',
          'type' => TType::BOOL,
          ),
        4 => array(
          'var' => 'isForceDeactivate',
          'type' => TType::BOOL,
          ),
        5 => array(
          'var' => 'isReplace',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['resourcePlanName'])) {
        $this->resourcePlanName = $vals['resourcePlanName'];
      }
      if (isset($vals['resourcePlan'])) {
        $this->resourcePlan = $vals['resourcePlan'];
      }
      if (isset($vals['isEnableAndActivate'])) {
        $this->isEnableAndActivate = $vals['isEnableAndActivate'];
      }
      if (isset($vals['isForceDeactivate'])) {
        $this->isForceDeactivate = $vals['isForceDeactivate'];
      }
      if (isset($vals['isReplace'])) {
        $this->isReplace = $vals['isReplace'];
      }
    }
  }

  public function getName() {
    return 'WMAlterResourcePlanRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->resourcePlanName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->resourcePlan = new \metastore\WMNullableResourcePlan();
            $xfer += $this->resourcePlan->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isEnableAndActivate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isForceDeactivate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isReplace);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMAlterResourcePlanRequest');
    if ($this->resourcePlanName !== null) {
      $xfer += $output->writeFieldBegin('resourcePlanName', TType::STRING, 1);
      $xfer += $output->writeString($this->resourcePlanName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->resourcePlan !== null) {
      if (!is_object($this->resourcePlan)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('resourcePlan', TType::STRUCT, 2);
      $xfer += $this->resourcePlan->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->isEnableAndActivate !== null) {
      $xfer += $output->writeFieldBegin('isEnableAndActivate', TType::BOOL, 3);
      $xfer += $output->writeBool($this->isEnableAndActivate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->isForceDeactivate !== null) {
      $xfer += $output->writeFieldBegin('isForceDeactivate', TType::BOOL, 4);
      $xfer += $output->writeBool($this->isForceDeactivate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->isReplace !== null) {
      $xfer += $output->writeFieldBegin('isReplace', TType::BOOL, 5);
      $xfer += $output->writeBool($this->isReplace);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMAlterResourcePlanResponse {
  static $_TSPEC;

  /**
   * @var \metastore\WMFullResourcePlan
   */
  public $fullResourcePlan = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'fullResourcePlan',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMFullResourcePlan',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['fullResourcePlan'])) {
        $this->fullResourcePlan = $vals['fullResourcePlan'];
      }
    }
  }

  public function getName() {
    return 'WMAlterResourcePlanResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->fullResourcePlan = new \metastore\WMFullResourcePlan();
            $xfer += $this->fullResourcePlan->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMAlterResourcePlanResponse');
    if ($this->fullResourcePlan !== null) {
      if (!is_object($this->fullResourcePlan)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('fullResourcePlan', TType::STRUCT, 1);
      $xfer += $this->fullResourcePlan->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMValidateResourcePlanRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $resourcePlanName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'resourcePlanName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['resourcePlanName'])) {
        $this->resourcePlanName = $vals['resourcePlanName'];
      }
    }
  }

  public function getName() {
    return 'WMValidateResourcePlanRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->resourcePlanName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMValidateResourcePlanRequest');
    if ($this->resourcePlanName !== null) {
      $xfer += $output->writeFieldBegin('resourcePlanName', TType::STRING, 1);
      $xfer += $output->writeString($this->resourcePlanName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMValidateResourcePlanResponse {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $errors = null;
  /**
   * @var string[]
   */
  public $warnings = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errors',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'warnings',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errors'])) {
        $this->errors = $vals['errors'];
      }
      if (isset($vals['warnings'])) {
        $this->warnings = $vals['warnings'];
      }
    }
  }

  public function getName() {
    return 'WMValidateResourcePlanResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->errors = array();
            $_size778 = 0;
            $_etype781 = 0;
            $xfer += $input->readListBegin($_etype781, $_size778);
            for ($_i782 = 0; $_i782 < $_size778; ++$_i782)
            {
              $elem783 = null;
              $xfer += $input->readString($elem783);
              $this->errors []= $elem783;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->warnings = array();
            $_size784 = 0;
            $_etype787 = 0;
            $xfer += $input->readListBegin($_etype787, $_size784);
            for ($_i788 = 0; $_i788 < $_size784; ++$_i788)
            {
              $elem789 = null;
              $xfer += $input->readString($elem789);
              $this->warnings []= $elem789;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMValidateResourcePlanResponse');
    if ($this->errors !== null) {
      if (!is_array($this->errors)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('errors', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->errors));
        {
          foreach ($this->errors as $iter790)
          {
            $xfer += $output->writeString($iter790);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->warnings !== null) {
      if (!is_array($this->warnings)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('warnings', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->warnings));
        {
          foreach ($this->warnings as $iter791)
          {
            $xfer += $output->writeString($iter791);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMDropResourcePlanRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $resourcePlanName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'resourcePlanName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['resourcePlanName'])) {
        $this->resourcePlanName = $vals['resourcePlanName'];
      }
    }
  }

  public function getName() {
    return 'WMDropResourcePlanRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->resourcePlanName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMDropResourcePlanRequest');
    if ($this->resourcePlanName !== null) {
      $xfer += $output->writeFieldBegin('resourcePlanName', TType::STRING, 1);
      $xfer += $output->writeString($this->resourcePlanName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMDropResourcePlanResponse {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'WMDropResourcePlanResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMDropResourcePlanResponse');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMCreateTriggerRequest {
  static $_TSPEC;

  /**
   * @var \metastore\WMTrigger
   */
  public $trigger = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'trigger',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMTrigger',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['trigger'])) {
        $this->trigger = $vals['trigger'];
      }
    }
  }

  public function getName() {
    return 'WMCreateTriggerRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->trigger = new \metastore\WMTrigger();
            $xfer += $this->trigger->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMCreateTriggerRequest');
    if ($this->trigger !== null) {
      if (!is_object($this->trigger)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('trigger', TType::STRUCT, 1);
      $xfer += $this->trigger->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMCreateTriggerResponse {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'WMCreateTriggerResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMCreateTriggerResponse');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMAlterTriggerRequest {
  static $_TSPEC;

  /**
   * @var \metastore\WMTrigger
   */
  public $trigger = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'trigger',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMTrigger',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['trigger'])) {
        $this->trigger = $vals['trigger'];
      }
    }
  }

  public function getName() {
    return 'WMAlterTriggerRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->trigger = new \metastore\WMTrigger();
            $xfer += $this->trigger->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMAlterTriggerRequest');
    if ($this->trigger !== null) {
      if (!is_object($this->trigger)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('trigger', TType::STRUCT, 1);
      $xfer += $this->trigger->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMAlterTriggerResponse {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'WMAlterTriggerResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMAlterTriggerResponse');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMDropTriggerRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $resourcePlanName = null;
  /**
   * @var string
   */
  public $triggerName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'resourcePlanName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'triggerName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['resourcePlanName'])) {
        $this->resourcePlanName = $vals['resourcePlanName'];
      }
      if (isset($vals['triggerName'])) {
        $this->triggerName = $vals['triggerName'];
      }
    }
  }

  public function getName() {
    return 'WMDropTriggerRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->resourcePlanName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->triggerName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMDropTriggerRequest');
    if ($this->resourcePlanName !== null) {
      $xfer += $output->writeFieldBegin('resourcePlanName', TType::STRING, 1);
      $xfer += $output->writeString($this->resourcePlanName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->triggerName !== null) {
      $xfer += $output->writeFieldBegin('triggerName', TType::STRING, 2);
      $xfer += $output->writeString($this->triggerName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMDropTriggerResponse {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'WMDropTriggerResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMDropTriggerResponse');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMGetTriggersForResourePlanRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $resourcePlanName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'resourcePlanName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['resourcePlanName'])) {
        $this->resourcePlanName = $vals['resourcePlanName'];
      }
    }
  }

  public function getName() {
    return 'WMGetTriggersForResourePlanRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->resourcePlanName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMGetTriggersForResourePlanRequest');
    if ($this->resourcePlanName !== null) {
      $xfer += $output->writeFieldBegin('resourcePlanName', TType::STRING, 1);
      $xfer += $output->writeString($this->resourcePlanName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMGetTriggersForResourePlanResponse {
  static $_TSPEC;

  /**
   * @var \metastore\WMTrigger[]
   */
  public $triggers = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'triggers',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\WMTrigger',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['triggers'])) {
        $this->triggers = $vals['triggers'];
      }
    }
  }

  public function getName() {
    return 'WMGetTriggersForResourePlanResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->triggers = array();
            $_size792 = 0;
            $_etype795 = 0;
            $xfer += $input->readListBegin($_etype795, $_size792);
            for ($_i796 = 0; $_i796 < $_size792; ++$_i796)
            {
              $elem797 = null;
              $elem797 = new \metastore\WMTrigger();
              $xfer += $elem797->read($input);
              $this->triggers []= $elem797;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMGetTriggersForResourePlanResponse');
    if ($this->triggers !== null) {
      if (!is_array($this->triggers)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('triggers', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->triggers));
        {
          foreach ($this->triggers as $iter798)
          {
            $xfer += $iter798->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMCreatePoolRequest {
  static $_TSPEC;

  /**
   * @var \metastore\WMPool
   */
  public $pool = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'pool',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMPool',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['pool'])) {
        $this->pool = $vals['pool'];
      }
    }
  }

  public function getName() {
    return 'WMCreatePoolRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->pool = new \metastore\WMPool();
            $xfer += $this->pool->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMCreatePoolRequest');
    if ($this->pool !== null) {
      if (!is_object($this->pool)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('pool', TType::STRUCT, 1);
      $xfer += $this->pool->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMCreatePoolResponse {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'WMCreatePoolResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMCreatePoolResponse');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMAlterPoolRequest {
  static $_TSPEC;

  /**
   * @var \metastore\WMNullablePool
   */
  public $pool = null;
  /**
   * @var string
   */
  public $poolPath = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'pool',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMNullablePool',
          ),
        2 => array(
          'var' => 'poolPath',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['pool'])) {
        $this->pool = $vals['pool'];
      }
      if (isset($vals['poolPath'])) {
        $this->poolPath = $vals['poolPath'];
      }
    }
  }

  public function getName() {
    return 'WMAlterPoolRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->pool = new \metastore\WMNullablePool();
            $xfer += $this->pool->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->poolPath);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMAlterPoolRequest');
    if ($this->pool !== null) {
      if (!is_object($this->pool)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('pool', TType::STRUCT, 1);
      $xfer += $this->pool->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->poolPath !== null) {
      $xfer += $output->writeFieldBegin('poolPath', TType::STRING, 2);
      $xfer += $output->writeString($this->poolPath);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMAlterPoolResponse {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'WMAlterPoolResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMAlterPoolResponse');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMDropPoolRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $resourcePlanName = null;
  /**
   * @var string
   */
  public $poolPath = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'resourcePlanName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'poolPath',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['resourcePlanName'])) {
        $this->resourcePlanName = $vals['resourcePlanName'];
      }
      if (isset($vals['poolPath'])) {
        $this->poolPath = $vals['poolPath'];
      }
    }
  }

  public function getName() {
    return 'WMDropPoolRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->resourcePlanName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->poolPath);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMDropPoolRequest');
    if ($this->resourcePlanName !== null) {
      $xfer += $output->writeFieldBegin('resourcePlanName', TType::STRING, 1);
      $xfer += $output->writeString($this->resourcePlanName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->poolPath !== null) {
      $xfer += $output->writeFieldBegin('poolPath', TType::STRING, 2);
      $xfer += $output->writeString($this->poolPath);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMDropPoolResponse {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'WMDropPoolResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMDropPoolResponse');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMCreateOrUpdateMappingRequest {
  static $_TSPEC;

  /**
   * @var \metastore\WMMapping
   */
  public $mapping = null;
  /**
   * @var bool
   */
  public $update = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'mapping',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMMapping',
          ),
        2 => array(
          'var' => 'update',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['mapping'])) {
        $this->mapping = $vals['mapping'];
      }
      if (isset($vals['update'])) {
        $this->update = $vals['update'];
      }
    }
  }

  public function getName() {
    return 'WMCreateOrUpdateMappingRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->mapping = new \metastore\WMMapping();
            $xfer += $this->mapping->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->update);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMCreateOrUpdateMappingRequest');
    if ($this->mapping !== null) {
      if (!is_object($this->mapping)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('mapping', TType::STRUCT, 1);
      $xfer += $this->mapping->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->update !== null) {
      $xfer += $output->writeFieldBegin('update', TType::BOOL, 2);
      $xfer += $output->writeBool($this->update);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMCreateOrUpdateMappingResponse {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'WMCreateOrUpdateMappingResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMCreateOrUpdateMappingResponse');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMDropMappingRequest {
  static $_TSPEC;

  /**
   * @var \metastore\WMMapping
   */
  public $mapping = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'mapping',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMMapping',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['mapping'])) {
        $this->mapping = $vals['mapping'];
      }
    }
  }

  public function getName() {
    return 'WMDropMappingRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->mapping = new \metastore\WMMapping();
            $xfer += $this->mapping->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMDropMappingRequest');
    if ($this->mapping !== null) {
      if (!is_object($this->mapping)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('mapping', TType::STRUCT, 1);
      $xfer += $this->mapping->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMDropMappingResponse {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'WMDropMappingResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMDropMappingResponse');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMCreateOrDropTriggerToPoolMappingRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $resourcePlanName = null;
  /**
   * @var string
   */
  public $triggerName = null;
  /**
   * @var string
   */
  public $poolPath = null;
  /**
   * @var bool
   */
  public $drop = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'resourcePlanName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'triggerName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'poolPath',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'drop',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['resourcePlanName'])) {
        $this->resourcePlanName = $vals['resourcePlanName'];
      }
      if (isset($vals['triggerName'])) {
        $this->triggerName = $vals['triggerName'];
      }
      if (isset($vals['poolPath'])) {
        $this->poolPath = $vals['poolPath'];
      }
      if (isset($vals['drop'])) {
        $this->drop = $vals['drop'];
      }
    }
  }

  public function getName() {
    return 'WMCreateOrDropTriggerToPoolMappingRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->resourcePlanName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->triggerName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->poolPath);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->drop);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMCreateOrDropTriggerToPoolMappingRequest');
    if ($this->resourcePlanName !== null) {
      $xfer += $output->writeFieldBegin('resourcePlanName', TType::STRING, 1);
      $xfer += $output->writeString($this->resourcePlanName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->triggerName !== null) {
      $xfer += $output->writeFieldBegin('triggerName', TType::STRING, 2);
      $xfer += $output->writeString($this->triggerName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->poolPath !== null) {
      $xfer += $output->writeFieldBegin('poolPath', TType::STRING, 3);
      $xfer += $output->writeString($this->poolPath);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->drop !== null) {
      $xfer += $output->writeFieldBegin('drop', TType::BOOL, 4);
      $xfer += $output->writeBool($this->drop);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WMCreateOrDropTriggerToPoolMappingResponse {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'WMCreateOrDropTriggerToPoolMappingResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WMCreateOrDropTriggerToPoolMappingResponse');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ISchema {
  static $_TSPEC;

  /**
   * @var int
   */
  public $schemaType = null;
  /**
   * @var string
   */
  public $name = null;
  /**
   * @var string
   */
  public $catName = null;
  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var int
   */
  public $compatibility = null;
  /**
   * @var int
   */
  public $validationLevel = null;
  /**
   * @var bool
   */
  public $canEvolve = null;
  /**
   * @var string
   */
  public $schemaGroup = null;
  /**
   * @var string
   */
  public $description = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'schemaType',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'compatibility',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'validationLevel',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'canEvolve',
          'type' => TType::BOOL,
          ),
        8 => array(
          'var' => 'schemaGroup',
          'type' => TType::STRING,
          ),
        9 => array(
          'var' => 'description',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['schemaType'])) {
        $this->schemaType = $vals['schemaType'];
      }
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['compatibility'])) {
        $this->compatibility = $vals['compatibility'];
      }
      if (isset($vals['validationLevel'])) {
        $this->validationLevel = $vals['validationLevel'];
      }
      if (isset($vals['canEvolve'])) {
        $this->canEvolve = $vals['canEvolve'];
      }
      if (isset($vals['schemaGroup'])) {
        $this->schemaGroup = $vals['schemaGroup'];
      }
      if (isset($vals['description'])) {
        $this->description = $vals['description'];
      }
    }
  }

  public function getName() {
    return 'ISchema';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->schemaType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->compatibility);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->validationLevel);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->canEvolve);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schemaGroup);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->description);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ISchema');
    if ($this->schemaType !== null) {
      $xfer += $output->writeFieldBegin('schemaType', TType::I32, 1);
      $xfer += $output->writeI32($this->schemaType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 3);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 4);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->compatibility !== null) {
      $xfer += $output->writeFieldBegin('compatibility', TType::I32, 5);
      $xfer += $output->writeI32($this->compatibility);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->validationLevel !== null) {
      $xfer += $output->writeFieldBegin('validationLevel', TType::I32, 6);
      $xfer += $output->writeI32($this->validationLevel);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->canEvolve !== null) {
      $xfer += $output->writeFieldBegin('canEvolve', TType::BOOL, 7);
      $xfer += $output->writeBool($this->canEvolve);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->schemaGroup !== null) {
      $xfer += $output->writeFieldBegin('schemaGroup', TType::STRING, 8);
      $xfer += $output->writeString($this->schemaGroup);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->description !== null) {
      $xfer += $output->writeFieldBegin('description', TType::STRING, 9);
      $xfer += $output->writeString($this->description);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ISchemaName {
  static $_TSPEC;

  /**
   * @var string
   */
  public $catName = null;
  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $schemaName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'catName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'schemaName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['catName'])) {
        $this->catName = $vals['catName'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['schemaName'])) {
        $this->schemaName = $vals['schemaName'];
      }
    }
  }

  public function getName() {
    return 'ISchemaName';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schemaName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ISchemaName');
    if ($this->catName !== null) {
      $xfer += $output->writeFieldBegin('catName', TType::STRING, 1);
      $xfer += $output->writeString($this->catName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->schemaName !== null) {
      $xfer += $output->writeFieldBegin('schemaName', TType::STRING, 3);
      $xfer += $output->writeString($this->schemaName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AlterISchemaRequest {
  static $_TSPEC;

  /**
   * @var \metastore\ISchemaName
   */
  public $name = null;
  /**
   * @var \metastore\ISchema
   */
  public $newSchema = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRUCT,
          'class' => '\metastore\ISchemaName',
          ),
        3 => array(
          'var' => 'newSchema',
          'type' => TType::STRUCT,
          'class' => '\metastore\ISchema',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['newSchema'])) {
        $this->newSchema = $vals['newSchema'];
      }
    }
  }

  public function getName() {
    return 'AlterISchemaRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->name = new \metastore\ISchemaName();
            $xfer += $this->name->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->newSchema = new \metastore\ISchema();
            $xfer += $this->newSchema->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AlterISchemaRequest');
    if ($this->name !== null) {
      if (!is_object($this->name)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('name', TType::STRUCT, 1);
      $xfer += $this->name->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newSchema !== null) {
      if (!is_object($this->newSchema)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('newSchema', TType::STRUCT, 3);
      $xfer += $this->newSchema->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SchemaVersion {
  static $_TSPEC;

  /**
   * @var \metastore\ISchemaName
   */
  public $schema = null;
  /**
   * @var int
   */
  public $version = null;
  /**
   * @var int
   */
  public $createdAt = null;
  /**
   * @var \metastore\FieldSchema[]
   */
  public $cols = null;
  /**
   * @var int
   */
  public $state = null;
  /**
   * @var string
   */
  public $description = null;
  /**
   * @var string
   */
  public $schemaText = null;
  /**
   * @var string
   */
  public $fingerprint = null;
  /**
   * @var string
   */
  public $name = null;
  /**
   * @var \metastore\SerDeInfo
   */
  public $serDe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'schema',
          'type' => TType::STRUCT,
          'class' => '\metastore\ISchemaName',
          ),
        2 => array(
          'var' => 'version',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'createdAt',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'cols',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\FieldSchema',
            ),
          ),
        5 => array(
          'var' => 'state',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'description',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'schemaText',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'fingerprint',
          'type' => TType::STRING,
          ),
        9 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        10 => array(
          'var' => 'serDe',
          'type' => TType::STRUCT,
          'class' => '\metastore\SerDeInfo',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['schema'])) {
        $this->schema = $vals['schema'];
      }
      if (isset($vals['version'])) {
        $this->version = $vals['version'];
      }
      if (isset($vals['createdAt'])) {
        $this->createdAt = $vals['createdAt'];
      }
      if (isset($vals['cols'])) {
        $this->cols = $vals['cols'];
      }
      if (isset($vals['state'])) {
        $this->state = $vals['state'];
      }
      if (isset($vals['description'])) {
        $this->description = $vals['description'];
      }
      if (isset($vals['schemaText'])) {
        $this->schemaText = $vals['schemaText'];
      }
      if (isset($vals['fingerprint'])) {
        $this->fingerprint = $vals['fingerprint'];
      }
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['serDe'])) {
        $this->serDe = $vals['serDe'];
      }
    }
  }

  public function getName() {
    return 'SchemaVersion';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->schema = new \metastore\ISchemaName();
            $xfer += $this->schema->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->version);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->createdAt);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->cols = array();
            $_size799 = 0;
            $_etype802 = 0;
            $xfer += $input->readListBegin($_etype802, $_size799);
            for ($_i803 = 0; $_i803 < $_size799; ++$_i803)
            {
              $elem804 = null;
              $elem804 = new \metastore\FieldSchema();
              $xfer += $elem804->read($input);
              $this->cols []= $elem804;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->state);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->description);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schemaText);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->fingerprint);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->serDe = new \metastore\SerDeInfo();
            $xfer += $this->serDe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SchemaVersion');
    if ($this->schema !== null) {
      if (!is_object($this->schema)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('schema', TType::STRUCT, 1);
      $xfer += $this->schema->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->version !== null) {
      $xfer += $output->writeFieldBegin('version', TType::I32, 2);
      $xfer += $output->writeI32($this->version);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->createdAt !== null) {
      $xfer += $output->writeFieldBegin('createdAt', TType::I64, 3);
      $xfer += $output->writeI64($this->createdAt);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cols !== null) {
      if (!is_array($this->cols)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('cols', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRUCT, count($this->cols));
        {
          foreach ($this->cols as $iter805)
          {
            $xfer += $iter805->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->state !== null) {
      $xfer += $output->writeFieldBegin('state', TType::I32, 5);
      $xfer += $output->writeI32($this->state);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->description !== null) {
      $xfer += $output->writeFieldBegin('description', TType::STRING, 6);
      $xfer += $output->writeString($this->description);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->schemaText !== null) {
      $xfer += $output->writeFieldBegin('schemaText', TType::STRING, 7);
      $xfer += $output->writeString($this->schemaText);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->fingerprint !== null) {
      $xfer += $output->writeFieldBegin('fingerprint', TType::STRING, 8);
      $xfer += $output->writeString($this->fingerprint);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 9);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->serDe !== null) {
      if (!is_object($this->serDe)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('serDe', TType::STRUCT, 10);
      $xfer += $this->serDe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SchemaVersionDescriptor {
  static $_TSPEC;

  /**
   * @var \metastore\ISchemaName
   */
  public $schema = null;
  /**
   * @var int
   */
  public $version = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'schema',
          'type' => TType::STRUCT,
          'class' => '\metastore\ISchemaName',
          ),
        2 => array(
          'var' => 'version',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['schema'])) {
        $this->schema = $vals['schema'];
      }
      if (isset($vals['version'])) {
        $this->version = $vals['version'];
      }
    }
  }

  public function getName() {
    return 'SchemaVersionDescriptor';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->schema = new \metastore\ISchemaName();
            $xfer += $this->schema->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->version);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SchemaVersionDescriptor');
    if ($this->schema !== null) {
      if (!is_object($this->schema)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('schema', TType::STRUCT, 1);
      $xfer += $this->schema->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->version !== null) {
      $xfer += $output->writeFieldBegin('version', TType::I32, 2);
      $xfer += $output->writeI32($this->version);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class FindSchemasByColsRqst {
  static $_TSPEC;

  /**
   * @var string
   */
  public $colName = null;
  /**
   * @var string
   */
  public $colNamespace = null;
  /**
   * @var string
   */
  public $type = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'colName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'colNamespace',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'type',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['colName'])) {
        $this->colName = $vals['colName'];
      }
      if (isset($vals['colNamespace'])) {
        $this->colNamespace = $vals['colNamespace'];
      }
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
    }
  }

  public function getName() {
    return 'FindSchemasByColsRqst';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->colName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->colNamespace);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('FindSchemasByColsRqst');
    if ($this->colName !== null) {
      $xfer += $output->writeFieldBegin('colName', TType::STRING, 1);
      $xfer += $output->writeString($this->colName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->colNamespace !== null) {
      $xfer += $output->writeFieldBegin('colNamespace', TType::STRING, 2);
      $xfer += $output->writeString($this->colNamespace);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::STRING, 3);
      $xfer += $output->writeString($this->type);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class FindSchemasByColsResp {
  static $_TSPEC;

  /**
   * @var \metastore\SchemaVersionDescriptor[]
   */
  public $schemaVersions = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'schemaVersions',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SchemaVersionDescriptor',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['schemaVersions'])) {
        $this->schemaVersions = $vals['schemaVersions'];
      }
    }
  }

  public function getName() {
    return 'FindSchemasByColsResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->schemaVersions = array();
            $_size806 = 0;
            $_etype809 = 0;
            $xfer += $input->readListBegin($_etype809, $_size806);
            for ($_i810 = 0; $_i810 < $_size806; ++$_i810)
            {
              $elem811 = null;
              $elem811 = new \metastore\SchemaVersionDescriptor();
              $xfer += $elem811->read($input);
              $this->schemaVersions []= $elem811;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('FindSchemasByColsResp');
    if ($this->schemaVersions !== null) {
      if (!is_array($this->schemaVersions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('schemaVersions', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->schemaVersions));
        {
          foreach ($this->schemaVersions as $iter812)
          {
            $xfer += $iter812->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MapSchemaVersionToSerdeRequest {
  static $_TSPEC;

  /**
   * @var \metastore\SchemaVersionDescriptor
   */
  public $schemaVersion = null;
  /**
   * @var string
   */
  public $serdeName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'schemaVersion',
          'type' => TType::STRUCT,
          'class' => '\metastore\SchemaVersionDescriptor',
          ),
        2 => array(
          'var' => 'serdeName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['schemaVersion'])) {
        $this->schemaVersion = $vals['schemaVersion'];
      }
      if (isset($vals['serdeName'])) {
        $this->serdeName = $vals['serdeName'];
      }
    }
  }

  public function getName() {
    return 'MapSchemaVersionToSerdeRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->schemaVersion = new \metastore\SchemaVersionDescriptor();
            $xfer += $this->schemaVersion->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->serdeName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MapSchemaVersionToSerdeRequest');
    if ($this->schemaVersion !== null) {
      if (!is_object($this->schemaVersion)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('schemaVersion', TType::STRUCT, 1);
      $xfer += $this->schemaVersion->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->serdeName !== null) {
      $xfer += $output->writeFieldBegin('serdeName', TType::STRING, 2);
      $xfer += $output->writeString($this->serdeName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SetSchemaVersionStateRequest {
  static $_TSPEC;

  /**
   * @var \metastore\SchemaVersionDescriptor
   */
  public $schemaVersion = null;
  /**
   * @var int
   */
  public $state = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'schemaVersion',
          'type' => TType::STRUCT,
          'class' => '\metastore\SchemaVersionDescriptor',
          ),
        2 => array(
          'var' => 'state',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['schemaVersion'])) {
        $this->schemaVersion = $vals['schemaVersion'];
      }
      if (isset($vals['state'])) {
        $this->state = $vals['state'];
      }
    }
  }

  public function getName() {
    return 'SetSchemaVersionStateRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->schemaVersion = new \metastore\SchemaVersionDescriptor();
            $xfer += $this->schemaVersion->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->state);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SetSchemaVersionStateRequest');
    if ($this->schemaVersion !== null) {
      if (!is_object($this->schemaVersion)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('schemaVersion', TType::STRUCT, 1);
      $xfer += $this->schemaVersion->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->state !== null) {
      $xfer += $output->writeFieldBegin('state', TType::I32, 2);
      $xfer += $output->writeI32($this->state);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetSerdeRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $serdeName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'serdeName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['serdeName'])) {
        $this->serdeName = $vals['serdeName'];
      }
    }
  }

  public function getName() {
    return 'GetSerdeRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->serdeName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetSerdeRequest');
    if ($this->serdeName !== null) {
      $xfer += $output->writeFieldBegin('serdeName', TType::STRING, 1);
      $xfer += $output->writeString($this->serdeName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class RuntimeStat {
  static $_TSPEC;

  /**
   * @var int
   */
  public $createTime = null;
  /**
   * @var int
   */
  public $weight = null;
  /**
   * @var string
   */
  public $payload = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'createTime',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'weight',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'payload',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['createTime'])) {
        $this->createTime = $vals['createTime'];
      }
      if (isset($vals['weight'])) {
        $this->weight = $vals['weight'];
      }
      if (isset($vals['payload'])) {
        $this->payload = $vals['payload'];
      }
    }
  }

  public function getName() {
    return 'RuntimeStat';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->createTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->weight);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->payload);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('RuntimeStat');
    if ($this->createTime !== null) {
      $xfer += $output->writeFieldBegin('createTime', TType::I32, 1);
      $xfer += $output->writeI32($this->createTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->weight !== null) {
      $xfer += $output->writeFieldBegin('weight', TType::I32, 2);
      $xfer += $output->writeI32($this->weight);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->payload !== null) {
      $xfer += $output->writeFieldBegin('payload', TType::STRING, 3);
      $xfer += $output->writeString($this->payload);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetRuntimeStatsRequest {
  static $_TSPEC;

  /**
   * @var int
   */
  public $maxWeight = null;
  /**
   * @var int
   */
  public $maxCreateTime = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'maxWeight',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'maxCreateTime',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['maxWeight'])) {
        $this->maxWeight = $vals['maxWeight'];
      }
      if (isset($vals['maxCreateTime'])) {
        $this->maxCreateTime = $vals['maxCreateTime'];
      }
    }
  }

  public function getName() {
    return 'GetRuntimeStatsRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->maxWeight);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->maxCreateTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetRuntimeStatsRequest');
    if ($this->maxWeight !== null) {
      $xfer += $output->writeFieldBegin('maxWeight', TType::I32, 1);
      $xfer += $output->writeI32($this->maxWeight);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxCreateTime !== null) {
      $xfer += $output->writeFieldBegin('maxCreateTime', TType::I32, 2);
      $xfer += $output->writeI32($this->maxCreateTime);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MetaException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'MetaException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MetaException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class UnknownTableException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'UnknownTableException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('UnknownTableException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class UnknownDBException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'UnknownDBException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('UnknownDBException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AlreadyExistsException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'AlreadyExistsException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AlreadyExistsException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class InvalidPartitionException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'InvalidPartitionException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('InvalidPartitionException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class UnknownPartitionException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'UnknownPartitionException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('UnknownPartitionException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class InvalidObjectException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'InvalidObjectException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('InvalidObjectException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NoSuchObjectException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'NoSuchObjectException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NoSuchObjectException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class InvalidOperationException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'InvalidOperationException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('InvalidOperationException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ConfigValSecurityException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'ConfigValSecurityException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ConfigValSecurityException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class InvalidInputException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'InvalidInputException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('InvalidInputException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NoSuchTxnException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'NoSuchTxnException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NoSuchTxnException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TxnAbortedException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'TxnAbortedException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TxnAbortedException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TxnOpenException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'TxnOpenException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TxnOpenException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NoSuchLockException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'NoSuchLockException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NoSuchLockException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

final class Constant extends \Thrift\Type\TConstant {
  static protected $DDL_TIME;
  static protected $HIVE_FILTER_FIELD_OWNER;
  static protected $HIVE_FILTER_FIELD_PARAMS;
  static protected $HIVE_FILTER_FIELD_LAST_ACCESS;
  static protected $IS_ARCHIVED;
  static protected $ORIGINAL_LOCATION;
  static protected $IS_IMMUTABLE;
  static protected $META_TABLE_COLUMNS;
  static protected $META_TABLE_COLUMN_TYPES;
  static protected $BUCKET_FIELD_NAME;
  static protected $BUCKET_COUNT;
  static protected $FIELD_TO_DIMENSION;
  static protected $META_TABLE_NAME;
  static protected $META_TABLE_DB;
  static protected $META_TABLE_LOCATION;
  static protected $META_TABLE_SERDE;
  static protected $META_TABLE_PARTITION_COLUMNS;
  static protected $META_TABLE_PARTITION_COLUMN_TYPES;
  static protected $FILE_INPUT_FORMAT;
  static protected $FILE_OUTPUT_FORMAT;
  static protected $META_TABLE_STORAGE;
  static protected $TABLE_IS_TRANSACTIONAL;
  static protected $TABLE_NO_AUTO_COMPACT;
  static protected $TABLE_TRANSACTIONAL_PROPERTIES;

  static protected function init_DDL_TIME() {
    return "transient_lastDdlTime";
  }

  static protected function init_HIVE_FILTER_FIELD_OWNER() {
    return "hive_filter_field_owner__";
  }

  static protected function init_HIVE_FILTER_FIELD_PARAMS() {
    return "hive_filter_field_params__";
  }

  static protected function init_HIVE_FILTER_FIELD_LAST_ACCESS() {
    return "hive_filter_field_last_access__";
  }

  static protected function init_IS_ARCHIVED() {
    return "is_archived";
  }

  static protected function init_ORIGINAL_LOCATION() {
    return "original_location";
  }

  static protected function init_IS_IMMUTABLE() {
    return "immutable";
  }

  static protected function init_META_TABLE_COLUMNS() {
    return "columns";
  }

  static protected function init_META_TABLE_COLUMN_TYPES() {
    return "columns.types";
  }

  static protected function init_BUCKET_FIELD_NAME() {
    return "bucket_field_name";
  }

  static protected function init_BUCKET_COUNT() {
    return "bucket_count";
  }

  static protected function init_FIELD_TO_DIMENSION() {
    return "field_to_dimension";
  }

  static protected function init_META_TABLE_NAME() {
    return "name";
  }

  static protected function init_META_TABLE_DB() {
    return "db";
  }

  static protected function init_META_TABLE_LOCATION() {
    return "location";
  }

  static protected function init_META_TABLE_SERDE() {
    return "serde";
  }

  static protected function init_META_TABLE_PARTITION_COLUMNS() {
    return "partition_columns";
  }

  static protected function init_META_TABLE_PARTITION_COLUMN_TYPES() {
    return "partition_columns.types";
  }

  static protected function init_FILE_INPUT_FORMAT() {
    return "file.inputformat";
  }

  static protected function init_FILE_OUTPUT_FORMAT() {
    return "file.outputformat";
  }

  static protected function init_META_TABLE_STORAGE() {
    return "storage_handler";
  }

  static protected function init_TABLE_IS_TRANSACTIONAL() {
    return "transactional";
  }

  static protected function init_TABLE_NO_AUTO_COMPACT() {
    return "no_auto_compaction";
  }

  static protected function init_TABLE_TRANSACTIONAL_PROPERTIES() {
    return "transactional_properties";
  }
}


