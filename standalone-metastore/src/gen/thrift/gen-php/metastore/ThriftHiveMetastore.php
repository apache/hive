<?php
namespace metastore;
/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


/**
 * This interface is live.
 */
interface ThriftHiveMetastoreIf extends \FacebookServiceIf {
  /**
   * @param string $key
   * @return string
   * @throws \metastore\MetaException
   */
  public function getMetaConf($key);
  /**
   * @param string $key
   * @param string $value
   * @throws \metastore\MetaException
   */
  public function setMetaConf($key, $value);
  /**
   * @param \metastore\Database $database
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\MetaException
   */
  public function create_database(\metastore\Database $database);
  /**
   * @param string $name
   * @return \metastore\Database
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function get_database($name);
  /**
   * @param string $name
   * @param bool $deleteData
   * @param bool $cascade
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\InvalidOperationException
   * @throws \metastore\MetaException
   */
  public function drop_database($name, $deleteData, $cascade);
  /**
   * @param string $pattern
   * @return string[]
   * @throws \metastore\MetaException
   */
  public function get_databases($pattern);
  /**
   * @return string[]
   * @throws \metastore\MetaException
   */
  public function get_all_databases();
  /**
   * @param string $dbname
   * @param \metastore\Database $db
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function alter_database($dbname, \metastore\Database $db);
  /**
   * @param string $name
   * @return \metastore\Type
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function get_type($name);
  /**
   * @param \metastore\Type $type
   * @return bool
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\MetaException
   */
  public function create_type(\metastore\Type $type);
  /**
   * @param string $type
   * @return bool
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function drop_type($type);
  /**
   * @param string $name
   * @return array
   * @throws \metastore\MetaException
   */
  public function get_type_all($name);
  /**
   * @param string $db_name
   * @param string $table_name
   * @return \metastore\FieldSchema[]
   * @throws \metastore\MetaException
   * @throws \metastore\UnknownTableException
   * @throws \metastore\UnknownDBException
   */
  public function get_fields($db_name, $table_name);
  /**
   * @param string $db_name
   * @param string $table_name
   * @param \metastore\EnvironmentContext $environment_context
   * @return \metastore\FieldSchema[]
   * @throws \metastore\MetaException
   * @throws \metastore\UnknownTableException
   * @throws \metastore\UnknownDBException
   */
  public function get_fields_with_environment_context($db_name, $table_name, \metastore\EnvironmentContext $environment_context);
  /**
   * @param string $db_name
   * @param string $table_name
   * @return \metastore\FieldSchema[]
   * @throws \metastore\MetaException
   * @throws \metastore\UnknownTableException
   * @throws \metastore\UnknownDBException
   */
  public function get_schema($db_name, $table_name);
  /**
   * @param string $db_name
   * @param string $table_name
   * @param \metastore\EnvironmentContext $environment_context
   * @return \metastore\FieldSchema[]
   * @throws \metastore\MetaException
   * @throws \metastore\UnknownTableException
   * @throws \metastore\UnknownDBException
   */
  public function get_schema_with_environment_context($db_name, $table_name, \metastore\EnvironmentContext $environment_context);
  /**
   * @param \metastore\Table $tbl
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function create_table(\metastore\Table $tbl);
  /**
   * @param \metastore\Table $tbl
   * @param \metastore\EnvironmentContext $environment_context
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function create_table_with_environment_context(\metastore\Table $tbl, \metastore\EnvironmentContext $environment_context);
  /**
   * @param \metastore\Table $tbl
   * @param \metastore\SQLPrimaryKey[] $primaryKeys
   * @param \metastore\SQLForeignKey[] $foreignKeys
   * @param \metastore\SQLUniqueConstraint[] $uniqueConstraints
   * @param \metastore\SQLNotNullConstraint[] $notNullConstraints
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function create_table_with_constraints(\metastore\Table $tbl, array $primaryKeys, array $foreignKeys, array $uniqueConstraints, array $notNullConstraints);
  /**
   * @param \metastore\DropConstraintRequest $req
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function drop_constraint(\metastore\DropConstraintRequest $req);
  /**
   * @param \metastore\AddPrimaryKeyRequest $req
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function add_primary_key(\metastore\AddPrimaryKeyRequest $req);
  /**
   * @param \metastore\AddForeignKeyRequest $req
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function add_foreign_key(\metastore\AddForeignKeyRequest $req);
  /**
   * @param \metastore\AddUniqueConstraintRequest $req
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function add_unique_constraint(\metastore\AddUniqueConstraintRequest $req);
  /**
   * @param \metastore\AddNotNullConstraintRequest $req
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function add_not_null_constraint(\metastore\AddNotNullConstraintRequest $req);
  /**
   * @param string $dbname
   * @param string $name
   * @param bool $deleteData
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function drop_table($dbname, $name, $deleteData);
  /**
   * @param string $dbname
   * @param string $name
   * @param bool $deleteData
   * @param \metastore\EnvironmentContext $environment_context
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function drop_table_with_environment_context($dbname, $name, $deleteData, \metastore\EnvironmentContext $environment_context);
  /**
   * @param string $dbName
   * @param string $tableName
   * @param string[] $partNames
   * @throws \metastore\MetaException
   */
  public function truncate_table($dbName, $tableName, array $partNames);
  /**
   * @param string $db_name
   * @param string $pattern
   * @return string[]
   * @throws \metastore\MetaException
   */
  public function get_tables($db_name, $pattern);
  /**
   * @param string $db_name
   * @param string $pattern
   * @param string $tableType
   * @return string[]
   * @throws \metastore\MetaException
   */
  public function get_tables_by_type($db_name, $pattern, $tableType);
  /**
   * @param string $db_name
   * @return string[]
   * @throws \metastore\MetaException
   */
  public function get_materialized_views_for_rewriting($db_name);
  /**
   * @param string $db_patterns
   * @param string $tbl_patterns
   * @param string[] $tbl_types
   * @return \metastore\TableMeta[]
   * @throws \metastore\MetaException
   */
  public function get_table_meta($db_patterns, $tbl_patterns, array $tbl_types);
  /**
   * @param string $db_name
   * @return string[]
   * @throws \metastore\MetaException
   */
  public function get_all_tables($db_name);
  /**
   * @param string $dbname
   * @param string $tbl_name
   * @return \metastore\Table
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function get_table($dbname, $tbl_name);
  /**
   * @param string $dbname
   * @param string[] $tbl_names
   * @return \metastore\Table[]
   */
  public function get_table_objects_by_name($dbname, array $tbl_names);
  /**
   * @param \metastore\GetTableRequest $req
   * @return \metastore\GetTableResult
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function get_table_req(\metastore\GetTableRequest $req);
  /**
   * @param \metastore\GetTablesRequest $req
   * @return \metastore\GetTablesResult
   * @throws \metastore\MetaException
   * @throws \metastore\InvalidOperationException
   * @throws \metastore\UnknownDBException
   */
  public function get_table_objects_by_name_req(\metastore\GetTablesRequest $req);
  /**
   * @param string $dbname
   * @param string[] $tbl_names
   * @return array
   * @throws \metastore\MetaException
   * @throws \metastore\InvalidOperationException
   * @throws \metastore\UnknownDBException
   */
  public function get_materialization_invalidation_info($dbname, array $tbl_names);
  /**
   * @param string $dbname
   * @param string $tbl_name
   * @param \metastore\CreationMetadata $creation_metadata
   * @throws \metastore\MetaException
   * @throws \metastore\InvalidOperationException
   * @throws \metastore\UnknownDBException
   */
  public function update_creation_metadata($dbname, $tbl_name, \metastore\CreationMetadata $creation_metadata);
  /**
   * @param string $dbname
   * @param string $filter
   * @param int $max_tables
   * @return string[]
   * @throws \metastore\MetaException
   * @throws \metastore\InvalidOperationException
   * @throws \metastore\UnknownDBException
   */
  public function get_table_names_by_filter($dbname, $filter, $max_tables);
  /**
   * @param string $dbname
   * @param string $tbl_name
   * @param \metastore\Table $new_tbl
   * @throws \metastore\InvalidOperationException
   * @throws \metastore\MetaException
   */
  public function alter_table($dbname, $tbl_name, \metastore\Table $new_tbl);
  /**
   * @param string $dbname
   * @param string $tbl_name
   * @param \metastore\Table $new_tbl
   * @param \metastore\EnvironmentContext $environment_context
   * @throws \metastore\InvalidOperationException
   * @throws \metastore\MetaException
   */
  public function alter_table_with_environment_context($dbname, $tbl_name, \metastore\Table $new_tbl, \metastore\EnvironmentContext $environment_context);
  /**
   * @param string $dbname
   * @param string $tbl_name
   * @param \metastore\Table $new_tbl
   * @param bool $cascade
   * @throws \metastore\InvalidOperationException
   * @throws \metastore\MetaException
   */
  public function alter_table_with_cascade($dbname, $tbl_name, \metastore\Table $new_tbl, $cascade);
  /**
   * @param \metastore\Partition $new_part
   * @return \metastore\Partition
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\MetaException
   */
  public function add_partition(\metastore\Partition $new_part);
  /**
   * @param \metastore\Partition $new_part
   * @param \metastore\EnvironmentContext $environment_context
   * @return \metastore\Partition
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\MetaException
   */
  public function add_partition_with_environment_context(\metastore\Partition $new_part, \metastore\EnvironmentContext $environment_context);
  /**
   * @param \metastore\Partition[] $new_parts
   * @return int
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\MetaException
   */
  public function add_partitions(array $new_parts);
  /**
   * @param \metastore\PartitionSpec[] $new_parts
   * @return int
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\MetaException
   */
  public function add_partitions_pspec(array $new_parts);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string[] $part_vals
   * @return \metastore\Partition
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\MetaException
   */
  public function append_partition($db_name, $tbl_name, array $part_vals);
  /**
   * @param \metastore\AddPartitionsRequest $request
   * @return \metastore\AddPartitionsResult
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\MetaException
   */
  public function add_partitions_req(\metastore\AddPartitionsRequest $request);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string[] $part_vals
   * @param \metastore\EnvironmentContext $environment_context
   * @return \metastore\Partition
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\MetaException
   */
  public function append_partition_with_environment_context($db_name, $tbl_name, array $part_vals, \metastore\EnvironmentContext $environment_context);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string $part_name
   * @return \metastore\Partition
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\MetaException
   */
  public function append_partition_by_name($db_name, $tbl_name, $part_name);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string $part_name
   * @param \metastore\EnvironmentContext $environment_context
   * @return \metastore\Partition
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\MetaException
   */
  public function append_partition_by_name_with_environment_context($db_name, $tbl_name, $part_name, \metastore\EnvironmentContext $environment_context);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string[] $part_vals
   * @param bool $deleteData
   * @return bool
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function drop_partition($db_name, $tbl_name, array $part_vals, $deleteData);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string[] $part_vals
   * @param bool $deleteData
   * @param \metastore\EnvironmentContext $environment_context
   * @return bool
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function drop_partition_with_environment_context($db_name, $tbl_name, array $part_vals, $deleteData, \metastore\EnvironmentContext $environment_context);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string $part_name
   * @param bool $deleteData
   * @return bool
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function drop_partition_by_name($db_name, $tbl_name, $part_name, $deleteData);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string $part_name
   * @param bool $deleteData
   * @param \metastore\EnvironmentContext $environment_context
   * @return bool
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function drop_partition_by_name_with_environment_context($db_name, $tbl_name, $part_name, $deleteData, \metastore\EnvironmentContext $environment_context);
  /**
   * @param \metastore\DropPartitionsRequest $req
   * @return \metastore\DropPartitionsResult
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function drop_partitions_req(\metastore\DropPartitionsRequest $req);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string[] $part_vals
   * @return \metastore\Partition
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function get_partition($db_name, $tbl_name, array $part_vals);
  /**
   * @param array $partitionSpecs
   * @param string $source_db
   * @param string $source_table_name
   * @param string $dest_db
   * @param string $dest_table_name
   * @return \metastore\Partition
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\InvalidInputException
   */
  public function exchange_partition(array $partitionSpecs, $source_db, $source_table_name, $dest_db, $dest_table_name);
  /**
   * @param array $partitionSpecs
   * @param string $source_db
   * @param string $source_table_name
   * @param string $dest_db
   * @param string $dest_table_name
   * @return \metastore\Partition[]
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\InvalidInputException
   */
  public function exchange_partitions(array $partitionSpecs, $source_db, $source_table_name, $dest_db, $dest_table_name);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string[] $part_vals
   * @param string $user_name
   * @param string[] $group_names
   * @return \metastore\Partition
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function get_partition_with_auth($db_name, $tbl_name, array $part_vals, $user_name, array $group_names);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string $part_name
   * @return \metastore\Partition
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function get_partition_by_name($db_name, $tbl_name, $part_name);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param int $max_parts
   * @return \metastore\Partition[]
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function get_partitions($db_name, $tbl_name, $max_parts);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param int $max_parts
   * @param string $user_name
   * @param string[] $group_names
   * @return \metastore\Partition[]
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function get_partitions_with_auth($db_name, $tbl_name, $max_parts, $user_name, array $group_names);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param int $max_parts
   * @return \metastore\PartitionSpec[]
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function get_partitions_pspec($db_name, $tbl_name, $max_parts);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param int $max_parts
   * @return string[]
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function get_partition_names($db_name, $tbl_name, $max_parts);
  /**
   * @param \metastore\PartitionValuesRequest $request
   * @return \metastore\PartitionValuesResponse
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function get_partition_values(\metastore\PartitionValuesRequest $request);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string[] $part_vals
   * @param int $max_parts
   * @return \metastore\Partition[]
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function get_partitions_ps($db_name, $tbl_name, array $part_vals, $max_parts);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string[] $part_vals
   * @param int $max_parts
   * @param string $user_name
   * @param string[] $group_names
   * @return \metastore\Partition[]
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function get_partitions_ps_with_auth($db_name, $tbl_name, array $part_vals, $max_parts, $user_name, array $group_names);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string[] $part_vals
   * @param int $max_parts
   * @return string[]
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function get_partition_names_ps($db_name, $tbl_name, array $part_vals, $max_parts);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string $filter
   * @param int $max_parts
   * @return \metastore\Partition[]
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function get_partitions_by_filter($db_name, $tbl_name, $filter, $max_parts);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string $filter
   * @param int $max_parts
   * @return \metastore\PartitionSpec[]
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function get_part_specs_by_filter($db_name, $tbl_name, $filter, $max_parts);
  /**
   * @param \metastore\PartitionsByExprRequest $req
   * @return \metastore\PartitionsByExprResult
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function get_partitions_by_expr(\metastore\PartitionsByExprRequest $req);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string $filter
   * @return int
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function get_num_partitions_by_filter($db_name, $tbl_name, $filter);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string[] $names
   * @return \metastore\Partition[]
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function get_partitions_by_names($db_name, $tbl_name, array $names);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param \metastore\Partition $new_part
   * @throws \metastore\InvalidOperationException
   * @throws \metastore\MetaException
   */
  public function alter_partition($db_name, $tbl_name, \metastore\Partition $new_part);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param \metastore\Partition[] $new_parts
   * @throws \metastore\InvalidOperationException
   * @throws \metastore\MetaException
   */
  public function alter_partitions($db_name, $tbl_name, array $new_parts);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param \metastore\Partition[] $new_parts
   * @param \metastore\EnvironmentContext $environment_context
   * @throws \metastore\InvalidOperationException
   * @throws \metastore\MetaException
   */
  public function alter_partitions_with_environment_context($db_name, $tbl_name, array $new_parts, \metastore\EnvironmentContext $environment_context);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param \metastore\Partition $new_part
   * @param \metastore\EnvironmentContext $environment_context
   * @throws \metastore\InvalidOperationException
   * @throws \metastore\MetaException
   */
  public function alter_partition_with_environment_context($db_name, $tbl_name, \metastore\Partition $new_part, \metastore\EnvironmentContext $environment_context);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string[] $part_vals
   * @param \metastore\Partition $new_part
   * @throws \metastore\InvalidOperationException
   * @throws \metastore\MetaException
   */
  public function rename_partition($db_name, $tbl_name, array $part_vals, \metastore\Partition $new_part);
  /**
   * @param string[] $part_vals
   * @param bool $throw_exception
   * @return bool
   * @throws \metastore\MetaException
   */
  public function partition_name_has_valid_characters(array $part_vals, $throw_exception);
  /**
   * @param string $name
   * @param string $defaultValue
   * @return string
   * @throws \metastore\ConfigValSecurityException
   */
  public function get_config_value($name, $defaultValue);
  /**
   * @param string $part_name
   * @return string[]
   * @throws \metastore\MetaException
   */
  public function partition_name_to_vals($part_name);
  /**
   * @param string $part_name
   * @return array
   * @throws \metastore\MetaException
   */
  public function partition_name_to_spec($part_name);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param array $part_vals
   * @param int $eventType
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\UnknownDBException
   * @throws \metastore\UnknownTableException
   * @throws \metastore\UnknownPartitionException
   * @throws \metastore\InvalidPartitionException
   */
  public function markPartitionForEvent($db_name, $tbl_name, array $part_vals, $eventType);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param array $part_vals
   * @param int $eventType
   * @return bool
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\UnknownDBException
   * @throws \metastore\UnknownTableException
   * @throws \metastore\UnknownPartitionException
   * @throws \metastore\InvalidPartitionException
   */
  public function isPartitionMarkedForEvent($db_name, $tbl_name, array $part_vals, $eventType);
  /**
   * @param \metastore\Index $new_index
   * @param \metastore\Table $index_table
   * @return \metastore\Index
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\MetaException
   */
  public function add_index(\metastore\Index $new_index, \metastore\Table $index_table);
  /**
   * @param string $dbname
   * @param string $base_tbl_name
   * @param string $idx_name
   * @param \metastore\Index $new_idx
   * @throws \metastore\InvalidOperationException
   * @throws \metastore\MetaException
   */
  public function alter_index($dbname, $base_tbl_name, $idx_name, \metastore\Index $new_idx);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string $index_name
   * @param bool $deleteData
   * @return bool
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function drop_index_by_name($db_name, $tbl_name, $index_name, $deleteData);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string $index_name
   * @return \metastore\Index
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function get_index_by_name($db_name, $tbl_name, $index_name);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param int $max_indexes
   * @return \metastore\Index[]
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function get_indexes($db_name, $tbl_name, $max_indexes);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param int $max_indexes
   * @return string[]
   * @throws \metastore\MetaException
   */
  public function get_index_names($db_name, $tbl_name, $max_indexes);
  /**
   * @param \metastore\PrimaryKeysRequest $request
   * @return \metastore\PrimaryKeysResponse
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function get_primary_keys(\metastore\PrimaryKeysRequest $request);
  /**
   * @param \metastore\ForeignKeysRequest $request
   * @return \metastore\ForeignKeysResponse
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function get_foreign_keys(\metastore\ForeignKeysRequest $request);
  /**
   * @param \metastore\UniqueConstraintsRequest $request
   * @return \metastore\UniqueConstraintsResponse
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function get_unique_constraints(\metastore\UniqueConstraintsRequest $request);
  /**
   * @param \metastore\NotNullConstraintsRequest $request
   * @return \metastore\NotNullConstraintsResponse
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function get_not_null_constraints(\metastore\NotNullConstraintsRequest $request);
  /**
   * @param \metastore\ColumnStatistics $stats_obj
   * @return bool
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\MetaException
   * @throws \metastore\InvalidInputException
   */
  public function update_table_column_statistics(\metastore\ColumnStatistics $stats_obj);
  /**
   * @param \metastore\ColumnStatistics $stats_obj
   * @return bool
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\MetaException
   * @throws \metastore\InvalidInputException
   */
  public function update_partition_column_statistics(\metastore\ColumnStatistics $stats_obj);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string $col_name
   * @return \metastore\ColumnStatistics
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   * @throws \metastore\InvalidInputException
   * @throws \metastore\InvalidObjectException
   */
  public function get_table_column_statistics($db_name, $tbl_name, $col_name);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string $part_name
   * @param string $col_name
   * @return \metastore\ColumnStatistics
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   * @throws \metastore\InvalidInputException
   * @throws \metastore\InvalidObjectException
   */
  public function get_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name);
  /**
   * @param \metastore\TableStatsRequest $request
   * @return \metastore\TableStatsResult
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function get_table_statistics_req(\metastore\TableStatsRequest $request);
  /**
   * @param \metastore\PartitionsStatsRequest $request
   * @return \metastore\PartitionsStatsResult
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function get_partitions_statistics_req(\metastore\PartitionsStatsRequest $request);
  /**
   * @param \metastore\PartitionsStatsRequest $request
   * @return \metastore\AggrStats
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function get_aggr_stats_for(\metastore\PartitionsStatsRequest $request);
  /**
   * @param \metastore\SetPartitionsStatsRequest $request
   * @return bool
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\MetaException
   * @throws \metastore\InvalidInputException
   */
  public function set_aggr_stats_for(\metastore\SetPartitionsStatsRequest $request);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string $part_name
   * @param string $col_name
   * @return bool
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\InvalidInputException
   */
  public function delete_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name);
  /**
   * @param string $db_name
   * @param string $tbl_name
   * @param string $col_name
   * @return bool
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\InvalidInputException
   */
  public function delete_table_column_statistics($db_name, $tbl_name, $col_name);
  /**
   * @param \metastore\Function $func
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function create_function(\metastore\Function $func);
  /**
   * @param string $dbName
   * @param string $funcName
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function drop_function($dbName, $funcName);
  /**
   * @param string $dbName
   * @param string $funcName
   * @param \metastore\Function $newFunc
   * @throws \metastore\InvalidOperationException
   * @throws \metastore\MetaException
   */
  public function alter_function($dbName, $funcName, \metastore\Function $newFunc);
  /**
   * @param string $dbName
   * @param string $pattern
   * @return string[]
   * @throws \metastore\MetaException
   */
  public function get_functions($dbName, $pattern);
  /**
   * @param string $dbName
   * @param string $funcName
   * @return \metastore\Function
   * @throws \metastore\MetaException
   * @throws \metastore\NoSuchObjectException
   */
  public function get_function($dbName, $funcName);
  /**
   * @return \metastore\GetAllFunctionsResponse
   * @throws \metastore\MetaException
   */
  public function get_all_functions();
  /**
   * @param \metastore\Role $role
   * @return bool
   * @throws \metastore\MetaException
   */
  public function create_role(\metastore\Role $role);
  /**
   * @param string $role_name
   * @return bool
   * @throws \metastore\MetaException
   */
  public function drop_role($role_name);
  /**
   * @return string[]
   * @throws \metastore\MetaException
   */
  public function get_role_names();
  /**
   * @param string $role_name
   * @param string $principal_name
   * @param int $principal_type
   * @param string $grantor
   * @param int $grantorType
   * @param bool $grant_option
   * @return bool
   * @throws \metastore\MetaException
   */
  public function grant_role($role_name, $principal_name, $principal_type, $grantor, $grantorType, $grant_option);
  /**
   * @param string $role_name
   * @param string $principal_name
   * @param int $principal_type
   * @return bool
   * @throws \metastore\MetaException
   */
  public function revoke_role($role_name, $principal_name, $principal_type);
  /**
   * @param string $principal_name
   * @param int $principal_type
   * @return \metastore\Role[]
   * @throws \metastore\MetaException
   */
  public function list_roles($principal_name, $principal_type);
  /**
   * @param \metastore\GrantRevokeRoleRequest $request
   * @return \metastore\GrantRevokeRoleResponse
   * @throws \metastore\MetaException
   */
  public function grant_revoke_role(\metastore\GrantRevokeRoleRequest $request);
  /**
   * @param \metastore\GetPrincipalsInRoleRequest $request
   * @return \metastore\GetPrincipalsInRoleResponse
   * @throws \metastore\MetaException
   */
  public function get_principals_in_role(\metastore\GetPrincipalsInRoleRequest $request);
  /**
   * @param \metastore\GetRoleGrantsForPrincipalRequest $request
   * @return \metastore\GetRoleGrantsForPrincipalResponse
   * @throws \metastore\MetaException
   */
  public function get_role_grants_for_principal(\metastore\GetRoleGrantsForPrincipalRequest $request);
  /**
   * @param \metastore\HiveObjectRef $hiveObject
   * @param string $user_name
   * @param string[] $group_names
   * @return \metastore\PrincipalPrivilegeSet
   * @throws \metastore\MetaException
   */
  public function get_privilege_set(\metastore\HiveObjectRef $hiveObject, $user_name, array $group_names);
  /**
   * @param string $principal_name
   * @param int $principal_type
   * @param \metastore\HiveObjectRef $hiveObject
   * @return \metastore\HiveObjectPrivilege[]
   * @throws \metastore\MetaException
   */
  public function list_privileges($principal_name, $principal_type, \metastore\HiveObjectRef $hiveObject);
  /**
   * @param \metastore\PrivilegeBag $privileges
   * @return bool
   * @throws \metastore\MetaException
   */
  public function grant_privileges(\metastore\PrivilegeBag $privileges);
  /**
   * @param \metastore\PrivilegeBag $privileges
   * @return bool
   * @throws \metastore\MetaException
   */
  public function revoke_privileges(\metastore\PrivilegeBag $privileges);
  /**
   * @param \metastore\GrantRevokePrivilegeRequest $request
   * @return \metastore\GrantRevokePrivilegeResponse
   * @throws \metastore\MetaException
   */
  public function grant_revoke_privileges(\metastore\GrantRevokePrivilegeRequest $request);
  /**
   * @param string $user_name
   * @param string[] $group_names
   * @return string[]
   * @throws \metastore\MetaException
   */
  public function set_ugi($user_name, array $group_names);
  /**
   * @param string $token_owner
   * @param string $renewer_kerberos_principal_name
   * @return string
   * @throws \metastore\MetaException
   */
  public function get_delegation_token($token_owner, $renewer_kerberos_principal_name);
  /**
   * @param string $token_str_form
   * @return int
   * @throws \metastore\MetaException
   */
  public function renew_delegation_token($token_str_form);
  /**
   * @param string $token_str_form
   * @throws \metastore\MetaException
   */
  public function cancel_delegation_token($token_str_form);
  /**
   * @param string $token_identifier
   * @param string $delegation_token
   * @return bool
   */
  public function add_token($token_identifier, $delegation_token);
  /**
   * @param string $token_identifier
   * @return bool
   */
  public function remove_token($token_identifier);
  /**
   * @param string $token_identifier
   * @return string
   */
  public function get_token($token_identifier);
  /**
   * @return string[]
   */
  public function get_all_token_identifiers();
  /**
   * @param string $key
   * @return int
   * @throws \metastore\MetaException
   */
  public function add_master_key($key);
  /**
   * @param int $seq_number
   * @param string $key
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function update_master_key($seq_number, $key);
  /**
   * @param int $key_seq
   * @return bool
   */
  public function remove_master_key($key_seq);
  /**
   * @return string[]
   */
  public function get_master_keys();
  /**
   * @return \metastore\GetOpenTxnsResponse
   */
  public function get_open_txns();
  /**
   * @return \metastore\GetOpenTxnsInfoResponse
   */
  public function get_open_txns_info();
  /**
   * @param \metastore\OpenTxnRequest $rqst
   * @return \metastore\OpenTxnsResponse
   */
  public function open_txns(\metastore\OpenTxnRequest $rqst);
  /**
   * @param \metastore\AbortTxnRequest $rqst
   * @throws \metastore\NoSuchTxnException
   */
  public function abort_txn(\metastore\AbortTxnRequest $rqst);
  /**
   * @param \metastore\AbortTxnsRequest $rqst
   * @throws \metastore\NoSuchTxnException
   */
  public function abort_txns(\metastore\AbortTxnsRequest $rqst);
  /**
   * @param \metastore\CommitTxnRequest $rqst
   * @throws \metastore\NoSuchTxnException
   * @throws \metastore\TxnAbortedException
   */
  public function commit_txn(\metastore\CommitTxnRequest $rqst);
  /**
   * @param \metastore\LockRequest $rqst
   * @return \metastore\LockResponse
   * @throws \metastore\NoSuchTxnException
   * @throws \metastore\TxnAbortedException
   */
  public function lock(\metastore\LockRequest $rqst);
  /**
   * @param \metastore\CheckLockRequest $rqst
   * @return \metastore\LockResponse
   * @throws \metastore\NoSuchTxnException
   * @throws \metastore\TxnAbortedException
   * @throws \metastore\NoSuchLockException
   */
  public function check_lock(\metastore\CheckLockRequest $rqst);
  /**
   * @param \metastore\UnlockRequest $rqst
   * @throws \metastore\NoSuchLockException
   * @throws \metastore\TxnOpenException
   */
  public function unlock(\metastore\UnlockRequest $rqst);
  /**
   * @param \metastore\ShowLocksRequest $rqst
   * @return \metastore\ShowLocksResponse
   */
  public function show_locks(\metastore\ShowLocksRequest $rqst);
  /**
   * @param \metastore\HeartbeatRequest $ids
   * @throws \metastore\NoSuchLockException
   * @throws \metastore\NoSuchTxnException
   * @throws \metastore\TxnAbortedException
   */
  public function heartbeat(\metastore\HeartbeatRequest $ids);
  /**
   * @param \metastore\HeartbeatTxnRangeRequest $txns
   * @return \metastore\HeartbeatTxnRangeResponse
   */
  public function heartbeat_txn_range(\metastore\HeartbeatTxnRangeRequest $txns);
  /**
   * @param \metastore\CompactionRequest $rqst
   */
  public function compact(\metastore\CompactionRequest $rqst);
  /**
   * @param \metastore\CompactionRequest $rqst
   * @return \metastore\CompactionResponse
   */
  public function compact2(\metastore\CompactionRequest $rqst);
  /**
   * @param \metastore\ShowCompactRequest $rqst
   * @return \metastore\ShowCompactResponse
   */
  public function show_compact(\metastore\ShowCompactRequest $rqst);
  /**
   * @param \metastore\AddDynamicPartitions $rqst
   * @throws \metastore\NoSuchTxnException
   * @throws \metastore\TxnAbortedException
   */
  public function add_dynamic_partitions(\metastore\AddDynamicPartitions $rqst);
  /**
   * @param \metastore\NotificationEventRequest $rqst
   * @return \metastore\NotificationEventResponse
   */
  public function get_next_notification(\metastore\NotificationEventRequest $rqst);
  /**
   * @return \metastore\CurrentNotificationEventId
   */
  public function get_current_notificationEventId();
  /**
   * @param \metastore\NotificationEventsCountRequest $rqst
   * @return \metastore\NotificationEventsCountResponse
   */
  public function get_notification_events_count(\metastore\NotificationEventsCountRequest $rqst);
  /**
   * @param \metastore\FireEventRequest $rqst
   * @return \metastore\FireEventResponse
   */
  public function fire_listener_event(\metastore\FireEventRequest $rqst);
  /**
   */
  public function flushCache();
  /**
   * @param \metastore\CmRecycleRequest $request
   * @return \metastore\CmRecycleResponse
   * @throws \metastore\MetaException
   */
  public function cm_recycle(\metastore\CmRecycleRequest $request);
  /**
   * @param \metastore\GetFileMetadataByExprRequest $req
   * @return \metastore\GetFileMetadataByExprResult
   */
  public function get_file_metadata_by_expr(\metastore\GetFileMetadataByExprRequest $req);
  /**
   * @param \metastore\GetFileMetadataRequest $req
   * @return \metastore\GetFileMetadataResult
   */
  public function get_file_metadata(\metastore\GetFileMetadataRequest $req);
  /**
   * @param \metastore\PutFileMetadataRequest $req
   * @return \metastore\PutFileMetadataResult
   */
  public function put_file_metadata(\metastore\PutFileMetadataRequest $req);
  /**
   * @param \metastore\ClearFileMetadataRequest $req
   * @return \metastore\ClearFileMetadataResult
   */
  public function clear_file_metadata(\metastore\ClearFileMetadataRequest $req);
  /**
   * @param \metastore\CacheFileMetadataRequest $req
   * @return \metastore\CacheFileMetadataResult
   */
  public function cache_file_metadata(\metastore\CacheFileMetadataRequest $req);
  /**
   * @return string
   * @throws \metastore\MetaException
   */
  public function get_metastore_db_uuid();
  /**
   * @param \metastore\WMCreateResourcePlanRequest $request
   * @return \metastore\WMCreateResourcePlanResponse
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\MetaException
   */
  public function create_resource_plan(\metastore\WMCreateResourcePlanRequest $request);
  /**
   * @param \metastore\WMGetResourcePlanRequest $request
   * @return \metastore\WMGetResourcePlanResponse
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function get_resource_plan(\metastore\WMGetResourcePlanRequest $request);
  /**
   * @param \metastore\WMGetActiveResourcePlanRequest $request
   * @return \metastore\WMGetActiveResourcePlanResponse
   * @throws \metastore\MetaException
   */
  public function get_active_resource_plan(\metastore\WMGetActiveResourcePlanRequest $request);
  /**
   * @param \metastore\WMGetAllResourcePlanRequest $request
   * @return \metastore\WMGetAllResourcePlanResponse
   * @throws \metastore\MetaException
   */
  public function get_all_resource_plans(\metastore\WMGetAllResourcePlanRequest $request);
  /**
   * @param \metastore\WMAlterResourcePlanRequest $request
   * @return \metastore\WMAlterResourcePlanResponse
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\InvalidOperationException
   * @throws \metastore\MetaException
   */
  public function alter_resource_plan(\metastore\WMAlterResourcePlanRequest $request);
  /**
   * @param \metastore\WMValidateResourcePlanRequest $request
   * @return \metastore\WMValidateResourcePlanResponse
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function validate_resource_plan(\metastore\WMValidateResourcePlanRequest $request);
  /**
   * @param \metastore\WMDropResourcePlanRequest $request
   * @return \metastore\WMDropResourcePlanResponse
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\InvalidOperationException
   * @throws \metastore\MetaException
   */
  public function drop_resource_plan(\metastore\WMDropResourcePlanRequest $request);
  /**
   * @param \metastore\WMCreateTriggerRequest $request
   * @return \metastore\WMCreateTriggerResponse
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\MetaException
   */
  public function create_wm_trigger(\metastore\WMCreateTriggerRequest $request);
  /**
   * @param \metastore\WMAlterTriggerRequest $request
   * @return \metastore\WMAlterTriggerResponse
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\MetaException
   */
  public function alter_wm_trigger(\metastore\WMAlterTriggerRequest $request);
  /**
   * @param \metastore\WMDropTriggerRequest $request
   * @return \metastore\WMDropTriggerResponse
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\InvalidOperationException
   * @throws \metastore\MetaException
   */
  public function drop_wm_trigger(\metastore\WMDropTriggerRequest $request);
  /**
   * @param \metastore\WMGetTriggersForResourePlanRequest $request
   * @return \metastore\WMGetTriggersForResourePlanResponse
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\MetaException
   */
  public function get_triggers_for_resourceplan(\metastore\WMGetTriggersForResourePlanRequest $request);
  /**
   * @param \metastore\WMCreatePoolRequest $request
   * @return \metastore\WMCreatePoolResponse
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\MetaException
   */
  public function create_wm_pool(\metastore\WMCreatePoolRequest $request);
  /**
   * @param \metastore\WMAlterPoolRequest $request
   * @return \metastore\WMAlterPoolResponse
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\MetaException
   */
  public function alter_wm_pool(\metastore\WMAlterPoolRequest $request);
  /**
   * @param \metastore\WMDropPoolRequest $request
   * @return \metastore\WMDropPoolResponse
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\InvalidOperationException
   * @throws \metastore\MetaException
   */
  public function drop_wm_pool(\metastore\WMDropPoolRequest $request);
  /**
   * @param \metastore\WMCreateOrUpdateMappingRequest $request
   * @return \metastore\WMCreateOrUpdateMappingResponse
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\MetaException
   */
  public function create_or_update_wm_mapping(\metastore\WMCreateOrUpdateMappingRequest $request);
  /**
   * @param \metastore\WMDropMappingRequest $request
   * @return \metastore\WMDropMappingResponse
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\InvalidOperationException
   * @throws \metastore\MetaException
   */
  public function drop_wm_mapping(\metastore\WMDropMappingRequest $request);
  /**
   * @param \metastore\WMCreateOrDropTriggerToPoolMappingRequest $request
   * @return \metastore\WMCreateOrDropTriggerToPoolMappingResponse
   * @throws \metastore\AlreadyExistsException
   * @throws \metastore\NoSuchObjectException
   * @throws \metastore\InvalidObjectException
   * @throws \metastore\MetaException
   */
  public function create_or_drop_wm_trigger_to_pool_mapping(\metastore\WMCreateOrDropTriggerToPoolMappingRequest $request);
}

class ThriftHiveMetastoreClient extends \FacebookServiceClient implements \metastore\ThriftHiveMetastoreIf {
  public function __construct($input, $output=null) {
    parent::__construct($input, $output);
  }

  public function getMetaConf($key)
  {
    $this->send_getMetaConf($key);
    return $this->recv_getMetaConf();
  }

  public function send_getMetaConf($key)
  {
    $args = new \metastore\ThriftHiveMetastore_getMetaConf_args();
    $args->key = $key;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getMetaConf', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getMetaConf', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getMetaConf()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_getMetaConf_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_getMetaConf_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("getMetaConf failed: unknown result");
  }

  public function setMetaConf($key, $value)
  {
    $this->send_setMetaConf($key, $value);
    $this->recv_setMetaConf();
  }

  public function send_setMetaConf($key, $value)
  {
    $args = new \metastore\ThriftHiveMetastore_setMetaConf_args();
    $args->key = $key;
    $args->value = $value;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'setMetaConf', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('setMetaConf', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_setMetaConf()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_setMetaConf_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_setMetaConf_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    return;
  }

  public function create_database(\metastore\Database $database)
  {
    $this->send_create_database($database);
    $this->recv_create_database();
  }

  public function send_create_database(\metastore\Database $database)
  {
    $args = new \metastore\ThriftHiveMetastore_create_database_args();
    $args->database = $database;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_database', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_database', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_database()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_database_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_database_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    return;
  }

  public function get_database($name)
  {
    $this->send_get_database($name);
    return $this->recv_get_database();
  }

  public function send_get_database($name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_database_args();
    $args->name = $name;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_database', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_database', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_database()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_database_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_database_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_database failed: unknown result");
  }

  public function drop_database($name, $deleteData, $cascade)
  {
    $this->send_drop_database($name, $deleteData, $cascade);
    $this->recv_drop_database();
  }

  public function send_drop_database($name, $deleteData, $cascade)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_database_args();
    $args->name = $name;
    $args->deleteData = $deleteData;
    $args->cascade = $cascade;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_database', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_database', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_database()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_database_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_database_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    return;
  }

  public function get_databases($pattern)
  {
    $this->send_get_databases($pattern);
    return $this->recv_get_databases();
  }

  public function send_get_databases($pattern)
  {
    $args = new \metastore\ThriftHiveMetastore_get_databases_args();
    $args->pattern = $pattern;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_databases', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_databases', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_databases()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_databases_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_databases_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_databases failed: unknown result");
  }

  public function get_all_databases()
  {
    $this->send_get_all_databases();
    return $this->recv_get_all_databases();
  }

  public function send_get_all_databases()
  {
    $args = new \metastore\ThriftHiveMetastore_get_all_databases_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_all_databases', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_all_databases', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_all_databases()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_all_databases_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_all_databases_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_all_databases failed: unknown result");
  }

  public function alter_database($dbname, \metastore\Database $db)
  {
    $this->send_alter_database($dbname, $db);
    $this->recv_alter_database();
  }

  public function send_alter_database($dbname, \metastore\Database $db)
  {
    $args = new \metastore\ThriftHiveMetastore_alter_database_args();
    $args->dbname = $dbname;
    $args->db = $db;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'alter_database', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('alter_database', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_alter_database()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_alter_database_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_alter_database_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function get_type($name)
  {
    $this->send_get_type($name);
    return $this->recv_get_type();
  }

  public function send_get_type($name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_type_args();
    $args->name = $name;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_type', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_type', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_type()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_type_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_type_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_type failed: unknown result");
  }

  public function create_type(\metastore\Type $type)
  {
    $this->send_create_type($type);
    return $this->recv_create_type();
  }

  public function send_create_type(\metastore\Type $type)
  {
    $args = new \metastore\ThriftHiveMetastore_create_type_args();
    $args->type = $type;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_type', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_type', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_type()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_type_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_type_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("create_type failed: unknown result");
  }

  public function drop_type($type)
  {
    $this->send_drop_type($type);
    return $this->recv_drop_type();
  }

  public function send_drop_type($type)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_type_args();
    $args->type = $type;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_type', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_type', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_type()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_type_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_type_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("drop_type failed: unknown result");
  }

  public function get_type_all($name)
  {
    $this->send_get_type_all($name);
    return $this->recv_get_type_all();
  }

  public function send_get_type_all($name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_type_all_args();
    $args->name = $name;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_type_all', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_type_all', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_type_all()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_type_all_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_type_all_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_type_all failed: unknown result");
  }

  public function get_fields($db_name, $table_name)
  {
    $this->send_get_fields($db_name, $table_name);
    return $this->recv_get_fields();
  }

  public function send_get_fields($db_name, $table_name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_fields_args();
    $args->db_name = $db_name;
    $args->table_name = $table_name;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_fields', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_fields', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_fields()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_fields_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_fields_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("get_fields failed: unknown result");
  }

  public function get_fields_with_environment_context($db_name, $table_name, \metastore\EnvironmentContext $environment_context)
  {
    $this->send_get_fields_with_environment_context($db_name, $table_name, $environment_context);
    return $this->recv_get_fields_with_environment_context();
  }

  public function send_get_fields_with_environment_context($db_name, $table_name, \metastore\EnvironmentContext $environment_context)
  {
    $args = new \metastore\ThriftHiveMetastore_get_fields_with_environment_context_args();
    $args->db_name = $db_name;
    $args->table_name = $table_name;
    $args->environment_context = $environment_context;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_fields_with_environment_context', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_fields_with_environment_context', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_fields_with_environment_context()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_fields_with_environment_context_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_fields_with_environment_context_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("get_fields_with_environment_context failed: unknown result");
  }

  public function get_schema($db_name, $table_name)
  {
    $this->send_get_schema($db_name, $table_name);
    return $this->recv_get_schema();
  }

  public function send_get_schema($db_name, $table_name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_schema_args();
    $args->db_name = $db_name;
    $args->table_name = $table_name;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_schema', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_schema', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_schema()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_schema_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_schema_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("get_schema failed: unknown result");
  }

  public function get_schema_with_environment_context($db_name, $table_name, \metastore\EnvironmentContext $environment_context)
  {
    $this->send_get_schema_with_environment_context($db_name, $table_name, $environment_context);
    return $this->recv_get_schema_with_environment_context();
  }

  public function send_get_schema_with_environment_context($db_name, $table_name, \metastore\EnvironmentContext $environment_context)
  {
    $args = new \metastore\ThriftHiveMetastore_get_schema_with_environment_context_args();
    $args->db_name = $db_name;
    $args->table_name = $table_name;
    $args->environment_context = $environment_context;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_schema_with_environment_context', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_schema_with_environment_context', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_schema_with_environment_context()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_schema_with_environment_context_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_schema_with_environment_context_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("get_schema_with_environment_context failed: unknown result");
  }

  public function create_table(\metastore\Table $tbl)
  {
    $this->send_create_table($tbl);
    $this->recv_create_table();
  }

  public function send_create_table(\metastore\Table $tbl)
  {
    $args = new \metastore\ThriftHiveMetastore_create_table_args();
    $args->tbl = $tbl;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_table', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_table', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_table()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_table_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_table_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    return;
  }

  public function create_table_with_environment_context(\metastore\Table $tbl, \metastore\EnvironmentContext $environment_context)
  {
    $this->send_create_table_with_environment_context($tbl, $environment_context);
    $this->recv_create_table_with_environment_context();
  }

  public function send_create_table_with_environment_context(\metastore\Table $tbl, \metastore\EnvironmentContext $environment_context)
  {
    $args = new \metastore\ThriftHiveMetastore_create_table_with_environment_context_args();
    $args->tbl = $tbl;
    $args->environment_context = $environment_context;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_table_with_environment_context', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_table_with_environment_context', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_table_with_environment_context()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_table_with_environment_context_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_table_with_environment_context_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    return;
  }

  public function create_table_with_constraints(\metastore\Table $tbl, array $primaryKeys, array $foreignKeys, array $uniqueConstraints, array $notNullConstraints)
  {
    $this->send_create_table_with_constraints($tbl, $primaryKeys, $foreignKeys, $uniqueConstraints, $notNullConstraints);
    $this->recv_create_table_with_constraints();
  }

  public function send_create_table_with_constraints(\metastore\Table $tbl, array $primaryKeys, array $foreignKeys, array $uniqueConstraints, array $notNullConstraints)
  {
    $args = new \metastore\ThriftHiveMetastore_create_table_with_constraints_args();
    $args->tbl = $tbl;
    $args->primaryKeys = $primaryKeys;
    $args->foreignKeys = $foreignKeys;
    $args->uniqueConstraints = $uniqueConstraints;
    $args->notNullConstraints = $notNullConstraints;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_table_with_constraints', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_table_with_constraints', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_table_with_constraints()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_table_with_constraints_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_table_with_constraints_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    return;
  }

  public function drop_constraint(\metastore\DropConstraintRequest $req)
  {
    $this->send_drop_constraint($req);
    $this->recv_drop_constraint();
  }

  public function send_drop_constraint(\metastore\DropConstraintRequest $req)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_constraint_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_constraint', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_constraint', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_constraint()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_constraint_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_constraint_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    return;
  }

  public function add_primary_key(\metastore\AddPrimaryKeyRequest $req)
  {
    $this->send_add_primary_key($req);
    $this->recv_add_primary_key();
  }

  public function send_add_primary_key(\metastore\AddPrimaryKeyRequest $req)
  {
    $args = new \metastore\ThriftHiveMetastore_add_primary_key_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_primary_key', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_primary_key', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_primary_key()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_primary_key_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_primary_key_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function add_foreign_key(\metastore\AddForeignKeyRequest $req)
  {
    $this->send_add_foreign_key($req);
    $this->recv_add_foreign_key();
  }

  public function send_add_foreign_key(\metastore\AddForeignKeyRequest $req)
  {
    $args = new \metastore\ThriftHiveMetastore_add_foreign_key_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_foreign_key', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_foreign_key', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_foreign_key()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_foreign_key_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_foreign_key_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function add_unique_constraint(\metastore\AddUniqueConstraintRequest $req)
  {
    $this->send_add_unique_constraint($req);
    $this->recv_add_unique_constraint();
  }

  public function send_add_unique_constraint(\metastore\AddUniqueConstraintRequest $req)
  {
    $args = new \metastore\ThriftHiveMetastore_add_unique_constraint_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_unique_constraint', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_unique_constraint', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_unique_constraint()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_unique_constraint_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_unique_constraint_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function add_not_null_constraint(\metastore\AddNotNullConstraintRequest $req)
  {
    $this->send_add_not_null_constraint($req);
    $this->recv_add_not_null_constraint();
  }

  public function send_add_not_null_constraint(\metastore\AddNotNullConstraintRequest $req)
  {
    $args = new \metastore\ThriftHiveMetastore_add_not_null_constraint_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_not_null_constraint', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_not_null_constraint', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_not_null_constraint()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_not_null_constraint_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_not_null_constraint_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function drop_table($dbname, $name, $deleteData)
  {
    $this->send_drop_table($dbname, $name, $deleteData);
    $this->recv_drop_table();
  }

  public function send_drop_table($dbname, $name, $deleteData)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_table_args();
    $args->dbname = $dbname;
    $args->name = $name;
    $args->deleteData = $deleteData;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_table', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_table', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_table()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_table_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_table_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    return;
  }

  public function drop_table_with_environment_context($dbname, $name, $deleteData, \metastore\EnvironmentContext $environment_context)
  {
    $this->send_drop_table_with_environment_context($dbname, $name, $deleteData, $environment_context);
    $this->recv_drop_table_with_environment_context();
  }

  public function send_drop_table_with_environment_context($dbname, $name, $deleteData, \metastore\EnvironmentContext $environment_context)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_table_with_environment_context_args();
    $args->dbname = $dbname;
    $args->name = $name;
    $args->deleteData = $deleteData;
    $args->environment_context = $environment_context;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_table_with_environment_context', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_table_with_environment_context', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_table_with_environment_context()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_table_with_environment_context_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_table_with_environment_context_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    return;
  }

  public function truncate_table($dbName, $tableName, array $partNames)
  {
    $this->send_truncate_table($dbName, $tableName, $partNames);
    $this->recv_truncate_table();
  }

  public function send_truncate_table($dbName, $tableName, array $partNames)
  {
    $args = new \metastore\ThriftHiveMetastore_truncate_table_args();
    $args->dbName = $dbName;
    $args->tableName = $tableName;
    $args->partNames = $partNames;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'truncate_table', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('truncate_table', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_truncate_table()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_truncate_table_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_truncate_table_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    return;
  }

  public function get_tables($db_name, $pattern)
  {
    $this->send_get_tables($db_name, $pattern);
    return $this->recv_get_tables();
  }

  public function send_get_tables($db_name, $pattern)
  {
    $args = new \metastore\ThriftHiveMetastore_get_tables_args();
    $args->db_name = $db_name;
    $args->pattern = $pattern;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_tables', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_tables', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_tables()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_tables_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_tables_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_tables failed: unknown result");
  }

  public function get_tables_by_type($db_name, $pattern, $tableType)
  {
    $this->send_get_tables_by_type($db_name, $pattern, $tableType);
    return $this->recv_get_tables_by_type();
  }

  public function send_get_tables_by_type($db_name, $pattern, $tableType)
  {
    $args = new \metastore\ThriftHiveMetastore_get_tables_by_type_args();
    $args->db_name = $db_name;
    $args->pattern = $pattern;
    $args->tableType = $tableType;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_tables_by_type', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_tables_by_type', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_tables_by_type()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_tables_by_type_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_tables_by_type_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_tables_by_type failed: unknown result");
  }

  public function get_materialized_views_for_rewriting($db_name)
  {
    $this->send_get_materialized_views_for_rewriting($db_name);
    return $this->recv_get_materialized_views_for_rewriting();
  }

  public function send_get_materialized_views_for_rewriting($db_name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_materialized_views_for_rewriting_args();
    $args->db_name = $db_name;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_materialized_views_for_rewriting', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_materialized_views_for_rewriting', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_materialized_views_for_rewriting()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_materialized_views_for_rewriting_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_materialized_views_for_rewriting_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_materialized_views_for_rewriting failed: unknown result");
  }

  public function get_table_meta($db_patterns, $tbl_patterns, array $tbl_types)
  {
    $this->send_get_table_meta($db_patterns, $tbl_patterns, $tbl_types);
    return $this->recv_get_table_meta();
  }

  public function send_get_table_meta($db_patterns, $tbl_patterns, array $tbl_types)
  {
    $args = new \metastore\ThriftHiveMetastore_get_table_meta_args();
    $args->db_patterns = $db_patterns;
    $args->tbl_patterns = $tbl_patterns;
    $args->tbl_types = $tbl_types;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_table_meta', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_table_meta', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_table_meta()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_table_meta_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_table_meta_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_table_meta failed: unknown result");
  }

  public function get_all_tables($db_name)
  {
    $this->send_get_all_tables($db_name);
    return $this->recv_get_all_tables();
  }

  public function send_get_all_tables($db_name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_all_tables_args();
    $args->db_name = $db_name;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_all_tables', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_all_tables', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_all_tables()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_all_tables_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_all_tables_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_all_tables failed: unknown result");
  }

  public function get_table($dbname, $tbl_name)
  {
    $this->send_get_table($dbname, $tbl_name);
    return $this->recv_get_table();
  }

  public function send_get_table($dbname, $tbl_name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_table_args();
    $args->dbname = $dbname;
    $args->tbl_name = $tbl_name;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_table', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_table', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_table()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_table_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_table_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_table failed: unknown result");
  }

  public function get_table_objects_by_name($dbname, array $tbl_names)
  {
    $this->send_get_table_objects_by_name($dbname, $tbl_names);
    return $this->recv_get_table_objects_by_name();
  }

  public function send_get_table_objects_by_name($dbname, array $tbl_names)
  {
    $args = new \metastore\ThriftHiveMetastore_get_table_objects_by_name_args();
    $args->dbname = $dbname;
    $args->tbl_names = $tbl_names;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_table_objects_by_name', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_table_objects_by_name', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_table_objects_by_name()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_table_objects_by_name_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_table_objects_by_name_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("get_table_objects_by_name failed: unknown result");
  }

  public function get_table_req(\metastore\GetTableRequest $req)
  {
    $this->send_get_table_req($req);
    return $this->recv_get_table_req();
  }

  public function send_get_table_req(\metastore\GetTableRequest $req)
  {
    $args = new \metastore\ThriftHiveMetastore_get_table_req_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_table_req', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_table_req', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_table_req()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_table_req_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_table_req_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_table_req failed: unknown result");
  }

  public function get_table_objects_by_name_req(\metastore\GetTablesRequest $req)
  {
    $this->send_get_table_objects_by_name_req($req);
    return $this->recv_get_table_objects_by_name_req();
  }

  public function send_get_table_objects_by_name_req(\metastore\GetTablesRequest $req)
  {
    $args = new \metastore\ThriftHiveMetastore_get_table_objects_by_name_req_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_table_objects_by_name_req', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_table_objects_by_name_req', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_table_objects_by_name_req()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_table_objects_by_name_req_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_table_objects_by_name_req_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("get_table_objects_by_name_req failed: unknown result");
  }

  public function get_materialization_invalidation_info($dbname, array $tbl_names)
  {
    $this->send_get_materialization_invalidation_info($dbname, $tbl_names);
    return $this->recv_get_materialization_invalidation_info();
  }

  public function send_get_materialization_invalidation_info($dbname, array $tbl_names)
  {
    $args = new \metastore\ThriftHiveMetastore_get_materialization_invalidation_info_args();
    $args->dbname = $dbname;
    $args->tbl_names = $tbl_names;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_materialization_invalidation_info', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_materialization_invalidation_info', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_materialization_invalidation_info()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_materialization_invalidation_info_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_materialization_invalidation_info_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("get_materialization_invalidation_info failed: unknown result");
  }

  public function update_creation_metadata($dbname, $tbl_name, \metastore\CreationMetadata $creation_metadata)
  {
    $this->send_update_creation_metadata($dbname, $tbl_name, $creation_metadata);
    $this->recv_update_creation_metadata();
  }

  public function send_update_creation_metadata($dbname, $tbl_name, \metastore\CreationMetadata $creation_metadata)
  {
    $args = new \metastore\ThriftHiveMetastore_update_creation_metadata_args();
    $args->dbname = $dbname;
    $args->tbl_name = $tbl_name;
    $args->creation_metadata = $creation_metadata;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'update_creation_metadata', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('update_creation_metadata', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_update_creation_metadata()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_update_creation_metadata_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_update_creation_metadata_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    return;
  }

  public function get_table_names_by_filter($dbname, $filter, $max_tables)
  {
    $this->send_get_table_names_by_filter($dbname, $filter, $max_tables);
    return $this->recv_get_table_names_by_filter();
  }

  public function send_get_table_names_by_filter($dbname, $filter, $max_tables)
  {
    $args = new \metastore\ThriftHiveMetastore_get_table_names_by_filter_args();
    $args->dbname = $dbname;
    $args->filter = $filter;
    $args->max_tables = $max_tables;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_table_names_by_filter', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_table_names_by_filter', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_table_names_by_filter()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_table_names_by_filter_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_table_names_by_filter_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("get_table_names_by_filter failed: unknown result");
  }

  public function alter_table($dbname, $tbl_name, \metastore\Table $new_tbl)
  {
    $this->send_alter_table($dbname, $tbl_name, $new_tbl);
    $this->recv_alter_table();
  }

  public function send_alter_table($dbname, $tbl_name, \metastore\Table $new_tbl)
  {
    $args = new \metastore\ThriftHiveMetastore_alter_table_args();
    $args->dbname = $dbname;
    $args->tbl_name = $tbl_name;
    $args->new_tbl = $new_tbl;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'alter_table', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('alter_table', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_alter_table()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_alter_table_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_alter_table_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function alter_table_with_environment_context($dbname, $tbl_name, \metastore\Table $new_tbl, \metastore\EnvironmentContext $environment_context)
  {
    $this->send_alter_table_with_environment_context($dbname, $tbl_name, $new_tbl, $environment_context);
    $this->recv_alter_table_with_environment_context();
  }

  public function send_alter_table_with_environment_context($dbname, $tbl_name, \metastore\Table $new_tbl, \metastore\EnvironmentContext $environment_context)
  {
    $args = new \metastore\ThriftHiveMetastore_alter_table_with_environment_context_args();
    $args->dbname = $dbname;
    $args->tbl_name = $tbl_name;
    $args->new_tbl = $new_tbl;
    $args->environment_context = $environment_context;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'alter_table_with_environment_context', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('alter_table_with_environment_context', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_alter_table_with_environment_context()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_alter_table_with_environment_context_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_alter_table_with_environment_context_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function alter_table_with_cascade($dbname, $tbl_name, \metastore\Table $new_tbl, $cascade)
  {
    $this->send_alter_table_with_cascade($dbname, $tbl_name, $new_tbl, $cascade);
    $this->recv_alter_table_with_cascade();
  }

  public function send_alter_table_with_cascade($dbname, $tbl_name, \metastore\Table $new_tbl, $cascade)
  {
    $args = new \metastore\ThriftHiveMetastore_alter_table_with_cascade_args();
    $args->dbname = $dbname;
    $args->tbl_name = $tbl_name;
    $args->new_tbl = $new_tbl;
    $args->cascade = $cascade;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'alter_table_with_cascade', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('alter_table_with_cascade', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_alter_table_with_cascade()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_alter_table_with_cascade_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_alter_table_with_cascade_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function add_partition(\metastore\Partition $new_part)
  {
    $this->send_add_partition($new_part);
    return $this->recv_add_partition();
  }

  public function send_add_partition(\metastore\Partition $new_part)
  {
    $args = new \metastore\ThriftHiveMetastore_add_partition_args();
    $args->new_part = $new_part;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_partition', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_partition', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_partition()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_partition_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_partition_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("add_partition failed: unknown result");
  }

  public function add_partition_with_environment_context(\metastore\Partition $new_part, \metastore\EnvironmentContext $environment_context)
  {
    $this->send_add_partition_with_environment_context($new_part, $environment_context);
    return $this->recv_add_partition_with_environment_context();
  }

  public function send_add_partition_with_environment_context(\metastore\Partition $new_part, \metastore\EnvironmentContext $environment_context)
  {
    $args = new \metastore\ThriftHiveMetastore_add_partition_with_environment_context_args();
    $args->new_part = $new_part;
    $args->environment_context = $environment_context;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_partition_with_environment_context', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_partition_with_environment_context', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_partition_with_environment_context()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_partition_with_environment_context_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_partition_with_environment_context_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("add_partition_with_environment_context failed: unknown result");
  }

  public function add_partitions(array $new_parts)
  {
    $this->send_add_partitions($new_parts);
    return $this->recv_add_partitions();
  }

  public function send_add_partitions(array $new_parts)
  {
    $args = new \metastore\ThriftHiveMetastore_add_partitions_args();
    $args->new_parts = $new_parts;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_partitions', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_partitions', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_partitions()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_partitions_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_partitions_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("add_partitions failed: unknown result");
  }

  public function add_partitions_pspec(array $new_parts)
  {
    $this->send_add_partitions_pspec($new_parts);
    return $this->recv_add_partitions_pspec();
  }

  public function send_add_partitions_pspec(array $new_parts)
  {
    $args = new \metastore\ThriftHiveMetastore_add_partitions_pspec_args();
    $args->new_parts = $new_parts;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_partitions_pspec', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_partitions_pspec', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_partitions_pspec()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_partitions_pspec_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_partitions_pspec_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("add_partitions_pspec failed: unknown result");
  }

  public function append_partition($db_name, $tbl_name, array $part_vals)
  {
    $this->send_append_partition($db_name, $tbl_name, $part_vals);
    return $this->recv_append_partition();
  }

  public function send_append_partition($db_name, $tbl_name, array $part_vals)
  {
    $args = new \metastore\ThriftHiveMetastore_append_partition_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'append_partition', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('append_partition', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_append_partition()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_append_partition_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_append_partition_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("append_partition failed: unknown result");
  }

  public function add_partitions_req(\metastore\AddPartitionsRequest $request)
  {
    $this->send_add_partitions_req($request);
    return $this->recv_add_partitions_req();
  }

  public function send_add_partitions_req(\metastore\AddPartitionsRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_add_partitions_req_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_partitions_req', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_partitions_req', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_partitions_req()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_partitions_req_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_partitions_req_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("add_partitions_req failed: unknown result");
  }

  public function append_partition_with_environment_context($db_name, $tbl_name, array $part_vals, \metastore\EnvironmentContext $environment_context)
  {
    $this->send_append_partition_with_environment_context($db_name, $tbl_name, $part_vals, $environment_context);
    return $this->recv_append_partition_with_environment_context();
  }

  public function send_append_partition_with_environment_context($db_name, $tbl_name, array $part_vals, \metastore\EnvironmentContext $environment_context)
  {
    $args = new \metastore\ThriftHiveMetastore_append_partition_with_environment_context_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $args->environment_context = $environment_context;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'append_partition_with_environment_context', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('append_partition_with_environment_context', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_append_partition_with_environment_context()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_append_partition_with_environment_context_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_append_partition_with_environment_context_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("append_partition_with_environment_context failed: unknown result");
  }

  public function append_partition_by_name($db_name, $tbl_name, $part_name)
  {
    $this->send_append_partition_by_name($db_name, $tbl_name, $part_name);
    return $this->recv_append_partition_by_name();
  }

  public function send_append_partition_by_name($db_name, $tbl_name, $part_name)
  {
    $args = new \metastore\ThriftHiveMetastore_append_partition_by_name_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_name = $part_name;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'append_partition_by_name', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('append_partition_by_name', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_append_partition_by_name()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_append_partition_by_name_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_append_partition_by_name_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("append_partition_by_name failed: unknown result");
  }

  public function append_partition_by_name_with_environment_context($db_name, $tbl_name, $part_name, \metastore\EnvironmentContext $environment_context)
  {
    $this->send_append_partition_by_name_with_environment_context($db_name, $tbl_name, $part_name, $environment_context);
    return $this->recv_append_partition_by_name_with_environment_context();
  }

  public function send_append_partition_by_name_with_environment_context($db_name, $tbl_name, $part_name, \metastore\EnvironmentContext $environment_context)
  {
    $args = new \metastore\ThriftHiveMetastore_append_partition_by_name_with_environment_context_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_name = $part_name;
    $args->environment_context = $environment_context;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'append_partition_by_name_with_environment_context', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('append_partition_by_name_with_environment_context', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_append_partition_by_name_with_environment_context()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_append_partition_by_name_with_environment_context_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_append_partition_by_name_with_environment_context_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("append_partition_by_name_with_environment_context failed: unknown result");
  }

  public function drop_partition($db_name, $tbl_name, array $part_vals, $deleteData)
  {
    $this->send_drop_partition($db_name, $tbl_name, $part_vals, $deleteData);
    return $this->recv_drop_partition();
  }

  public function send_drop_partition($db_name, $tbl_name, array $part_vals, $deleteData)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_partition_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $args->deleteData = $deleteData;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_partition', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_partition', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_partition()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_partition_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_partition_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("drop_partition failed: unknown result");
  }

  public function drop_partition_with_environment_context($db_name, $tbl_name, array $part_vals, $deleteData, \metastore\EnvironmentContext $environment_context)
  {
    $this->send_drop_partition_with_environment_context($db_name, $tbl_name, $part_vals, $deleteData, $environment_context);
    return $this->recv_drop_partition_with_environment_context();
  }

  public function send_drop_partition_with_environment_context($db_name, $tbl_name, array $part_vals, $deleteData, \metastore\EnvironmentContext $environment_context)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_partition_with_environment_context_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $args->deleteData = $deleteData;
    $args->environment_context = $environment_context;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_partition_with_environment_context', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_partition_with_environment_context', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_partition_with_environment_context()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_partition_with_environment_context_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_partition_with_environment_context_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("drop_partition_with_environment_context failed: unknown result");
  }

  public function drop_partition_by_name($db_name, $tbl_name, $part_name, $deleteData)
  {
    $this->send_drop_partition_by_name($db_name, $tbl_name, $part_name, $deleteData);
    return $this->recv_drop_partition_by_name();
  }

  public function send_drop_partition_by_name($db_name, $tbl_name, $part_name, $deleteData)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_partition_by_name_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_name = $part_name;
    $args->deleteData = $deleteData;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_partition_by_name', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_partition_by_name', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_partition_by_name()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_partition_by_name_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_partition_by_name_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("drop_partition_by_name failed: unknown result");
  }

  public function drop_partition_by_name_with_environment_context($db_name, $tbl_name, $part_name, $deleteData, \metastore\EnvironmentContext $environment_context)
  {
    $this->send_drop_partition_by_name_with_environment_context($db_name, $tbl_name, $part_name, $deleteData, $environment_context);
    return $this->recv_drop_partition_by_name_with_environment_context();
  }

  public function send_drop_partition_by_name_with_environment_context($db_name, $tbl_name, $part_name, $deleteData, \metastore\EnvironmentContext $environment_context)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_partition_by_name_with_environment_context_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_name = $part_name;
    $args->deleteData = $deleteData;
    $args->environment_context = $environment_context;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_partition_by_name_with_environment_context', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_partition_by_name_with_environment_context', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_partition_by_name_with_environment_context()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_partition_by_name_with_environment_context_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_partition_by_name_with_environment_context_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("drop_partition_by_name_with_environment_context failed: unknown result");
  }

  public function drop_partitions_req(\metastore\DropPartitionsRequest $req)
  {
    $this->send_drop_partitions_req($req);
    return $this->recv_drop_partitions_req();
  }

  public function send_drop_partitions_req(\metastore\DropPartitionsRequest $req)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_partitions_req_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_partitions_req', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_partitions_req', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_partitions_req()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_partitions_req_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_partitions_req_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("drop_partitions_req failed: unknown result");
  }

  public function get_partition($db_name, $tbl_name, array $part_vals)
  {
    $this->send_get_partition($db_name, $tbl_name, $part_vals);
    return $this->recv_get_partition();
  }

  public function send_get_partition($db_name, $tbl_name, array $part_vals)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partition_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partition', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partition', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partition()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partition_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partition_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partition failed: unknown result");
  }

  public function exchange_partition(array $partitionSpecs, $source_db, $source_table_name, $dest_db, $dest_table_name)
  {
    $this->send_exchange_partition($partitionSpecs, $source_db, $source_table_name, $dest_db, $dest_table_name);
    return $this->recv_exchange_partition();
  }

  public function send_exchange_partition(array $partitionSpecs, $source_db, $source_table_name, $dest_db, $dest_table_name)
  {
    $args = new \metastore\ThriftHiveMetastore_exchange_partition_args();
    $args->partitionSpecs = $partitionSpecs;
    $args->source_db = $source_db;
    $args->source_table_name = $source_table_name;
    $args->dest_db = $dest_db;
    $args->dest_table_name = $dest_table_name;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'exchange_partition', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('exchange_partition', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_exchange_partition()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_exchange_partition_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_exchange_partition_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    throw new \Exception("exchange_partition failed: unknown result");
  }

  public function exchange_partitions(array $partitionSpecs, $source_db, $source_table_name, $dest_db, $dest_table_name)
  {
    $this->send_exchange_partitions($partitionSpecs, $source_db, $source_table_name, $dest_db, $dest_table_name);
    return $this->recv_exchange_partitions();
  }

  public function send_exchange_partitions(array $partitionSpecs, $source_db, $source_table_name, $dest_db, $dest_table_name)
  {
    $args = new \metastore\ThriftHiveMetastore_exchange_partitions_args();
    $args->partitionSpecs = $partitionSpecs;
    $args->source_db = $source_db;
    $args->source_table_name = $source_table_name;
    $args->dest_db = $dest_db;
    $args->dest_table_name = $dest_table_name;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'exchange_partitions', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('exchange_partitions', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_exchange_partitions()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_exchange_partitions_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_exchange_partitions_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    throw new \Exception("exchange_partitions failed: unknown result");
  }

  public function get_partition_with_auth($db_name, $tbl_name, array $part_vals, $user_name, array $group_names)
  {
    $this->send_get_partition_with_auth($db_name, $tbl_name, $part_vals, $user_name, $group_names);
    return $this->recv_get_partition_with_auth();
  }

  public function send_get_partition_with_auth($db_name, $tbl_name, array $part_vals, $user_name, array $group_names)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partition_with_auth_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $args->user_name = $user_name;
    $args->group_names = $group_names;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partition_with_auth', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partition_with_auth', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partition_with_auth()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partition_with_auth_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partition_with_auth_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partition_with_auth failed: unknown result");
  }

  public function get_partition_by_name($db_name, $tbl_name, $part_name)
  {
    $this->send_get_partition_by_name($db_name, $tbl_name, $part_name);
    return $this->recv_get_partition_by_name();
  }

  public function send_get_partition_by_name($db_name, $tbl_name, $part_name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partition_by_name_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_name = $part_name;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partition_by_name', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partition_by_name', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partition_by_name()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partition_by_name_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partition_by_name_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partition_by_name failed: unknown result");
  }

  public function get_partitions($db_name, $tbl_name, $max_parts)
  {
    $this->send_get_partitions($db_name, $tbl_name, $max_parts);
    return $this->recv_get_partitions();
  }

  public function send_get_partitions($db_name, $tbl_name, $max_parts)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partitions_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->max_parts = $max_parts;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partitions', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partitions', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partitions()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partitions_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partitions_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partitions failed: unknown result");
  }

  public function get_partitions_with_auth($db_name, $tbl_name, $max_parts, $user_name, array $group_names)
  {
    $this->send_get_partitions_with_auth($db_name, $tbl_name, $max_parts, $user_name, $group_names);
    return $this->recv_get_partitions_with_auth();
  }

  public function send_get_partitions_with_auth($db_name, $tbl_name, $max_parts, $user_name, array $group_names)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partitions_with_auth_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->max_parts = $max_parts;
    $args->user_name = $user_name;
    $args->group_names = $group_names;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partitions_with_auth', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partitions_with_auth', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partitions_with_auth()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partitions_with_auth_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partitions_with_auth_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partitions_with_auth failed: unknown result");
  }

  public function get_partitions_pspec($db_name, $tbl_name, $max_parts)
  {
    $this->send_get_partitions_pspec($db_name, $tbl_name, $max_parts);
    return $this->recv_get_partitions_pspec();
  }

  public function send_get_partitions_pspec($db_name, $tbl_name, $max_parts)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partitions_pspec_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->max_parts = $max_parts;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partitions_pspec', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partitions_pspec', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partitions_pspec()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partitions_pspec_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partitions_pspec_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partitions_pspec failed: unknown result");
  }

  public function get_partition_names($db_name, $tbl_name, $max_parts)
  {
    $this->send_get_partition_names($db_name, $tbl_name, $max_parts);
    return $this->recv_get_partition_names();
  }

  public function send_get_partition_names($db_name, $tbl_name, $max_parts)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partition_names_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->max_parts = $max_parts;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partition_names', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partition_names', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partition_names()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partition_names_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partition_names_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partition_names failed: unknown result");
  }

  public function get_partition_values(\metastore\PartitionValuesRequest $request)
  {
    $this->send_get_partition_values($request);
    return $this->recv_get_partition_values();
  }

  public function send_get_partition_values(\metastore\PartitionValuesRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partition_values_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partition_values', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partition_values', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partition_values()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partition_values_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partition_values_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partition_values failed: unknown result");
  }

  public function get_partitions_ps($db_name, $tbl_name, array $part_vals, $max_parts)
  {
    $this->send_get_partitions_ps($db_name, $tbl_name, $part_vals, $max_parts);
    return $this->recv_get_partitions_ps();
  }

  public function send_get_partitions_ps($db_name, $tbl_name, array $part_vals, $max_parts)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partitions_ps_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $args->max_parts = $max_parts;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partitions_ps', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partitions_ps', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partitions_ps()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partitions_ps_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partitions_ps_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partitions_ps failed: unknown result");
  }

  public function get_partitions_ps_with_auth($db_name, $tbl_name, array $part_vals, $max_parts, $user_name, array $group_names)
  {
    $this->send_get_partitions_ps_with_auth($db_name, $tbl_name, $part_vals, $max_parts, $user_name, $group_names);
    return $this->recv_get_partitions_ps_with_auth();
  }

  public function send_get_partitions_ps_with_auth($db_name, $tbl_name, array $part_vals, $max_parts, $user_name, array $group_names)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partitions_ps_with_auth_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $args->max_parts = $max_parts;
    $args->user_name = $user_name;
    $args->group_names = $group_names;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partitions_ps_with_auth', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partitions_ps_with_auth', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partitions_ps_with_auth()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partitions_ps_with_auth_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partitions_ps_with_auth_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partitions_ps_with_auth failed: unknown result");
  }

  public function get_partition_names_ps($db_name, $tbl_name, array $part_vals, $max_parts)
  {
    $this->send_get_partition_names_ps($db_name, $tbl_name, $part_vals, $max_parts);
    return $this->recv_get_partition_names_ps();
  }

  public function send_get_partition_names_ps($db_name, $tbl_name, array $part_vals, $max_parts)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partition_names_ps_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $args->max_parts = $max_parts;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partition_names_ps', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partition_names_ps', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partition_names_ps()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partition_names_ps_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partition_names_ps_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partition_names_ps failed: unknown result");
  }

  public function get_partitions_by_filter($db_name, $tbl_name, $filter, $max_parts)
  {
    $this->send_get_partitions_by_filter($db_name, $tbl_name, $filter, $max_parts);
    return $this->recv_get_partitions_by_filter();
  }

  public function send_get_partitions_by_filter($db_name, $tbl_name, $filter, $max_parts)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partitions_by_filter_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->filter = $filter;
    $args->max_parts = $max_parts;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partitions_by_filter', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partitions_by_filter', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partitions_by_filter()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partitions_by_filter_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partitions_by_filter_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partitions_by_filter failed: unknown result");
  }

  public function get_part_specs_by_filter($db_name, $tbl_name, $filter, $max_parts)
  {
    $this->send_get_part_specs_by_filter($db_name, $tbl_name, $filter, $max_parts);
    return $this->recv_get_part_specs_by_filter();
  }

  public function send_get_part_specs_by_filter($db_name, $tbl_name, $filter, $max_parts)
  {
    $args = new \metastore\ThriftHiveMetastore_get_part_specs_by_filter_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->filter = $filter;
    $args->max_parts = $max_parts;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_part_specs_by_filter', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_part_specs_by_filter', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_part_specs_by_filter()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_part_specs_by_filter_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_part_specs_by_filter_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_part_specs_by_filter failed: unknown result");
  }

  public function get_partitions_by_expr(\metastore\PartitionsByExprRequest $req)
  {
    $this->send_get_partitions_by_expr($req);
    return $this->recv_get_partitions_by_expr();
  }

  public function send_get_partitions_by_expr(\metastore\PartitionsByExprRequest $req)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partitions_by_expr_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partitions_by_expr', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partitions_by_expr', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partitions_by_expr()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partitions_by_expr_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partitions_by_expr_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partitions_by_expr failed: unknown result");
  }

  public function get_num_partitions_by_filter($db_name, $tbl_name, $filter)
  {
    $this->send_get_num_partitions_by_filter($db_name, $tbl_name, $filter);
    return $this->recv_get_num_partitions_by_filter();
  }

  public function send_get_num_partitions_by_filter($db_name, $tbl_name, $filter)
  {
    $args = new \metastore\ThriftHiveMetastore_get_num_partitions_by_filter_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->filter = $filter;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_num_partitions_by_filter', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_num_partitions_by_filter', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_num_partitions_by_filter()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_num_partitions_by_filter_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_num_partitions_by_filter_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_num_partitions_by_filter failed: unknown result");
  }

  public function get_partitions_by_names($db_name, $tbl_name, array $names)
  {
    $this->send_get_partitions_by_names($db_name, $tbl_name, $names);
    return $this->recv_get_partitions_by_names();
  }

  public function send_get_partitions_by_names($db_name, $tbl_name, array $names)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partitions_by_names_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->names = $names;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partitions_by_names', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partitions_by_names', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partitions_by_names()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partitions_by_names_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partitions_by_names_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partitions_by_names failed: unknown result");
  }

  public function alter_partition($db_name, $tbl_name, \metastore\Partition $new_part)
  {
    $this->send_alter_partition($db_name, $tbl_name, $new_part);
    $this->recv_alter_partition();
  }

  public function send_alter_partition($db_name, $tbl_name, \metastore\Partition $new_part)
  {
    $args = new \metastore\ThriftHiveMetastore_alter_partition_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->new_part = $new_part;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'alter_partition', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('alter_partition', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_alter_partition()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_alter_partition_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_alter_partition_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function alter_partitions($db_name, $tbl_name, array $new_parts)
  {
    $this->send_alter_partitions($db_name, $tbl_name, $new_parts);
    $this->recv_alter_partitions();
  }

  public function send_alter_partitions($db_name, $tbl_name, array $new_parts)
  {
    $args = new \metastore\ThriftHiveMetastore_alter_partitions_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->new_parts = $new_parts;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'alter_partitions', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('alter_partitions', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_alter_partitions()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_alter_partitions_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_alter_partitions_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function alter_partitions_with_environment_context($db_name, $tbl_name, array $new_parts, \metastore\EnvironmentContext $environment_context)
  {
    $this->send_alter_partitions_with_environment_context($db_name, $tbl_name, $new_parts, $environment_context);
    $this->recv_alter_partitions_with_environment_context();
  }

  public function send_alter_partitions_with_environment_context($db_name, $tbl_name, array $new_parts, \metastore\EnvironmentContext $environment_context)
  {
    $args = new \metastore\ThriftHiveMetastore_alter_partitions_with_environment_context_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->new_parts = $new_parts;
    $args->environment_context = $environment_context;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'alter_partitions_with_environment_context', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('alter_partitions_with_environment_context', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_alter_partitions_with_environment_context()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_alter_partitions_with_environment_context_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_alter_partitions_with_environment_context_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function alter_partition_with_environment_context($db_name, $tbl_name, \metastore\Partition $new_part, \metastore\EnvironmentContext $environment_context)
  {
    $this->send_alter_partition_with_environment_context($db_name, $tbl_name, $new_part, $environment_context);
    $this->recv_alter_partition_with_environment_context();
  }

  public function send_alter_partition_with_environment_context($db_name, $tbl_name, \metastore\Partition $new_part, \metastore\EnvironmentContext $environment_context)
  {
    $args = new \metastore\ThriftHiveMetastore_alter_partition_with_environment_context_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->new_part = $new_part;
    $args->environment_context = $environment_context;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'alter_partition_with_environment_context', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('alter_partition_with_environment_context', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_alter_partition_with_environment_context()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_alter_partition_with_environment_context_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_alter_partition_with_environment_context_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function rename_partition($db_name, $tbl_name, array $part_vals, \metastore\Partition $new_part)
  {
    $this->send_rename_partition($db_name, $tbl_name, $part_vals, $new_part);
    $this->recv_rename_partition();
  }

  public function send_rename_partition($db_name, $tbl_name, array $part_vals, \metastore\Partition $new_part)
  {
    $args = new \metastore\ThriftHiveMetastore_rename_partition_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $args->new_part = $new_part;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'rename_partition', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('rename_partition', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_rename_partition()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_rename_partition_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_rename_partition_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function partition_name_has_valid_characters(array $part_vals, $throw_exception)
  {
    $this->send_partition_name_has_valid_characters($part_vals, $throw_exception);
    return $this->recv_partition_name_has_valid_characters();
  }

  public function send_partition_name_has_valid_characters(array $part_vals, $throw_exception)
  {
    $args = new \metastore\ThriftHiveMetastore_partition_name_has_valid_characters_args();
    $args->part_vals = $part_vals;
    $args->throw_exception = $throw_exception;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'partition_name_has_valid_characters', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('partition_name_has_valid_characters', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_partition_name_has_valid_characters()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_partition_name_has_valid_characters_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_partition_name_has_valid_characters_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("partition_name_has_valid_characters failed: unknown result");
  }

  public function get_config_value($name, $defaultValue)
  {
    $this->send_get_config_value($name, $defaultValue);
    return $this->recv_get_config_value();
  }

  public function send_get_config_value($name, $defaultValue)
  {
    $args = new \metastore\ThriftHiveMetastore_get_config_value_args();
    $args->name = $name;
    $args->defaultValue = $defaultValue;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_config_value', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_config_value', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_config_value()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_config_value_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_config_value_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_config_value failed: unknown result");
  }

  public function partition_name_to_vals($part_name)
  {
    $this->send_partition_name_to_vals($part_name);
    return $this->recv_partition_name_to_vals();
  }

  public function send_partition_name_to_vals($part_name)
  {
    $args = new \metastore\ThriftHiveMetastore_partition_name_to_vals_args();
    $args->part_name = $part_name;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'partition_name_to_vals', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('partition_name_to_vals', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_partition_name_to_vals()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_partition_name_to_vals_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_partition_name_to_vals_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("partition_name_to_vals failed: unknown result");
  }

  public function partition_name_to_spec($part_name)
  {
    $this->send_partition_name_to_spec($part_name);
    return $this->recv_partition_name_to_spec();
  }

  public function send_partition_name_to_spec($part_name)
  {
    $args = new \metastore\ThriftHiveMetastore_partition_name_to_spec_args();
    $args->part_name = $part_name;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'partition_name_to_spec', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('partition_name_to_spec', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_partition_name_to_spec()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_partition_name_to_spec_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_partition_name_to_spec_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("partition_name_to_spec failed: unknown result");
  }

  public function markPartitionForEvent($db_name, $tbl_name, array $part_vals, $eventType)
  {
    $this->send_markPartitionForEvent($db_name, $tbl_name, $part_vals, $eventType);
    $this->recv_markPartitionForEvent();
  }

  public function send_markPartitionForEvent($db_name, $tbl_name, array $part_vals, $eventType)
  {
    $args = new \metastore\ThriftHiveMetastore_markPartitionForEvent_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $args->eventType = $eventType;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'markPartitionForEvent', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('markPartitionForEvent', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_markPartitionForEvent()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_markPartitionForEvent_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_markPartitionForEvent_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    if ($result->o5 !== null) {
      throw $result->o5;
    }
    if ($result->o6 !== null) {
      throw $result->o6;
    }
    return;
  }

  public function isPartitionMarkedForEvent($db_name, $tbl_name, array $part_vals, $eventType)
  {
    $this->send_isPartitionMarkedForEvent($db_name, $tbl_name, $part_vals, $eventType);
    return $this->recv_isPartitionMarkedForEvent();
  }

  public function send_isPartitionMarkedForEvent($db_name, $tbl_name, array $part_vals, $eventType)
  {
    $args = new \metastore\ThriftHiveMetastore_isPartitionMarkedForEvent_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $args->eventType = $eventType;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'isPartitionMarkedForEvent', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('isPartitionMarkedForEvent', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_isPartitionMarkedForEvent()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_isPartitionMarkedForEvent_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_isPartitionMarkedForEvent_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    if ($result->o5 !== null) {
      throw $result->o5;
    }
    if ($result->o6 !== null) {
      throw $result->o6;
    }
    throw new \Exception("isPartitionMarkedForEvent failed: unknown result");
  }

  public function add_index(\metastore\Index $new_index, \metastore\Table $index_table)
  {
    $this->send_add_index($new_index, $index_table);
    return $this->recv_add_index();
  }

  public function send_add_index(\metastore\Index $new_index, \metastore\Table $index_table)
  {
    $args = new \metastore\ThriftHiveMetastore_add_index_args();
    $args->new_index = $new_index;
    $args->index_table = $index_table;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_index', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_index', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_index()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_index_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_index_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("add_index failed: unknown result");
  }

  public function alter_index($dbname, $base_tbl_name, $idx_name, \metastore\Index $new_idx)
  {
    $this->send_alter_index($dbname, $base_tbl_name, $idx_name, $new_idx);
    $this->recv_alter_index();
  }

  public function send_alter_index($dbname, $base_tbl_name, $idx_name, \metastore\Index $new_idx)
  {
    $args = new \metastore\ThriftHiveMetastore_alter_index_args();
    $args->dbname = $dbname;
    $args->base_tbl_name = $base_tbl_name;
    $args->idx_name = $idx_name;
    $args->new_idx = $new_idx;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'alter_index', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('alter_index', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_alter_index()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_alter_index_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_alter_index_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function drop_index_by_name($db_name, $tbl_name, $index_name, $deleteData)
  {
    $this->send_drop_index_by_name($db_name, $tbl_name, $index_name, $deleteData);
    return $this->recv_drop_index_by_name();
  }

  public function send_drop_index_by_name($db_name, $tbl_name, $index_name, $deleteData)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_index_by_name_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->index_name = $index_name;
    $args->deleteData = $deleteData;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_index_by_name', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_index_by_name', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_index_by_name()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_index_by_name_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_index_by_name_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("drop_index_by_name failed: unknown result");
  }

  public function get_index_by_name($db_name, $tbl_name, $index_name)
  {
    $this->send_get_index_by_name($db_name, $tbl_name, $index_name);
    return $this->recv_get_index_by_name();
  }

  public function send_get_index_by_name($db_name, $tbl_name, $index_name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_index_by_name_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->index_name = $index_name;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_index_by_name', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_index_by_name', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_index_by_name()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_index_by_name_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_index_by_name_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_index_by_name failed: unknown result");
  }

  public function get_indexes($db_name, $tbl_name, $max_indexes)
  {
    $this->send_get_indexes($db_name, $tbl_name, $max_indexes);
    return $this->recv_get_indexes();
  }

  public function send_get_indexes($db_name, $tbl_name, $max_indexes)
  {
    $args = new \metastore\ThriftHiveMetastore_get_indexes_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->max_indexes = $max_indexes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_indexes', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_indexes', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_indexes()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_indexes_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_indexes_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_indexes failed: unknown result");
  }

  public function get_index_names($db_name, $tbl_name, $max_indexes)
  {
    $this->send_get_index_names($db_name, $tbl_name, $max_indexes);
    return $this->recv_get_index_names();
  }

  public function send_get_index_names($db_name, $tbl_name, $max_indexes)
  {
    $args = new \metastore\ThriftHiveMetastore_get_index_names_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->max_indexes = $max_indexes;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_index_names', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_index_names', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_index_names()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_index_names_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_index_names_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_index_names failed: unknown result");
  }

  public function get_primary_keys(\metastore\PrimaryKeysRequest $request)
  {
    $this->send_get_primary_keys($request);
    return $this->recv_get_primary_keys();
  }

  public function send_get_primary_keys(\metastore\PrimaryKeysRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_get_primary_keys_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_primary_keys', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_primary_keys', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_primary_keys()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_primary_keys_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_primary_keys_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_primary_keys failed: unknown result");
  }

  public function get_foreign_keys(\metastore\ForeignKeysRequest $request)
  {
    $this->send_get_foreign_keys($request);
    return $this->recv_get_foreign_keys();
  }

  public function send_get_foreign_keys(\metastore\ForeignKeysRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_get_foreign_keys_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_foreign_keys', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_foreign_keys', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_foreign_keys()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_foreign_keys_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_foreign_keys_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_foreign_keys failed: unknown result");
  }

  public function get_unique_constraints(\metastore\UniqueConstraintsRequest $request)
  {
    $this->send_get_unique_constraints($request);
    return $this->recv_get_unique_constraints();
  }

  public function send_get_unique_constraints(\metastore\UniqueConstraintsRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_get_unique_constraints_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_unique_constraints', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_unique_constraints', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_unique_constraints()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_unique_constraints_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_unique_constraints_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_unique_constraints failed: unknown result");
  }

  public function get_not_null_constraints(\metastore\NotNullConstraintsRequest $request)
  {
    $this->send_get_not_null_constraints($request);
    return $this->recv_get_not_null_constraints();
  }

  public function send_get_not_null_constraints(\metastore\NotNullConstraintsRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_get_not_null_constraints_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_not_null_constraints', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_not_null_constraints', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_not_null_constraints()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_not_null_constraints_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_not_null_constraints_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_not_null_constraints failed: unknown result");
  }

  public function update_table_column_statistics(\metastore\ColumnStatistics $stats_obj)
  {
    $this->send_update_table_column_statistics($stats_obj);
    return $this->recv_update_table_column_statistics();
  }

  public function send_update_table_column_statistics(\metastore\ColumnStatistics $stats_obj)
  {
    $args = new \metastore\ThriftHiveMetastore_update_table_column_statistics_args();
    $args->stats_obj = $stats_obj;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'update_table_column_statistics', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('update_table_column_statistics', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_update_table_column_statistics()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_update_table_column_statistics_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_update_table_column_statistics_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    throw new \Exception("update_table_column_statistics failed: unknown result");
  }

  public function update_partition_column_statistics(\metastore\ColumnStatistics $stats_obj)
  {
    $this->send_update_partition_column_statistics($stats_obj);
    return $this->recv_update_partition_column_statistics();
  }

  public function send_update_partition_column_statistics(\metastore\ColumnStatistics $stats_obj)
  {
    $args = new \metastore\ThriftHiveMetastore_update_partition_column_statistics_args();
    $args->stats_obj = $stats_obj;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'update_partition_column_statistics', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('update_partition_column_statistics', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_update_partition_column_statistics()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_update_partition_column_statistics_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_update_partition_column_statistics_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    throw new \Exception("update_partition_column_statistics failed: unknown result");
  }

  public function get_table_column_statistics($db_name, $tbl_name, $col_name)
  {
    $this->send_get_table_column_statistics($db_name, $tbl_name, $col_name);
    return $this->recv_get_table_column_statistics();
  }

  public function send_get_table_column_statistics($db_name, $tbl_name, $col_name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_table_column_statistics_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->col_name = $col_name;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_table_column_statistics', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_table_column_statistics', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_table_column_statistics()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_table_column_statistics_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_table_column_statistics_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    throw new \Exception("get_table_column_statistics failed: unknown result");
  }

  public function get_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name)
  {
    $this->send_get_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name);
    return $this->recv_get_partition_column_statistics();
  }

  public function send_get_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partition_column_statistics_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_name = $part_name;
    $args->col_name = $col_name;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partition_column_statistics', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partition_column_statistics', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partition_column_statistics()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partition_column_statistics_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partition_column_statistics_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    throw new \Exception("get_partition_column_statistics failed: unknown result");
  }

  public function get_table_statistics_req(\metastore\TableStatsRequest $request)
  {
    $this->send_get_table_statistics_req($request);
    return $this->recv_get_table_statistics_req();
  }

  public function send_get_table_statistics_req(\metastore\TableStatsRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_get_table_statistics_req_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_table_statistics_req', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_table_statistics_req', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_table_statistics_req()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_table_statistics_req_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_table_statistics_req_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_table_statistics_req failed: unknown result");
  }

  public function get_partitions_statistics_req(\metastore\PartitionsStatsRequest $request)
  {
    $this->send_get_partitions_statistics_req($request);
    return $this->recv_get_partitions_statistics_req();
  }

  public function send_get_partitions_statistics_req(\metastore\PartitionsStatsRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partitions_statistics_req_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partitions_statistics_req', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partitions_statistics_req', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partitions_statistics_req()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partitions_statistics_req_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partitions_statistics_req_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partitions_statistics_req failed: unknown result");
  }

  public function get_aggr_stats_for(\metastore\PartitionsStatsRequest $request)
  {
    $this->send_get_aggr_stats_for($request);
    return $this->recv_get_aggr_stats_for();
  }

  public function send_get_aggr_stats_for(\metastore\PartitionsStatsRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_get_aggr_stats_for_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_aggr_stats_for', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_aggr_stats_for', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_aggr_stats_for()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_aggr_stats_for_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_aggr_stats_for_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_aggr_stats_for failed: unknown result");
  }

  public function set_aggr_stats_for(\metastore\SetPartitionsStatsRequest $request)
  {
    $this->send_set_aggr_stats_for($request);
    return $this->recv_set_aggr_stats_for();
  }

  public function send_set_aggr_stats_for(\metastore\SetPartitionsStatsRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_set_aggr_stats_for_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'set_aggr_stats_for', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('set_aggr_stats_for', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_set_aggr_stats_for()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_set_aggr_stats_for_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_set_aggr_stats_for_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    throw new \Exception("set_aggr_stats_for failed: unknown result");
  }

  public function delete_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name)
  {
    $this->send_delete_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name);
    return $this->recv_delete_partition_column_statistics();
  }

  public function send_delete_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name)
  {
    $args = new \metastore\ThriftHiveMetastore_delete_partition_column_statistics_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_name = $part_name;
    $args->col_name = $col_name;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'delete_partition_column_statistics', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('delete_partition_column_statistics', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_delete_partition_column_statistics()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_delete_partition_column_statistics_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_delete_partition_column_statistics_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    throw new \Exception("delete_partition_column_statistics failed: unknown result");
  }

  public function delete_table_column_statistics($db_name, $tbl_name, $col_name)
  {
    $this->send_delete_table_column_statistics($db_name, $tbl_name, $col_name);
    return $this->recv_delete_table_column_statistics();
  }

  public function send_delete_table_column_statistics($db_name, $tbl_name, $col_name)
  {
    $args = new \metastore\ThriftHiveMetastore_delete_table_column_statistics_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->col_name = $col_name;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'delete_table_column_statistics', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('delete_table_column_statistics', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_delete_table_column_statistics()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_delete_table_column_statistics_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_delete_table_column_statistics_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    throw new \Exception("delete_table_column_statistics failed: unknown result");
  }

  public function create_function(\metastore\Function $func)
  {
    $this->send_create_function($func);
    $this->recv_create_function();
  }

  public function send_create_function(\metastore\Function $func)
  {
    $args = new \metastore\ThriftHiveMetastore_create_function_args();
    $args->func = $func;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_function', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_function', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_function()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_function_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_function_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    return;
  }

  public function drop_function($dbName, $funcName)
  {
    $this->send_drop_function($dbName, $funcName);
    $this->recv_drop_function();
  }

  public function send_drop_function($dbName, $funcName)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_function_args();
    $args->dbName = $dbName;
    $args->funcName = $funcName;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_function', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_function', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_function()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_function_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_function_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    return;
  }

  public function alter_function($dbName, $funcName, \metastore\Function $newFunc)
  {
    $this->send_alter_function($dbName, $funcName, $newFunc);
    $this->recv_alter_function();
  }

  public function send_alter_function($dbName, $funcName, \metastore\Function $newFunc)
  {
    $args = new \metastore\ThriftHiveMetastore_alter_function_args();
    $args->dbName = $dbName;
    $args->funcName = $funcName;
    $args->newFunc = $newFunc;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'alter_function', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('alter_function', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_alter_function()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_alter_function_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_alter_function_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function get_functions($dbName, $pattern)
  {
    $this->send_get_functions($dbName, $pattern);
    return $this->recv_get_functions();
  }

  public function send_get_functions($dbName, $pattern)
  {
    $args = new \metastore\ThriftHiveMetastore_get_functions_args();
    $args->dbName = $dbName;
    $args->pattern = $pattern;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_functions', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_functions', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_functions()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_functions_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_functions_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_functions failed: unknown result");
  }

  public function get_function($dbName, $funcName)
  {
    $this->send_get_function($dbName, $funcName);
    return $this->recv_get_function();
  }

  public function send_get_function($dbName, $funcName)
  {
    $args = new \metastore\ThriftHiveMetastore_get_function_args();
    $args->dbName = $dbName;
    $args->funcName = $funcName;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_function', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_function', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_function()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_function_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_function_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_function failed: unknown result");
  }

  public function get_all_functions()
  {
    $this->send_get_all_functions();
    return $this->recv_get_all_functions();
  }

  public function send_get_all_functions()
  {
    $args = new \metastore\ThriftHiveMetastore_get_all_functions_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_all_functions', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_all_functions', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_all_functions()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_all_functions_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_all_functions_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_all_functions failed: unknown result");
  }

  public function create_role(\metastore\Role $role)
  {
    $this->send_create_role($role);
    return $this->recv_create_role();
  }

  public function send_create_role(\metastore\Role $role)
  {
    $args = new \metastore\ThriftHiveMetastore_create_role_args();
    $args->role = $role;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_role', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_role', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_role()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_role_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_role_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("create_role failed: unknown result");
  }

  public function drop_role($role_name)
  {
    $this->send_drop_role($role_name);
    return $this->recv_drop_role();
  }

  public function send_drop_role($role_name)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_role_args();
    $args->role_name = $role_name;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_role', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_role', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_role()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_role_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_role_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("drop_role failed: unknown result");
  }

  public function get_role_names()
  {
    $this->send_get_role_names();
    return $this->recv_get_role_names();
  }

  public function send_get_role_names()
  {
    $args = new \metastore\ThriftHiveMetastore_get_role_names_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_role_names', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_role_names', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_role_names()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_role_names_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_role_names_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_role_names failed: unknown result");
  }

  public function grant_role($role_name, $principal_name, $principal_type, $grantor, $grantorType, $grant_option)
  {
    $this->send_grant_role($role_name, $principal_name, $principal_type, $grantor, $grantorType, $grant_option);
    return $this->recv_grant_role();
  }

  public function send_grant_role($role_name, $principal_name, $principal_type, $grantor, $grantorType, $grant_option)
  {
    $args = new \metastore\ThriftHiveMetastore_grant_role_args();
    $args->role_name = $role_name;
    $args->principal_name = $principal_name;
    $args->principal_type = $principal_type;
    $args->grantor = $grantor;
    $args->grantorType = $grantorType;
    $args->grant_option = $grant_option;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'grant_role', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('grant_role', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_grant_role()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_grant_role_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_grant_role_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("grant_role failed: unknown result");
  }

  public function revoke_role($role_name, $principal_name, $principal_type)
  {
    $this->send_revoke_role($role_name, $principal_name, $principal_type);
    return $this->recv_revoke_role();
  }

  public function send_revoke_role($role_name, $principal_name, $principal_type)
  {
    $args = new \metastore\ThriftHiveMetastore_revoke_role_args();
    $args->role_name = $role_name;
    $args->principal_name = $principal_name;
    $args->principal_type = $principal_type;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'revoke_role', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('revoke_role', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_revoke_role()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_revoke_role_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_revoke_role_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("revoke_role failed: unknown result");
  }

  public function list_roles($principal_name, $principal_type)
  {
    $this->send_list_roles($principal_name, $principal_type);
    return $this->recv_list_roles();
  }

  public function send_list_roles($principal_name, $principal_type)
  {
    $args = new \metastore\ThriftHiveMetastore_list_roles_args();
    $args->principal_name = $principal_name;
    $args->principal_type = $principal_type;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'list_roles', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('list_roles', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_list_roles()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_list_roles_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_list_roles_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("list_roles failed: unknown result");
  }

  public function grant_revoke_role(\metastore\GrantRevokeRoleRequest $request)
  {
    $this->send_grant_revoke_role($request);
    return $this->recv_grant_revoke_role();
  }

  public function send_grant_revoke_role(\metastore\GrantRevokeRoleRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_grant_revoke_role_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'grant_revoke_role', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('grant_revoke_role', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_grant_revoke_role()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_grant_revoke_role_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_grant_revoke_role_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("grant_revoke_role failed: unknown result");
  }

  public function get_principals_in_role(\metastore\GetPrincipalsInRoleRequest $request)
  {
    $this->send_get_principals_in_role($request);
    return $this->recv_get_principals_in_role();
  }

  public function send_get_principals_in_role(\metastore\GetPrincipalsInRoleRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_get_principals_in_role_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_principals_in_role', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_principals_in_role', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_principals_in_role()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_principals_in_role_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_principals_in_role_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_principals_in_role failed: unknown result");
  }

  public function get_role_grants_for_principal(\metastore\GetRoleGrantsForPrincipalRequest $request)
  {
    $this->send_get_role_grants_for_principal($request);
    return $this->recv_get_role_grants_for_principal();
  }

  public function send_get_role_grants_for_principal(\metastore\GetRoleGrantsForPrincipalRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_get_role_grants_for_principal_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_role_grants_for_principal', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_role_grants_for_principal', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_role_grants_for_principal()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_role_grants_for_principal_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_role_grants_for_principal_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_role_grants_for_principal failed: unknown result");
  }

  public function get_privilege_set(\metastore\HiveObjectRef $hiveObject, $user_name, array $group_names)
  {
    $this->send_get_privilege_set($hiveObject, $user_name, $group_names);
    return $this->recv_get_privilege_set();
  }

  public function send_get_privilege_set(\metastore\HiveObjectRef $hiveObject, $user_name, array $group_names)
  {
    $args = new \metastore\ThriftHiveMetastore_get_privilege_set_args();
    $args->hiveObject = $hiveObject;
    $args->user_name = $user_name;
    $args->group_names = $group_names;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_privilege_set', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_privilege_set', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_privilege_set()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_privilege_set_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_privilege_set_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_privilege_set failed: unknown result");
  }

  public function list_privileges($principal_name, $principal_type, \metastore\HiveObjectRef $hiveObject)
  {
    $this->send_list_privileges($principal_name, $principal_type, $hiveObject);
    return $this->recv_list_privileges();
  }

  public function send_list_privileges($principal_name, $principal_type, \metastore\HiveObjectRef $hiveObject)
  {
    $args = new \metastore\ThriftHiveMetastore_list_privileges_args();
    $args->principal_name = $principal_name;
    $args->principal_type = $principal_type;
    $args->hiveObject = $hiveObject;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'list_privileges', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('list_privileges', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_list_privileges()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_list_privileges_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_list_privileges_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("list_privileges failed: unknown result");
  }

  public function grant_privileges(\metastore\PrivilegeBag $privileges)
  {
    $this->send_grant_privileges($privileges);
    return $this->recv_grant_privileges();
  }

  public function send_grant_privileges(\metastore\PrivilegeBag $privileges)
  {
    $args = new \metastore\ThriftHiveMetastore_grant_privileges_args();
    $args->privileges = $privileges;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'grant_privileges', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('grant_privileges', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_grant_privileges()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_grant_privileges_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_grant_privileges_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("grant_privileges failed: unknown result");
  }

  public function revoke_privileges(\metastore\PrivilegeBag $privileges)
  {
    $this->send_revoke_privileges($privileges);
    return $this->recv_revoke_privileges();
  }

  public function send_revoke_privileges(\metastore\PrivilegeBag $privileges)
  {
    $args = new \metastore\ThriftHiveMetastore_revoke_privileges_args();
    $args->privileges = $privileges;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'revoke_privileges', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('revoke_privileges', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_revoke_privileges()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_revoke_privileges_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_revoke_privileges_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("revoke_privileges failed: unknown result");
  }

  public function grant_revoke_privileges(\metastore\GrantRevokePrivilegeRequest $request)
  {
    $this->send_grant_revoke_privileges($request);
    return $this->recv_grant_revoke_privileges();
  }

  public function send_grant_revoke_privileges(\metastore\GrantRevokePrivilegeRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_grant_revoke_privileges_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'grant_revoke_privileges', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('grant_revoke_privileges', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_grant_revoke_privileges()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_grant_revoke_privileges_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_grant_revoke_privileges_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("grant_revoke_privileges failed: unknown result");
  }

  public function set_ugi($user_name, array $group_names)
  {
    $this->send_set_ugi($user_name, $group_names);
    return $this->recv_set_ugi();
  }

  public function send_set_ugi($user_name, array $group_names)
  {
    $args = new \metastore\ThriftHiveMetastore_set_ugi_args();
    $args->user_name = $user_name;
    $args->group_names = $group_names;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'set_ugi', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('set_ugi', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_set_ugi()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_set_ugi_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_set_ugi_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("set_ugi failed: unknown result");
  }

  public function get_delegation_token($token_owner, $renewer_kerberos_principal_name)
  {
    $this->send_get_delegation_token($token_owner, $renewer_kerberos_principal_name);
    return $this->recv_get_delegation_token();
  }

  public function send_get_delegation_token($token_owner, $renewer_kerberos_principal_name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_delegation_token_args();
    $args->token_owner = $token_owner;
    $args->renewer_kerberos_principal_name = $renewer_kerberos_principal_name;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_delegation_token', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_delegation_token', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_delegation_token()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_delegation_token_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_delegation_token_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_delegation_token failed: unknown result");
  }

  public function renew_delegation_token($token_str_form)
  {
    $this->send_renew_delegation_token($token_str_form);
    return $this->recv_renew_delegation_token();
  }

  public function send_renew_delegation_token($token_str_form)
  {
    $args = new \metastore\ThriftHiveMetastore_renew_delegation_token_args();
    $args->token_str_form = $token_str_form;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'renew_delegation_token', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('renew_delegation_token', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_renew_delegation_token()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_renew_delegation_token_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_renew_delegation_token_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("renew_delegation_token failed: unknown result");
  }

  public function cancel_delegation_token($token_str_form)
  {
    $this->send_cancel_delegation_token($token_str_form);
    $this->recv_cancel_delegation_token();
  }

  public function send_cancel_delegation_token($token_str_form)
  {
    $args = new \metastore\ThriftHiveMetastore_cancel_delegation_token_args();
    $args->token_str_form = $token_str_form;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'cancel_delegation_token', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('cancel_delegation_token', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_cancel_delegation_token()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_cancel_delegation_token_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_cancel_delegation_token_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    return;
  }

  public function add_token($token_identifier, $delegation_token)
  {
    $this->send_add_token($token_identifier, $delegation_token);
    return $this->recv_add_token();
  }

  public function send_add_token($token_identifier, $delegation_token)
  {
    $args = new \metastore\ThriftHiveMetastore_add_token_args();
    $args->token_identifier = $token_identifier;
    $args->delegation_token = $delegation_token;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_token', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_token', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_token()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_token_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_token_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("add_token failed: unknown result");
  }

  public function remove_token($token_identifier)
  {
    $this->send_remove_token($token_identifier);
    return $this->recv_remove_token();
  }

  public function send_remove_token($token_identifier)
  {
    $args = new \metastore\ThriftHiveMetastore_remove_token_args();
    $args->token_identifier = $token_identifier;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'remove_token', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('remove_token', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_remove_token()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_remove_token_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_remove_token_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("remove_token failed: unknown result");
  }

  public function get_token($token_identifier)
  {
    $this->send_get_token($token_identifier);
    return $this->recv_get_token();
  }

  public function send_get_token($token_identifier)
  {
    $args = new \metastore\ThriftHiveMetastore_get_token_args();
    $args->token_identifier = $token_identifier;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_token', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_token', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_token()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_token_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_token_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("get_token failed: unknown result");
  }

  public function get_all_token_identifiers()
  {
    $this->send_get_all_token_identifiers();
    return $this->recv_get_all_token_identifiers();
  }

  public function send_get_all_token_identifiers()
  {
    $args = new \metastore\ThriftHiveMetastore_get_all_token_identifiers_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_all_token_identifiers', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_all_token_identifiers', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_all_token_identifiers()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_all_token_identifiers_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_all_token_identifiers_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("get_all_token_identifiers failed: unknown result");
  }

  public function add_master_key($key)
  {
    $this->send_add_master_key($key);
    return $this->recv_add_master_key();
  }

  public function send_add_master_key($key)
  {
    $args = new \metastore\ThriftHiveMetastore_add_master_key_args();
    $args->key = $key;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_master_key', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_master_key', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_master_key()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_master_key_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_master_key_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("add_master_key failed: unknown result");
  }

  public function update_master_key($seq_number, $key)
  {
    $this->send_update_master_key($seq_number, $key);
    $this->recv_update_master_key();
  }

  public function send_update_master_key($seq_number, $key)
  {
    $args = new \metastore\ThriftHiveMetastore_update_master_key_args();
    $args->seq_number = $seq_number;
    $args->key = $key;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'update_master_key', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('update_master_key', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_update_master_key()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_update_master_key_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_update_master_key_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function remove_master_key($key_seq)
  {
    $this->send_remove_master_key($key_seq);
    return $this->recv_remove_master_key();
  }

  public function send_remove_master_key($key_seq)
  {
    $args = new \metastore\ThriftHiveMetastore_remove_master_key_args();
    $args->key_seq = $key_seq;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'remove_master_key', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('remove_master_key', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_remove_master_key()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_remove_master_key_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_remove_master_key_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("remove_master_key failed: unknown result");
  }

  public function get_master_keys()
  {
    $this->send_get_master_keys();
    return $this->recv_get_master_keys();
  }

  public function send_get_master_keys()
  {
    $args = new \metastore\ThriftHiveMetastore_get_master_keys_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_master_keys', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_master_keys', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_master_keys()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_master_keys_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_master_keys_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("get_master_keys failed: unknown result");
  }

  public function get_open_txns()
  {
    $this->send_get_open_txns();
    return $this->recv_get_open_txns();
  }

  public function send_get_open_txns()
  {
    $args = new \metastore\ThriftHiveMetastore_get_open_txns_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_open_txns', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_open_txns', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_open_txns()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_open_txns_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_open_txns_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("get_open_txns failed: unknown result");
  }

  public function get_open_txns_info()
  {
    $this->send_get_open_txns_info();
    return $this->recv_get_open_txns_info();
  }

  public function send_get_open_txns_info()
  {
    $args = new \metastore\ThriftHiveMetastore_get_open_txns_info_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_open_txns_info', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_open_txns_info', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_open_txns_info()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_open_txns_info_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_open_txns_info_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("get_open_txns_info failed: unknown result");
  }

  public function open_txns(\metastore\OpenTxnRequest $rqst)
  {
    $this->send_open_txns($rqst);
    return $this->recv_open_txns();
  }

  public function send_open_txns(\metastore\OpenTxnRequest $rqst)
  {
    $args = new \metastore\ThriftHiveMetastore_open_txns_args();
    $args->rqst = $rqst;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'open_txns', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('open_txns', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_open_txns()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_open_txns_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_open_txns_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("open_txns failed: unknown result");
  }

  public function abort_txn(\metastore\AbortTxnRequest $rqst)
  {
    $this->send_abort_txn($rqst);
    $this->recv_abort_txn();
  }

  public function send_abort_txn(\metastore\AbortTxnRequest $rqst)
  {
    $args = new \metastore\ThriftHiveMetastore_abort_txn_args();
    $args->rqst = $rqst;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'abort_txn', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('abort_txn', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_abort_txn()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_abort_txn_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_abort_txn_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    return;
  }

  public function abort_txns(\metastore\AbortTxnsRequest $rqst)
  {
    $this->send_abort_txns($rqst);
    $this->recv_abort_txns();
  }

  public function send_abort_txns(\metastore\AbortTxnsRequest $rqst)
  {
    $args = new \metastore\ThriftHiveMetastore_abort_txns_args();
    $args->rqst = $rqst;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'abort_txns', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('abort_txns', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_abort_txns()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_abort_txns_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_abort_txns_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    return;
  }

  public function commit_txn(\metastore\CommitTxnRequest $rqst)
  {
    $this->send_commit_txn($rqst);
    $this->recv_commit_txn();
  }

  public function send_commit_txn(\metastore\CommitTxnRequest $rqst)
  {
    $args = new \metastore\ThriftHiveMetastore_commit_txn_args();
    $args->rqst = $rqst;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'commit_txn', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('commit_txn', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_commit_txn()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_commit_txn_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_commit_txn_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function lock(\metastore\LockRequest $rqst)
  {
    $this->send_lock($rqst);
    return $this->recv_lock();
  }

  public function send_lock(\metastore\LockRequest $rqst)
  {
    $args = new \metastore\ThriftHiveMetastore_lock_args();
    $args->rqst = $rqst;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'lock', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('lock', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_lock()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_lock_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_lock_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("lock failed: unknown result");
  }

  public function check_lock(\metastore\CheckLockRequest $rqst)
  {
    $this->send_check_lock($rqst);
    return $this->recv_check_lock();
  }

  public function send_check_lock(\metastore\CheckLockRequest $rqst)
  {
    $args = new \metastore\ThriftHiveMetastore_check_lock_args();
    $args->rqst = $rqst;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'check_lock', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('check_lock', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_check_lock()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_check_lock_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_check_lock_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("check_lock failed: unknown result");
  }

  public function unlock(\metastore\UnlockRequest $rqst)
  {
    $this->send_unlock($rqst);
    $this->recv_unlock();
  }

  public function send_unlock(\metastore\UnlockRequest $rqst)
  {
    $args = new \metastore\ThriftHiveMetastore_unlock_args();
    $args->rqst = $rqst;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'unlock', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('unlock', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_unlock()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_unlock_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_unlock_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function show_locks(\metastore\ShowLocksRequest $rqst)
  {
    $this->send_show_locks($rqst);
    return $this->recv_show_locks();
  }

  public function send_show_locks(\metastore\ShowLocksRequest $rqst)
  {
    $args = new \metastore\ThriftHiveMetastore_show_locks_args();
    $args->rqst = $rqst;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'show_locks', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('show_locks', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_show_locks()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_show_locks_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_show_locks_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("show_locks failed: unknown result");
  }

  public function heartbeat(\metastore\HeartbeatRequest $ids)
  {
    $this->send_heartbeat($ids);
    $this->recv_heartbeat();
  }

  public function send_heartbeat(\metastore\HeartbeatRequest $ids)
  {
    $args = new \metastore\ThriftHiveMetastore_heartbeat_args();
    $args->ids = $ids;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'heartbeat', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('heartbeat', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_heartbeat()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_heartbeat_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_heartbeat_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    return;
  }

  public function heartbeat_txn_range(\metastore\HeartbeatTxnRangeRequest $txns)
  {
    $this->send_heartbeat_txn_range($txns);
    return $this->recv_heartbeat_txn_range();
  }

  public function send_heartbeat_txn_range(\metastore\HeartbeatTxnRangeRequest $txns)
  {
    $args = new \metastore\ThriftHiveMetastore_heartbeat_txn_range_args();
    $args->txns = $txns;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'heartbeat_txn_range', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('heartbeat_txn_range', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_heartbeat_txn_range()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_heartbeat_txn_range_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_heartbeat_txn_range_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("heartbeat_txn_range failed: unknown result");
  }

  public function compact(\metastore\CompactionRequest $rqst)
  {
    $this->send_compact($rqst);
    $this->recv_compact();
  }

  public function send_compact(\metastore\CompactionRequest $rqst)
  {
    $args = new \metastore\ThriftHiveMetastore_compact_args();
    $args->rqst = $rqst;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'compact', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('compact', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_compact()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_compact_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_compact_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    return;
  }

  public function compact2(\metastore\CompactionRequest $rqst)
  {
    $this->send_compact2($rqst);
    return $this->recv_compact2();
  }

  public function send_compact2(\metastore\CompactionRequest $rqst)
  {
    $args = new \metastore\ThriftHiveMetastore_compact2_args();
    $args->rqst = $rqst;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'compact2', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('compact2', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_compact2()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_compact2_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_compact2_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("compact2 failed: unknown result");
  }

  public function show_compact(\metastore\ShowCompactRequest $rqst)
  {
    $this->send_show_compact($rqst);
    return $this->recv_show_compact();
  }

  public function send_show_compact(\metastore\ShowCompactRequest $rqst)
  {
    $args = new \metastore\ThriftHiveMetastore_show_compact_args();
    $args->rqst = $rqst;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'show_compact', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('show_compact', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_show_compact()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_show_compact_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_show_compact_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("show_compact failed: unknown result");
  }

  public function add_dynamic_partitions(\metastore\AddDynamicPartitions $rqst)
  {
    $this->send_add_dynamic_partitions($rqst);
    $this->recv_add_dynamic_partitions();
  }

  public function send_add_dynamic_partitions(\metastore\AddDynamicPartitions $rqst)
  {
    $args = new \metastore\ThriftHiveMetastore_add_dynamic_partitions_args();
    $args->rqst = $rqst;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_dynamic_partitions', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_dynamic_partitions', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_dynamic_partitions()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_dynamic_partitions_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_dynamic_partitions_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function get_next_notification(\metastore\NotificationEventRequest $rqst)
  {
    $this->send_get_next_notification($rqst);
    return $this->recv_get_next_notification();
  }

  public function send_get_next_notification(\metastore\NotificationEventRequest $rqst)
  {
    $args = new \metastore\ThriftHiveMetastore_get_next_notification_args();
    $args->rqst = $rqst;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_next_notification', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_next_notification', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_next_notification()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_next_notification_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_next_notification_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("get_next_notification failed: unknown result");
  }

  public function get_current_notificationEventId()
  {
    $this->send_get_current_notificationEventId();
    return $this->recv_get_current_notificationEventId();
  }

  public function send_get_current_notificationEventId()
  {
    $args = new \metastore\ThriftHiveMetastore_get_current_notificationEventId_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_current_notificationEventId', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_current_notificationEventId', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_current_notificationEventId()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_current_notificationEventId_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_current_notificationEventId_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("get_current_notificationEventId failed: unknown result");
  }

  public function get_notification_events_count(\metastore\NotificationEventsCountRequest $rqst)
  {
    $this->send_get_notification_events_count($rqst);
    return $this->recv_get_notification_events_count();
  }

  public function send_get_notification_events_count(\metastore\NotificationEventsCountRequest $rqst)
  {
    $args = new \metastore\ThriftHiveMetastore_get_notification_events_count_args();
    $args->rqst = $rqst;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_notification_events_count', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_notification_events_count', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_notification_events_count()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_notification_events_count_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_notification_events_count_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("get_notification_events_count failed: unknown result");
  }

  public function fire_listener_event(\metastore\FireEventRequest $rqst)
  {
    $this->send_fire_listener_event($rqst);
    return $this->recv_fire_listener_event();
  }

  public function send_fire_listener_event(\metastore\FireEventRequest $rqst)
  {
    $args = new \metastore\ThriftHiveMetastore_fire_listener_event_args();
    $args->rqst = $rqst;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'fire_listener_event', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('fire_listener_event', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_fire_listener_event()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_fire_listener_event_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_fire_listener_event_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("fire_listener_event failed: unknown result");
  }

  public function flushCache()
  {
    $this->send_flushCache();
    $this->recv_flushCache();
  }

  public function send_flushCache()
  {
    $args = new \metastore\ThriftHiveMetastore_flushCache_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'flushCache', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('flushCache', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_flushCache()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_flushCache_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_flushCache_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    return;
  }

  public function cm_recycle(\metastore\CmRecycleRequest $request)
  {
    $this->send_cm_recycle($request);
    return $this->recv_cm_recycle();
  }

  public function send_cm_recycle(\metastore\CmRecycleRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_cm_recycle_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'cm_recycle', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('cm_recycle', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_cm_recycle()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_cm_recycle_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_cm_recycle_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("cm_recycle failed: unknown result");
  }

  public function get_file_metadata_by_expr(\metastore\GetFileMetadataByExprRequest $req)
  {
    $this->send_get_file_metadata_by_expr($req);
    return $this->recv_get_file_metadata_by_expr();
  }

  public function send_get_file_metadata_by_expr(\metastore\GetFileMetadataByExprRequest $req)
  {
    $args = new \metastore\ThriftHiveMetastore_get_file_metadata_by_expr_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_file_metadata_by_expr', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_file_metadata_by_expr', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_file_metadata_by_expr()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_file_metadata_by_expr_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_file_metadata_by_expr_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("get_file_metadata_by_expr failed: unknown result");
  }

  public function get_file_metadata(\metastore\GetFileMetadataRequest $req)
  {
    $this->send_get_file_metadata($req);
    return $this->recv_get_file_metadata();
  }

  public function send_get_file_metadata(\metastore\GetFileMetadataRequest $req)
  {
    $args = new \metastore\ThriftHiveMetastore_get_file_metadata_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_file_metadata', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_file_metadata', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_file_metadata()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_file_metadata_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_file_metadata_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("get_file_metadata failed: unknown result");
  }

  public function put_file_metadata(\metastore\PutFileMetadataRequest $req)
  {
    $this->send_put_file_metadata($req);
    return $this->recv_put_file_metadata();
  }

  public function send_put_file_metadata(\metastore\PutFileMetadataRequest $req)
  {
    $args = new \metastore\ThriftHiveMetastore_put_file_metadata_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'put_file_metadata', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('put_file_metadata', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_put_file_metadata()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_put_file_metadata_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_put_file_metadata_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("put_file_metadata failed: unknown result");
  }

  public function clear_file_metadata(\metastore\ClearFileMetadataRequest $req)
  {
    $this->send_clear_file_metadata($req);
    return $this->recv_clear_file_metadata();
  }

  public function send_clear_file_metadata(\metastore\ClearFileMetadataRequest $req)
  {
    $args = new \metastore\ThriftHiveMetastore_clear_file_metadata_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'clear_file_metadata', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('clear_file_metadata', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_clear_file_metadata()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_clear_file_metadata_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_clear_file_metadata_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("clear_file_metadata failed: unknown result");
  }

  public function cache_file_metadata(\metastore\CacheFileMetadataRequest $req)
  {
    $this->send_cache_file_metadata($req);
    return $this->recv_cache_file_metadata();
  }

  public function send_cache_file_metadata(\metastore\CacheFileMetadataRequest $req)
  {
    $args = new \metastore\ThriftHiveMetastore_cache_file_metadata_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'cache_file_metadata', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('cache_file_metadata', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_cache_file_metadata()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_cache_file_metadata_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_cache_file_metadata_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("cache_file_metadata failed: unknown result");
  }

  public function get_metastore_db_uuid()
  {
    $this->send_get_metastore_db_uuid();
    return $this->recv_get_metastore_db_uuid();
  }

  public function send_get_metastore_db_uuid()
  {
    $args = new \metastore\ThriftHiveMetastore_get_metastore_db_uuid_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_metastore_db_uuid', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_metastore_db_uuid', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_metastore_db_uuid()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_metastore_db_uuid_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_metastore_db_uuid_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_metastore_db_uuid failed: unknown result");
  }

  public function create_resource_plan(\metastore\WMCreateResourcePlanRequest $request)
  {
    $this->send_create_resource_plan($request);
    return $this->recv_create_resource_plan();
  }

  public function send_create_resource_plan(\metastore\WMCreateResourcePlanRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_create_resource_plan_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_resource_plan', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_resource_plan', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_resource_plan()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_resource_plan_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_resource_plan_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("create_resource_plan failed: unknown result");
  }

  public function get_resource_plan(\metastore\WMGetResourcePlanRequest $request)
  {
    $this->send_get_resource_plan($request);
    return $this->recv_get_resource_plan();
  }

  public function send_get_resource_plan(\metastore\WMGetResourcePlanRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_get_resource_plan_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_resource_plan', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_resource_plan', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_resource_plan()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_resource_plan_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_resource_plan_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_resource_plan failed: unknown result");
  }

  public function get_active_resource_plan(\metastore\WMGetActiveResourcePlanRequest $request)
  {
    $this->send_get_active_resource_plan($request);
    return $this->recv_get_active_resource_plan();
  }

  public function send_get_active_resource_plan(\metastore\WMGetActiveResourcePlanRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_get_active_resource_plan_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_active_resource_plan', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_active_resource_plan', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_active_resource_plan()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_active_resource_plan_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_active_resource_plan_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_active_resource_plan failed: unknown result");
  }

  public function get_all_resource_plans(\metastore\WMGetAllResourcePlanRequest $request)
  {
    $this->send_get_all_resource_plans($request);
    return $this->recv_get_all_resource_plans();
  }

  public function send_get_all_resource_plans(\metastore\WMGetAllResourcePlanRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_get_all_resource_plans_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_all_resource_plans', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_all_resource_plans', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_all_resource_plans()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_all_resource_plans_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_all_resource_plans_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_all_resource_plans failed: unknown result");
  }

  public function alter_resource_plan(\metastore\WMAlterResourcePlanRequest $request)
  {
    $this->send_alter_resource_plan($request);
    return $this->recv_alter_resource_plan();
  }

  public function send_alter_resource_plan(\metastore\WMAlterResourcePlanRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_alter_resource_plan_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'alter_resource_plan', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('alter_resource_plan', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_alter_resource_plan()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_alter_resource_plan_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_alter_resource_plan_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("alter_resource_plan failed: unknown result");
  }

  public function validate_resource_plan(\metastore\WMValidateResourcePlanRequest $request)
  {
    $this->send_validate_resource_plan($request);
    return $this->recv_validate_resource_plan();
  }

  public function send_validate_resource_plan(\metastore\WMValidateResourcePlanRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_validate_resource_plan_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'validate_resource_plan', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('validate_resource_plan', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_validate_resource_plan()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_validate_resource_plan_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_validate_resource_plan_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("validate_resource_plan failed: unknown result");
  }

  public function drop_resource_plan(\metastore\WMDropResourcePlanRequest $request)
  {
    $this->send_drop_resource_plan($request);
    return $this->recv_drop_resource_plan();
  }

  public function send_drop_resource_plan(\metastore\WMDropResourcePlanRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_resource_plan_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_resource_plan', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_resource_plan', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_resource_plan()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_resource_plan_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_resource_plan_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("drop_resource_plan failed: unknown result");
  }

  public function create_wm_trigger(\metastore\WMCreateTriggerRequest $request)
  {
    $this->send_create_wm_trigger($request);
    return $this->recv_create_wm_trigger();
  }

  public function send_create_wm_trigger(\metastore\WMCreateTriggerRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_create_wm_trigger_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_wm_trigger', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_wm_trigger', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_wm_trigger()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_wm_trigger_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_wm_trigger_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    throw new \Exception("create_wm_trigger failed: unknown result");
  }

  public function alter_wm_trigger(\metastore\WMAlterTriggerRequest $request)
  {
    $this->send_alter_wm_trigger($request);
    return $this->recv_alter_wm_trigger();
  }

  public function send_alter_wm_trigger(\metastore\WMAlterTriggerRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_alter_wm_trigger_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'alter_wm_trigger', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('alter_wm_trigger', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_alter_wm_trigger()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_alter_wm_trigger_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_alter_wm_trigger_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("alter_wm_trigger failed: unknown result");
  }

  public function drop_wm_trigger(\metastore\WMDropTriggerRequest $request)
  {
    $this->send_drop_wm_trigger($request);
    return $this->recv_drop_wm_trigger();
  }

  public function send_drop_wm_trigger(\metastore\WMDropTriggerRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_wm_trigger_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_wm_trigger', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_wm_trigger', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_wm_trigger()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_wm_trigger_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_wm_trigger_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("drop_wm_trigger failed: unknown result");
  }

  public function get_triggers_for_resourceplan(\metastore\WMGetTriggersForResourePlanRequest $request)
  {
    $this->send_get_triggers_for_resourceplan($request);
    return $this->recv_get_triggers_for_resourceplan();
  }

  public function send_get_triggers_for_resourceplan(\metastore\WMGetTriggersForResourePlanRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_get_triggers_for_resourceplan_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_triggers_for_resourceplan', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_triggers_for_resourceplan', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_triggers_for_resourceplan()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_triggers_for_resourceplan_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_triggers_for_resourceplan_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_triggers_for_resourceplan failed: unknown result");
  }

  public function create_wm_pool(\metastore\WMCreatePoolRequest $request)
  {
    $this->send_create_wm_pool($request);
    return $this->recv_create_wm_pool();
  }

  public function send_create_wm_pool(\metastore\WMCreatePoolRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_create_wm_pool_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_wm_pool', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_wm_pool', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_wm_pool()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_wm_pool_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_wm_pool_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    throw new \Exception("create_wm_pool failed: unknown result");
  }

  public function alter_wm_pool(\metastore\WMAlterPoolRequest $request)
  {
    $this->send_alter_wm_pool($request);
    return $this->recv_alter_wm_pool();
  }

  public function send_alter_wm_pool(\metastore\WMAlterPoolRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_alter_wm_pool_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'alter_wm_pool', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('alter_wm_pool', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_alter_wm_pool()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_alter_wm_pool_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_alter_wm_pool_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    throw new \Exception("alter_wm_pool failed: unknown result");
  }

  public function drop_wm_pool(\metastore\WMDropPoolRequest $request)
  {
    $this->send_drop_wm_pool($request);
    return $this->recv_drop_wm_pool();
  }

  public function send_drop_wm_pool(\metastore\WMDropPoolRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_wm_pool_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_wm_pool', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_wm_pool', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_wm_pool()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_wm_pool_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_wm_pool_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("drop_wm_pool failed: unknown result");
  }

  public function create_or_update_wm_mapping(\metastore\WMCreateOrUpdateMappingRequest $request)
  {
    $this->send_create_or_update_wm_mapping($request);
    return $this->recv_create_or_update_wm_mapping();
  }

  public function send_create_or_update_wm_mapping(\metastore\WMCreateOrUpdateMappingRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_create_or_update_wm_mapping_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_or_update_wm_mapping', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_or_update_wm_mapping', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_or_update_wm_mapping()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_or_update_wm_mapping_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_or_update_wm_mapping_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    throw new \Exception("create_or_update_wm_mapping failed: unknown result");
  }

  public function drop_wm_mapping(\metastore\WMDropMappingRequest $request)
  {
    $this->send_drop_wm_mapping($request);
    return $this->recv_drop_wm_mapping();
  }

  public function send_drop_wm_mapping(\metastore\WMDropMappingRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_wm_mapping_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_wm_mapping', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_wm_mapping', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_wm_mapping()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_wm_mapping_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_wm_mapping_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("drop_wm_mapping failed: unknown result");
  }

  public function create_or_drop_wm_trigger_to_pool_mapping(\metastore\WMCreateOrDropTriggerToPoolMappingRequest $request)
  {
    $this->send_create_or_drop_wm_trigger_to_pool_mapping($request);
    return $this->recv_create_or_drop_wm_trigger_to_pool_mapping();
  }

  public function send_create_or_drop_wm_trigger_to_pool_mapping(\metastore\WMCreateOrDropTriggerToPoolMappingRequest $request)
  {
    $args = new \metastore\ThriftHiveMetastore_create_or_drop_wm_trigger_to_pool_mapping_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_or_drop_wm_trigger_to_pool_mapping', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_or_drop_wm_trigger_to_pool_mapping', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_or_drop_wm_trigger_to_pool_mapping()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_or_drop_wm_trigger_to_pool_mapping_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_or_drop_wm_trigger_to_pool_mapping_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    throw new \Exception("create_or_drop_wm_trigger_to_pool_mapping failed: unknown result");
  }

}

// HELPER FUNCTIONS AND STRUCTURES

class ThriftHiveMetastore_getMetaConf_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $key = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['key'])) {
        $this->key = $vals['key'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_getMetaConf_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->key);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_getMetaConf_args');
    if ($this->key !== null) {
      $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
      $xfer += $output->writeString($this->key);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_getMetaConf_result {
  static $_TSPEC;

  /**
   * @var string
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_getMetaConf_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_getMetaConf_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
      $xfer += $output->writeString($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_setMetaConf_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $key = null;
  /**
   * @var string
   */
  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'value',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['key'])) {
        $this->key = $vals['key'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_setMetaConf_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->key);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_setMetaConf_args');
    if ($this->key !== null) {
      $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
      $xfer += $output->writeString($this->key);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::STRING, 2);
      $xfer += $output->writeString($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_setMetaConf_result {
  static $_TSPEC;

  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_setMetaConf_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_setMetaConf_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_database_args {
  static $_TSPEC;

  /**
   * @var \metastore\Database
   */
  public $database = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'database',
          'type' => TType::STRUCT,
          'class' => '\metastore\Database',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['database'])) {
        $this->database = $vals['database'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_database_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->database = new \metastore\Database();
            $xfer += $this->database->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_database_args');
    if ($this->database !== null) {
      if (!is_object($this->database)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('database', TType::STRUCT, 1);
      $xfer += $this->database->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_database_result {
  static $_TSPEC;

  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o1 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_database_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\AlreadyExistsException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_database_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_database_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_database_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_database_args');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_database_result {
  static $_TSPEC;

  /**
   * @var \metastore\Database
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Database',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_database_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Database();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_database_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_database_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $name = null;
  /**
   * @var bool
   */
  public $deleteData = null;
  /**
   * @var bool
   */
  public $cascade = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'deleteData',
          'type' => TType::BOOL,
          ),
        3 => array(
          'var' => 'cascade',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['deleteData'])) {
        $this->deleteData = $vals['deleteData'];
      }
      if (isset($vals['cascade'])) {
        $this->cascade = $vals['cascade'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_database_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->deleteData);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->cascade);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_database_args');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteData !== null) {
      $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 2);
      $xfer += $output->writeBool($this->deleteData);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cascade !== null) {
      $xfer += $output->writeFieldBegin('cascade', TType::BOOL, 3);
      $xfer += $output->writeBool($this->cascade);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_database_result {
  static $_TSPEC;

  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\InvalidOperationException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_database_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidOperationException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_database_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_databases_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $pattern = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'pattern',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['pattern'])) {
        $this->pattern = $vals['pattern'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_databases_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->pattern);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_databases_args');
    if ($this->pattern !== null) {
      $xfer += $output->writeFieldBegin('pattern', TType::STRING, 1);
      $xfer += $output->writeString($this->pattern);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_databases_result {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_databases_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size724 = 0;
            $_etype727 = 0;
            $xfer += $input->readListBegin($_etype727, $_size724);
            for ($_i728 = 0; $_i728 < $_size724; ++$_i728)
            {
              $elem729 = null;
              $xfer += $input->readString($elem729);
              $this->success []= $elem729;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_databases_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter730)
          {
            $xfer += $output->writeString($iter730);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_databases_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_databases_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_databases_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_databases_result {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_databases_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size731 = 0;
            $_etype734 = 0;
            $xfer += $input->readListBegin($_etype734, $_size731);
            for ($_i735 = 0; $_i735 < $_size731; ++$_i735)
            {
              $elem736 = null;
              $xfer += $input->readString($elem736);
              $this->success []= $elem736;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_databases_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter737)
          {
            $xfer += $output->writeString($iter737);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_database_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbname = null;
  /**
   * @var \metastore\Database
   */
  public $db = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'db',
          'type' => TType::STRUCT,
          'class' => '\metastore\Database',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['db'])) {
        $this->db = $vals['db'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_database_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->db = new \metastore\Database();
            $xfer += $this->db->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_database_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->db !== null) {
      if (!is_object($this->db)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('db', TType::STRUCT, 2);
      $xfer += $this->db->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_database_result {
  static $_TSPEC;

  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_database_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_database_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_type_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_type_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_type_args');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_type_result {
  static $_TSPEC;

  /**
   * @var \metastore\Type
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Type',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_type_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Type();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_type_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_type_args {
  static $_TSPEC;

  /**
   * @var \metastore\Type
   */
  public $type = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::STRUCT,
          'class' => '\metastore\Type',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_type_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->type = new \metastore\Type();
            $xfer += $this->type->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_type_args');
    if ($this->type !== null) {
      if (!is_object($this->type)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('type', TType::STRUCT, 1);
      $xfer += $this->type->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_type_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o1 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_type_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\AlreadyExistsException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_type_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_type_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $type = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_type_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_type_args');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::STRING, 1);
      $xfer += $output->writeString($this->type);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_type_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_type_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_type_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_type_all_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_type_all_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_type_all_args');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_type_all_result {
  static $_TSPEC;

  /**
   * @var array
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Type',
            ),
          ),
        1 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_type_all_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::MAP) {
            $this->success = array();
            $_size738 = 0;
            $_ktype739 = 0;
            $_vtype740 = 0;
            $xfer += $input->readMapBegin($_ktype739, $_vtype740, $_size738);
            for ($_i742 = 0; $_i742 < $_size738; ++$_i742)
            {
              $key743 = '';
              $val744 = new \metastore\Type();
              $xfer += $input->readString($key743);
              $val744 = new \metastore\Type();
              $xfer += $val744->read($input);
              $this->success[$key743] = $val744;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_type_all_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $kiter745 => $viter746)
          {
            $xfer += $output->writeString($kiter745);
            $xfer += $viter746->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 1);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_fields_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $table_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'table_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['table_name'])) {
        $this->table_name = $vals['table_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_fields_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_fields_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->table_name !== null) {
      $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
      $xfer += $output->writeString($this->table_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_fields_result {
  static $_TSPEC;

  /**
   * @var \metastore\FieldSchema[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\UnknownTableException
   */
  public $o2 = null;
  /**
   * @var \metastore\UnknownDBException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\FieldSchema',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownTableException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownDBException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_fields_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size747 = 0;
            $_etype750 = 0;
            $xfer += $input->readListBegin($_etype750, $_size747);
            for ($_i751 = 0; $_i751 < $_size747; ++$_i751)
            {
              $elem752 = null;
              $elem752 = new \metastore\FieldSchema();
              $xfer += $elem752->read($input);
              $this->success []= $elem752;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\UnknownTableException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\UnknownDBException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_fields_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter753)
          {
            $xfer += $iter753->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_fields_with_environment_context_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $table_name = null;
  /**
   * @var \metastore\EnvironmentContext
   */
  public $environment_context = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'table_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'environment_context',
          'type' => TType::STRUCT,
          'class' => '\metastore\EnvironmentContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['table_name'])) {
        $this->table_name = $vals['table_name'];
      }
      if (isset($vals['environment_context'])) {
        $this->environment_context = $vals['environment_context'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_fields_with_environment_context_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->environment_context = new \metastore\EnvironmentContext();
            $xfer += $this->environment_context->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_fields_with_environment_context_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->table_name !== null) {
      $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
      $xfer += $output->writeString($this->table_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->environment_context !== null) {
      if (!is_object($this->environment_context)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('environment_context', TType::STRUCT, 3);
      $xfer += $this->environment_context->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_fields_with_environment_context_result {
  static $_TSPEC;

  /**
   * @var \metastore\FieldSchema[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\UnknownTableException
   */
  public $o2 = null;
  /**
   * @var \metastore\UnknownDBException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\FieldSchema',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownTableException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownDBException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_fields_with_environment_context_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size754 = 0;
            $_etype757 = 0;
            $xfer += $input->readListBegin($_etype757, $_size754);
            for ($_i758 = 0; $_i758 < $_size754; ++$_i758)
            {
              $elem759 = null;
              $elem759 = new \metastore\FieldSchema();
              $xfer += $elem759->read($input);
              $this->success []= $elem759;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\UnknownTableException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\UnknownDBException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_fields_with_environment_context_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter760)
          {
            $xfer += $iter760->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_schema_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $table_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'table_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['table_name'])) {
        $this->table_name = $vals['table_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_schema_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_schema_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->table_name !== null) {
      $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
      $xfer += $output->writeString($this->table_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_schema_result {
  static $_TSPEC;

  /**
   * @var \metastore\FieldSchema[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\UnknownTableException
   */
  public $o2 = null;
  /**
   * @var \metastore\UnknownDBException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\FieldSchema',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownTableException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownDBException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_schema_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size761 = 0;
            $_etype764 = 0;
            $xfer += $input->readListBegin($_etype764, $_size761);
            for ($_i765 = 0; $_i765 < $_size761; ++$_i765)
            {
              $elem766 = null;
              $elem766 = new \metastore\FieldSchema();
              $xfer += $elem766->read($input);
              $this->success []= $elem766;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\UnknownTableException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\UnknownDBException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_schema_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter767)
          {
            $xfer += $iter767->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_schema_with_environment_context_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $table_name = null;
  /**
   * @var \metastore\EnvironmentContext
   */
  public $environment_context = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'table_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'environment_context',
          'type' => TType::STRUCT,
          'class' => '\metastore\EnvironmentContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['table_name'])) {
        $this->table_name = $vals['table_name'];
      }
      if (isset($vals['environment_context'])) {
        $this->environment_context = $vals['environment_context'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_schema_with_environment_context_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->environment_context = new \metastore\EnvironmentContext();
            $xfer += $this->environment_context->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_schema_with_environment_context_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->table_name !== null) {
      $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
      $xfer += $output->writeString($this->table_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->environment_context !== null) {
      if (!is_object($this->environment_context)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('environment_context', TType::STRUCT, 3);
      $xfer += $this->environment_context->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_schema_with_environment_context_result {
  static $_TSPEC;

  /**
   * @var \metastore\FieldSchema[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\UnknownTableException
   */
  public $o2 = null;
  /**
   * @var \metastore\UnknownDBException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\FieldSchema',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownTableException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownDBException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_schema_with_environment_context_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size768 = 0;
            $_etype771 = 0;
            $xfer += $input->readListBegin($_etype771, $_size768);
            for ($_i772 = 0; $_i772 < $_size768; ++$_i772)
            {
              $elem773 = null;
              $elem773 = new \metastore\FieldSchema();
              $xfer += $elem773->read($input);
              $this->success []= $elem773;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\UnknownTableException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\UnknownDBException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_schema_with_environment_context_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter774)
          {
            $xfer += $iter774->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_table_args {
  static $_TSPEC;

  /**
   * @var \metastore\Table
   */
  public $tbl = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tbl',
          'type' => TType::STRUCT,
          'class' => '\metastore\Table',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tbl'])) {
        $this->tbl = $vals['tbl'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_table_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->tbl = new \metastore\Table();
            $xfer += $this->tbl->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_table_args');
    if ($this->tbl !== null) {
      if (!is_object($this->tbl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tbl', TType::STRUCT, 1);
      $xfer += $this->tbl->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_table_result {
  static $_TSPEC;

  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o1 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_table_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\AlreadyExistsException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\NoSuchObjectException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_table_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_table_with_environment_context_args {
  static $_TSPEC;

  /**
   * @var \metastore\Table
   */
  public $tbl = null;
  /**
   * @var \metastore\EnvironmentContext
   */
  public $environment_context = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tbl',
          'type' => TType::STRUCT,
          'class' => '\metastore\Table',
          ),
        2 => array(
          'var' => 'environment_context',
          'type' => TType::STRUCT,
          'class' => '\metastore\EnvironmentContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tbl'])) {
        $this->tbl = $vals['tbl'];
      }
      if (isset($vals['environment_context'])) {
        $this->environment_context = $vals['environment_context'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_table_with_environment_context_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->tbl = new \metastore\Table();
            $xfer += $this->tbl->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->environment_context = new \metastore\EnvironmentContext();
            $xfer += $this->environment_context->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_table_with_environment_context_args');
    if ($this->tbl !== null) {
      if (!is_object($this->tbl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tbl', TType::STRUCT, 1);
      $xfer += $this->tbl->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->environment_context !== null) {
      if (!is_object($this->environment_context)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('environment_context', TType::STRUCT, 2);
      $xfer += $this->environment_context->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_table_with_environment_context_result {
  static $_TSPEC;

  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o1 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_table_with_environment_context_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\AlreadyExistsException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\NoSuchObjectException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_table_with_environment_context_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_table_with_constraints_args {
  static $_TSPEC;

  /**
   * @var \metastore\Table
   */
  public $tbl = null;
  /**
   * @var \metastore\SQLPrimaryKey[]
   */
  public $primaryKeys = null;
  /**
   * @var \metastore\SQLForeignKey[]
   */
  public $foreignKeys = null;
  /**
   * @var \metastore\SQLUniqueConstraint[]
   */
  public $uniqueConstraints = null;
  /**
   * @var \metastore\SQLNotNullConstraint[]
   */
  public $notNullConstraints = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tbl',
          'type' => TType::STRUCT,
          'class' => '\metastore\Table',
          ),
        2 => array(
          'var' => 'primaryKeys',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SQLPrimaryKey',
            ),
          ),
        3 => array(
          'var' => 'foreignKeys',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SQLForeignKey',
            ),
          ),
        4 => array(
          'var' => 'uniqueConstraints',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SQLUniqueConstraint',
            ),
          ),
        5 => array(
          'var' => 'notNullConstraints',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SQLNotNullConstraint',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tbl'])) {
        $this->tbl = $vals['tbl'];
      }
      if (isset($vals['primaryKeys'])) {
        $this->primaryKeys = $vals['primaryKeys'];
      }
      if (isset($vals['foreignKeys'])) {
        $this->foreignKeys = $vals['foreignKeys'];
      }
      if (isset($vals['uniqueConstraints'])) {
        $this->uniqueConstraints = $vals['uniqueConstraints'];
      }
      if (isset($vals['notNullConstraints'])) {
        $this->notNullConstraints = $vals['notNullConstraints'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_table_with_constraints_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->tbl = new \metastore\Table();
            $xfer += $this->tbl->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->primaryKeys = array();
            $_size775 = 0;
            $_etype778 = 0;
            $xfer += $input->readListBegin($_etype778, $_size775);
            for ($_i779 = 0; $_i779 < $_size775; ++$_i779)
            {
              $elem780 = null;
              $elem780 = new \metastore\SQLPrimaryKey();
              $xfer += $elem780->read($input);
              $this->primaryKeys []= $elem780;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->foreignKeys = array();
            $_size781 = 0;
            $_etype784 = 0;
            $xfer += $input->readListBegin($_etype784, $_size781);
            for ($_i785 = 0; $_i785 < $_size781; ++$_i785)
            {
              $elem786 = null;
              $elem786 = new \metastore\SQLForeignKey();
              $xfer += $elem786->read($input);
              $this->foreignKeys []= $elem786;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->uniqueConstraints = array();
            $_size787 = 0;
            $_etype790 = 0;
            $xfer += $input->readListBegin($_etype790, $_size787);
            for ($_i791 = 0; $_i791 < $_size787; ++$_i791)
            {
              $elem792 = null;
              $elem792 = new \metastore\SQLUniqueConstraint();
              $xfer += $elem792->read($input);
              $this->uniqueConstraints []= $elem792;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->notNullConstraints = array();
            $_size793 = 0;
            $_etype796 = 0;
            $xfer += $input->readListBegin($_etype796, $_size793);
            for ($_i797 = 0; $_i797 < $_size793; ++$_i797)
            {
              $elem798 = null;
              $elem798 = new \metastore\SQLNotNullConstraint();
              $xfer += $elem798->read($input);
              $this->notNullConstraints []= $elem798;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_table_with_constraints_args');
    if ($this->tbl !== null) {
      if (!is_object($this->tbl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tbl', TType::STRUCT, 1);
      $xfer += $this->tbl->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->primaryKeys !== null) {
      if (!is_array($this->primaryKeys)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('primaryKeys', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->primaryKeys));
        {
          foreach ($this->primaryKeys as $iter799)
          {
            $xfer += $iter799->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->foreignKeys !== null) {
      if (!is_array($this->foreignKeys)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('foreignKeys', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->foreignKeys));
        {
          foreach ($this->foreignKeys as $iter800)
          {
            $xfer += $iter800->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->uniqueConstraints !== null) {
      if (!is_array($this->uniqueConstraints)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('uniqueConstraints', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRUCT, count($this->uniqueConstraints));
        {
          foreach ($this->uniqueConstraints as $iter801)
          {
            $xfer += $iter801->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->notNullConstraints !== null) {
      if (!is_array($this->notNullConstraints)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('notNullConstraints', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRUCT, count($this->notNullConstraints));
        {
          foreach ($this->notNullConstraints as $iter802)
          {
            $xfer += $iter802->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_table_with_constraints_result {
  static $_TSPEC;

  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o1 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_table_with_constraints_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\AlreadyExistsException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\NoSuchObjectException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_table_with_constraints_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_constraint_args {
  static $_TSPEC;

  /**
   * @var \metastore\DropConstraintRequest
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\metastore\DropConstraintRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_constraint_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \metastore\DropConstraintRequest();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_constraint_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_constraint_result {
  static $_TSPEC;

  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_constraint_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_constraint_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 2);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_primary_key_args {
  static $_TSPEC;

  /**
   * @var \metastore\AddPrimaryKeyRequest
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\metastore\AddPrimaryKeyRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_primary_key_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \metastore\AddPrimaryKeyRequest();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_primary_key_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_primary_key_result {
  static $_TSPEC;

  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_primary_key_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_primary_key_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_foreign_key_args {
  static $_TSPEC;

  /**
   * @var \metastore\AddForeignKeyRequest
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\metastore\AddForeignKeyRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_foreign_key_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \metastore\AddForeignKeyRequest();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_foreign_key_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_foreign_key_result {
  static $_TSPEC;

  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_foreign_key_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_foreign_key_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_unique_constraint_args {
  static $_TSPEC;

  /**
   * @var \metastore\AddUniqueConstraintRequest
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\metastore\AddUniqueConstraintRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_unique_constraint_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \metastore\AddUniqueConstraintRequest();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_unique_constraint_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_unique_constraint_result {
  static $_TSPEC;

  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_unique_constraint_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_unique_constraint_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_not_null_constraint_args {
  static $_TSPEC;

  /**
   * @var \metastore\AddNotNullConstraintRequest
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\metastore\AddNotNullConstraintRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_not_null_constraint_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \metastore\AddNotNullConstraintRequest();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_not_null_constraint_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_not_null_constraint_result {
  static $_TSPEC;

  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_not_null_constraint_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_not_null_constraint_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_table_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbname = null;
  /**
   * @var string
   */
  public $name = null;
  /**
   * @var bool
   */
  public $deleteData = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'deleteData',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['deleteData'])) {
        $this->deleteData = $vals['deleteData'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_table_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->deleteData);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_table_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteData !== null) {
      $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 3);
      $xfer += $output->writeBool($this->deleteData);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_table_result {
  static $_TSPEC;

  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_table_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_table_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 2);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_table_with_environment_context_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbname = null;
  /**
   * @var string
   */
  public $name = null;
  /**
   * @var bool
   */
  public $deleteData = null;
  /**
   * @var \metastore\EnvironmentContext
   */
  public $environment_context = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'deleteData',
          'type' => TType::BOOL,
          ),
        4 => array(
          'var' => 'environment_context',
          'type' => TType::STRUCT,
          'class' => '\metastore\EnvironmentContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['deleteData'])) {
        $this->deleteData = $vals['deleteData'];
      }
      if (isset($vals['environment_context'])) {
        $this->environment_context = $vals['environment_context'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_table_with_environment_context_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->deleteData);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->environment_context = new \metastore\EnvironmentContext();
            $xfer += $this->environment_context->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_table_with_environment_context_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteData !== null) {
      $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 3);
      $xfer += $output->writeBool($this->deleteData);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->environment_context !== null) {
      if (!is_object($this->environment_context)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('environment_context', TType::STRUCT, 4);
      $xfer += $this->environment_context->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_table_with_environment_context_result {
  static $_TSPEC;

  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_table_with_environment_context_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_table_with_environment_context_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 2);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_truncate_table_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $tableName = null;
  /**
   * @var string[]
   */
  public $partNames = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'partNames',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['partNames'])) {
        $this->partNames = $vals['partNames'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_truncate_table_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->partNames = array();
            $_size803 = 0;
            $_etype806 = 0;
            $xfer += $input->readListBegin($_etype806, $_size803);
            for ($_i807 = 0; $_i807 < $_size803; ++$_i807)
            {
              $elem808 = null;
              $xfer += $input->readString($elem808);
              $this->partNames []= $elem808;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_truncate_table_args');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 2);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partNames !== null) {
      if (!is_array($this->partNames)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partNames', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->partNames));
        {
          foreach ($this->partNames as $iter809)
          {
            $xfer += $output->writeString($iter809);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_truncate_table_result {
  static $_TSPEC;

  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_truncate_table_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_truncate_table_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_tables_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $pattern = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'pattern',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['pattern'])) {
        $this->pattern = $vals['pattern'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_tables_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->pattern);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_tables_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->pattern !== null) {
      $xfer += $output->writeFieldBegin('pattern', TType::STRING, 2);
      $xfer += $output->writeString($this->pattern);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_tables_result {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_tables_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size810 = 0;
            $_etype813 = 0;
            $xfer += $input->readListBegin($_etype813, $_size810);
            for ($_i814 = 0; $_i814 < $_size810; ++$_i814)
            {
              $elem815 = null;
              $xfer += $input->readString($elem815);
              $this->success []= $elem815;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_tables_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter816)
          {
            $xfer += $output->writeString($iter816);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_tables_by_type_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $pattern = null;
  /**
   * @var string
   */
  public $tableType = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'pattern',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'tableType',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['pattern'])) {
        $this->pattern = $vals['pattern'];
      }
      if (isset($vals['tableType'])) {
        $this->tableType = $vals['tableType'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_tables_by_type_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->pattern);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_tables_by_type_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->pattern !== null) {
      $xfer += $output->writeFieldBegin('pattern', TType::STRING, 2);
      $xfer += $output->writeString($this->pattern);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableType !== null) {
      $xfer += $output->writeFieldBegin('tableType', TType::STRING, 3);
      $xfer += $output->writeString($this->tableType);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_tables_by_type_result {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_tables_by_type_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size817 = 0;
            $_etype820 = 0;
            $xfer += $input->readListBegin($_etype820, $_size817);
            for ($_i821 = 0; $_i821 < $_size817; ++$_i821)
            {
              $elem822 = null;
              $xfer += $input->readString($elem822);
              $this->success []= $elem822;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_tables_by_type_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter823)
          {
            $xfer += $output->writeString($iter823);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_materialized_views_for_rewriting_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_materialized_views_for_rewriting_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_materialized_views_for_rewriting_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_materialized_views_for_rewriting_result {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_materialized_views_for_rewriting_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size824 = 0;
            $_etype827 = 0;
            $xfer += $input->readListBegin($_etype827, $_size824);
            for ($_i828 = 0; $_i828 < $_size824; ++$_i828)
            {
              $elem829 = null;
              $xfer += $input->readString($elem829);
              $this->success []= $elem829;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_materialized_views_for_rewriting_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter830)
          {
            $xfer += $output->writeString($iter830);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_meta_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_patterns = null;
  /**
   * @var string
   */
  public $tbl_patterns = null;
  /**
   * @var string[]
   */
  public $tbl_types = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_patterns',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_patterns',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'tbl_types',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_patterns'])) {
        $this->db_patterns = $vals['db_patterns'];
      }
      if (isset($vals['tbl_patterns'])) {
        $this->tbl_patterns = $vals['tbl_patterns'];
      }
      if (isset($vals['tbl_types'])) {
        $this->tbl_types = $vals['tbl_types'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_meta_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_patterns);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_patterns);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->tbl_types = array();
            $_size831 = 0;
            $_etype834 = 0;
            $xfer += $input->readListBegin($_etype834, $_size831);
            for ($_i835 = 0; $_i835 < $_size831; ++$_i835)
            {
              $elem836 = null;
              $xfer += $input->readString($elem836);
              $this->tbl_types []= $elem836;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_meta_args');
    if ($this->db_patterns !== null) {
      $xfer += $output->writeFieldBegin('db_patterns', TType::STRING, 1);
      $xfer += $output->writeString($this->db_patterns);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_patterns !== null) {
      $xfer += $output->writeFieldBegin('tbl_patterns', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_patterns);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_types !== null) {
      if (!is_array($this->tbl_types)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tbl_types', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->tbl_types));
        {
          foreach ($this->tbl_types as $iter837)
          {
            $xfer += $output->writeString($iter837);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_meta_result {
  static $_TSPEC;

  /**
   * @var \metastore\TableMeta[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\TableMeta',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_meta_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size838 = 0;
            $_etype841 = 0;
            $xfer += $input->readListBegin($_etype841, $_size838);
            for ($_i842 = 0; $_i842 < $_size838; ++$_i842)
            {
              $elem843 = null;
              $elem843 = new \metastore\TableMeta();
              $xfer += $elem843->read($input);
              $this->success []= $elem843;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_meta_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter844)
          {
            $xfer += $iter844->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_tables_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_tables_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_tables_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_tables_result {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_tables_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size845 = 0;
            $_etype848 = 0;
            $xfer += $input->readListBegin($_etype848, $_size845);
            for ($_i849 = 0; $_i849 < $_size845; ++$_i849)
            {
              $elem850 = null;
              $xfer += $input->readString($elem850);
              $this->success []= $elem850;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_tables_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter851)
          {
            $xfer += $output->writeString($iter851);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbname = null;
  /**
   * @var string
   */
  public $tbl_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_result {
  static $_TSPEC;

  /**
   * @var \metastore\Table
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Table',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Table();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_objects_by_name_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbname = null;
  /**
   * @var string[]
   */
  public $tbl_names = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_names',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['tbl_names'])) {
        $this->tbl_names = $vals['tbl_names'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_objects_by_name_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->tbl_names = array();
            $_size852 = 0;
            $_etype855 = 0;
            $xfer += $input->readListBegin($_etype855, $_size852);
            for ($_i856 = 0; $_i856 < $_size852; ++$_i856)
            {
              $elem857 = null;
              $xfer += $input->readString($elem857);
              $this->tbl_names []= $elem857;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_objects_by_name_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_names !== null) {
      if (!is_array($this->tbl_names)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tbl_names', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->tbl_names));
        {
          foreach ($this->tbl_names as $iter858)
          {
            $xfer += $output->writeString($iter858);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_objects_by_name_result {
  static $_TSPEC;

  /**
   * @var \metastore\Table[]
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Table',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_objects_by_name_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size859 = 0;
            $_etype862 = 0;
            $xfer += $input->readListBegin($_etype862, $_size859);
            for ($_i863 = 0; $_i863 < $_size859; ++$_i863)
            {
              $elem864 = null;
              $elem864 = new \metastore\Table();
              $xfer += $elem864->read($input);
              $this->success []= $elem864;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_objects_by_name_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter865)
          {
            $xfer += $iter865->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_req_args {
  static $_TSPEC;

  /**
   * @var \metastore\GetTableRequest
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\metastore\GetTableRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_req_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \metastore\GetTableRequest();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_req_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_req_result {
  static $_TSPEC;

  /**
   * @var \metastore\GetTableResult
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\GetTableResult',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_req_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\GetTableResult();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_req_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_objects_by_name_req_args {
  static $_TSPEC;

  /**
   * @var \metastore\GetTablesRequest
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\metastore\GetTablesRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_objects_by_name_req_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \metastore\GetTablesRequest();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_objects_by_name_req_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_objects_by_name_req_result {
  static $_TSPEC;

  /**
   * @var \metastore\GetTablesResult
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\InvalidOperationException
   */
  public $o2 = null;
  /**
   * @var \metastore\UnknownDBException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\GetTablesResult',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownDBException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_objects_by_name_req_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\GetTablesResult();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidOperationException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\UnknownDBException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_objects_by_name_req_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_materialization_invalidation_info_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbname = null;
  /**
   * @var string[]
   */
  public $tbl_names = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_names',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['tbl_names'])) {
        $this->tbl_names = $vals['tbl_names'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_materialization_invalidation_info_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->tbl_names = array();
            $_size866 = 0;
            $_etype869 = 0;
            $xfer += $input->readListBegin($_etype869, $_size866);
            for ($_i870 = 0; $_i870 < $_size866; ++$_i870)
            {
              $elem871 = null;
              $xfer += $input->readString($elem871);
              $this->tbl_names []= $elem871;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_materialization_invalidation_info_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_names !== null) {
      if (!is_array($this->tbl_names)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tbl_names', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->tbl_names));
        {
          foreach ($this->tbl_names as $iter872)
          {
            $xfer += $output->writeString($iter872);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_materialization_invalidation_info_result {
  static $_TSPEC;

  /**
   * @var array
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\InvalidOperationException
   */
  public $o2 = null;
  /**
   * @var \metastore\UnknownDBException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Materialization',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownDBException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_materialization_invalidation_info_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::MAP) {
            $this->success = array();
            $_size873 = 0;
            $_ktype874 = 0;
            $_vtype875 = 0;
            $xfer += $input->readMapBegin($_ktype874, $_vtype875, $_size873);
            for ($_i877 = 0; $_i877 < $_size873; ++$_i877)
            {
              $key878 = '';
              $val879 = new \metastore\Materialization();
              $xfer += $input->readString($key878);
              $val879 = new \metastore\Materialization();
              $xfer += $val879->read($input);
              $this->success[$key878] = $val879;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidOperationException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\UnknownDBException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_materialization_invalidation_info_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $kiter880 => $viter881)
          {
            $xfer += $output->writeString($kiter880);
            $xfer += $viter881->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_update_creation_metadata_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbname = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var \metastore\CreationMetadata
   */
  public $creation_metadata = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'creation_metadata',
          'type' => TType::STRUCT,
          'class' => '\metastore\CreationMetadata',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['creation_metadata'])) {
        $this->creation_metadata = $vals['creation_metadata'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_update_creation_metadata_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->creation_metadata = new \metastore\CreationMetadata();
            $xfer += $this->creation_metadata->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_update_creation_metadata_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->creation_metadata !== null) {
      if (!is_object($this->creation_metadata)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('creation_metadata', TType::STRUCT, 3);
      $xfer += $this->creation_metadata->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_update_creation_metadata_result {
  static $_TSPEC;

  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\InvalidOperationException
   */
  public $o2 = null;
  /**
   * @var \metastore\UnknownDBException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownDBException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_update_creation_metadata_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidOperationException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\UnknownDBException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_update_creation_metadata_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_names_by_filter_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbname = null;
  /**
   * @var string
   */
  public $filter = null;
  /**
   * @var int
   */
  public $max_tables = -1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'filter',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'max_tables',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['filter'])) {
        $this->filter = $vals['filter'];
      }
      if (isset($vals['max_tables'])) {
        $this->max_tables = $vals['max_tables'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_names_by_filter_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->filter);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->max_tables);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_names_by_filter_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filter !== null) {
      $xfer += $output->writeFieldBegin('filter', TType::STRING, 2);
      $xfer += $output->writeString($this->filter);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_tables !== null) {
      $xfer += $output->writeFieldBegin('max_tables', TType::I16, 3);
      $xfer += $output->writeI16($this->max_tables);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_names_by_filter_result {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\InvalidOperationException
   */
  public $o2 = null;
  /**
   * @var \metastore\UnknownDBException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownDBException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_names_by_filter_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size882 = 0;
            $_etype885 = 0;
            $xfer += $input->readListBegin($_etype885, $_size882);
            for ($_i886 = 0; $_i886 < $_size882; ++$_i886)
            {
              $elem887 = null;
              $xfer += $input->readString($elem887);
              $this->success []= $elem887;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidOperationException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\UnknownDBException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_names_by_filter_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter888)
          {
            $xfer += $output->writeString($iter888);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_table_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbname = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var \metastore\Table
   */
  public $new_tbl = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'new_tbl',
          'type' => TType::STRUCT,
          'class' => '\metastore\Table',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['new_tbl'])) {
        $this->new_tbl = $vals['new_tbl'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_table_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->new_tbl = new \metastore\Table();
            $xfer += $this->new_tbl->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_table_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->new_tbl !== null) {
      if (!is_object($this->new_tbl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_tbl', TType::STRUCT, 3);
      $xfer += $this->new_tbl->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_table_result {
  static $_TSPEC;

  /**
   * @var \metastore\InvalidOperationException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_table_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_table_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_table_with_environment_context_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbname = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var \metastore\Table
   */
  public $new_tbl = null;
  /**
   * @var \metastore\EnvironmentContext
   */
  public $environment_context = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'new_tbl',
          'type' => TType::STRUCT,
          'class' => '\metastore\Table',
          ),
        4 => array(
          'var' => 'environment_context',
          'type' => TType::STRUCT,
          'class' => '\metastore\EnvironmentContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['new_tbl'])) {
        $this->new_tbl = $vals['new_tbl'];
      }
      if (isset($vals['environment_context'])) {
        $this->environment_context = $vals['environment_context'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_table_with_environment_context_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->new_tbl = new \metastore\Table();
            $xfer += $this->new_tbl->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->environment_context = new \metastore\EnvironmentContext();
            $xfer += $this->environment_context->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_table_with_environment_context_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->new_tbl !== null) {
      if (!is_object($this->new_tbl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_tbl', TType::STRUCT, 3);
      $xfer += $this->new_tbl->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->environment_context !== null) {
      if (!is_object($this->environment_context)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('environment_context', TType::STRUCT, 4);
      $xfer += $this->environment_context->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_table_with_environment_context_result {
  static $_TSPEC;

  /**
   * @var \metastore\InvalidOperationException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_table_with_environment_context_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_table_with_environment_context_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_table_with_cascade_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbname = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var \metastore\Table
   */
  public $new_tbl = null;
  /**
   * @var bool
   */
  public $cascade = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'new_tbl',
          'type' => TType::STRUCT,
          'class' => '\metastore\Table',
          ),
        4 => array(
          'var' => 'cascade',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['new_tbl'])) {
        $this->new_tbl = $vals['new_tbl'];
      }
      if (isset($vals['cascade'])) {
        $this->cascade = $vals['cascade'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_table_with_cascade_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->new_tbl = new \metastore\Table();
            $xfer += $this->new_tbl->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->cascade);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_table_with_cascade_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->new_tbl !== null) {
      if (!is_object($this->new_tbl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_tbl', TType::STRUCT, 3);
      $xfer += $this->new_tbl->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cascade !== null) {
      $xfer += $output->writeFieldBegin('cascade', TType::BOOL, 4);
      $xfer += $output->writeBool($this->cascade);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_table_with_cascade_result {
  static $_TSPEC;

  /**
   * @var \metastore\InvalidOperationException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_table_with_cascade_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_table_with_cascade_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partition_args {
  static $_TSPEC;

  /**
   * @var \metastore\Partition
   */
  public $new_part = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'new_part',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['new_part'])) {
        $this->new_part = $vals['new_part'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partition_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->new_part = new \metastore\Partition();
            $xfer += $this->new_part->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_args');
    if ($this->new_part !== null) {
      if (!is_object($this->new_part)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_part', TType::STRUCT, 1);
      $xfer += $this->new_part->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partition_result {
  static $_TSPEC;

  /**
   * @var \metastore\Partition
   */
  public $success = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partition_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Partition();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\AlreadyExistsException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partition_with_environment_context_args {
  static $_TSPEC;

  /**
   * @var \metastore\Partition
   */
  public $new_part = null;
  /**
   * @var \metastore\EnvironmentContext
   */
  public $environment_context = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'new_part',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        2 => array(
          'var' => 'environment_context',
          'type' => TType::STRUCT,
          'class' => '\metastore\EnvironmentContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['new_part'])) {
        $this->new_part = $vals['new_part'];
      }
      if (isset($vals['environment_context'])) {
        $this->environment_context = $vals['environment_context'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partition_with_environment_context_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->new_part = new \metastore\Partition();
            $xfer += $this->new_part->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->environment_context = new \metastore\EnvironmentContext();
            $xfer += $this->environment_context->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_with_environment_context_args');
    if ($this->new_part !== null) {
      if (!is_object($this->new_part)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_part', TType::STRUCT, 1);
      $xfer += $this->new_part->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->environment_context !== null) {
      if (!is_object($this->environment_context)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('environment_context', TType::STRUCT, 2);
      $xfer += $this->environment_context->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partition_with_environment_context_result {
  static $_TSPEC;

  /**
   * @var \metastore\Partition
   */
  public $success = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partition_with_environment_context_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Partition();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\AlreadyExistsException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_with_environment_context_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partitions_args {
  static $_TSPEC;

  /**
   * @var \metastore\Partition[]
   */
  public $new_parts = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'new_parts',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['new_parts'])) {
        $this->new_parts = $vals['new_parts'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partitions_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->new_parts = array();
            $_size889 = 0;
            $_etype892 = 0;
            $xfer += $input->readListBegin($_etype892, $_size889);
            for ($_i893 = 0; $_i893 < $_size889; ++$_i893)
            {
              $elem894 = null;
              $elem894 = new \metastore\Partition();
              $xfer += $elem894->read($input);
              $this->new_parts []= $elem894;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partitions_args');
    if ($this->new_parts !== null) {
      if (!is_array($this->new_parts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_parts', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->new_parts));
        {
          foreach ($this->new_parts as $iter895)
          {
            $xfer += $iter895->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partitions_result {
  static $_TSPEC;

  /**
   * @var int
   */
  public $success = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partitions_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\AlreadyExistsException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partitions_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partitions_pspec_args {
  static $_TSPEC;

  /**
   * @var \metastore\PartitionSpec[]
   */
  public $new_parts = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'new_parts',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\PartitionSpec',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['new_parts'])) {
        $this->new_parts = $vals['new_parts'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partitions_pspec_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->new_parts = array();
            $_size896 = 0;
            $_etype899 = 0;
            $xfer += $input->readListBegin($_etype899, $_size896);
            for ($_i900 = 0; $_i900 < $_size896; ++$_i900)
            {
              $elem901 = null;
              $elem901 = new \metastore\PartitionSpec();
              $xfer += $elem901->read($input);
              $this->new_parts []= $elem901;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partitions_pspec_args');
    if ($this->new_parts !== null) {
      if (!is_array($this->new_parts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_parts', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->new_parts));
        {
          foreach ($this->new_parts as $iter902)
          {
            $xfer += $iter902->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partitions_pspec_result {
  static $_TSPEC;

  /**
   * @var int
   */
  public $success = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partitions_pspec_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\AlreadyExistsException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partitions_pspec_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_append_partition_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string[]
   */
  public $part_vals = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_append_partition_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->part_vals = array();
            $_size903 = 0;
            $_etype906 = 0;
            $xfer += $input->readListBegin($_etype906, $_size903);
            for ($_i907 = 0; $_i907 < $_size903; ++$_i907)
            {
              $elem908 = null;
              $xfer += $input->readString($elem908);
              $this->part_vals []= $elem908;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $iter909)
          {
            $xfer += $output->writeString($iter909);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_append_partition_result {
  static $_TSPEC;

  /**
   * @var \metastore\Partition
   */
  public $success = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_append_partition_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Partition();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\AlreadyExistsException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partitions_req_args {
  static $_TSPEC;

  /**
   * @var \metastore\AddPartitionsRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\AddPartitionsRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partitions_req_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\AddPartitionsRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partitions_req_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partitions_req_result {
  static $_TSPEC;

  /**
   * @var \metastore\AddPartitionsResult
   */
  public $success = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\AddPartitionsResult',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partitions_req_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\AddPartitionsResult();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\AlreadyExistsException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partitions_req_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_append_partition_with_environment_context_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string[]
   */
  public $part_vals = null;
  /**
   * @var \metastore\EnvironmentContext
   */
  public $environment_context = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'environment_context',
          'type' => TType::STRUCT,
          'class' => '\metastore\EnvironmentContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
      if (isset($vals['environment_context'])) {
        $this->environment_context = $vals['environment_context'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_append_partition_with_environment_context_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->part_vals = array();
            $_size910 = 0;
            $_etype913 = 0;
            $xfer += $input->readListBegin($_etype913, $_size910);
            for ($_i914 = 0; $_i914 < $_size910; ++$_i914)
            {
              $elem915 = null;
              $xfer += $input->readString($elem915);
              $this->part_vals []= $elem915;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->environment_context = new \metastore\EnvironmentContext();
            $xfer += $this->environment_context->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_with_environment_context_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $iter916)
          {
            $xfer += $output->writeString($iter916);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->environment_context !== null) {
      if (!is_object($this->environment_context)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('environment_context', TType::STRUCT, 4);
      $xfer += $this->environment_context->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_append_partition_with_environment_context_result {
  static $_TSPEC;

  /**
   * @var \metastore\Partition
   */
  public $success = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_append_partition_with_environment_context_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Partition();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\AlreadyExistsException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_with_environment_context_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_append_partition_by_name_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string
   */
  public $part_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_name'])) {
        $this->part_name = $vals['part_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_append_partition_by_name_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->part_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_by_name_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_name !== null) {
      $xfer += $output->writeFieldBegin('part_name', TType::STRING, 3);
      $xfer += $output->writeString($this->part_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_append_partition_by_name_result {
  static $_TSPEC;

  /**
   * @var \metastore\Partition
   */
  public $success = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_append_partition_by_name_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Partition();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\AlreadyExistsException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_by_name_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_append_partition_by_name_with_environment_context_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string
   */
  public $part_name = null;
  /**
   * @var \metastore\EnvironmentContext
   */
  public $environment_context = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'environment_context',
          'type' => TType::STRUCT,
          'class' => '\metastore\EnvironmentContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_name'])) {
        $this->part_name = $vals['part_name'];
      }
      if (isset($vals['environment_context'])) {
        $this->environment_context = $vals['environment_context'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_append_partition_by_name_with_environment_context_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->part_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->environment_context = new \metastore\EnvironmentContext();
            $xfer += $this->environment_context->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_by_name_with_environment_context_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_name !== null) {
      $xfer += $output->writeFieldBegin('part_name', TType::STRING, 3);
      $xfer += $output->writeString($this->part_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->environment_context !== null) {
      if (!is_object($this->environment_context)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('environment_context', TType::STRUCT, 4);
      $xfer += $this->environment_context->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_append_partition_by_name_with_environment_context_result {
  static $_TSPEC;

  /**
   * @var \metastore\Partition
   */
  public $success = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_append_partition_by_name_with_environment_context_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Partition();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\AlreadyExistsException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_by_name_with_environment_context_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_partition_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string[]
   */
  public $part_vals = null;
  /**
   * @var bool
   */
  public $deleteData = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'deleteData',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
      if (isset($vals['deleteData'])) {
        $this->deleteData = $vals['deleteData'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_partition_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->part_vals = array();
            $_size917 = 0;
            $_etype920 = 0;
            $xfer += $input->readListBegin($_etype920, $_size917);
            for ($_i921 = 0; $_i921 < $_size917; ++$_i921)
            {
              $elem922 = null;
              $xfer += $input->readString($elem922);
              $this->part_vals []= $elem922;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->deleteData);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $iter923)
          {
            $xfer += $output->writeString($iter923);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteData !== null) {
      $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 4);
      $xfer += $output->writeBool($this->deleteData);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_partition_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_partition_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_partition_with_environment_context_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string[]
   */
  public $part_vals = null;
  /**
   * @var bool
   */
  public $deleteData = null;
  /**
   * @var \metastore\EnvironmentContext
   */
  public $environment_context = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'deleteData',
          'type' => TType::BOOL,
          ),
        5 => array(
          'var' => 'environment_context',
          'type' => TType::STRUCT,
          'class' => '\metastore\EnvironmentContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
      if (isset($vals['deleteData'])) {
        $this->deleteData = $vals['deleteData'];
      }
      if (isset($vals['environment_context'])) {
        $this->environment_context = $vals['environment_context'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_partition_with_environment_context_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->part_vals = array();
            $_size924 = 0;
            $_etype927 = 0;
            $xfer += $input->readListBegin($_etype927, $_size924);
            for ($_i928 = 0; $_i928 < $_size924; ++$_i928)
            {
              $elem929 = null;
              $xfer += $input->readString($elem929);
              $this->part_vals []= $elem929;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->deleteData);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->environment_context = new \metastore\EnvironmentContext();
            $xfer += $this->environment_context->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_with_environment_context_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $iter930)
          {
            $xfer += $output->writeString($iter930);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteData !== null) {
      $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 4);
      $xfer += $output->writeBool($this->deleteData);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->environment_context !== null) {
      if (!is_object($this->environment_context)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('environment_context', TType::STRUCT, 5);
      $xfer += $this->environment_context->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_partition_with_environment_context_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_partition_with_environment_context_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_with_environment_context_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_partition_by_name_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string
   */
  public $part_name = null;
  /**
   * @var bool
   */
  public $deleteData = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'deleteData',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_name'])) {
        $this->part_name = $vals['part_name'];
      }
      if (isset($vals['deleteData'])) {
        $this->deleteData = $vals['deleteData'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_partition_by_name_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->part_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->deleteData);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_by_name_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_name !== null) {
      $xfer += $output->writeFieldBegin('part_name', TType::STRING, 3);
      $xfer += $output->writeString($this->part_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteData !== null) {
      $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 4);
      $xfer += $output->writeBool($this->deleteData);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_partition_by_name_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_partition_by_name_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_by_name_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_partition_by_name_with_environment_context_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string
   */
  public $part_name = null;
  /**
   * @var bool
   */
  public $deleteData = null;
  /**
   * @var \metastore\EnvironmentContext
   */
  public $environment_context = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'deleteData',
          'type' => TType::BOOL,
          ),
        5 => array(
          'var' => 'environment_context',
          'type' => TType::STRUCT,
          'class' => '\metastore\EnvironmentContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_name'])) {
        $this->part_name = $vals['part_name'];
      }
      if (isset($vals['deleteData'])) {
        $this->deleteData = $vals['deleteData'];
      }
      if (isset($vals['environment_context'])) {
        $this->environment_context = $vals['environment_context'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_partition_by_name_with_environment_context_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->part_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->deleteData);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->environment_context = new \metastore\EnvironmentContext();
            $xfer += $this->environment_context->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_by_name_with_environment_context_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_name !== null) {
      $xfer += $output->writeFieldBegin('part_name', TType::STRING, 3);
      $xfer += $output->writeString($this->part_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteData !== null) {
      $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 4);
      $xfer += $output->writeBool($this->deleteData);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->environment_context !== null) {
      if (!is_object($this->environment_context)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('environment_context', TType::STRUCT, 5);
      $xfer += $this->environment_context->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_partition_by_name_with_environment_context_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_partition_by_name_with_environment_context_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_by_name_with_environment_context_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_partitions_req_args {
  static $_TSPEC;

  /**
   * @var \metastore\DropPartitionsRequest
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\metastore\DropPartitionsRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_partitions_req_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \metastore\DropPartitionsRequest();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partitions_req_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_partitions_req_result {
  static $_TSPEC;

  /**
   * @var \metastore\DropPartitionsResult
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\DropPartitionsResult',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_partitions_req_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\DropPartitionsResult();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partitions_req_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string[]
   */
  public $part_vals = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->part_vals = array();
            $_size931 = 0;
            $_etype934 = 0;
            $xfer += $input->readListBegin($_etype934, $_size931);
            for ($_i935 = 0; $_i935 < $_size931; ++$_i935)
            {
              $elem936 = null;
              $xfer += $input->readString($elem936);
              $this->part_vals []= $elem936;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $iter937)
          {
            $xfer += $output->writeString($iter937);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_result {
  static $_TSPEC;

  /**
   * @var \metastore\Partition
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Partition();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_exchange_partition_args {
  static $_TSPEC;

  /**
   * @var array
   */
  public $partitionSpecs = null;
  /**
   * @var string
   */
  public $source_db = null;
  /**
   * @var string
   */
  public $source_table_name = null;
  /**
   * @var string
   */
  public $dest_db = null;
  /**
   * @var string
   */
  public $dest_table_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'partitionSpecs',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'source_db',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'source_table_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'dest_db',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'dest_table_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['partitionSpecs'])) {
        $this->partitionSpecs = $vals['partitionSpecs'];
      }
      if (isset($vals['source_db'])) {
        $this->source_db = $vals['source_db'];
      }
      if (isset($vals['source_table_name'])) {
        $this->source_table_name = $vals['source_table_name'];
      }
      if (isset($vals['dest_db'])) {
        $this->dest_db = $vals['dest_db'];
      }
      if (isset($vals['dest_table_name'])) {
        $this->dest_table_name = $vals['dest_table_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_exchange_partition_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->partitionSpecs = array();
            $_size938 = 0;
            $_ktype939 = 0;
            $_vtype940 = 0;
            $xfer += $input->readMapBegin($_ktype939, $_vtype940, $_size938);
            for ($_i942 = 0; $_i942 < $_size938; ++$_i942)
            {
              $key943 = '';
              $val944 = '';
              $xfer += $input->readString($key943);
              $xfer += $input->readString($val944);
              $this->partitionSpecs[$key943] = $val944;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->source_db);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->source_table_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dest_db);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dest_table_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_exchange_partition_args');
    if ($this->partitionSpecs !== null) {
      if (!is_array($this->partitionSpecs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partitionSpecs', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->partitionSpecs));
        {
          foreach ($this->partitionSpecs as $kiter945 => $viter946)
          {
            $xfer += $output->writeString($kiter945);
            $xfer += $output->writeString($viter946);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->source_db !== null) {
      $xfer += $output->writeFieldBegin('source_db', TType::STRING, 2);
      $xfer += $output->writeString($this->source_db);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->source_table_name !== null) {
      $xfer += $output->writeFieldBegin('source_table_name', TType::STRING, 3);
      $xfer += $output->writeString($this->source_table_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dest_db !== null) {
      $xfer += $output->writeFieldBegin('dest_db', TType::STRING, 4);
      $xfer += $output->writeString($this->dest_db);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dest_table_name !== null) {
      $xfer += $output->writeFieldBegin('dest_table_name', TType::STRING, 5);
      $xfer += $output->writeString($this->dest_table_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_exchange_partition_result {
  static $_TSPEC;

  /**
   * @var \metastore\Partition
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o3 = null;
  /**
   * @var \metastore\InvalidInputException
   */
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidInputException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_exchange_partition_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Partition();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\InvalidObjectException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\InvalidInputException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_exchange_partition_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_exchange_partitions_args {
  static $_TSPEC;

  /**
   * @var array
   */
  public $partitionSpecs = null;
  /**
   * @var string
   */
  public $source_db = null;
  /**
   * @var string
   */
  public $source_table_name = null;
  /**
   * @var string
   */
  public $dest_db = null;
  /**
   * @var string
   */
  public $dest_table_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'partitionSpecs',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'source_db',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'source_table_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'dest_db',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'dest_table_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['partitionSpecs'])) {
        $this->partitionSpecs = $vals['partitionSpecs'];
      }
      if (isset($vals['source_db'])) {
        $this->source_db = $vals['source_db'];
      }
      if (isset($vals['source_table_name'])) {
        $this->source_table_name = $vals['source_table_name'];
      }
      if (isset($vals['dest_db'])) {
        $this->dest_db = $vals['dest_db'];
      }
      if (isset($vals['dest_table_name'])) {
        $this->dest_table_name = $vals['dest_table_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_exchange_partitions_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->partitionSpecs = array();
            $_size947 = 0;
            $_ktype948 = 0;
            $_vtype949 = 0;
            $xfer += $input->readMapBegin($_ktype948, $_vtype949, $_size947);
            for ($_i951 = 0; $_i951 < $_size947; ++$_i951)
            {
              $key952 = '';
              $val953 = '';
              $xfer += $input->readString($key952);
              $xfer += $input->readString($val953);
              $this->partitionSpecs[$key952] = $val953;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->source_db);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->source_table_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dest_db);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dest_table_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_exchange_partitions_args');
    if ($this->partitionSpecs !== null) {
      if (!is_array($this->partitionSpecs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partitionSpecs', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->partitionSpecs));
        {
          foreach ($this->partitionSpecs as $kiter954 => $viter955)
          {
            $xfer += $output->writeString($kiter954);
            $xfer += $output->writeString($viter955);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->source_db !== null) {
      $xfer += $output->writeFieldBegin('source_db', TType::STRING, 2);
      $xfer += $output->writeString($this->source_db);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->source_table_name !== null) {
      $xfer += $output->writeFieldBegin('source_table_name', TType::STRING, 3);
      $xfer += $output->writeString($this->source_table_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dest_db !== null) {
      $xfer += $output->writeFieldBegin('dest_db', TType::STRING, 4);
      $xfer += $output->writeString($this->dest_db);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dest_table_name !== null) {
      $xfer += $output->writeFieldBegin('dest_table_name', TType::STRING, 5);
      $xfer += $output->writeString($this->dest_table_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_exchange_partitions_result {
  static $_TSPEC;

  /**
   * @var \metastore\Partition[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o3 = null;
  /**
   * @var \metastore\InvalidInputException
   */
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidInputException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_exchange_partitions_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size956 = 0;
            $_etype959 = 0;
            $xfer += $input->readListBegin($_etype959, $_size956);
            for ($_i960 = 0; $_i960 < $_size956; ++$_i960)
            {
              $elem961 = null;
              $elem961 = new \metastore\Partition();
              $xfer += $elem961->read($input);
              $this->success []= $elem961;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\InvalidObjectException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\InvalidInputException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_exchange_partitions_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter962)
          {
            $xfer += $iter962->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_with_auth_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string[]
   */
  public $part_vals = null;
  /**
   * @var string
   */
  public $user_name = null;
  /**
   * @var string[]
   */
  public $group_names = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'user_name',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'group_names',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
      if (isset($vals['user_name'])) {
        $this->user_name = $vals['user_name'];
      }
      if (isset($vals['group_names'])) {
        $this->group_names = $vals['group_names'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_with_auth_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->part_vals = array();
            $_size963 = 0;
            $_etype966 = 0;
            $xfer += $input->readListBegin($_etype966, $_size963);
            for ($_i967 = 0; $_i967 < $_size963; ++$_i967)
            {
              $elem968 = null;
              $xfer += $input->readString($elem968);
              $this->part_vals []= $elem968;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->user_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->group_names = array();
            $_size969 = 0;
            $_etype972 = 0;
            $xfer += $input->readListBegin($_etype972, $_size969);
            for ($_i973 = 0; $_i973 < $_size969; ++$_i973)
            {
              $elem974 = null;
              $xfer += $input->readString($elem974);
              $this->group_names []= $elem974;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_with_auth_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $iter975)
          {
            $xfer += $output->writeString($iter975);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->user_name !== null) {
      $xfer += $output->writeFieldBegin('user_name', TType::STRING, 4);
      $xfer += $output->writeString($this->user_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->group_names !== null) {
      if (!is_array($this->group_names)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('group_names', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRING, count($this->group_names));
        {
          foreach ($this->group_names as $iter976)
          {
            $xfer += $output->writeString($iter976);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_with_auth_result {
  static $_TSPEC;

  /**
   * @var \metastore\Partition
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_with_auth_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Partition();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_with_auth_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_by_name_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string
   */
  public $part_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_name'])) {
        $this->part_name = $vals['part_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_by_name_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->part_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_by_name_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_name !== null) {
      $xfer += $output->writeFieldBegin('part_name', TType::STRING, 3);
      $xfer += $output->writeString($this->part_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_by_name_result {
  static $_TSPEC;

  /**
   * @var \metastore\Partition
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_by_name_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Partition();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_by_name_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var int
   */
  public $max_parts = -1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'max_parts',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['max_parts'])) {
        $this->max_parts = $vals['max_parts'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->max_parts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_parts !== null) {
      $xfer += $output->writeFieldBegin('max_parts', TType::I16, 3);
      $xfer += $output->writeI16($this->max_parts);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_result {
  static $_TSPEC;

  /**
   * @var \metastore\Partition[]
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size977 = 0;
            $_etype980 = 0;
            $xfer += $input->readListBegin($_etype980, $_size977);
            for ($_i981 = 0; $_i981 < $_size977; ++$_i981)
            {
              $elem982 = null;
              $elem982 = new \metastore\Partition();
              $xfer += $elem982->read($input);
              $this->success []= $elem982;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter983)
          {
            $xfer += $iter983->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_with_auth_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var int
   */
  public $max_parts = -1;
  /**
   * @var string
   */
  public $user_name = null;
  /**
   * @var string[]
   */
  public $group_names = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'max_parts',
          'type' => TType::I16,
          ),
        4 => array(
          'var' => 'user_name',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'group_names',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['max_parts'])) {
        $this->max_parts = $vals['max_parts'];
      }
      if (isset($vals['user_name'])) {
        $this->user_name = $vals['user_name'];
      }
      if (isset($vals['group_names'])) {
        $this->group_names = $vals['group_names'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_with_auth_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->max_parts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->user_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->group_names = array();
            $_size984 = 0;
            $_etype987 = 0;
            $xfer += $input->readListBegin($_etype987, $_size984);
            for ($_i988 = 0; $_i988 < $_size984; ++$_i988)
            {
              $elem989 = null;
              $xfer += $input->readString($elem989);
              $this->group_names []= $elem989;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_with_auth_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_parts !== null) {
      $xfer += $output->writeFieldBegin('max_parts', TType::I16, 3);
      $xfer += $output->writeI16($this->max_parts);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->user_name !== null) {
      $xfer += $output->writeFieldBegin('user_name', TType::STRING, 4);
      $xfer += $output->writeString($this->user_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->group_names !== null) {
      if (!is_array($this->group_names)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('group_names', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRING, count($this->group_names));
        {
          foreach ($this->group_names as $iter990)
          {
            $xfer += $output->writeString($iter990);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_with_auth_result {
  static $_TSPEC;

  /**
   * @var \metastore\Partition[]
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_with_auth_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size991 = 0;
            $_etype994 = 0;
            $xfer += $input->readListBegin($_etype994, $_size991);
            for ($_i995 = 0; $_i995 < $_size991; ++$_i995)
            {
              $elem996 = null;
              $elem996 = new \metastore\Partition();
              $xfer += $elem996->read($input);
              $this->success []= $elem996;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_with_auth_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter997)
          {
            $xfer += $iter997->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_pspec_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var int
   */
  public $max_parts = -1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'max_parts',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['max_parts'])) {
        $this->max_parts = $vals['max_parts'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_pspec_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->max_parts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_pspec_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_parts !== null) {
      $xfer += $output->writeFieldBegin('max_parts', TType::I32, 3);
      $xfer += $output->writeI32($this->max_parts);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_pspec_result {
  static $_TSPEC;

  /**
   * @var \metastore\PartitionSpec[]
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\PartitionSpec',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_pspec_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size998 = 0;
            $_etype1001 = 0;
            $xfer += $input->readListBegin($_etype1001, $_size998);
            for ($_i1002 = 0; $_i1002 < $_size998; ++$_i1002)
            {
              $elem1003 = null;
              $elem1003 = new \metastore\PartitionSpec();
              $xfer += $elem1003->read($input);
              $this->success []= $elem1003;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_pspec_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter1004)
          {
            $xfer += $iter1004->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_names_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var int
   */
  public $max_parts = -1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'max_parts',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['max_parts'])) {
        $this->max_parts = $vals['max_parts'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_names_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->max_parts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_names_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_parts !== null) {
      $xfer += $output->writeFieldBegin('max_parts', TType::I16, 3);
      $xfer += $output->writeI16($this->max_parts);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_names_result {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_names_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1005 = 0;
            $_etype1008 = 0;
            $xfer += $input->readListBegin($_etype1008, $_size1005);
            for ($_i1009 = 0; $_i1009 < $_size1005; ++$_i1009)
            {
              $elem1010 = null;
              $xfer += $input->readString($elem1010);
              $this->success []= $elem1010;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_names_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter1011)
          {
            $xfer += $output->writeString($iter1011);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_values_args {
  static $_TSPEC;

  /**
   * @var \metastore\PartitionValuesRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\PartitionValuesRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_values_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\PartitionValuesRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_values_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_values_result {
  static $_TSPEC;

  /**
   * @var \metastore\PartitionValuesResponse
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\PartitionValuesResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_values_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\PartitionValuesResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_values_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_ps_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string[]
   */
  public $part_vals = null;
  /**
   * @var int
   */
  public $max_parts = -1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'max_parts',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
      if (isset($vals['max_parts'])) {
        $this->max_parts = $vals['max_parts'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_ps_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->part_vals = array();
            $_size1012 = 0;
            $_etype1015 = 0;
            $xfer += $input->readListBegin($_etype1015, $_size1012);
            for ($_i1016 = 0; $_i1016 < $_size1012; ++$_i1016)
            {
              $elem1017 = null;
              $xfer += $input->readString($elem1017);
              $this->part_vals []= $elem1017;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->max_parts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_ps_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $iter1018)
          {
            $xfer += $output->writeString($iter1018);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_parts !== null) {
      $xfer += $output->writeFieldBegin('max_parts', TType::I16, 4);
      $xfer += $output->writeI16($this->max_parts);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_ps_result {
  static $_TSPEC;

  /**
   * @var \metastore\Partition[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_ps_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1019 = 0;
            $_etype1022 = 0;
            $xfer += $input->readListBegin($_etype1022, $_size1019);
            for ($_i1023 = 0; $_i1023 < $_size1019; ++$_i1023)
            {
              $elem1024 = null;
              $elem1024 = new \metastore\Partition();
              $xfer += $elem1024->read($input);
              $this->success []= $elem1024;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_ps_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter1025)
          {
            $xfer += $iter1025->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_ps_with_auth_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string[]
   */
  public $part_vals = null;
  /**
   * @var int
   */
  public $max_parts = -1;
  /**
   * @var string
   */
  public $user_name = null;
  /**
   * @var string[]
   */
  public $group_names = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'max_parts',
          'type' => TType::I16,
          ),
        5 => array(
          'var' => 'user_name',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'group_names',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
      if (isset($vals['max_parts'])) {
        $this->max_parts = $vals['max_parts'];
      }
      if (isset($vals['user_name'])) {
        $this->user_name = $vals['user_name'];
      }
      if (isset($vals['group_names'])) {
        $this->group_names = $vals['group_names'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_ps_with_auth_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->part_vals = array();
            $_size1026 = 0;
            $_etype1029 = 0;
            $xfer += $input->readListBegin($_etype1029, $_size1026);
            for ($_i1030 = 0; $_i1030 < $_size1026; ++$_i1030)
            {
              $elem1031 = null;
              $xfer += $input->readString($elem1031);
              $this->part_vals []= $elem1031;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->max_parts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->user_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::LST) {
            $this->group_names = array();
            $_size1032 = 0;
            $_etype1035 = 0;
            $xfer += $input->readListBegin($_etype1035, $_size1032);
            for ($_i1036 = 0; $_i1036 < $_size1032; ++$_i1036)
            {
              $elem1037 = null;
              $xfer += $input->readString($elem1037);
              $this->group_names []= $elem1037;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_ps_with_auth_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $iter1038)
          {
            $xfer += $output->writeString($iter1038);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_parts !== null) {
      $xfer += $output->writeFieldBegin('max_parts', TType::I16, 4);
      $xfer += $output->writeI16($this->max_parts);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->user_name !== null) {
      $xfer += $output->writeFieldBegin('user_name', TType::STRING, 5);
      $xfer += $output->writeString($this->user_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->group_names !== null) {
      if (!is_array($this->group_names)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('group_names', TType::LST, 6);
      {
        $output->writeListBegin(TType::STRING, count($this->group_names));
        {
          foreach ($this->group_names as $iter1039)
          {
            $xfer += $output->writeString($iter1039);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_ps_with_auth_result {
  static $_TSPEC;

  /**
   * @var \metastore\Partition[]
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_ps_with_auth_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1040 = 0;
            $_etype1043 = 0;
            $xfer += $input->readListBegin($_etype1043, $_size1040);
            for ($_i1044 = 0; $_i1044 < $_size1040; ++$_i1044)
            {
              $elem1045 = null;
              $elem1045 = new \metastore\Partition();
              $xfer += $elem1045->read($input);
              $this->success []= $elem1045;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_ps_with_auth_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter1046)
          {
            $xfer += $iter1046->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_names_ps_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string[]
   */
  public $part_vals = null;
  /**
   * @var int
   */
  public $max_parts = -1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'max_parts',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
      if (isset($vals['max_parts'])) {
        $this->max_parts = $vals['max_parts'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_names_ps_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->part_vals = array();
            $_size1047 = 0;
            $_etype1050 = 0;
            $xfer += $input->readListBegin($_etype1050, $_size1047);
            for ($_i1051 = 0; $_i1051 < $_size1047; ++$_i1051)
            {
              $elem1052 = null;
              $xfer += $input->readString($elem1052);
              $this->part_vals []= $elem1052;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->max_parts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_names_ps_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $iter1053)
          {
            $xfer += $output->writeString($iter1053);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_parts !== null) {
      $xfer += $output->writeFieldBegin('max_parts', TType::I16, 4);
      $xfer += $output->writeI16($this->max_parts);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_names_ps_result {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_names_ps_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1054 = 0;
            $_etype1057 = 0;
            $xfer += $input->readListBegin($_etype1057, $_size1054);
            for ($_i1058 = 0; $_i1058 < $_size1054; ++$_i1058)
            {
              $elem1059 = null;
              $xfer += $input->readString($elem1059);
              $this->success []= $elem1059;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_names_ps_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter1060)
          {
            $xfer += $output->writeString($iter1060);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_by_filter_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string
   */
  public $filter = null;
  /**
   * @var int
   */
  public $max_parts = -1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'filter',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'max_parts',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['filter'])) {
        $this->filter = $vals['filter'];
      }
      if (isset($vals['max_parts'])) {
        $this->max_parts = $vals['max_parts'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_by_filter_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->filter);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->max_parts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_by_filter_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filter !== null) {
      $xfer += $output->writeFieldBegin('filter', TType::STRING, 3);
      $xfer += $output->writeString($this->filter);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_parts !== null) {
      $xfer += $output->writeFieldBegin('max_parts', TType::I16, 4);
      $xfer += $output->writeI16($this->max_parts);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_by_filter_result {
  static $_TSPEC;

  /**
   * @var \metastore\Partition[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_by_filter_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1061 = 0;
            $_etype1064 = 0;
            $xfer += $input->readListBegin($_etype1064, $_size1061);
            for ($_i1065 = 0; $_i1065 < $_size1061; ++$_i1065)
            {
              $elem1066 = null;
              $elem1066 = new \metastore\Partition();
              $xfer += $elem1066->read($input);
              $this->success []= $elem1066;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_by_filter_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter1067)
          {
            $xfer += $iter1067->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_part_specs_by_filter_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string
   */
  public $filter = null;
  /**
   * @var int
   */
  public $max_parts = -1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'filter',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'max_parts',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['filter'])) {
        $this->filter = $vals['filter'];
      }
      if (isset($vals['max_parts'])) {
        $this->max_parts = $vals['max_parts'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_part_specs_by_filter_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->filter);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->max_parts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_part_specs_by_filter_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filter !== null) {
      $xfer += $output->writeFieldBegin('filter', TType::STRING, 3);
      $xfer += $output->writeString($this->filter);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_parts !== null) {
      $xfer += $output->writeFieldBegin('max_parts', TType::I32, 4);
      $xfer += $output->writeI32($this->max_parts);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_part_specs_by_filter_result {
  static $_TSPEC;

  /**
   * @var \metastore\PartitionSpec[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\PartitionSpec',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_part_specs_by_filter_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1068 = 0;
            $_etype1071 = 0;
            $xfer += $input->readListBegin($_etype1071, $_size1068);
            for ($_i1072 = 0; $_i1072 < $_size1068; ++$_i1072)
            {
              $elem1073 = null;
              $elem1073 = new \metastore\PartitionSpec();
              $xfer += $elem1073->read($input);
              $this->success []= $elem1073;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_part_specs_by_filter_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter1074)
          {
            $xfer += $iter1074->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_by_expr_args {
  static $_TSPEC;

  /**
   * @var \metastore\PartitionsByExprRequest
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\metastore\PartitionsByExprRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_by_expr_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \metastore\PartitionsByExprRequest();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_by_expr_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_by_expr_result {
  static $_TSPEC;

  /**
   * @var \metastore\PartitionsByExprResult
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\PartitionsByExprResult',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_by_expr_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\PartitionsByExprResult();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_by_expr_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_num_partitions_by_filter_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string
   */
  public $filter = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'filter',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['filter'])) {
        $this->filter = $vals['filter'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_num_partitions_by_filter_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->filter);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_num_partitions_by_filter_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filter !== null) {
      $xfer += $output->writeFieldBegin('filter', TType::STRING, 3);
      $xfer += $output->writeString($this->filter);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_num_partitions_by_filter_result {
  static $_TSPEC;

  /**
   * @var int
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_num_partitions_by_filter_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_num_partitions_by_filter_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_by_names_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string[]
   */
  public $names = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'names',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['names'])) {
        $this->names = $vals['names'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_by_names_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->names = array();
            $_size1075 = 0;
            $_etype1078 = 0;
            $xfer += $input->readListBegin($_etype1078, $_size1075);
            for ($_i1079 = 0; $_i1079 < $_size1075; ++$_i1079)
            {
              $elem1080 = null;
              $xfer += $input->readString($elem1080);
              $this->names []= $elem1080;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_by_names_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->names !== null) {
      if (!is_array($this->names)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('names', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->names));
        {
          foreach ($this->names as $iter1081)
          {
            $xfer += $output->writeString($iter1081);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_by_names_result {
  static $_TSPEC;

  /**
   * @var \metastore\Partition[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_by_names_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1082 = 0;
            $_etype1085 = 0;
            $xfer += $input->readListBegin($_etype1085, $_size1082);
            for ($_i1086 = 0; $_i1086 < $_size1082; ++$_i1086)
            {
              $elem1087 = null;
              $elem1087 = new \metastore\Partition();
              $xfer += $elem1087->read($input);
              $this->success []= $elem1087;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_by_names_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter1088)
          {
            $xfer += $iter1088->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_partition_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var \metastore\Partition
   */
  public $new_part = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'new_part',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['new_part'])) {
        $this->new_part = $vals['new_part'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_partition_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->new_part = new \metastore\Partition();
            $xfer += $this->new_part->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partition_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->new_part !== null) {
      if (!is_object($this->new_part)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_part', TType::STRUCT, 3);
      $xfer += $this->new_part->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_partition_result {
  static $_TSPEC;

  /**
   * @var \metastore\InvalidOperationException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_partition_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partition_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_partitions_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var \metastore\Partition[]
   */
  public $new_parts = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'new_parts',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['new_parts'])) {
        $this->new_parts = $vals['new_parts'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_partitions_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->new_parts = array();
            $_size1089 = 0;
            $_etype1092 = 0;
            $xfer += $input->readListBegin($_etype1092, $_size1089);
            for ($_i1093 = 0; $_i1093 < $_size1089; ++$_i1093)
            {
              $elem1094 = null;
              $elem1094 = new \metastore\Partition();
              $xfer += $elem1094->read($input);
              $this->new_parts []= $elem1094;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partitions_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->new_parts !== null) {
      if (!is_array($this->new_parts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_parts', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->new_parts));
        {
          foreach ($this->new_parts as $iter1095)
          {
            $xfer += $iter1095->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_partitions_result {
  static $_TSPEC;

  /**
   * @var \metastore\InvalidOperationException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_partitions_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partitions_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_partitions_with_environment_context_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var \metastore\Partition[]
   */
  public $new_parts = null;
  /**
   * @var \metastore\EnvironmentContext
   */
  public $environment_context = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'new_parts',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        4 => array(
          'var' => 'environment_context',
          'type' => TType::STRUCT,
          'class' => '\metastore\EnvironmentContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['new_parts'])) {
        $this->new_parts = $vals['new_parts'];
      }
      if (isset($vals['environment_context'])) {
        $this->environment_context = $vals['environment_context'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_partitions_with_environment_context_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->new_parts = array();
            $_size1096 = 0;
            $_etype1099 = 0;
            $xfer += $input->readListBegin($_etype1099, $_size1096);
            for ($_i1100 = 0; $_i1100 < $_size1096; ++$_i1100)
            {
              $elem1101 = null;
              $elem1101 = new \metastore\Partition();
              $xfer += $elem1101->read($input);
              $this->new_parts []= $elem1101;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->environment_context = new \metastore\EnvironmentContext();
            $xfer += $this->environment_context->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partitions_with_environment_context_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->new_parts !== null) {
      if (!is_array($this->new_parts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_parts', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->new_parts));
        {
          foreach ($this->new_parts as $iter1102)
          {
            $xfer += $iter1102->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->environment_context !== null) {
      if (!is_object($this->environment_context)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('environment_context', TType::STRUCT, 4);
      $xfer += $this->environment_context->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_partitions_with_environment_context_result {
  static $_TSPEC;

  /**
   * @var \metastore\InvalidOperationException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_partitions_with_environment_context_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partitions_with_environment_context_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_partition_with_environment_context_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var \metastore\Partition
   */
  public $new_part = null;
  /**
   * @var \metastore\EnvironmentContext
   */
  public $environment_context = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'new_part',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        4 => array(
          'var' => 'environment_context',
          'type' => TType::STRUCT,
          'class' => '\metastore\EnvironmentContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['new_part'])) {
        $this->new_part = $vals['new_part'];
      }
      if (isset($vals['environment_context'])) {
        $this->environment_context = $vals['environment_context'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_partition_with_environment_context_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->new_part = new \metastore\Partition();
            $xfer += $this->new_part->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->environment_context = new \metastore\EnvironmentContext();
            $xfer += $this->environment_context->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partition_with_environment_context_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->new_part !== null) {
      if (!is_object($this->new_part)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_part', TType::STRUCT, 3);
      $xfer += $this->new_part->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->environment_context !== null) {
      if (!is_object($this->environment_context)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('environment_context', TType::STRUCT, 4);
      $xfer += $this->environment_context->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_partition_with_environment_context_result {
  static $_TSPEC;

  /**
   * @var \metastore\InvalidOperationException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_partition_with_environment_context_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partition_with_environment_context_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_rename_partition_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string[]
   */
  public $part_vals = null;
  /**
   * @var \metastore\Partition
   */
  public $new_part = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'new_part',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
      if (isset($vals['new_part'])) {
        $this->new_part = $vals['new_part'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_rename_partition_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->part_vals = array();
            $_size1103 = 0;
            $_etype1106 = 0;
            $xfer += $input->readListBegin($_etype1106, $_size1103);
            for ($_i1107 = 0; $_i1107 < $_size1103; ++$_i1107)
            {
              $elem1108 = null;
              $xfer += $input->readString($elem1108);
              $this->part_vals []= $elem1108;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->new_part = new \metastore\Partition();
            $xfer += $this->new_part->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_rename_partition_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $iter1109)
          {
            $xfer += $output->writeString($iter1109);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->new_part !== null) {
      if (!is_object($this->new_part)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_part', TType::STRUCT, 4);
      $xfer += $this->new_part->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_rename_partition_result {
  static $_TSPEC;

  /**
   * @var \metastore\InvalidOperationException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_rename_partition_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_rename_partition_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_partition_name_has_valid_characters_args {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $part_vals = null;
  /**
   * @var bool
   */
  public $throw_exception = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'part_vals',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'throw_exception',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
      if (isset($vals['throw_exception'])) {
        $this->throw_exception = $vals['throw_exception'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_partition_name_has_valid_characters_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->part_vals = array();
            $_size1110 = 0;
            $_etype1113 = 0;
            $xfer += $input->readListBegin($_etype1113, $_size1110);
            for ($_i1114 = 0; $_i1114 < $_size1110; ++$_i1114)
            {
              $elem1115 = null;
              $xfer += $input->readString($elem1115);
              $this->part_vals []= $elem1115;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->throw_exception);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_has_valid_characters_args');
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $iter1116)
          {
            $xfer += $output->writeString($iter1116);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->throw_exception !== null) {
      $xfer += $output->writeFieldBegin('throw_exception', TType::BOOL, 2);
      $xfer += $output->writeBool($this->throw_exception);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_partition_name_has_valid_characters_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_partition_name_has_valid_characters_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_has_valid_characters_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_config_value_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $name = null;
  /**
   * @var string
   */
  public $defaultValue = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'defaultValue',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['defaultValue'])) {
        $this->defaultValue = $vals['defaultValue'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_config_value_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->defaultValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_config_value_args');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->defaultValue !== null) {
      $xfer += $output->writeFieldBegin('defaultValue', TType::STRING, 2);
      $xfer += $output->writeString($this->defaultValue);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_config_value_result {
  static $_TSPEC;

  /**
   * @var string
   */
  public $success = null;
  /**
   * @var \metastore\ConfigValSecurityException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\ConfigValSecurityException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_config_value_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\ConfigValSecurityException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_config_value_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
      $xfer += $output->writeString($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_partition_name_to_vals_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $part_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'part_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['part_name'])) {
        $this->part_name = $vals['part_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_partition_name_to_vals_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->part_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_to_vals_args');
    if ($this->part_name !== null) {
      $xfer += $output->writeFieldBegin('part_name', TType::STRING, 1);
      $xfer += $output->writeString($this->part_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_partition_name_to_vals_result {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_partition_name_to_vals_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1117 = 0;
            $_etype1120 = 0;
            $xfer += $input->readListBegin($_etype1120, $_size1117);
            for ($_i1121 = 0; $_i1121 < $_size1117; ++$_i1121)
            {
              $elem1122 = null;
              $xfer += $input->readString($elem1122);
              $this->success []= $elem1122;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_to_vals_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter1123)
          {
            $xfer += $output->writeString($iter1123);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_partition_name_to_spec_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $part_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'part_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['part_name'])) {
        $this->part_name = $vals['part_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_partition_name_to_spec_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->part_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_to_spec_args');
    if ($this->part_name !== null) {
      $xfer += $output->writeFieldBegin('part_name', TType::STRING, 1);
      $xfer += $output->writeString($this->part_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_partition_name_to_spec_result {
  static $_TSPEC;

  /**
   * @var array
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_partition_name_to_spec_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::MAP) {
            $this->success = array();
            $_size1124 = 0;
            $_ktype1125 = 0;
            $_vtype1126 = 0;
            $xfer += $input->readMapBegin($_ktype1125, $_vtype1126, $_size1124);
            for ($_i1128 = 0; $_i1128 < $_size1124; ++$_i1128)
            {
              $key1129 = '';
              $val1130 = '';
              $xfer += $input->readString($key1129);
              $xfer += $input->readString($val1130);
              $this->success[$key1129] = $val1130;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_to_spec_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->success));
        {
          foreach ($this->success as $kiter1131 => $viter1132)
          {
            $xfer += $output->writeString($kiter1131);
            $xfer += $output->writeString($viter1132);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_markPartitionForEvent_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var array
   */
  public $part_vals = null;
  /**
   * @var int
   */
  public $eventType = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'eventType',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
      if (isset($vals['eventType'])) {
        $this->eventType = $vals['eventType'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_markPartitionForEvent_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::MAP) {
            $this->part_vals = array();
            $_size1133 = 0;
            $_ktype1134 = 0;
            $_vtype1135 = 0;
            $xfer += $input->readMapBegin($_ktype1134, $_vtype1135, $_size1133);
            for ($_i1137 = 0; $_i1137 < $_size1133; ++$_i1137)
            {
              $key1138 = '';
              $val1139 = '';
              $xfer += $input->readString($key1138);
              $xfer += $input->readString($val1139);
              $this->part_vals[$key1138] = $val1139;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->eventType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_markPartitionForEvent_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::MAP, 3);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $kiter1140 => $viter1141)
          {
            $xfer += $output->writeString($kiter1140);
            $xfer += $output->writeString($viter1141);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->eventType !== null) {
      $xfer += $output->writeFieldBegin('eventType', TType::I32, 4);
      $xfer += $output->writeI32($this->eventType);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_markPartitionForEvent_result {
  static $_TSPEC;

  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;
  /**
   * @var \metastore\UnknownDBException
   */
  public $o3 = null;
  /**
   * @var \metastore\UnknownTableException
   */
  public $o4 = null;
  /**
   * @var \metastore\UnknownPartitionException
   */
  public $o5 = null;
  /**
   * @var \metastore\InvalidPartitionException
   */
  public $o6 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownDBException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownTableException',
          ),
        5 => array(
          'var' => 'o5',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownPartitionException',
          ),
        6 => array(
          'var' => 'o6',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidPartitionException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
      if (isset($vals['o5'])) {
        $this->o5 = $vals['o5'];
      }
      if (isset($vals['o6'])) {
        $this->o6 = $vals['o6'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_markPartitionForEvent_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\UnknownDBException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\UnknownTableException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->o5 = new \metastore\UnknownPartitionException();
            $xfer += $this->o5->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->o6 = new \metastore\InvalidPartitionException();
            $xfer += $this->o6->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_markPartitionForEvent_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o5 !== null) {
      $xfer += $output->writeFieldBegin('o5', TType::STRUCT, 5);
      $xfer += $this->o5->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o6 !== null) {
      $xfer += $output->writeFieldBegin('o6', TType::STRUCT, 6);
      $xfer += $this->o6->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_isPartitionMarkedForEvent_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var array
   */
  public $part_vals = null;
  /**
   * @var int
   */
  public $eventType = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'eventType',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
      if (isset($vals['eventType'])) {
        $this->eventType = $vals['eventType'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_isPartitionMarkedForEvent_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::MAP) {
            $this->part_vals = array();
            $_size1142 = 0;
            $_ktype1143 = 0;
            $_vtype1144 = 0;
            $xfer += $input->readMapBegin($_ktype1143, $_vtype1144, $_size1142);
            for ($_i1146 = 0; $_i1146 < $_size1142; ++$_i1146)
            {
              $key1147 = '';
              $val1148 = '';
              $xfer += $input->readString($key1147);
              $xfer += $input->readString($val1148);
              $this->part_vals[$key1147] = $val1148;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->eventType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_isPartitionMarkedForEvent_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::MAP, 3);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $kiter1149 => $viter1150)
          {
            $xfer += $output->writeString($kiter1149);
            $xfer += $output->writeString($viter1150);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->eventType !== null) {
      $xfer += $output->writeFieldBegin('eventType', TType::I32, 4);
      $xfer += $output->writeI32($this->eventType);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_isPartitionMarkedForEvent_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;
  /**
   * @var \metastore\UnknownDBException
   */
  public $o3 = null;
  /**
   * @var \metastore\UnknownTableException
   */
  public $o4 = null;
  /**
   * @var \metastore\UnknownPartitionException
   */
  public $o5 = null;
  /**
   * @var \metastore\InvalidPartitionException
   */
  public $o6 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownDBException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownTableException',
          ),
        5 => array(
          'var' => 'o5',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownPartitionException',
          ),
        6 => array(
          'var' => 'o6',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidPartitionException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
      if (isset($vals['o5'])) {
        $this->o5 = $vals['o5'];
      }
      if (isset($vals['o6'])) {
        $this->o6 = $vals['o6'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_isPartitionMarkedForEvent_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\UnknownDBException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\UnknownTableException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->o5 = new \metastore\UnknownPartitionException();
            $xfer += $this->o5->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->o6 = new \metastore\InvalidPartitionException();
            $xfer += $this->o6->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_isPartitionMarkedForEvent_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o5 !== null) {
      $xfer += $output->writeFieldBegin('o5', TType::STRUCT, 5);
      $xfer += $this->o5->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o6 !== null) {
      $xfer += $output->writeFieldBegin('o6', TType::STRUCT, 6);
      $xfer += $this->o6->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_index_args {
  static $_TSPEC;

  /**
   * @var \metastore\Index
   */
  public $new_index = null;
  /**
   * @var \metastore\Table
   */
  public $index_table = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'new_index',
          'type' => TType::STRUCT,
          'class' => '\metastore\Index',
          ),
        2 => array(
          'var' => 'index_table',
          'type' => TType::STRUCT,
          'class' => '\metastore\Table',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['new_index'])) {
        $this->new_index = $vals['new_index'];
      }
      if (isset($vals['index_table'])) {
        $this->index_table = $vals['index_table'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_index_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->new_index = new \metastore\Index();
            $xfer += $this->new_index->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->index_table = new \metastore\Table();
            $xfer += $this->index_table->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_index_args');
    if ($this->new_index !== null) {
      if (!is_object($this->new_index)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_index', TType::STRUCT, 1);
      $xfer += $this->new_index->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->index_table !== null) {
      if (!is_object($this->index_table)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('index_table', TType::STRUCT, 2);
      $xfer += $this->index_table->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_index_result {
  static $_TSPEC;

  /**
   * @var \metastore\Index
   */
  public $success = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Index',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_index_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Index();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\AlreadyExistsException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_index_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_index_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbname = null;
  /**
   * @var string
   */
  public $base_tbl_name = null;
  /**
   * @var string
   */
  public $idx_name = null;
  /**
   * @var \metastore\Index
   */
  public $new_idx = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'base_tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'idx_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'new_idx',
          'type' => TType::STRUCT,
          'class' => '\metastore\Index',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['base_tbl_name'])) {
        $this->base_tbl_name = $vals['base_tbl_name'];
      }
      if (isset($vals['idx_name'])) {
        $this->idx_name = $vals['idx_name'];
      }
      if (isset($vals['new_idx'])) {
        $this->new_idx = $vals['new_idx'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_index_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->base_tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->idx_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->new_idx = new \metastore\Index();
            $xfer += $this->new_idx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_index_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->base_tbl_name !== null) {
      $xfer += $output->writeFieldBegin('base_tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->base_tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->idx_name !== null) {
      $xfer += $output->writeFieldBegin('idx_name', TType::STRING, 3);
      $xfer += $output->writeString($this->idx_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->new_idx !== null) {
      if (!is_object($this->new_idx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_idx', TType::STRUCT, 4);
      $xfer += $this->new_idx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_index_result {
  static $_TSPEC;

  /**
   * @var \metastore\InvalidOperationException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_index_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_index_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_index_by_name_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string
   */
  public $index_name = null;
  /**
   * @var bool
   */
  public $deleteData = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'index_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'deleteData',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['index_name'])) {
        $this->index_name = $vals['index_name'];
      }
      if (isset($vals['deleteData'])) {
        $this->deleteData = $vals['deleteData'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_index_by_name_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->index_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->deleteData);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_index_by_name_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->index_name !== null) {
      $xfer += $output->writeFieldBegin('index_name', TType::STRING, 3);
      $xfer += $output->writeString($this->index_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteData !== null) {
      $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 4);
      $xfer += $output->writeBool($this->deleteData);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_index_by_name_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_index_by_name_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_index_by_name_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_index_by_name_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string
   */
  public $index_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'index_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['index_name'])) {
        $this->index_name = $vals['index_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_index_by_name_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->index_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_index_by_name_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->index_name !== null) {
      $xfer += $output->writeFieldBegin('index_name', TType::STRING, 3);
      $xfer += $output->writeString($this->index_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_index_by_name_result {
  static $_TSPEC;

  /**
   * @var \metastore\Index
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Index',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_index_by_name_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Index();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_index_by_name_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_indexes_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var int
   */
  public $max_indexes = -1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'max_indexes',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['max_indexes'])) {
        $this->max_indexes = $vals['max_indexes'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_indexes_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->max_indexes);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_indexes_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_indexes !== null) {
      $xfer += $output->writeFieldBegin('max_indexes', TType::I16, 3);
      $xfer += $output->writeI16($this->max_indexes);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_indexes_result {
  static $_TSPEC;

  /**
   * @var \metastore\Index[]
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Index',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_indexes_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1151 = 0;
            $_etype1154 = 0;
            $xfer += $input->readListBegin($_etype1154, $_size1151);
            for ($_i1155 = 0; $_i1155 < $_size1151; ++$_i1155)
            {
              $elem1156 = null;
              $elem1156 = new \metastore\Index();
              $xfer += $elem1156->read($input);
              $this->success []= $elem1156;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_indexes_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter1157)
          {
            $xfer += $iter1157->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_index_names_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var int
   */
  public $max_indexes = -1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'max_indexes',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['max_indexes'])) {
        $this->max_indexes = $vals['max_indexes'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_index_names_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->max_indexes);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_index_names_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_indexes !== null) {
      $xfer += $output->writeFieldBegin('max_indexes', TType::I16, 3);
      $xfer += $output->writeI16($this->max_indexes);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_index_names_result {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_index_names_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1158 = 0;
            $_etype1161 = 0;
            $xfer += $input->readListBegin($_etype1161, $_size1158);
            for ($_i1162 = 0; $_i1162 < $_size1158; ++$_i1162)
            {
              $elem1163 = null;
              $xfer += $input->readString($elem1163);
              $this->success []= $elem1163;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_index_names_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter1164)
          {
            $xfer += $output->writeString($iter1164);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 1);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_primary_keys_args {
  static $_TSPEC;

  /**
   * @var \metastore\PrimaryKeysRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\PrimaryKeysRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_primary_keys_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\PrimaryKeysRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_primary_keys_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_primary_keys_result {
  static $_TSPEC;

  /**
   * @var \metastore\PrimaryKeysResponse
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\PrimaryKeysResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_primary_keys_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\PrimaryKeysResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_primary_keys_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_foreign_keys_args {
  static $_TSPEC;

  /**
   * @var \metastore\ForeignKeysRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\ForeignKeysRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_foreign_keys_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\ForeignKeysRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_foreign_keys_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_foreign_keys_result {
  static $_TSPEC;

  /**
   * @var \metastore\ForeignKeysResponse
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\ForeignKeysResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_foreign_keys_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\ForeignKeysResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_foreign_keys_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_unique_constraints_args {
  static $_TSPEC;

  /**
   * @var \metastore\UniqueConstraintsRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\UniqueConstraintsRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_unique_constraints_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\UniqueConstraintsRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_unique_constraints_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_unique_constraints_result {
  static $_TSPEC;

  /**
   * @var \metastore\UniqueConstraintsResponse
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\UniqueConstraintsResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_unique_constraints_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\UniqueConstraintsResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_unique_constraints_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_not_null_constraints_args {
  static $_TSPEC;

  /**
   * @var \metastore\NotNullConstraintsRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\NotNullConstraintsRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_not_null_constraints_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\NotNullConstraintsRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_not_null_constraints_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_not_null_constraints_result {
  static $_TSPEC;

  /**
   * @var \metastore\NotNullConstraintsResponse
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\NotNullConstraintsResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_not_null_constraints_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\NotNullConstraintsResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_not_null_constraints_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_update_table_column_statistics_args {
  static $_TSPEC;

  /**
   * @var \metastore\ColumnStatistics
   */
  public $stats_obj = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'stats_obj',
          'type' => TType::STRUCT,
          'class' => '\metastore\ColumnStatistics',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['stats_obj'])) {
        $this->stats_obj = $vals['stats_obj'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_update_table_column_statistics_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->stats_obj = new \metastore\ColumnStatistics();
            $xfer += $this->stats_obj->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_update_table_column_statistics_args');
    if ($this->stats_obj !== null) {
      if (!is_object($this->stats_obj)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('stats_obj', TType::STRUCT, 1);
      $xfer += $this->stats_obj->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_update_table_column_statistics_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;
  /**
   * @var \metastore\InvalidInputException
   */
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidInputException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_update_table_column_statistics_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\InvalidInputException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_update_table_column_statistics_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_update_partition_column_statistics_args {
  static $_TSPEC;

  /**
   * @var \metastore\ColumnStatistics
   */
  public $stats_obj = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'stats_obj',
          'type' => TType::STRUCT,
          'class' => '\metastore\ColumnStatistics',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['stats_obj'])) {
        $this->stats_obj = $vals['stats_obj'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_update_partition_column_statistics_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->stats_obj = new \metastore\ColumnStatistics();
            $xfer += $this->stats_obj->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_update_partition_column_statistics_args');
    if ($this->stats_obj !== null) {
      if (!is_object($this->stats_obj)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('stats_obj', TType::STRUCT, 1);
      $xfer += $this->stats_obj->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_update_partition_column_statistics_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;
  /**
   * @var \metastore\InvalidInputException
   */
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidInputException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_update_partition_column_statistics_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\InvalidInputException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_update_partition_column_statistics_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_column_statistics_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string
   */
  public $col_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'col_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['col_name'])) {
        $this->col_name = $vals['col_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_column_statistics_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->col_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_column_statistics_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->col_name !== null) {
      $xfer += $output->writeFieldBegin('col_name', TType::STRING, 3);
      $xfer += $output->writeString($this->col_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_column_statistics_result {
  static $_TSPEC;

  /**
   * @var \metastore\ColumnStatistics
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;
  /**
   * @var \metastore\InvalidInputException
   */
  public $o3 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\ColumnStatistics',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidInputException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_column_statistics_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\ColumnStatistics();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\InvalidInputException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\InvalidObjectException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_column_statistics_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_column_statistics_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string
   */
  public $part_name = null;
  /**
   * @var string
   */
  public $col_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'col_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_name'])) {
        $this->part_name = $vals['part_name'];
      }
      if (isset($vals['col_name'])) {
        $this->col_name = $vals['col_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_column_statistics_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->part_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->col_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_column_statistics_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_name !== null) {
      $xfer += $output->writeFieldBegin('part_name', TType::STRING, 3);
      $xfer += $output->writeString($this->part_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->col_name !== null) {
      $xfer += $output->writeFieldBegin('col_name', TType::STRING, 4);
      $xfer += $output->writeString($this->col_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_column_statistics_result {
  static $_TSPEC;

  /**
   * @var \metastore\ColumnStatistics
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;
  /**
   * @var \metastore\InvalidInputException
   */
  public $o3 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\ColumnStatistics',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidInputException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_column_statistics_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\ColumnStatistics();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\InvalidInputException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\InvalidObjectException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_column_statistics_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_statistics_req_args {
  static $_TSPEC;

  /**
   * @var \metastore\TableStatsRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\TableStatsRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_statistics_req_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\TableStatsRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_statistics_req_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_statistics_req_result {
  static $_TSPEC;

  /**
   * @var \metastore\TableStatsResult
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\TableStatsResult',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_statistics_req_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\TableStatsResult();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_statistics_req_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_statistics_req_args {
  static $_TSPEC;

  /**
   * @var \metastore\PartitionsStatsRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\PartitionsStatsRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_statistics_req_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\PartitionsStatsRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_statistics_req_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_statistics_req_result {
  static $_TSPEC;

  /**
   * @var \metastore\PartitionsStatsResult
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\PartitionsStatsResult',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_statistics_req_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\PartitionsStatsResult();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_statistics_req_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_aggr_stats_for_args {
  static $_TSPEC;

  /**
   * @var \metastore\PartitionsStatsRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\PartitionsStatsRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_aggr_stats_for_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\PartitionsStatsRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_aggr_stats_for_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_aggr_stats_for_result {
  static $_TSPEC;

  /**
   * @var \metastore\AggrStats
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\AggrStats',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_aggr_stats_for_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\AggrStats();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_aggr_stats_for_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_set_aggr_stats_for_args {
  static $_TSPEC;

  /**
   * @var \metastore\SetPartitionsStatsRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\SetPartitionsStatsRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_set_aggr_stats_for_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\SetPartitionsStatsRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_set_aggr_stats_for_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_set_aggr_stats_for_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;
  /**
   * @var \metastore\InvalidInputException
   */
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidInputException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_set_aggr_stats_for_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\InvalidInputException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_set_aggr_stats_for_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_delete_partition_column_statistics_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string
   */
  public $part_name = null;
  /**
   * @var string
   */
  public $col_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'col_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_name'])) {
        $this->part_name = $vals['part_name'];
      }
      if (isset($vals['col_name'])) {
        $this->col_name = $vals['col_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_delete_partition_column_statistics_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->part_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->col_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_delete_partition_column_statistics_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_name !== null) {
      $xfer += $output->writeFieldBegin('part_name', TType::STRING, 3);
      $xfer += $output->writeString($this->part_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->col_name !== null) {
      $xfer += $output->writeFieldBegin('col_name', TType::STRING, 4);
      $xfer += $output->writeString($this->col_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_delete_partition_column_statistics_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o3 = null;
  /**
   * @var \metastore\InvalidInputException
   */
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidInputException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_delete_partition_column_statistics_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\InvalidObjectException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\InvalidInputException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_delete_partition_column_statistics_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_delete_table_column_statistics_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $tbl_name = null;
  /**
   * @var string
   */
  public $col_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'col_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['col_name'])) {
        $this->col_name = $vals['col_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_delete_table_column_statistics_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->col_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_delete_table_column_statistics_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->col_name !== null) {
      $xfer += $output->writeFieldBegin('col_name', TType::STRING, 3);
      $xfer += $output->writeString($this->col_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_delete_table_column_statistics_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o3 = null;
  /**
   * @var \metastore\InvalidInputException
   */
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidInputException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_delete_table_column_statistics_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\InvalidObjectException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\InvalidInputException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_delete_table_column_statistics_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_function_args {
  static $_TSPEC;

  /**
   * @var \metastore\Function
   */
  public $func = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'func',
          'type' => TType::STRUCT,
          'class' => '\metastore\Function',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['func'])) {
        $this->func = $vals['func'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_function_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->func = new \metastore\Function();
            $xfer += $this->func->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_function_args');
    if ($this->func !== null) {
      if (!is_object($this->func)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('func', TType::STRUCT, 1);
      $xfer += $this->func->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_function_result {
  static $_TSPEC;

  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o1 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_function_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\AlreadyExistsException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\NoSuchObjectException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_function_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_function_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $funcName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'funcName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['funcName'])) {
        $this->funcName = $vals['funcName'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_function_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->funcName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_function_args');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->funcName !== null) {
      $xfer += $output->writeFieldBegin('funcName', TType::STRING, 2);
      $xfer += $output->writeString($this->funcName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_function_result {
  static $_TSPEC;

  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_function_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_function_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 2);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_function_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $funcName = null;
  /**
   * @var \metastore\Function
   */
  public $newFunc = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'funcName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'newFunc',
          'type' => TType::STRUCT,
          'class' => '\metastore\Function',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['funcName'])) {
        $this->funcName = $vals['funcName'];
      }
      if (isset($vals['newFunc'])) {
        $this->newFunc = $vals['newFunc'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_function_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->funcName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->newFunc = new \metastore\Function();
            $xfer += $this->newFunc->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_function_args');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->funcName !== null) {
      $xfer += $output->writeFieldBegin('funcName', TType::STRING, 2);
      $xfer += $output->writeString($this->funcName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newFunc !== null) {
      if (!is_object($this->newFunc)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('newFunc', TType::STRUCT, 3);
      $xfer += $this->newFunc->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_function_result {
  static $_TSPEC;

  /**
   * @var \metastore\InvalidOperationException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_function_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_function_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_functions_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $pattern = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'pattern',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['pattern'])) {
        $this->pattern = $vals['pattern'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_functions_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->pattern);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_functions_args');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->pattern !== null) {
      $xfer += $output->writeFieldBegin('pattern', TType::STRING, 2);
      $xfer += $output->writeString($this->pattern);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_functions_result {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_functions_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1165 = 0;
            $_etype1168 = 0;
            $xfer += $input->readListBegin($_etype1168, $_size1165);
            for ($_i1169 = 0; $_i1169 < $_size1165; ++$_i1169)
            {
              $elem1170 = null;
              $xfer += $input->readString($elem1170);
              $this->success []= $elem1170;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_functions_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter1171)
          {
            $xfer += $output->writeString($iter1171);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_function_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dbName = null;
  /**
   * @var string
   */
  public $funcName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'funcName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['funcName'])) {
        $this->funcName = $vals['funcName'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_function_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->funcName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_function_args');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->funcName !== null) {
      $xfer += $output->writeFieldBegin('funcName', TType::STRING, 2);
      $xfer += $output->writeString($this->funcName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_function_result {
  static $_TSPEC;

  /**
   * @var \metastore\Function
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Function',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_function_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Function();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_function_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_functions_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_functions_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_functions_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_functions_result {
  static $_TSPEC;

  /**
   * @var \metastore\GetAllFunctionsResponse
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\GetAllFunctionsResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_functions_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\GetAllFunctionsResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_functions_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_role_args {
  static $_TSPEC;

  /**
   * @var \metastore\Role
   */
  public $role = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'role',
          'type' => TType::STRUCT,
          'class' => '\metastore\Role',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['role'])) {
        $this->role = $vals['role'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_role_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->role = new \metastore\Role();
            $xfer += $this->role->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_role_args');
    if ($this->role !== null) {
      if (!is_object($this->role)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('role', TType::STRUCT, 1);
      $xfer += $this->role->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_role_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_role_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_role_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_role_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $role_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'role_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['role_name'])) {
        $this->role_name = $vals['role_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_role_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->role_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_role_args');
    if ($this->role_name !== null) {
      $xfer += $output->writeFieldBegin('role_name', TType::STRING, 1);
      $xfer += $output->writeString($this->role_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_role_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_role_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_role_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_role_names_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_role_names_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_role_names_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_role_names_result {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_role_names_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1172 = 0;
            $_etype1175 = 0;
            $xfer += $input->readListBegin($_etype1175, $_size1172);
            for ($_i1176 = 0; $_i1176 < $_size1172; ++$_i1176)
            {
              $elem1177 = null;
              $xfer += $input->readString($elem1177);
              $this->success []= $elem1177;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_role_names_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter1178)
          {
            $xfer += $output->writeString($iter1178);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_grant_role_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $role_name = null;
  /**
   * @var string
   */
  public $principal_name = null;
  /**
   * @var int
   */
  public $principal_type = null;
  /**
   * @var string
   */
  public $grantor = null;
  /**
   * @var int
   */
  public $grantorType = null;
  /**
   * @var bool
   */
  public $grant_option = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'role_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'principal_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'principal_type',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'grantor',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'grantorType',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'grant_option',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['role_name'])) {
        $this->role_name = $vals['role_name'];
      }
      if (isset($vals['principal_name'])) {
        $this->principal_name = $vals['principal_name'];
      }
      if (isset($vals['principal_type'])) {
        $this->principal_type = $vals['principal_type'];
      }
      if (isset($vals['grantor'])) {
        $this->grantor = $vals['grantor'];
      }
      if (isset($vals['grantorType'])) {
        $this->grantorType = $vals['grantorType'];
      }
      if (isset($vals['grant_option'])) {
        $this->grant_option = $vals['grant_option'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_grant_role_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->role_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->principal_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->principal_type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->grantor);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->grantorType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->grant_option);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_grant_role_args');
    if ($this->role_name !== null) {
      $xfer += $output->writeFieldBegin('role_name', TType::STRING, 1);
      $xfer += $output->writeString($this->role_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->principal_name !== null) {
      $xfer += $output->writeFieldBegin('principal_name', TType::STRING, 2);
      $xfer += $output->writeString($this->principal_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->principal_type !== null) {
      $xfer += $output->writeFieldBegin('principal_type', TType::I32, 3);
      $xfer += $output->writeI32($this->principal_type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->grantor !== null) {
      $xfer += $output->writeFieldBegin('grantor', TType::STRING, 4);
      $xfer += $output->writeString($this->grantor);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->grantorType !== null) {
      $xfer += $output->writeFieldBegin('grantorType', TType::I32, 5);
      $xfer += $output->writeI32($this->grantorType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->grant_option !== null) {
      $xfer += $output->writeFieldBegin('grant_option', TType::BOOL, 6);
      $xfer += $output->writeBool($this->grant_option);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_grant_role_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_grant_role_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_grant_role_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_revoke_role_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $role_name = null;
  /**
   * @var string
   */
  public $principal_name = null;
  /**
   * @var int
   */
  public $principal_type = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'role_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'principal_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'principal_type',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['role_name'])) {
        $this->role_name = $vals['role_name'];
      }
      if (isset($vals['principal_name'])) {
        $this->principal_name = $vals['principal_name'];
      }
      if (isset($vals['principal_type'])) {
        $this->principal_type = $vals['principal_type'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_revoke_role_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->role_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->principal_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->principal_type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_revoke_role_args');
    if ($this->role_name !== null) {
      $xfer += $output->writeFieldBegin('role_name', TType::STRING, 1);
      $xfer += $output->writeString($this->role_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->principal_name !== null) {
      $xfer += $output->writeFieldBegin('principal_name', TType::STRING, 2);
      $xfer += $output->writeString($this->principal_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->principal_type !== null) {
      $xfer += $output->writeFieldBegin('principal_type', TType::I32, 3);
      $xfer += $output->writeI32($this->principal_type);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_revoke_role_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_revoke_role_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_revoke_role_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_list_roles_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $principal_name = null;
  /**
   * @var int
   */
  public $principal_type = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'principal_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'principal_type',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['principal_name'])) {
        $this->principal_name = $vals['principal_name'];
      }
      if (isset($vals['principal_type'])) {
        $this->principal_type = $vals['principal_type'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_list_roles_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->principal_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->principal_type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_list_roles_args');
    if ($this->principal_name !== null) {
      $xfer += $output->writeFieldBegin('principal_name', TType::STRING, 1);
      $xfer += $output->writeString($this->principal_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->principal_type !== null) {
      $xfer += $output->writeFieldBegin('principal_type', TType::I32, 2);
      $xfer += $output->writeI32($this->principal_type);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_list_roles_result {
  static $_TSPEC;

  /**
   * @var \metastore\Role[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Role',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_list_roles_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1179 = 0;
            $_etype1182 = 0;
            $xfer += $input->readListBegin($_etype1182, $_size1179);
            for ($_i1183 = 0; $_i1183 < $_size1179; ++$_i1183)
            {
              $elem1184 = null;
              $elem1184 = new \metastore\Role();
              $xfer += $elem1184->read($input);
              $this->success []= $elem1184;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_list_roles_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter1185)
          {
            $xfer += $iter1185->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_grant_revoke_role_args {
  static $_TSPEC;

  /**
   * @var \metastore\GrantRevokeRoleRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\GrantRevokeRoleRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_grant_revoke_role_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\GrantRevokeRoleRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_grant_revoke_role_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_grant_revoke_role_result {
  static $_TSPEC;

  /**
   * @var \metastore\GrantRevokeRoleResponse
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\GrantRevokeRoleResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_grant_revoke_role_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\GrantRevokeRoleResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_grant_revoke_role_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_principals_in_role_args {
  static $_TSPEC;

  /**
   * @var \metastore\GetPrincipalsInRoleRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\GetPrincipalsInRoleRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_principals_in_role_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\GetPrincipalsInRoleRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_principals_in_role_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_principals_in_role_result {
  static $_TSPEC;

  /**
   * @var \metastore\GetPrincipalsInRoleResponse
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\GetPrincipalsInRoleResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_principals_in_role_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\GetPrincipalsInRoleResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_principals_in_role_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_role_grants_for_principal_args {
  static $_TSPEC;

  /**
   * @var \metastore\GetRoleGrantsForPrincipalRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\GetRoleGrantsForPrincipalRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_role_grants_for_principal_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\GetRoleGrantsForPrincipalRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_role_grants_for_principal_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_role_grants_for_principal_result {
  static $_TSPEC;

  /**
   * @var \metastore\GetRoleGrantsForPrincipalResponse
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\GetRoleGrantsForPrincipalResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_role_grants_for_principal_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\GetRoleGrantsForPrincipalResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_role_grants_for_principal_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_privilege_set_args {
  static $_TSPEC;

  /**
   * @var \metastore\HiveObjectRef
   */
  public $hiveObject = null;
  /**
   * @var string
   */
  public $user_name = null;
  /**
   * @var string[]
   */
  public $group_names = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'hiveObject',
          'type' => TType::STRUCT,
          'class' => '\metastore\HiveObjectRef',
          ),
        2 => array(
          'var' => 'user_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'group_names',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['hiveObject'])) {
        $this->hiveObject = $vals['hiveObject'];
      }
      if (isset($vals['user_name'])) {
        $this->user_name = $vals['user_name'];
      }
      if (isset($vals['group_names'])) {
        $this->group_names = $vals['group_names'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_privilege_set_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->hiveObject = new \metastore\HiveObjectRef();
            $xfer += $this->hiveObject->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->user_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->group_names = array();
            $_size1186 = 0;
            $_etype1189 = 0;
            $xfer += $input->readListBegin($_etype1189, $_size1186);
            for ($_i1190 = 0; $_i1190 < $_size1186; ++$_i1190)
            {
              $elem1191 = null;
              $xfer += $input->readString($elem1191);
              $this->group_names []= $elem1191;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_privilege_set_args');
    if ($this->hiveObject !== null) {
      if (!is_object($this->hiveObject)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('hiveObject', TType::STRUCT, 1);
      $xfer += $this->hiveObject->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->user_name !== null) {
      $xfer += $output->writeFieldBegin('user_name', TType::STRING, 2);
      $xfer += $output->writeString($this->user_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->group_names !== null) {
      if (!is_array($this->group_names)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('group_names', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->group_names));
        {
          foreach ($this->group_names as $iter1192)
          {
            $xfer += $output->writeString($iter1192);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_privilege_set_result {
  static $_TSPEC;

  /**
   * @var \metastore\PrincipalPrivilegeSet
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\PrincipalPrivilegeSet',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_privilege_set_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\PrincipalPrivilegeSet();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_privilege_set_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_list_privileges_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $principal_name = null;
  /**
   * @var int
   */
  public $principal_type = null;
  /**
   * @var \metastore\HiveObjectRef
   */
  public $hiveObject = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'principal_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'principal_type',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'hiveObject',
          'type' => TType::STRUCT,
          'class' => '\metastore\HiveObjectRef',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['principal_name'])) {
        $this->principal_name = $vals['principal_name'];
      }
      if (isset($vals['principal_type'])) {
        $this->principal_type = $vals['principal_type'];
      }
      if (isset($vals['hiveObject'])) {
        $this->hiveObject = $vals['hiveObject'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_list_privileges_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->principal_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->principal_type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->hiveObject = new \metastore\HiveObjectRef();
            $xfer += $this->hiveObject->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_list_privileges_args');
    if ($this->principal_name !== null) {
      $xfer += $output->writeFieldBegin('principal_name', TType::STRING, 1);
      $xfer += $output->writeString($this->principal_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->principal_type !== null) {
      $xfer += $output->writeFieldBegin('principal_type', TType::I32, 2);
      $xfer += $output->writeI32($this->principal_type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hiveObject !== null) {
      if (!is_object($this->hiveObject)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('hiveObject', TType::STRUCT, 3);
      $xfer += $this->hiveObject->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_list_privileges_result {
  static $_TSPEC;

  /**
   * @var \metastore\HiveObjectPrivilege[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\HiveObjectPrivilege',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_list_privileges_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1193 = 0;
            $_etype1196 = 0;
            $xfer += $input->readListBegin($_etype1196, $_size1193);
            for ($_i1197 = 0; $_i1197 < $_size1193; ++$_i1197)
            {
              $elem1198 = null;
              $elem1198 = new \metastore\HiveObjectPrivilege();
              $xfer += $elem1198->read($input);
              $this->success []= $elem1198;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_list_privileges_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter1199)
          {
            $xfer += $iter1199->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_grant_privileges_args {
  static $_TSPEC;

  /**
   * @var \metastore\PrivilegeBag
   */
  public $privileges = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'privileges',
          'type' => TType::STRUCT,
          'class' => '\metastore\PrivilegeBag',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['privileges'])) {
        $this->privileges = $vals['privileges'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_grant_privileges_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->privileges = new \metastore\PrivilegeBag();
            $xfer += $this->privileges->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_grant_privileges_args');
    if ($this->privileges !== null) {
      if (!is_object($this->privileges)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('privileges', TType::STRUCT, 1);
      $xfer += $this->privileges->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_grant_privileges_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_grant_privileges_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_grant_privileges_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_revoke_privileges_args {
  static $_TSPEC;

  /**
   * @var \metastore\PrivilegeBag
   */
  public $privileges = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'privileges',
          'type' => TType::STRUCT,
          'class' => '\metastore\PrivilegeBag',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['privileges'])) {
        $this->privileges = $vals['privileges'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_revoke_privileges_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->privileges = new \metastore\PrivilegeBag();
            $xfer += $this->privileges->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_revoke_privileges_args');
    if ($this->privileges !== null) {
      if (!is_object($this->privileges)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('privileges', TType::STRUCT, 1);
      $xfer += $this->privileges->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_revoke_privileges_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_revoke_privileges_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_revoke_privileges_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_grant_revoke_privileges_args {
  static $_TSPEC;

  /**
   * @var \metastore\GrantRevokePrivilegeRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\GrantRevokePrivilegeRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_grant_revoke_privileges_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\GrantRevokePrivilegeRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_grant_revoke_privileges_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_grant_revoke_privileges_result {
  static $_TSPEC;

  /**
   * @var \metastore\GrantRevokePrivilegeResponse
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\GrantRevokePrivilegeResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_grant_revoke_privileges_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\GrantRevokePrivilegeResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_grant_revoke_privileges_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_set_ugi_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $user_name = null;
  /**
   * @var string[]
   */
  public $group_names = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'user_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'group_names',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['user_name'])) {
        $this->user_name = $vals['user_name'];
      }
      if (isset($vals['group_names'])) {
        $this->group_names = $vals['group_names'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_set_ugi_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->user_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->group_names = array();
            $_size1200 = 0;
            $_etype1203 = 0;
            $xfer += $input->readListBegin($_etype1203, $_size1200);
            for ($_i1204 = 0; $_i1204 < $_size1200; ++$_i1204)
            {
              $elem1205 = null;
              $xfer += $input->readString($elem1205);
              $this->group_names []= $elem1205;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_set_ugi_args');
    if ($this->user_name !== null) {
      $xfer += $output->writeFieldBegin('user_name', TType::STRING, 1);
      $xfer += $output->writeString($this->user_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->group_names !== null) {
      if (!is_array($this->group_names)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('group_names', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->group_names));
        {
          foreach ($this->group_names as $iter1206)
          {
            $xfer += $output->writeString($iter1206);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_set_ugi_result {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_set_ugi_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1207 = 0;
            $_etype1210 = 0;
            $xfer += $input->readListBegin($_etype1210, $_size1207);
            for ($_i1211 = 0; $_i1211 < $_size1207; ++$_i1211)
            {
              $elem1212 = null;
              $xfer += $input->readString($elem1212);
              $this->success []= $elem1212;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_set_ugi_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter1213)
          {
            $xfer += $output->writeString($iter1213);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_delegation_token_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $token_owner = null;
  /**
   * @var string
   */
  public $renewer_kerberos_principal_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'token_owner',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'renewer_kerberos_principal_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['token_owner'])) {
        $this->token_owner = $vals['token_owner'];
      }
      if (isset($vals['renewer_kerberos_principal_name'])) {
        $this->renewer_kerberos_principal_name = $vals['renewer_kerberos_principal_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_delegation_token_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->token_owner);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->renewer_kerberos_principal_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_delegation_token_args');
    if ($this->token_owner !== null) {
      $xfer += $output->writeFieldBegin('token_owner', TType::STRING, 1);
      $xfer += $output->writeString($this->token_owner);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->renewer_kerberos_principal_name !== null) {
      $xfer += $output->writeFieldBegin('renewer_kerberos_principal_name', TType::STRING, 2);
      $xfer += $output->writeString($this->renewer_kerberos_principal_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_delegation_token_result {
  static $_TSPEC;

  /**
   * @var string
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_delegation_token_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_delegation_token_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
      $xfer += $output->writeString($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_renew_delegation_token_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $token_str_form = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'token_str_form',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['token_str_form'])) {
        $this->token_str_form = $vals['token_str_form'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_renew_delegation_token_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->token_str_form);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_renew_delegation_token_args');
    if ($this->token_str_form !== null) {
      $xfer += $output->writeFieldBegin('token_str_form', TType::STRING, 1);
      $xfer += $output->writeString($this->token_str_form);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_renew_delegation_token_result {
  static $_TSPEC;

  /**
   * @var int
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I64,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_renew_delegation_token_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_renew_delegation_token_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I64, 0);
      $xfer += $output->writeI64($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_cancel_delegation_token_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $token_str_form = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'token_str_form',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['token_str_form'])) {
        $this->token_str_form = $vals['token_str_form'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_cancel_delegation_token_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->token_str_form);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_cancel_delegation_token_args');
    if ($this->token_str_form !== null) {
      $xfer += $output->writeFieldBegin('token_str_form', TType::STRING, 1);
      $xfer += $output->writeString($this->token_str_form);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_cancel_delegation_token_result {
  static $_TSPEC;

  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_cancel_delegation_token_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_cancel_delegation_token_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_token_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $token_identifier = null;
  /**
   * @var string
   */
  public $delegation_token = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'token_identifier',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'delegation_token',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['token_identifier'])) {
        $this->token_identifier = $vals['token_identifier'];
      }
      if (isset($vals['delegation_token'])) {
        $this->delegation_token = $vals['delegation_token'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_token_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->token_identifier);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->delegation_token);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_token_args');
    if ($this->token_identifier !== null) {
      $xfer += $output->writeFieldBegin('token_identifier', TType::STRING, 1);
      $xfer += $output->writeString($this->token_identifier);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->delegation_token !== null) {
      $xfer += $output->writeFieldBegin('delegation_token', TType::STRING, 2);
      $xfer += $output->writeString($this->delegation_token);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_token_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_token_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_token_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_remove_token_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $token_identifier = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'token_identifier',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['token_identifier'])) {
        $this->token_identifier = $vals['token_identifier'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_remove_token_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->token_identifier);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_remove_token_args');
    if ($this->token_identifier !== null) {
      $xfer += $output->writeFieldBegin('token_identifier', TType::STRING, 1);
      $xfer += $output->writeString($this->token_identifier);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_remove_token_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_remove_token_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_remove_token_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_token_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $token_identifier = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'token_identifier',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['token_identifier'])) {
        $this->token_identifier = $vals['token_identifier'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_token_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->token_identifier);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_token_args');
    if ($this->token_identifier !== null) {
      $xfer += $output->writeFieldBegin('token_identifier', TType::STRING, 1);
      $xfer += $output->writeString($this->token_identifier);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_token_result {
  static $_TSPEC;

  /**
   * @var string
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_token_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_token_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
      $xfer += $output->writeString($this->success);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_token_identifiers_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_token_identifiers_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_token_identifiers_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_token_identifiers_result {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_token_identifiers_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1214 = 0;
            $_etype1217 = 0;
            $xfer += $input->readListBegin($_etype1217, $_size1214);
            for ($_i1218 = 0; $_i1218 < $_size1214; ++$_i1218)
            {
              $elem1219 = null;
              $xfer += $input->readString($elem1219);
              $this->success []= $elem1219;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_token_identifiers_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter1220)
          {
            $xfer += $output->writeString($iter1220);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_master_key_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $key = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['key'])) {
        $this->key = $vals['key'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_master_key_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->key);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_master_key_args');
    if ($this->key !== null) {
      $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
      $xfer += $output->writeString($this->key);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_master_key_result {
  static $_TSPEC;

  /**
   * @var int
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_master_key_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_master_key_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_update_master_key_args {
  static $_TSPEC;

  /**
   * @var int
   */
  public $seq_number = null;
  /**
   * @var string
   */
  public $key = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'seq_number',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['seq_number'])) {
        $this->seq_number = $vals['seq_number'];
      }
      if (isset($vals['key'])) {
        $this->key = $vals['key'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_update_master_key_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->seq_number);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->key);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_update_master_key_args');
    if ($this->seq_number !== null) {
      $xfer += $output->writeFieldBegin('seq_number', TType::I32, 1);
      $xfer += $output->writeI32($this->seq_number);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->key !== null) {
      $xfer += $output->writeFieldBegin('key', TType::STRING, 2);
      $xfer += $output->writeString($this->key);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_update_master_key_result {
  static $_TSPEC;

  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_update_master_key_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_update_master_key_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_remove_master_key_args {
  static $_TSPEC;

  /**
   * @var int
   */
  public $key_seq = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key_seq',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['key_seq'])) {
        $this->key_seq = $vals['key_seq'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_remove_master_key_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->key_seq);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_remove_master_key_args');
    if ($this->key_seq !== null) {
      $xfer += $output->writeFieldBegin('key_seq', TType::I32, 1);
      $xfer += $output->writeI32($this->key_seq);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_remove_master_key_result {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_remove_master_key_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_remove_master_key_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_master_keys_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_master_keys_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_master_keys_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_master_keys_result {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_master_keys_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1221 = 0;
            $_etype1224 = 0;
            $xfer += $input->readListBegin($_etype1224, $_size1221);
            for ($_i1225 = 0; $_i1225 < $_size1221; ++$_i1225)
            {
              $elem1226 = null;
              $xfer += $input->readString($elem1226);
              $this->success []= $elem1226;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_master_keys_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter1227)
          {
            $xfer += $output->writeString($iter1227);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_open_txns_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_open_txns_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_open_txns_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_open_txns_result {
  static $_TSPEC;

  /**
   * @var \metastore\GetOpenTxnsResponse
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\GetOpenTxnsResponse',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_open_txns_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\GetOpenTxnsResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_open_txns_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_open_txns_info_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_open_txns_info_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_open_txns_info_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_open_txns_info_result {
  static $_TSPEC;

  /**
   * @var \metastore\GetOpenTxnsInfoResponse
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\GetOpenTxnsInfoResponse',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_open_txns_info_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\GetOpenTxnsInfoResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_open_txns_info_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_open_txns_args {
  static $_TSPEC;

  /**
   * @var \metastore\OpenTxnRequest
   */
  public $rqst = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'rqst',
          'type' => TType::STRUCT,
          'class' => '\metastore\OpenTxnRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['rqst'])) {
        $this->rqst = $vals['rqst'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_open_txns_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->rqst = new \metastore\OpenTxnRequest();
            $xfer += $this->rqst->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_open_txns_args');
    if ($this->rqst !== null) {
      if (!is_object($this->rqst)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rqst', TType::STRUCT, 1);
      $xfer += $this->rqst->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_open_txns_result {
  static $_TSPEC;

  /**
   * @var \metastore\OpenTxnsResponse
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\OpenTxnsResponse',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_open_txns_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\OpenTxnsResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_open_txns_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_abort_txn_args {
  static $_TSPEC;

  /**
   * @var \metastore\AbortTxnRequest
   */
  public $rqst = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'rqst',
          'type' => TType::STRUCT,
          'class' => '\metastore\AbortTxnRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['rqst'])) {
        $this->rqst = $vals['rqst'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_abort_txn_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->rqst = new \metastore\AbortTxnRequest();
            $xfer += $this->rqst->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_abort_txn_args');
    if ($this->rqst !== null) {
      if (!is_object($this->rqst)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rqst', TType::STRUCT, 1);
      $xfer += $this->rqst->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_abort_txn_result {
  static $_TSPEC;

  /**
   * @var \metastore\NoSuchTxnException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchTxnException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_abort_txn_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchTxnException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_abort_txn_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_abort_txns_args {
  static $_TSPEC;

  /**
   * @var \metastore\AbortTxnsRequest
   */
  public $rqst = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'rqst',
          'type' => TType::STRUCT,
          'class' => '\metastore\AbortTxnsRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['rqst'])) {
        $this->rqst = $vals['rqst'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_abort_txns_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->rqst = new \metastore\AbortTxnsRequest();
            $xfer += $this->rqst->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_abort_txns_args');
    if ($this->rqst !== null) {
      if (!is_object($this->rqst)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rqst', TType::STRUCT, 1);
      $xfer += $this->rqst->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_abort_txns_result {
  static $_TSPEC;

  /**
   * @var \metastore\NoSuchTxnException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchTxnException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_abort_txns_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchTxnException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_abort_txns_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_commit_txn_args {
  static $_TSPEC;

  /**
   * @var \metastore\CommitTxnRequest
   */
  public $rqst = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'rqst',
          'type' => TType::STRUCT,
          'class' => '\metastore\CommitTxnRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['rqst'])) {
        $this->rqst = $vals['rqst'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_commit_txn_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->rqst = new \metastore\CommitTxnRequest();
            $xfer += $this->rqst->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_commit_txn_args');
    if ($this->rqst !== null) {
      if (!is_object($this->rqst)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rqst', TType::STRUCT, 1);
      $xfer += $this->rqst->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_commit_txn_result {
  static $_TSPEC;

  /**
   * @var \metastore\NoSuchTxnException
   */
  public $o1 = null;
  /**
   * @var \metastore\TxnAbortedException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchTxnException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\TxnAbortedException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_commit_txn_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchTxnException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\TxnAbortedException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_commit_txn_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_lock_args {
  static $_TSPEC;

  /**
   * @var \metastore\LockRequest
   */
  public $rqst = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'rqst',
          'type' => TType::STRUCT,
          'class' => '\metastore\LockRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['rqst'])) {
        $this->rqst = $vals['rqst'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_lock_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->rqst = new \metastore\LockRequest();
            $xfer += $this->rqst->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_lock_args');
    if ($this->rqst !== null) {
      if (!is_object($this->rqst)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rqst', TType::STRUCT, 1);
      $xfer += $this->rqst->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_lock_result {
  static $_TSPEC;

  /**
   * @var \metastore\LockResponse
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchTxnException
   */
  public $o1 = null;
  /**
   * @var \metastore\TxnAbortedException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\LockResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchTxnException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\TxnAbortedException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_lock_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\LockResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchTxnException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\TxnAbortedException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_lock_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_check_lock_args {
  static $_TSPEC;

  /**
   * @var \metastore\CheckLockRequest
   */
  public $rqst = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'rqst',
          'type' => TType::STRUCT,
          'class' => '\metastore\CheckLockRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['rqst'])) {
        $this->rqst = $vals['rqst'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_check_lock_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->rqst = new \metastore\CheckLockRequest();
            $xfer += $this->rqst->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_check_lock_args');
    if ($this->rqst !== null) {
      if (!is_object($this->rqst)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rqst', TType::STRUCT, 1);
      $xfer += $this->rqst->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_check_lock_result {
  static $_TSPEC;

  /**
   * @var \metastore\LockResponse
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchTxnException
   */
  public $o1 = null;
  /**
   * @var \metastore\TxnAbortedException
   */
  public $o2 = null;
  /**
   * @var \metastore\NoSuchLockException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\LockResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchTxnException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\TxnAbortedException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchLockException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_check_lock_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\LockResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchTxnException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\TxnAbortedException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\NoSuchLockException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_check_lock_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_unlock_args {
  static $_TSPEC;

  /**
   * @var \metastore\UnlockRequest
   */
  public $rqst = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'rqst',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnlockRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['rqst'])) {
        $this->rqst = $vals['rqst'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_unlock_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->rqst = new \metastore\UnlockRequest();
            $xfer += $this->rqst->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_unlock_args');
    if ($this->rqst !== null) {
      if (!is_object($this->rqst)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rqst', TType::STRUCT, 1);
      $xfer += $this->rqst->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_unlock_result {
  static $_TSPEC;

  /**
   * @var \metastore\NoSuchLockException
   */
  public $o1 = null;
  /**
   * @var \metastore\TxnOpenException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchLockException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\TxnOpenException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_unlock_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchLockException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\TxnOpenException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_unlock_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_show_locks_args {
  static $_TSPEC;

  /**
   * @var \metastore\ShowLocksRequest
   */
  public $rqst = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'rqst',
          'type' => TType::STRUCT,
          'class' => '\metastore\ShowLocksRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['rqst'])) {
        $this->rqst = $vals['rqst'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_show_locks_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->rqst = new \metastore\ShowLocksRequest();
            $xfer += $this->rqst->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_show_locks_args');
    if ($this->rqst !== null) {
      if (!is_object($this->rqst)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rqst', TType::STRUCT, 1);
      $xfer += $this->rqst->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_show_locks_result {
  static $_TSPEC;

  /**
   * @var \metastore\ShowLocksResponse
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\ShowLocksResponse',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_show_locks_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\ShowLocksResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_show_locks_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_heartbeat_args {
  static $_TSPEC;

  /**
   * @var \metastore\HeartbeatRequest
   */
  public $ids = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ids',
          'type' => TType::STRUCT,
          'class' => '\metastore\HeartbeatRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ids'])) {
        $this->ids = $vals['ids'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_heartbeat_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ids = new \metastore\HeartbeatRequest();
            $xfer += $this->ids->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_heartbeat_args');
    if ($this->ids !== null) {
      if (!is_object($this->ids)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ids', TType::STRUCT, 1);
      $xfer += $this->ids->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_heartbeat_result {
  static $_TSPEC;

  /**
   * @var \metastore\NoSuchLockException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchTxnException
   */
  public $o2 = null;
  /**
   * @var \metastore\TxnAbortedException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchLockException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchTxnException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\TxnAbortedException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_heartbeat_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchLockException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchTxnException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\TxnAbortedException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_heartbeat_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_heartbeat_txn_range_args {
  static $_TSPEC;

  /**
   * @var \metastore\HeartbeatTxnRangeRequest
   */
  public $txns = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'txns',
          'type' => TType::STRUCT,
          'class' => '\metastore\HeartbeatTxnRangeRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['txns'])) {
        $this->txns = $vals['txns'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_heartbeat_txn_range_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->txns = new \metastore\HeartbeatTxnRangeRequest();
            $xfer += $this->txns->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_heartbeat_txn_range_args');
    if ($this->txns !== null) {
      if (!is_object($this->txns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('txns', TType::STRUCT, 1);
      $xfer += $this->txns->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_heartbeat_txn_range_result {
  static $_TSPEC;

  /**
   * @var \metastore\HeartbeatTxnRangeResponse
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\HeartbeatTxnRangeResponse',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_heartbeat_txn_range_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\HeartbeatTxnRangeResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_heartbeat_txn_range_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_compact_args {
  static $_TSPEC;

  /**
   * @var \metastore\CompactionRequest
   */
  public $rqst = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'rqst',
          'type' => TType::STRUCT,
          'class' => '\metastore\CompactionRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['rqst'])) {
        $this->rqst = $vals['rqst'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_compact_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->rqst = new \metastore\CompactionRequest();
            $xfer += $this->rqst->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_compact_args');
    if ($this->rqst !== null) {
      if (!is_object($this->rqst)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rqst', TType::STRUCT, 1);
      $xfer += $this->rqst->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_compact_result {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_compact_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_compact_result');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_compact2_args {
  static $_TSPEC;

  /**
   * @var \metastore\CompactionRequest
   */
  public $rqst = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'rqst',
          'type' => TType::STRUCT,
          'class' => '\metastore\CompactionRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['rqst'])) {
        $this->rqst = $vals['rqst'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_compact2_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->rqst = new \metastore\CompactionRequest();
            $xfer += $this->rqst->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_compact2_args');
    if ($this->rqst !== null) {
      if (!is_object($this->rqst)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rqst', TType::STRUCT, 1);
      $xfer += $this->rqst->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_compact2_result {
  static $_TSPEC;

  /**
   * @var \metastore\CompactionResponse
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\CompactionResponse',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_compact2_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\CompactionResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_compact2_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_show_compact_args {
  static $_TSPEC;

  /**
   * @var \metastore\ShowCompactRequest
   */
  public $rqst = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'rqst',
          'type' => TType::STRUCT,
          'class' => '\metastore\ShowCompactRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['rqst'])) {
        $this->rqst = $vals['rqst'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_show_compact_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->rqst = new \metastore\ShowCompactRequest();
            $xfer += $this->rqst->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_show_compact_args');
    if ($this->rqst !== null) {
      if (!is_object($this->rqst)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rqst', TType::STRUCT, 1);
      $xfer += $this->rqst->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_show_compact_result {
  static $_TSPEC;

  /**
   * @var \metastore\ShowCompactResponse
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\ShowCompactResponse',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_show_compact_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\ShowCompactResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_show_compact_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_dynamic_partitions_args {
  static $_TSPEC;

  /**
   * @var \metastore\AddDynamicPartitions
   */
  public $rqst = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'rqst',
          'type' => TType::STRUCT,
          'class' => '\metastore\AddDynamicPartitions',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['rqst'])) {
        $this->rqst = $vals['rqst'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_dynamic_partitions_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->rqst = new \metastore\AddDynamicPartitions();
            $xfer += $this->rqst->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_dynamic_partitions_args');
    if ($this->rqst !== null) {
      if (!is_object($this->rqst)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rqst', TType::STRUCT, 1);
      $xfer += $this->rqst->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_dynamic_partitions_result {
  static $_TSPEC;

  /**
   * @var \metastore\NoSuchTxnException
   */
  public $o1 = null;
  /**
   * @var \metastore\TxnAbortedException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchTxnException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\TxnAbortedException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_dynamic_partitions_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchTxnException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\TxnAbortedException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_dynamic_partitions_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_next_notification_args {
  static $_TSPEC;

  /**
   * @var \metastore\NotificationEventRequest
   */
  public $rqst = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'rqst',
          'type' => TType::STRUCT,
          'class' => '\metastore\NotificationEventRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['rqst'])) {
        $this->rqst = $vals['rqst'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_next_notification_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->rqst = new \metastore\NotificationEventRequest();
            $xfer += $this->rqst->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_next_notification_args');
    if ($this->rqst !== null) {
      if (!is_object($this->rqst)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rqst', TType::STRUCT, 1);
      $xfer += $this->rqst->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_next_notification_result {
  static $_TSPEC;

  /**
   * @var \metastore\NotificationEventResponse
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\NotificationEventResponse',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_next_notification_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\NotificationEventResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_next_notification_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_current_notificationEventId_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_current_notificationEventId_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_current_notificationEventId_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_current_notificationEventId_result {
  static $_TSPEC;

  /**
   * @var \metastore\CurrentNotificationEventId
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\CurrentNotificationEventId',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_current_notificationEventId_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\CurrentNotificationEventId();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_current_notificationEventId_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_notification_events_count_args {
  static $_TSPEC;

  /**
   * @var \metastore\NotificationEventsCountRequest
   */
  public $rqst = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'rqst',
          'type' => TType::STRUCT,
          'class' => '\metastore\NotificationEventsCountRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['rqst'])) {
        $this->rqst = $vals['rqst'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_notification_events_count_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->rqst = new \metastore\NotificationEventsCountRequest();
            $xfer += $this->rqst->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_notification_events_count_args');
    if ($this->rqst !== null) {
      if (!is_object($this->rqst)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rqst', TType::STRUCT, 1);
      $xfer += $this->rqst->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_notification_events_count_result {
  static $_TSPEC;

  /**
   * @var \metastore\NotificationEventsCountResponse
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\NotificationEventsCountResponse',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_notification_events_count_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\NotificationEventsCountResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_notification_events_count_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_fire_listener_event_args {
  static $_TSPEC;

  /**
   * @var \metastore\FireEventRequest
   */
  public $rqst = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'rqst',
          'type' => TType::STRUCT,
          'class' => '\metastore\FireEventRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['rqst'])) {
        $this->rqst = $vals['rqst'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_fire_listener_event_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->rqst = new \metastore\FireEventRequest();
            $xfer += $this->rqst->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_fire_listener_event_args');
    if ($this->rqst !== null) {
      if (!is_object($this->rqst)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rqst', TType::STRUCT, 1);
      $xfer += $this->rqst->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_fire_listener_event_result {
  static $_TSPEC;

  /**
   * @var \metastore\FireEventResponse
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\FireEventResponse',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_fire_listener_event_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\FireEventResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_fire_listener_event_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_flushCache_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_flushCache_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_flushCache_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_flushCache_result {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_flushCache_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_flushCache_result');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_cm_recycle_args {
  static $_TSPEC;

  /**
   * @var \metastore\CmRecycleRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\CmRecycleRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_cm_recycle_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\CmRecycleRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_cm_recycle_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_cm_recycle_result {
  static $_TSPEC;

  /**
   * @var \metastore\CmRecycleResponse
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\CmRecycleResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_cm_recycle_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\CmRecycleResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_cm_recycle_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_file_metadata_by_expr_args {
  static $_TSPEC;

  /**
   * @var \metastore\GetFileMetadataByExprRequest
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\metastore\GetFileMetadataByExprRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_file_metadata_by_expr_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \metastore\GetFileMetadataByExprRequest();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_file_metadata_by_expr_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_file_metadata_by_expr_result {
  static $_TSPEC;

  /**
   * @var \metastore\GetFileMetadataByExprResult
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\GetFileMetadataByExprResult',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_file_metadata_by_expr_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\GetFileMetadataByExprResult();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_file_metadata_by_expr_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_file_metadata_args {
  static $_TSPEC;

  /**
   * @var \metastore\GetFileMetadataRequest
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\metastore\GetFileMetadataRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_file_metadata_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \metastore\GetFileMetadataRequest();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_file_metadata_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_file_metadata_result {
  static $_TSPEC;

  /**
   * @var \metastore\GetFileMetadataResult
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\GetFileMetadataResult',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_file_metadata_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\GetFileMetadataResult();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_file_metadata_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_put_file_metadata_args {
  static $_TSPEC;

  /**
   * @var \metastore\PutFileMetadataRequest
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\metastore\PutFileMetadataRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_put_file_metadata_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \metastore\PutFileMetadataRequest();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_put_file_metadata_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_put_file_metadata_result {
  static $_TSPEC;

  /**
   * @var \metastore\PutFileMetadataResult
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\PutFileMetadataResult',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_put_file_metadata_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\PutFileMetadataResult();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_put_file_metadata_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_clear_file_metadata_args {
  static $_TSPEC;

  /**
   * @var \metastore\ClearFileMetadataRequest
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\metastore\ClearFileMetadataRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_clear_file_metadata_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \metastore\ClearFileMetadataRequest();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_clear_file_metadata_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_clear_file_metadata_result {
  static $_TSPEC;

  /**
   * @var \metastore\ClearFileMetadataResult
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\ClearFileMetadataResult',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_clear_file_metadata_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\ClearFileMetadataResult();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_clear_file_metadata_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_cache_file_metadata_args {
  static $_TSPEC;

  /**
   * @var \metastore\CacheFileMetadataRequest
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\metastore\CacheFileMetadataRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_cache_file_metadata_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \metastore\CacheFileMetadataRequest();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_cache_file_metadata_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_cache_file_metadata_result {
  static $_TSPEC;

  /**
   * @var \metastore\CacheFileMetadataResult
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\CacheFileMetadataResult',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_cache_file_metadata_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\CacheFileMetadataResult();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_cache_file_metadata_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_metastore_db_uuid_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_metastore_db_uuid_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_metastore_db_uuid_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_metastore_db_uuid_result {
  static $_TSPEC;

  /**
   * @var string
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_metastore_db_uuid_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_metastore_db_uuid_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
      $xfer += $output->writeString($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_resource_plan_args {
  static $_TSPEC;

  /**
   * @var \metastore\WMCreateResourcePlanRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMCreateResourcePlanRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_resource_plan_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\WMCreateResourcePlanRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_resource_plan_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_resource_plan_result {
  static $_TSPEC;

  /**
   * @var \metastore\WMCreateResourcePlanResponse
   */
  public $success = null;
  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o1 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMCreateResourcePlanResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_resource_plan_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\WMCreateResourcePlanResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\AlreadyExistsException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_resource_plan_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_resource_plan_args {
  static $_TSPEC;

  /**
   * @var \metastore\WMGetResourcePlanRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMGetResourcePlanRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_resource_plan_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\WMGetResourcePlanRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_resource_plan_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_resource_plan_result {
  static $_TSPEC;

  /**
   * @var \metastore\WMGetResourcePlanResponse
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMGetResourcePlanResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_resource_plan_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\WMGetResourcePlanResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_resource_plan_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_active_resource_plan_args {
  static $_TSPEC;

  /**
   * @var \metastore\WMGetActiveResourcePlanRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMGetActiveResourcePlanRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_active_resource_plan_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\WMGetActiveResourcePlanRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_active_resource_plan_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_active_resource_plan_result {
  static $_TSPEC;

  /**
   * @var \metastore\WMGetActiveResourcePlanResponse
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMGetActiveResourcePlanResponse',
          ),
        1 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_active_resource_plan_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\WMGetActiveResourcePlanResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_active_resource_plan_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 1);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_resource_plans_args {
  static $_TSPEC;

  /**
   * @var \metastore\WMGetAllResourcePlanRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMGetAllResourcePlanRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_resource_plans_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\WMGetAllResourcePlanRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_resource_plans_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_resource_plans_result {
  static $_TSPEC;

  /**
   * @var \metastore\WMGetAllResourcePlanResponse
   */
  public $success = null;
  /**
   * @var \metastore\MetaException
   */
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMGetAllResourcePlanResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_resource_plans_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\WMGetAllResourcePlanResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_resource_plans_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_resource_plan_args {
  static $_TSPEC;

  /**
   * @var \metastore\WMAlterResourcePlanRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMAlterResourcePlanRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_resource_plan_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\WMAlterResourcePlanRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_resource_plan_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_resource_plan_result {
  static $_TSPEC;

  /**
   * @var \metastore\WMAlterResourcePlanResponse
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\InvalidOperationException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMAlterResourcePlanResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_resource_plan_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\WMAlterResourcePlanResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidOperationException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_resource_plan_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_validate_resource_plan_args {
  static $_TSPEC;

  /**
   * @var \metastore\WMValidateResourcePlanRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMValidateResourcePlanRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_validate_resource_plan_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\WMValidateResourcePlanRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_validate_resource_plan_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_validate_resource_plan_result {
  static $_TSPEC;

  /**
   * @var \metastore\WMValidateResourcePlanResponse
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMValidateResourcePlanResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_validate_resource_plan_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\WMValidateResourcePlanResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_validate_resource_plan_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_resource_plan_args {
  static $_TSPEC;

  /**
   * @var \metastore\WMDropResourcePlanRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMDropResourcePlanRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_resource_plan_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\WMDropResourcePlanRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_resource_plan_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_resource_plan_result {
  static $_TSPEC;

  /**
   * @var \metastore\WMDropResourcePlanResponse
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\InvalidOperationException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMDropResourcePlanResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_resource_plan_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\WMDropResourcePlanResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidOperationException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_resource_plan_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_wm_trigger_args {
  static $_TSPEC;

  /**
   * @var \metastore\WMCreateTriggerRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMCreateTriggerRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_wm_trigger_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\WMCreateTriggerRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_wm_trigger_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_wm_trigger_result {
  static $_TSPEC;

  /**
   * @var \metastore\WMCreateTriggerResponse
   */
  public $success = null;
  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o3 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMCreateTriggerResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_wm_trigger_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\WMCreateTriggerResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\AlreadyExistsException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\InvalidObjectException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\MetaException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_wm_trigger_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_wm_trigger_args {
  static $_TSPEC;

  /**
   * @var \metastore\WMAlterTriggerRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMAlterTriggerRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_wm_trigger_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\WMAlterTriggerRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_wm_trigger_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_wm_trigger_result {
  static $_TSPEC;

  /**
   * @var \metastore\WMAlterTriggerResponse
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMAlterTriggerResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_wm_trigger_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\WMAlterTriggerResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_wm_trigger_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_wm_trigger_args {
  static $_TSPEC;

  /**
   * @var \metastore\WMDropTriggerRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMDropTriggerRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_wm_trigger_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\WMDropTriggerRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_wm_trigger_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_wm_trigger_result {
  static $_TSPEC;

  /**
   * @var \metastore\WMDropTriggerResponse
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\InvalidOperationException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMDropTriggerResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_wm_trigger_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\WMDropTriggerResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidOperationException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_wm_trigger_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_triggers_for_resourceplan_args {
  static $_TSPEC;

  /**
   * @var \metastore\WMGetTriggersForResourePlanRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMGetTriggersForResourePlanRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_triggers_for_resourceplan_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\WMGetTriggersForResourePlanRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_triggers_for_resourceplan_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_triggers_for_resourceplan_result {
  static $_TSPEC;

  /**
   * @var \metastore\WMGetTriggersForResourePlanResponse
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMGetTriggersForResourePlanResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_triggers_for_resourceplan_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\WMGetTriggersForResourePlanResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_triggers_for_resourceplan_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_wm_pool_args {
  static $_TSPEC;

  /**
   * @var \metastore\WMCreatePoolRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMCreatePoolRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_wm_pool_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\WMCreatePoolRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_wm_pool_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_wm_pool_result {
  static $_TSPEC;

  /**
   * @var \metastore\WMCreatePoolResponse
   */
  public $success = null;
  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o3 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMCreatePoolResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_wm_pool_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\WMCreatePoolResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\AlreadyExistsException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\InvalidObjectException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\MetaException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_wm_pool_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_wm_pool_args {
  static $_TSPEC;

  /**
   * @var \metastore\WMAlterPoolRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMAlterPoolRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_wm_pool_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\WMAlterPoolRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_wm_pool_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_wm_pool_result {
  static $_TSPEC;

  /**
   * @var \metastore\WMAlterPoolResponse
   */
  public $success = null;
  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o3 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMAlterPoolResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_wm_pool_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\WMAlterPoolResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\AlreadyExistsException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\InvalidObjectException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\MetaException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_wm_pool_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_wm_pool_args {
  static $_TSPEC;

  /**
   * @var \metastore\WMDropPoolRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMDropPoolRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_wm_pool_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\WMDropPoolRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_wm_pool_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_wm_pool_result {
  static $_TSPEC;

  /**
   * @var \metastore\WMDropPoolResponse
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\InvalidOperationException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMDropPoolResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_wm_pool_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\WMDropPoolResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidOperationException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_wm_pool_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_or_update_wm_mapping_args {
  static $_TSPEC;

  /**
   * @var \metastore\WMCreateOrUpdateMappingRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMCreateOrUpdateMappingRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_or_update_wm_mapping_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\WMCreateOrUpdateMappingRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_or_update_wm_mapping_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_or_update_wm_mapping_result {
  static $_TSPEC;

  /**
   * @var \metastore\WMCreateOrUpdateMappingResponse
   */
  public $success = null;
  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o3 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMCreateOrUpdateMappingResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_or_update_wm_mapping_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\WMCreateOrUpdateMappingResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\AlreadyExistsException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\InvalidObjectException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\MetaException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_or_update_wm_mapping_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_wm_mapping_args {
  static $_TSPEC;

  /**
   * @var \metastore\WMDropMappingRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMDropMappingRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_wm_mapping_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\WMDropMappingRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_wm_mapping_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_wm_mapping_result {
  static $_TSPEC;

  /**
   * @var \metastore\WMDropMappingResponse
   */
  public $success = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o1 = null;
  /**
   * @var \metastore\InvalidOperationException
   */
  public $o2 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMDropMappingResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_wm_mapping_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\WMDropMappingResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidOperationException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_wm_mapping_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_or_drop_wm_trigger_to_pool_mapping_args {
  static $_TSPEC;

  /**
   * @var \metastore\WMCreateOrDropTriggerToPoolMappingRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMCreateOrDropTriggerToPoolMappingRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_or_drop_wm_trigger_to_pool_mapping_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \metastore\WMCreateOrDropTriggerToPoolMappingRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_or_drop_wm_trigger_to_pool_mapping_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_or_drop_wm_trigger_to_pool_mapping_result {
  static $_TSPEC;

  /**
   * @var \metastore\WMCreateOrDropTriggerToPoolMappingResponse
   */
  public $success = null;
  /**
   * @var \metastore\AlreadyExistsException
   */
  public $o1 = null;
  /**
   * @var \metastore\NoSuchObjectException
   */
  public $o2 = null;
  /**
   * @var \metastore\InvalidObjectException
   */
  public $o3 = null;
  /**
   * @var \metastore\MetaException
   */
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\WMCreateOrDropTriggerToPoolMappingResponse',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_or_drop_wm_trigger_to_pool_mapping_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\WMCreateOrDropTriggerToPoolMappingResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\AlreadyExistsException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\InvalidObjectException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\MetaException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_or_drop_wm_trigger_to_pool_mapping_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}


