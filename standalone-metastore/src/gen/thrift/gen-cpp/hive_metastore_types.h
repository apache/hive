/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef hive_metastore_TYPES_H
#define hive_metastore_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "fb303_types.h"


namespace Apache { namespace Hadoop { namespace Hive {

struct HiveObjectType {
  enum type {
    GLOBAL = 1,
    DATABASE = 2,
    TABLE = 3,
    PARTITION = 4,
    COLUMN = 5
  };
};

extern const std::map<int, const char*> _HiveObjectType_VALUES_TO_NAMES;

struct PrincipalType {
  enum type {
    USER = 1,
    ROLE = 2,
    GROUP = 3
  };
};

extern const std::map<int, const char*> _PrincipalType_VALUES_TO_NAMES;

struct PartitionEventType {
  enum type {
    LOAD_DONE = 1
  };
};

extern const std::map<int, const char*> _PartitionEventType_VALUES_TO_NAMES;

struct TxnState {
  enum type {
    COMMITTED = 1,
    ABORTED = 2,
    OPEN = 3
  };
};

extern const std::map<int, const char*> _TxnState_VALUES_TO_NAMES;

struct LockLevel {
  enum type {
    DB = 1,
    TABLE = 2,
    PARTITION = 3
  };
};

extern const std::map<int, const char*> _LockLevel_VALUES_TO_NAMES;

struct LockState {
  enum type {
    ACQUIRED = 1,
    WAITING = 2,
    ABORT = 3,
    NOT_ACQUIRED = 4
  };
};

extern const std::map<int, const char*> _LockState_VALUES_TO_NAMES;

struct LockType {
  enum type {
    SHARED_READ = 1,
    SHARED_WRITE = 2,
    EXCLUSIVE = 3
  };
};

extern const std::map<int, const char*> _LockType_VALUES_TO_NAMES;

struct CompactionType {
  enum type {
    MINOR = 1,
    MAJOR = 2
  };
};

extern const std::map<int, const char*> _CompactionType_VALUES_TO_NAMES;

struct GrantRevokeType {
  enum type {
    GRANT = 1,
    REVOKE = 2
  };
};

extern const std::map<int, const char*> _GrantRevokeType_VALUES_TO_NAMES;

struct DataOperationType {
  enum type {
    SELECT = 1,
    INSERT = 2,
    UPDATE = 3,
    DELETE = 4,
    UNSET = 5,
    NO_TXN = 6
  };
};

extern const std::map<int, const char*> _DataOperationType_VALUES_TO_NAMES;

struct EventRequestType {
  enum type {
    INSERT = 1,
    UPDATE = 2,
    DELETE = 3
  };
};

extern const std::map<int, const char*> _EventRequestType_VALUES_TO_NAMES;

struct SerdeType {
  enum type {
    HIVE = 1,
    SCHEMA_REGISTRY = 2
  };
};

extern const std::map<int, const char*> _SerdeType_VALUES_TO_NAMES;

struct SchemaType {
  enum type {
    HIVE = 1,
    AVRO = 2
  };
};

extern const std::map<int, const char*> _SchemaType_VALUES_TO_NAMES;

struct SchemaCompatibility {
  enum type {
    NONE = 1,
    BACKWARD = 2,
    FORWARD = 3,
    BOTH = 4
  };
};

extern const std::map<int, const char*> _SchemaCompatibility_VALUES_TO_NAMES;

struct SchemaValidation {
  enum type {
    LATEST = 1,
    ALL = 2
  };
};

extern const std::map<int, const char*> _SchemaValidation_VALUES_TO_NAMES;

struct SchemaVersionState {
  enum type {
    INITIATED = 1,
    START_REVIEW = 2,
    CHANGES_REQUIRED = 3,
    REVIEWED = 4,
    ENABLED = 5,
    DISABLED = 6,
    ARCHIVED = 7,
    DELETED = 8
  };
};

extern const std::map<int, const char*> _SchemaVersionState_VALUES_TO_NAMES;

struct FunctionType {
  enum type {
    JAVA = 1
  };
};

extern const std::map<int, const char*> _FunctionType_VALUES_TO_NAMES;

struct ResourceType {
  enum type {
    JAR = 1,
    FILE = 2,
    ARCHIVE = 3
  };
};

extern const std::map<int, const char*> _ResourceType_VALUES_TO_NAMES;

struct FileMetadataExprType {
  enum type {
    ORC_SARG = 1
  };
};

extern const std::map<int, const char*> _FileMetadataExprType_VALUES_TO_NAMES;

struct ClientCapability {
  enum type {
    TEST_CAPABILITY = 1,
    INSERT_ONLY_TABLES = 2
  };
};

extern const std::map<int, const char*> _ClientCapability_VALUES_TO_NAMES;

struct WMResourcePlanStatus {
  enum type {
    ACTIVE = 1,
    ENABLED = 2,
    DISABLED = 3
  };
};

extern const std::map<int, const char*> _WMResourcePlanStatus_VALUES_TO_NAMES;

struct WMPoolSchedulingPolicy {
  enum type {
    FAIR = 1,
    FIFO = 2
  };
};

extern const std::map<int, const char*> _WMPoolSchedulingPolicy_VALUES_TO_NAMES;

class Version;

class FieldSchema;

class SQLPrimaryKey;

class SQLForeignKey;

class SQLUniqueConstraint;

class SQLNotNullConstraint;

class SQLDefaultConstraint;

class SQLCheckConstraint;

class Type;

class HiveObjectRef;

class PrivilegeGrantInfo;

class HiveObjectPrivilege;

class PrivilegeBag;

class PrincipalPrivilegeSet;

class GrantRevokePrivilegeRequest;

class GrantRevokePrivilegeResponse;

class Role;

class RolePrincipalGrant;

class GetRoleGrantsForPrincipalRequest;

class GetRoleGrantsForPrincipalResponse;

class GetPrincipalsInRoleRequest;

class GetPrincipalsInRoleResponse;

class GrantRevokeRoleRequest;

class GrantRevokeRoleResponse;

class Catalog;

class CreateCatalogRequest;

class GetCatalogRequest;

class GetCatalogResponse;

class GetCatalogsResponse;

class DropCatalogRequest;

class Database;

class SerDeInfo;

class Order;

class SkewedInfo;

class StorageDescriptor;

class Table;

class Partition;

class PartitionWithoutSD;

class PartitionSpecWithSharedSD;

class PartitionListComposingSpec;

class PartitionSpec;

class BooleanColumnStatsData;

class DoubleColumnStatsData;

class LongColumnStatsData;

class StringColumnStatsData;

class BinaryColumnStatsData;

class Decimal;

class DecimalColumnStatsData;

class Date;

class DateColumnStatsData;

class ColumnStatisticsData;

class ColumnStatisticsObj;

class ColumnStatisticsDesc;

class ColumnStatistics;

class AggrStats;

class SetPartitionsStatsRequest;

class Schema;

class EnvironmentContext;

class PrimaryKeysRequest;

class PrimaryKeysResponse;

class ForeignKeysRequest;

class ForeignKeysResponse;

class UniqueConstraintsRequest;

class UniqueConstraintsResponse;

class NotNullConstraintsRequest;

class NotNullConstraintsResponse;

class DefaultConstraintsRequest;

class DefaultConstraintsResponse;

class CheckConstraintsRequest;

class CheckConstraintsResponse;

class DropConstraintRequest;

class AddPrimaryKeyRequest;

class AddForeignKeyRequest;

class AddUniqueConstraintRequest;

class AddNotNullConstraintRequest;

class AddDefaultConstraintRequest;

class AddCheckConstraintRequest;

class PartitionsByExprResult;

class PartitionsByExprRequest;

class TableStatsResult;

class PartitionsStatsResult;

class TableStatsRequest;

class PartitionsStatsRequest;

class AddPartitionsResult;

class AddPartitionsRequest;

class DropPartitionsResult;

class DropPartitionsExpr;

class RequestPartsSpec;

class DropPartitionsRequest;

class PartitionValuesRequest;

class PartitionValuesRow;

class PartitionValuesResponse;

class ResourceUri;

class Function;

class TxnInfo;

class GetOpenTxnsInfoResponse;

class GetOpenTxnsResponse;

class OpenTxnRequest;

class OpenTxnsResponse;

class AbortTxnRequest;

class AbortTxnsRequest;

class CommitTxnRequest;

class GetValidWriteIdsRequest;

class TableValidWriteIds;

class GetValidWriteIdsResponse;

class AllocateTableWriteIdsRequest;

class TxnToWriteId;

class AllocateTableWriteIdsResponse;

class LockComponent;

class LockRequest;

class LockResponse;

class CheckLockRequest;

class UnlockRequest;

class ShowLocksRequest;

class ShowLocksResponseElement;

class ShowLocksResponse;

class HeartbeatRequest;

class HeartbeatTxnRangeRequest;

class HeartbeatTxnRangeResponse;

class CompactionRequest;

class CompactionResponse;

class ShowCompactRequest;

class ShowCompactResponseElement;

class ShowCompactResponse;

class AddDynamicPartitions;

class BasicTxnInfo;

class CreationMetadata;

class NotificationEventRequest;

class NotificationEvent;

class NotificationEventResponse;

class CurrentNotificationEventId;

class NotificationEventsCountRequest;

class NotificationEventsCountResponse;

class InsertEventRequestData;

class FireEventRequestData;

class FireEventRequest;

class FireEventResponse;

class MetadataPpdResult;

class GetFileMetadataByExprResult;

class GetFileMetadataByExprRequest;

class GetFileMetadataResult;

class GetFileMetadataRequest;

class PutFileMetadataResult;

class PutFileMetadataRequest;

class ClearFileMetadataResult;

class ClearFileMetadataRequest;

class CacheFileMetadataResult;

class CacheFileMetadataRequest;

class GetAllFunctionsResponse;

class ClientCapabilities;

class GetTableRequest;

class GetTableResult;

class GetTablesRequest;

class GetTablesResult;

class CmRecycleRequest;

class CmRecycleResponse;

class TableMeta;

class Materialization;

class WMResourcePlan;

class WMNullableResourcePlan;

class WMPool;

class WMNullablePool;

class WMTrigger;

class WMMapping;

class WMPoolTrigger;

class WMFullResourcePlan;

class WMCreateResourcePlanRequest;

class WMCreateResourcePlanResponse;

class WMGetActiveResourcePlanRequest;

class WMGetActiveResourcePlanResponse;

class WMGetResourcePlanRequest;

class WMGetResourcePlanResponse;

class WMGetAllResourcePlanRequest;

class WMGetAllResourcePlanResponse;

class WMAlterResourcePlanRequest;

class WMAlterResourcePlanResponse;

class WMValidateResourcePlanRequest;

class WMValidateResourcePlanResponse;

class WMDropResourcePlanRequest;

class WMDropResourcePlanResponse;

class WMCreateTriggerRequest;

class WMCreateTriggerResponse;

class WMAlterTriggerRequest;

class WMAlterTriggerResponse;

class WMDropTriggerRequest;

class WMDropTriggerResponse;

class WMGetTriggersForResourePlanRequest;

class WMGetTriggersForResourePlanResponse;

class WMCreatePoolRequest;

class WMCreatePoolResponse;

class WMAlterPoolRequest;

class WMAlterPoolResponse;

class WMDropPoolRequest;

class WMDropPoolResponse;

class WMCreateOrUpdateMappingRequest;

class WMCreateOrUpdateMappingResponse;

class WMDropMappingRequest;

class WMDropMappingResponse;

class WMCreateOrDropTriggerToPoolMappingRequest;

class WMCreateOrDropTriggerToPoolMappingResponse;

class ISchema;

class ISchemaName;

class AlterISchemaRequest;

class SchemaVersion;

class SchemaVersionDescriptor;

class FindSchemasByColsRqst;

class FindSchemasByColsResp;

class MapSchemaVersionToSerdeRequest;

class SetSchemaVersionStateRequest;

class GetSerdeRequest;

class MetaException;

class UnknownTableException;

class UnknownDBException;

class AlreadyExistsException;

class InvalidPartitionException;

class UnknownPartitionException;

class InvalidObjectException;

class NoSuchObjectException;

class InvalidOperationException;

class ConfigValSecurityException;

class InvalidInputException;

class NoSuchTxnException;

class TxnAbortedException;

class TxnOpenException;

class NoSuchLockException;

typedef struct _Version__isset {
  _Version__isset() : version(false), comments(false) {}
  bool version :1;
  bool comments :1;
} _Version__isset;

class Version {
 public:

  Version(const Version&);
  Version& operator=(const Version&);
  Version() : version(), comments() {
  }

  virtual ~Version() throw();
  std::string version;
  std::string comments;

  _Version__isset __isset;

  void __set_version(const std::string& val);

  void __set_comments(const std::string& val);

  bool operator == (const Version & rhs) const
  {
    if (!(version == rhs.version))
      return false;
    if (!(comments == rhs.comments))
      return false;
    return true;
  }
  bool operator != (const Version &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Version & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Version &a, Version &b);

inline std::ostream& operator<<(std::ostream& out, const Version& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _FieldSchema__isset {
  _FieldSchema__isset() : name(false), type(false), comment(false) {}
  bool name :1;
  bool type :1;
  bool comment :1;
} _FieldSchema__isset;

class FieldSchema {
 public:

  FieldSchema(const FieldSchema&);
  FieldSchema& operator=(const FieldSchema&);
  FieldSchema() : name(), type(), comment() {
  }

  virtual ~FieldSchema() throw();
  std::string name;
  std::string type;
  std::string comment;

  _FieldSchema__isset __isset;

  void __set_name(const std::string& val);

  void __set_type(const std::string& val);

  void __set_comment(const std::string& val);

  bool operator == (const FieldSchema & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(comment == rhs.comment))
      return false;
    return true;
  }
  bool operator != (const FieldSchema &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FieldSchema & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FieldSchema &a, FieldSchema &b);

inline std::ostream& operator<<(std::ostream& out, const FieldSchema& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SQLPrimaryKey__isset {
  _SQLPrimaryKey__isset() : table_db(false), table_name(false), column_name(false), key_seq(false), pk_name(false), enable_cstr(false), validate_cstr(false), rely_cstr(false), catName(false) {}
  bool table_db :1;
  bool table_name :1;
  bool column_name :1;
  bool key_seq :1;
  bool pk_name :1;
  bool enable_cstr :1;
  bool validate_cstr :1;
  bool rely_cstr :1;
  bool catName :1;
} _SQLPrimaryKey__isset;

class SQLPrimaryKey {
 public:

  SQLPrimaryKey(const SQLPrimaryKey&);
  SQLPrimaryKey& operator=(const SQLPrimaryKey&);
  SQLPrimaryKey() : table_db(), table_name(), column_name(), key_seq(0), pk_name(), enable_cstr(0), validate_cstr(0), rely_cstr(0), catName() {
  }

  virtual ~SQLPrimaryKey() throw();
  std::string table_db;
  std::string table_name;
  std::string column_name;
  int32_t key_seq;
  std::string pk_name;
  bool enable_cstr;
  bool validate_cstr;
  bool rely_cstr;
  std::string catName;

  _SQLPrimaryKey__isset __isset;

  void __set_table_db(const std::string& val);

  void __set_table_name(const std::string& val);

  void __set_column_name(const std::string& val);

  void __set_key_seq(const int32_t val);

  void __set_pk_name(const std::string& val);

  void __set_enable_cstr(const bool val);

  void __set_validate_cstr(const bool val);

  void __set_rely_cstr(const bool val);

  void __set_catName(const std::string& val);

  bool operator == (const SQLPrimaryKey & rhs) const
  {
    if (!(table_db == rhs.table_db))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(column_name == rhs.column_name))
      return false;
    if (!(key_seq == rhs.key_seq))
      return false;
    if (!(pk_name == rhs.pk_name))
      return false;
    if (!(enable_cstr == rhs.enable_cstr))
      return false;
    if (!(validate_cstr == rhs.validate_cstr))
      return false;
    if (!(rely_cstr == rhs.rely_cstr))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const SQLPrimaryKey &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SQLPrimaryKey & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SQLPrimaryKey &a, SQLPrimaryKey &b);

inline std::ostream& operator<<(std::ostream& out, const SQLPrimaryKey& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SQLForeignKey__isset {
  _SQLForeignKey__isset() : pktable_db(false), pktable_name(false), pkcolumn_name(false), fktable_db(false), fktable_name(false), fkcolumn_name(false), key_seq(false), update_rule(false), delete_rule(false), fk_name(false), pk_name(false), enable_cstr(false), validate_cstr(false), rely_cstr(false), catName(false) {}
  bool pktable_db :1;
  bool pktable_name :1;
  bool pkcolumn_name :1;
  bool fktable_db :1;
  bool fktable_name :1;
  bool fkcolumn_name :1;
  bool key_seq :1;
  bool update_rule :1;
  bool delete_rule :1;
  bool fk_name :1;
  bool pk_name :1;
  bool enable_cstr :1;
  bool validate_cstr :1;
  bool rely_cstr :1;
  bool catName :1;
} _SQLForeignKey__isset;

class SQLForeignKey {
 public:

  SQLForeignKey(const SQLForeignKey&);
  SQLForeignKey& operator=(const SQLForeignKey&);
  SQLForeignKey() : pktable_db(), pktable_name(), pkcolumn_name(), fktable_db(), fktable_name(), fkcolumn_name(), key_seq(0), update_rule(0), delete_rule(0), fk_name(), pk_name(), enable_cstr(0), validate_cstr(0), rely_cstr(0), catName() {
  }

  virtual ~SQLForeignKey() throw();
  std::string pktable_db;
  std::string pktable_name;
  std::string pkcolumn_name;
  std::string fktable_db;
  std::string fktable_name;
  std::string fkcolumn_name;
  int32_t key_seq;
  int32_t update_rule;
  int32_t delete_rule;
  std::string fk_name;
  std::string pk_name;
  bool enable_cstr;
  bool validate_cstr;
  bool rely_cstr;
  std::string catName;

  _SQLForeignKey__isset __isset;

  void __set_pktable_db(const std::string& val);

  void __set_pktable_name(const std::string& val);

  void __set_pkcolumn_name(const std::string& val);

  void __set_fktable_db(const std::string& val);

  void __set_fktable_name(const std::string& val);

  void __set_fkcolumn_name(const std::string& val);

  void __set_key_seq(const int32_t val);

  void __set_update_rule(const int32_t val);

  void __set_delete_rule(const int32_t val);

  void __set_fk_name(const std::string& val);

  void __set_pk_name(const std::string& val);

  void __set_enable_cstr(const bool val);

  void __set_validate_cstr(const bool val);

  void __set_rely_cstr(const bool val);

  void __set_catName(const std::string& val);

  bool operator == (const SQLForeignKey & rhs) const
  {
    if (!(pktable_db == rhs.pktable_db))
      return false;
    if (!(pktable_name == rhs.pktable_name))
      return false;
    if (!(pkcolumn_name == rhs.pkcolumn_name))
      return false;
    if (!(fktable_db == rhs.fktable_db))
      return false;
    if (!(fktable_name == rhs.fktable_name))
      return false;
    if (!(fkcolumn_name == rhs.fkcolumn_name))
      return false;
    if (!(key_seq == rhs.key_seq))
      return false;
    if (!(update_rule == rhs.update_rule))
      return false;
    if (!(delete_rule == rhs.delete_rule))
      return false;
    if (!(fk_name == rhs.fk_name))
      return false;
    if (!(pk_name == rhs.pk_name))
      return false;
    if (!(enable_cstr == rhs.enable_cstr))
      return false;
    if (!(validate_cstr == rhs.validate_cstr))
      return false;
    if (!(rely_cstr == rhs.rely_cstr))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const SQLForeignKey &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SQLForeignKey & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SQLForeignKey &a, SQLForeignKey &b);

inline std::ostream& operator<<(std::ostream& out, const SQLForeignKey& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SQLUniqueConstraint__isset {
  _SQLUniqueConstraint__isset() : catName(false), table_db(false), table_name(false), column_name(false), key_seq(false), uk_name(false), enable_cstr(false), validate_cstr(false), rely_cstr(false) {}
  bool catName :1;
  bool table_db :1;
  bool table_name :1;
  bool column_name :1;
  bool key_seq :1;
  bool uk_name :1;
  bool enable_cstr :1;
  bool validate_cstr :1;
  bool rely_cstr :1;
} _SQLUniqueConstraint__isset;

class SQLUniqueConstraint {
 public:

  SQLUniqueConstraint(const SQLUniqueConstraint&);
  SQLUniqueConstraint& operator=(const SQLUniqueConstraint&);
  SQLUniqueConstraint() : catName(), table_db(), table_name(), column_name(), key_seq(0), uk_name(), enable_cstr(0), validate_cstr(0), rely_cstr(0) {
  }

  virtual ~SQLUniqueConstraint() throw();
  std::string catName;
  std::string table_db;
  std::string table_name;
  std::string column_name;
  int32_t key_seq;
  std::string uk_name;
  bool enable_cstr;
  bool validate_cstr;
  bool rely_cstr;

  _SQLUniqueConstraint__isset __isset;

  void __set_catName(const std::string& val);

  void __set_table_db(const std::string& val);

  void __set_table_name(const std::string& val);

  void __set_column_name(const std::string& val);

  void __set_key_seq(const int32_t val);

  void __set_uk_name(const std::string& val);

  void __set_enable_cstr(const bool val);

  void __set_validate_cstr(const bool val);

  void __set_rely_cstr(const bool val);

  bool operator == (const SQLUniqueConstraint & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(table_db == rhs.table_db))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(column_name == rhs.column_name))
      return false;
    if (!(key_seq == rhs.key_seq))
      return false;
    if (!(uk_name == rhs.uk_name))
      return false;
    if (!(enable_cstr == rhs.enable_cstr))
      return false;
    if (!(validate_cstr == rhs.validate_cstr))
      return false;
    if (!(rely_cstr == rhs.rely_cstr))
      return false;
    return true;
  }
  bool operator != (const SQLUniqueConstraint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SQLUniqueConstraint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SQLUniqueConstraint &a, SQLUniqueConstraint &b);

inline std::ostream& operator<<(std::ostream& out, const SQLUniqueConstraint& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SQLNotNullConstraint__isset {
  _SQLNotNullConstraint__isset() : catName(false), table_db(false), table_name(false), column_name(false), nn_name(false), enable_cstr(false), validate_cstr(false), rely_cstr(false) {}
  bool catName :1;
  bool table_db :1;
  bool table_name :1;
  bool column_name :1;
  bool nn_name :1;
  bool enable_cstr :1;
  bool validate_cstr :1;
  bool rely_cstr :1;
} _SQLNotNullConstraint__isset;

class SQLNotNullConstraint {
 public:

  SQLNotNullConstraint(const SQLNotNullConstraint&);
  SQLNotNullConstraint& operator=(const SQLNotNullConstraint&);
  SQLNotNullConstraint() : catName(), table_db(), table_name(), column_name(), nn_name(), enable_cstr(0), validate_cstr(0), rely_cstr(0) {
  }

  virtual ~SQLNotNullConstraint() throw();
  std::string catName;
  std::string table_db;
  std::string table_name;
  std::string column_name;
  std::string nn_name;
  bool enable_cstr;
  bool validate_cstr;
  bool rely_cstr;

  _SQLNotNullConstraint__isset __isset;

  void __set_catName(const std::string& val);

  void __set_table_db(const std::string& val);

  void __set_table_name(const std::string& val);

  void __set_column_name(const std::string& val);

  void __set_nn_name(const std::string& val);

  void __set_enable_cstr(const bool val);

  void __set_validate_cstr(const bool val);

  void __set_rely_cstr(const bool val);

  bool operator == (const SQLNotNullConstraint & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(table_db == rhs.table_db))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(column_name == rhs.column_name))
      return false;
    if (!(nn_name == rhs.nn_name))
      return false;
    if (!(enable_cstr == rhs.enable_cstr))
      return false;
    if (!(validate_cstr == rhs.validate_cstr))
      return false;
    if (!(rely_cstr == rhs.rely_cstr))
      return false;
    return true;
  }
  bool operator != (const SQLNotNullConstraint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SQLNotNullConstraint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SQLNotNullConstraint &a, SQLNotNullConstraint &b);

inline std::ostream& operator<<(std::ostream& out, const SQLNotNullConstraint& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SQLDefaultConstraint__isset {
  _SQLDefaultConstraint__isset() : catName(false), table_db(false), table_name(false), column_name(false), default_value(false), dc_name(false), enable_cstr(false), validate_cstr(false), rely_cstr(false) {}
  bool catName :1;
  bool table_db :1;
  bool table_name :1;
  bool column_name :1;
  bool default_value :1;
  bool dc_name :1;
  bool enable_cstr :1;
  bool validate_cstr :1;
  bool rely_cstr :1;
} _SQLDefaultConstraint__isset;

class SQLDefaultConstraint {
 public:

  SQLDefaultConstraint(const SQLDefaultConstraint&);
  SQLDefaultConstraint& operator=(const SQLDefaultConstraint&);
  SQLDefaultConstraint() : catName(), table_db(), table_name(), column_name(), default_value(), dc_name(), enable_cstr(0), validate_cstr(0), rely_cstr(0) {
  }

  virtual ~SQLDefaultConstraint() throw();
  std::string catName;
  std::string table_db;
  std::string table_name;
  std::string column_name;
  std::string default_value;
  std::string dc_name;
  bool enable_cstr;
  bool validate_cstr;
  bool rely_cstr;

  _SQLDefaultConstraint__isset __isset;

  void __set_catName(const std::string& val);

  void __set_table_db(const std::string& val);

  void __set_table_name(const std::string& val);

  void __set_column_name(const std::string& val);

  void __set_default_value(const std::string& val);

  void __set_dc_name(const std::string& val);

  void __set_enable_cstr(const bool val);

  void __set_validate_cstr(const bool val);

  void __set_rely_cstr(const bool val);

  bool operator == (const SQLDefaultConstraint & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(table_db == rhs.table_db))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(column_name == rhs.column_name))
      return false;
    if (!(default_value == rhs.default_value))
      return false;
    if (!(dc_name == rhs.dc_name))
      return false;
    if (!(enable_cstr == rhs.enable_cstr))
      return false;
    if (!(validate_cstr == rhs.validate_cstr))
      return false;
    if (!(rely_cstr == rhs.rely_cstr))
      return false;
    return true;
  }
  bool operator != (const SQLDefaultConstraint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SQLDefaultConstraint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SQLDefaultConstraint &a, SQLDefaultConstraint &b);

inline std::ostream& operator<<(std::ostream& out, const SQLDefaultConstraint& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SQLCheckConstraint__isset {
  _SQLCheckConstraint__isset() : catName(false), table_db(false), table_name(false), column_name(false), check_expression(false), dc_name(false), enable_cstr(false), validate_cstr(false), rely_cstr(false) {}
  bool catName :1;
  bool table_db :1;
  bool table_name :1;
  bool column_name :1;
  bool check_expression :1;
  bool dc_name :1;
  bool enable_cstr :1;
  bool validate_cstr :1;
  bool rely_cstr :1;
} _SQLCheckConstraint__isset;

class SQLCheckConstraint {
 public:

  SQLCheckConstraint(const SQLCheckConstraint&);
  SQLCheckConstraint& operator=(const SQLCheckConstraint&);
  SQLCheckConstraint() : catName(), table_db(), table_name(), column_name(), check_expression(), dc_name(), enable_cstr(0), validate_cstr(0), rely_cstr(0) {
  }

  virtual ~SQLCheckConstraint() throw();
  std::string catName;
  std::string table_db;
  std::string table_name;
  std::string column_name;
  std::string check_expression;
  std::string dc_name;
  bool enable_cstr;
  bool validate_cstr;
  bool rely_cstr;

  _SQLCheckConstraint__isset __isset;

  void __set_catName(const std::string& val);

  void __set_table_db(const std::string& val);

  void __set_table_name(const std::string& val);

  void __set_column_name(const std::string& val);

  void __set_check_expression(const std::string& val);

  void __set_dc_name(const std::string& val);

  void __set_enable_cstr(const bool val);

  void __set_validate_cstr(const bool val);

  void __set_rely_cstr(const bool val);

  bool operator == (const SQLCheckConstraint & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(table_db == rhs.table_db))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(column_name == rhs.column_name))
      return false;
    if (!(check_expression == rhs.check_expression))
      return false;
    if (!(dc_name == rhs.dc_name))
      return false;
    if (!(enable_cstr == rhs.enable_cstr))
      return false;
    if (!(validate_cstr == rhs.validate_cstr))
      return false;
    if (!(rely_cstr == rhs.rely_cstr))
      return false;
    return true;
  }
  bool operator != (const SQLCheckConstraint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SQLCheckConstraint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SQLCheckConstraint &a, SQLCheckConstraint &b);

inline std::ostream& operator<<(std::ostream& out, const SQLCheckConstraint& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Type__isset {
  _Type__isset() : name(false), type1(false), type2(false), fields(false) {}
  bool name :1;
  bool type1 :1;
  bool type2 :1;
  bool fields :1;
} _Type__isset;

class Type {
 public:

  Type(const Type&);
  Type& operator=(const Type&);
  Type() : name(), type1(), type2() {
  }

  virtual ~Type() throw();
  std::string name;
  std::string type1;
  std::string type2;
  std::vector<FieldSchema>  fields;

  _Type__isset __isset;

  void __set_name(const std::string& val);

  void __set_type1(const std::string& val);

  void __set_type2(const std::string& val);

  void __set_fields(const std::vector<FieldSchema> & val);

  bool operator == (const Type & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.type1 != rhs.__isset.type1)
      return false;
    else if (__isset.type1 && !(type1 == rhs.type1))
      return false;
    if (__isset.type2 != rhs.__isset.type2)
      return false;
    else if (__isset.type2 && !(type2 == rhs.type2))
      return false;
    if (__isset.fields != rhs.__isset.fields)
      return false;
    else if (__isset.fields && !(fields == rhs.fields))
      return false;
    return true;
  }
  bool operator != (const Type &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Type & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Type &a, Type &b);

inline std::ostream& operator<<(std::ostream& out, const Type& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _HiveObjectRef__isset {
  _HiveObjectRef__isset() : objectType(false), dbName(false), objectName(false), partValues(false), columnName(false), catName(false) {}
  bool objectType :1;
  bool dbName :1;
  bool objectName :1;
  bool partValues :1;
  bool columnName :1;
  bool catName :1;
} _HiveObjectRef__isset;

class HiveObjectRef {
 public:

  HiveObjectRef(const HiveObjectRef&);
  HiveObjectRef& operator=(const HiveObjectRef&);
  HiveObjectRef() : objectType((HiveObjectType::type)0), dbName(), objectName(), columnName(), catName() {
  }

  virtual ~HiveObjectRef() throw();
  HiveObjectType::type objectType;
  std::string dbName;
  std::string objectName;
  std::vector<std::string>  partValues;
  std::string columnName;
  std::string catName;

  _HiveObjectRef__isset __isset;

  void __set_objectType(const HiveObjectType::type val);

  void __set_dbName(const std::string& val);

  void __set_objectName(const std::string& val);

  void __set_partValues(const std::vector<std::string> & val);

  void __set_columnName(const std::string& val);

  void __set_catName(const std::string& val);

  bool operator == (const HiveObjectRef & rhs) const
  {
    if (!(objectType == rhs.objectType))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(objectName == rhs.objectName))
      return false;
    if (!(partValues == rhs.partValues))
      return false;
    if (!(columnName == rhs.columnName))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const HiveObjectRef &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HiveObjectRef & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HiveObjectRef &a, HiveObjectRef &b);

inline std::ostream& operator<<(std::ostream& out, const HiveObjectRef& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _PrivilegeGrantInfo__isset {
  _PrivilegeGrantInfo__isset() : privilege(false), createTime(false), grantor(false), grantorType(false), grantOption(false) {}
  bool privilege :1;
  bool createTime :1;
  bool grantor :1;
  bool grantorType :1;
  bool grantOption :1;
} _PrivilegeGrantInfo__isset;

class PrivilegeGrantInfo {
 public:

  PrivilegeGrantInfo(const PrivilegeGrantInfo&);
  PrivilegeGrantInfo& operator=(const PrivilegeGrantInfo&);
  PrivilegeGrantInfo() : privilege(), createTime(0), grantor(), grantorType((PrincipalType::type)0), grantOption(0) {
  }

  virtual ~PrivilegeGrantInfo() throw();
  std::string privilege;
  int32_t createTime;
  std::string grantor;
  PrincipalType::type grantorType;
  bool grantOption;

  _PrivilegeGrantInfo__isset __isset;

  void __set_privilege(const std::string& val);

  void __set_createTime(const int32_t val);

  void __set_grantor(const std::string& val);

  void __set_grantorType(const PrincipalType::type val);

  void __set_grantOption(const bool val);

  bool operator == (const PrivilegeGrantInfo & rhs) const
  {
    if (!(privilege == rhs.privilege))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(grantor == rhs.grantor))
      return false;
    if (!(grantorType == rhs.grantorType))
      return false;
    if (!(grantOption == rhs.grantOption))
      return false;
    return true;
  }
  bool operator != (const PrivilegeGrantInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrivilegeGrantInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PrivilegeGrantInfo &a, PrivilegeGrantInfo &b);

inline std::ostream& operator<<(std::ostream& out, const PrivilegeGrantInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _HiveObjectPrivilege__isset {
  _HiveObjectPrivilege__isset() : hiveObject(false), principalName(false), principalType(false), grantInfo(false) {}
  bool hiveObject :1;
  bool principalName :1;
  bool principalType :1;
  bool grantInfo :1;
} _HiveObjectPrivilege__isset;

class HiveObjectPrivilege {
 public:

  HiveObjectPrivilege(const HiveObjectPrivilege&);
  HiveObjectPrivilege& operator=(const HiveObjectPrivilege&);
  HiveObjectPrivilege() : principalName(), principalType((PrincipalType::type)0) {
  }

  virtual ~HiveObjectPrivilege() throw();
  HiveObjectRef hiveObject;
  std::string principalName;
  PrincipalType::type principalType;
  PrivilegeGrantInfo grantInfo;

  _HiveObjectPrivilege__isset __isset;

  void __set_hiveObject(const HiveObjectRef& val);

  void __set_principalName(const std::string& val);

  void __set_principalType(const PrincipalType::type val);

  void __set_grantInfo(const PrivilegeGrantInfo& val);

  bool operator == (const HiveObjectPrivilege & rhs) const
  {
    if (!(hiveObject == rhs.hiveObject))
      return false;
    if (!(principalName == rhs.principalName))
      return false;
    if (!(principalType == rhs.principalType))
      return false;
    if (!(grantInfo == rhs.grantInfo))
      return false;
    return true;
  }
  bool operator != (const HiveObjectPrivilege &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HiveObjectPrivilege & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HiveObjectPrivilege &a, HiveObjectPrivilege &b);

inline std::ostream& operator<<(std::ostream& out, const HiveObjectPrivilege& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _PrivilegeBag__isset {
  _PrivilegeBag__isset() : privileges(false) {}
  bool privileges :1;
} _PrivilegeBag__isset;

class PrivilegeBag {
 public:

  PrivilegeBag(const PrivilegeBag&);
  PrivilegeBag& operator=(const PrivilegeBag&);
  PrivilegeBag() {
  }

  virtual ~PrivilegeBag() throw();
  std::vector<HiveObjectPrivilege>  privileges;

  _PrivilegeBag__isset __isset;

  void __set_privileges(const std::vector<HiveObjectPrivilege> & val);

  bool operator == (const PrivilegeBag & rhs) const
  {
    if (!(privileges == rhs.privileges))
      return false;
    return true;
  }
  bool operator != (const PrivilegeBag &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrivilegeBag & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PrivilegeBag &a, PrivilegeBag &b);

inline std::ostream& operator<<(std::ostream& out, const PrivilegeBag& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _PrincipalPrivilegeSet__isset {
  _PrincipalPrivilegeSet__isset() : userPrivileges(false), groupPrivileges(false), rolePrivileges(false) {}
  bool userPrivileges :1;
  bool groupPrivileges :1;
  bool rolePrivileges :1;
} _PrincipalPrivilegeSet__isset;

class PrincipalPrivilegeSet {
 public:

  PrincipalPrivilegeSet(const PrincipalPrivilegeSet&);
  PrincipalPrivilegeSet& operator=(const PrincipalPrivilegeSet&);
  PrincipalPrivilegeSet() {
  }

  virtual ~PrincipalPrivilegeSet() throw();
  std::map<std::string, std::vector<PrivilegeGrantInfo> >  userPrivileges;
  std::map<std::string, std::vector<PrivilegeGrantInfo> >  groupPrivileges;
  std::map<std::string, std::vector<PrivilegeGrantInfo> >  rolePrivileges;

  _PrincipalPrivilegeSet__isset __isset;

  void __set_userPrivileges(const std::map<std::string, std::vector<PrivilegeGrantInfo> > & val);

  void __set_groupPrivileges(const std::map<std::string, std::vector<PrivilegeGrantInfo> > & val);

  void __set_rolePrivileges(const std::map<std::string, std::vector<PrivilegeGrantInfo> > & val);

  bool operator == (const PrincipalPrivilegeSet & rhs) const
  {
    if (!(userPrivileges == rhs.userPrivileges))
      return false;
    if (!(groupPrivileges == rhs.groupPrivileges))
      return false;
    if (!(rolePrivileges == rhs.rolePrivileges))
      return false;
    return true;
  }
  bool operator != (const PrincipalPrivilegeSet &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrincipalPrivilegeSet & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PrincipalPrivilegeSet &a, PrincipalPrivilegeSet &b);

inline std::ostream& operator<<(std::ostream& out, const PrincipalPrivilegeSet& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GrantRevokePrivilegeRequest__isset {
  _GrantRevokePrivilegeRequest__isset() : requestType(false), privileges(false), revokeGrantOption(false) {}
  bool requestType :1;
  bool privileges :1;
  bool revokeGrantOption :1;
} _GrantRevokePrivilegeRequest__isset;

class GrantRevokePrivilegeRequest {
 public:

  GrantRevokePrivilegeRequest(const GrantRevokePrivilegeRequest&);
  GrantRevokePrivilegeRequest& operator=(const GrantRevokePrivilegeRequest&);
  GrantRevokePrivilegeRequest() : requestType((GrantRevokeType::type)0), revokeGrantOption(0) {
  }

  virtual ~GrantRevokePrivilegeRequest() throw();
  GrantRevokeType::type requestType;
  PrivilegeBag privileges;
  bool revokeGrantOption;

  _GrantRevokePrivilegeRequest__isset __isset;

  void __set_requestType(const GrantRevokeType::type val);

  void __set_privileges(const PrivilegeBag& val);

  void __set_revokeGrantOption(const bool val);

  bool operator == (const GrantRevokePrivilegeRequest & rhs) const
  {
    if (!(requestType == rhs.requestType))
      return false;
    if (!(privileges == rhs.privileges))
      return false;
    if (__isset.revokeGrantOption != rhs.__isset.revokeGrantOption)
      return false;
    else if (__isset.revokeGrantOption && !(revokeGrantOption == rhs.revokeGrantOption))
      return false;
    return true;
  }
  bool operator != (const GrantRevokePrivilegeRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GrantRevokePrivilegeRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GrantRevokePrivilegeRequest &a, GrantRevokePrivilegeRequest &b);

inline std::ostream& operator<<(std::ostream& out, const GrantRevokePrivilegeRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GrantRevokePrivilegeResponse__isset {
  _GrantRevokePrivilegeResponse__isset() : success(false) {}
  bool success :1;
} _GrantRevokePrivilegeResponse__isset;

class GrantRevokePrivilegeResponse {
 public:

  GrantRevokePrivilegeResponse(const GrantRevokePrivilegeResponse&);
  GrantRevokePrivilegeResponse& operator=(const GrantRevokePrivilegeResponse&);
  GrantRevokePrivilegeResponse() : success(0) {
  }

  virtual ~GrantRevokePrivilegeResponse() throw();
  bool success;

  _GrantRevokePrivilegeResponse__isset __isset;

  void __set_success(const bool val);

  bool operator == (const GrantRevokePrivilegeResponse & rhs) const
  {
    if (__isset.success != rhs.__isset.success)
      return false;
    else if (__isset.success && !(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const GrantRevokePrivilegeResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GrantRevokePrivilegeResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GrantRevokePrivilegeResponse &a, GrantRevokePrivilegeResponse &b);

inline std::ostream& operator<<(std::ostream& out, const GrantRevokePrivilegeResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Role__isset {
  _Role__isset() : roleName(false), createTime(false), ownerName(false) {}
  bool roleName :1;
  bool createTime :1;
  bool ownerName :1;
} _Role__isset;

class Role {
 public:

  Role(const Role&);
  Role& operator=(const Role&);
  Role() : roleName(), createTime(0), ownerName() {
  }

  virtual ~Role() throw();
  std::string roleName;
  int32_t createTime;
  std::string ownerName;

  _Role__isset __isset;

  void __set_roleName(const std::string& val);

  void __set_createTime(const int32_t val);

  void __set_ownerName(const std::string& val);

  bool operator == (const Role & rhs) const
  {
    if (!(roleName == rhs.roleName))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(ownerName == rhs.ownerName))
      return false;
    return true;
  }
  bool operator != (const Role &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Role & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Role &a, Role &b);

inline std::ostream& operator<<(std::ostream& out, const Role& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _RolePrincipalGrant__isset {
  _RolePrincipalGrant__isset() : roleName(false), principalName(false), principalType(false), grantOption(false), grantTime(false), grantorName(false), grantorPrincipalType(false) {}
  bool roleName :1;
  bool principalName :1;
  bool principalType :1;
  bool grantOption :1;
  bool grantTime :1;
  bool grantorName :1;
  bool grantorPrincipalType :1;
} _RolePrincipalGrant__isset;

class RolePrincipalGrant {
 public:

  RolePrincipalGrant(const RolePrincipalGrant&);
  RolePrincipalGrant& operator=(const RolePrincipalGrant&);
  RolePrincipalGrant() : roleName(), principalName(), principalType((PrincipalType::type)0), grantOption(0), grantTime(0), grantorName(), grantorPrincipalType((PrincipalType::type)0) {
  }

  virtual ~RolePrincipalGrant() throw();
  std::string roleName;
  std::string principalName;
  PrincipalType::type principalType;
  bool grantOption;
  int32_t grantTime;
  std::string grantorName;
  PrincipalType::type grantorPrincipalType;

  _RolePrincipalGrant__isset __isset;

  void __set_roleName(const std::string& val);

  void __set_principalName(const std::string& val);

  void __set_principalType(const PrincipalType::type val);

  void __set_grantOption(const bool val);

  void __set_grantTime(const int32_t val);

  void __set_grantorName(const std::string& val);

  void __set_grantorPrincipalType(const PrincipalType::type val);

  bool operator == (const RolePrincipalGrant & rhs) const
  {
    if (!(roleName == rhs.roleName))
      return false;
    if (!(principalName == rhs.principalName))
      return false;
    if (!(principalType == rhs.principalType))
      return false;
    if (!(grantOption == rhs.grantOption))
      return false;
    if (!(grantTime == rhs.grantTime))
      return false;
    if (!(grantorName == rhs.grantorName))
      return false;
    if (!(grantorPrincipalType == rhs.grantorPrincipalType))
      return false;
    return true;
  }
  bool operator != (const RolePrincipalGrant &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RolePrincipalGrant & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RolePrincipalGrant &a, RolePrincipalGrant &b);

inline std::ostream& operator<<(std::ostream& out, const RolePrincipalGrant& obj)
{
  obj.printTo(out);
  return out;
}


class GetRoleGrantsForPrincipalRequest {
 public:

  GetRoleGrantsForPrincipalRequest(const GetRoleGrantsForPrincipalRequest&);
  GetRoleGrantsForPrincipalRequest& operator=(const GetRoleGrantsForPrincipalRequest&);
  GetRoleGrantsForPrincipalRequest() : principal_name(), principal_type((PrincipalType::type)0) {
  }

  virtual ~GetRoleGrantsForPrincipalRequest() throw();
  std::string principal_name;
  PrincipalType::type principal_type;

  void __set_principal_name(const std::string& val);

  void __set_principal_type(const PrincipalType::type val);

  bool operator == (const GetRoleGrantsForPrincipalRequest & rhs) const
  {
    if (!(principal_name == rhs.principal_name))
      return false;
    if (!(principal_type == rhs.principal_type))
      return false;
    return true;
  }
  bool operator != (const GetRoleGrantsForPrincipalRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetRoleGrantsForPrincipalRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetRoleGrantsForPrincipalRequest &a, GetRoleGrantsForPrincipalRequest &b);

inline std::ostream& operator<<(std::ostream& out, const GetRoleGrantsForPrincipalRequest& obj)
{
  obj.printTo(out);
  return out;
}


class GetRoleGrantsForPrincipalResponse {
 public:

  GetRoleGrantsForPrincipalResponse(const GetRoleGrantsForPrincipalResponse&);
  GetRoleGrantsForPrincipalResponse& operator=(const GetRoleGrantsForPrincipalResponse&);
  GetRoleGrantsForPrincipalResponse() {
  }

  virtual ~GetRoleGrantsForPrincipalResponse() throw();
  std::vector<RolePrincipalGrant>  principalGrants;

  void __set_principalGrants(const std::vector<RolePrincipalGrant> & val);

  bool operator == (const GetRoleGrantsForPrincipalResponse & rhs) const
  {
    if (!(principalGrants == rhs.principalGrants))
      return false;
    return true;
  }
  bool operator != (const GetRoleGrantsForPrincipalResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetRoleGrantsForPrincipalResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetRoleGrantsForPrincipalResponse &a, GetRoleGrantsForPrincipalResponse &b);

inline std::ostream& operator<<(std::ostream& out, const GetRoleGrantsForPrincipalResponse& obj)
{
  obj.printTo(out);
  return out;
}


class GetPrincipalsInRoleRequest {
 public:

  GetPrincipalsInRoleRequest(const GetPrincipalsInRoleRequest&);
  GetPrincipalsInRoleRequest& operator=(const GetPrincipalsInRoleRequest&);
  GetPrincipalsInRoleRequest() : roleName() {
  }

  virtual ~GetPrincipalsInRoleRequest() throw();
  std::string roleName;

  void __set_roleName(const std::string& val);

  bool operator == (const GetPrincipalsInRoleRequest & rhs) const
  {
    if (!(roleName == rhs.roleName))
      return false;
    return true;
  }
  bool operator != (const GetPrincipalsInRoleRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetPrincipalsInRoleRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetPrincipalsInRoleRequest &a, GetPrincipalsInRoleRequest &b);

inline std::ostream& operator<<(std::ostream& out, const GetPrincipalsInRoleRequest& obj)
{
  obj.printTo(out);
  return out;
}


class GetPrincipalsInRoleResponse {
 public:

  GetPrincipalsInRoleResponse(const GetPrincipalsInRoleResponse&);
  GetPrincipalsInRoleResponse& operator=(const GetPrincipalsInRoleResponse&);
  GetPrincipalsInRoleResponse() {
  }

  virtual ~GetPrincipalsInRoleResponse() throw();
  std::vector<RolePrincipalGrant>  principalGrants;

  void __set_principalGrants(const std::vector<RolePrincipalGrant> & val);

  bool operator == (const GetPrincipalsInRoleResponse & rhs) const
  {
    if (!(principalGrants == rhs.principalGrants))
      return false;
    return true;
  }
  bool operator != (const GetPrincipalsInRoleResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetPrincipalsInRoleResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetPrincipalsInRoleResponse &a, GetPrincipalsInRoleResponse &b);

inline std::ostream& operator<<(std::ostream& out, const GetPrincipalsInRoleResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GrantRevokeRoleRequest__isset {
  _GrantRevokeRoleRequest__isset() : requestType(false), roleName(false), principalName(false), principalType(false), grantor(false), grantorType(false), grantOption(false) {}
  bool requestType :1;
  bool roleName :1;
  bool principalName :1;
  bool principalType :1;
  bool grantor :1;
  bool grantorType :1;
  bool grantOption :1;
} _GrantRevokeRoleRequest__isset;

class GrantRevokeRoleRequest {
 public:

  GrantRevokeRoleRequest(const GrantRevokeRoleRequest&);
  GrantRevokeRoleRequest& operator=(const GrantRevokeRoleRequest&);
  GrantRevokeRoleRequest() : requestType((GrantRevokeType::type)0), roleName(), principalName(), principalType((PrincipalType::type)0), grantor(), grantorType((PrincipalType::type)0), grantOption(0) {
  }

  virtual ~GrantRevokeRoleRequest() throw();
  GrantRevokeType::type requestType;
  std::string roleName;
  std::string principalName;
  PrincipalType::type principalType;
  std::string grantor;
  PrincipalType::type grantorType;
  bool grantOption;

  _GrantRevokeRoleRequest__isset __isset;

  void __set_requestType(const GrantRevokeType::type val);

  void __set_roleName(const std::string& val);

  void __set_principalName(const std::string& val);

  void __set_principalType(const PrincipalType::type val);

  void __set_grantor(const std::string& val);

  void __set_grantorType(const PrincipalType::type val);

  void __set_grantOption(const bool val);

  bool operator == (const GrantRevokeRoleRequest & rhs) const
  {
    if (!(requestType == rhs.requestType))
      return false;
    if (!(roleName == rhs.roleName))
      return false;
    if (!(principalName == rhs.principalName))
      return false;
    if (!(principalType == rhs.principalType))
      return false;
    if (__isset.grantor != rhs.__isset.grantor)
      return false;
    else if (__isset.grantor && !(grantor == rhs.grantor))
      return false;
    if (__isset.grantorType != rhs.__isset.grantorType)
      return false;
    else if (__isset.grantorType && !(grantorType == rhs.grantorType))
      return false;
    if (__isset.grantOption != rhs.__isset.grantOption)
      return false;
    else if (__isset.grantOption && !(grantOption == rhs.grantOption))
      return false;
    return true;
  }
  bool operator != (const GrantRevokeRoleRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GrantRevokeRoleRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GrantRevokeRoleRequest &a, GrantRevokeRoleRequest &b);

inline std::ostream& operator<<(std::ostream& out, const GrantRevokeRoleRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GrantRevokeRoleResponse__isset {
  _GrantRevokeRoleResponse__isset() : success(false) {}
  bool success :1;
} _GrantRevokeRoleResponse__isset;

class GrantRevokeRoleResponse {
 public:

  GrantRevokeRoleResponse(const GrantRevokeRoleResponse&);
  GrantRevokeRoleResponse& operator=(const GrantRevokeRoleResponse&);
  GrantRevokeRoleResponse() : success(0) {
  }

  virtual ~GrantRevokeRoleResponse() throw();
  bool success;

  _GrantRevokeRoleResponse__isset __isset;

  void __set_success(const bool val);

  bool operator == (const GrantRevokeRoleResponse & rhs) const
  {
    if (__isset.success != rhs.__isset.success)
      return false;
    else if (__isset.success && !(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const GrantRevokeRoleResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GrantRevokeRoleResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GrantRevokeRoleResponse &a, GrantRevokeRoleResponse &b);

inline std::ostream& operator<<(std::ostream& out, const GrantRevokeRoleResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Catalog__isset {
  _Catalog__isset() : name(false), description(false), locationUri(false) {}
  bool name :1;
  bool description :1;
  bool locationUri :1;
} _Catalog__isset;

class Catalog {
 public:

  Catalog(const Catalog&);
  Catalog& operator=(const Catalog&);
  Catalog() : name(), description(), locationUri() {
  }

  virtual ~Catalog() throw();
  std::string name;
  std::string description;
  std::string locationUri;

  _Catalog__isset __isset;

  void __set_name(const std::string& val);

  void __set_description(const std::string& val);

  void __set_locationUri(const std::string& val);

  bool operator == (const Catalog & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    if (!(locationUri == rhs.locationUri))
      return false;
    return true;
  }
  bool operator != (const Catalog &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Catalog & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Catalog &a, Catalog &b);

inline std::ostream& operator<<(std::ostream& out, const Catalog& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _CreateCatalogRequest__isset {
  _CreateCatalogRequest__isset() : catalog(false) {}
  bool catalog :1;
} _CreateCatalogRequest__isset;

class CreateCatalogRequest {
 public:

  CreateCatalogRequest(const CreateCatalogRequest&);
  CreateCatalogRequest& operator=(const CreateCatalogRequest&);
  CreateCatalogRequest() {
  }

  virtual ~CreateCatalogRequest() throw();
  Catalog catalog;

  _CreateCatalogRequest__isset __isset;

  void __set_catalog(const Catalog& val);

  bool operator == (const CreateCatalogRequest & rhs) const
  {
    if (!(catalog == rhs.catalog))
      return false;
    return true;
  }
  bool operator != (const CreateCatalogRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CreateCatalogRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CreateCatalogRequest &a, CreateCatalogRequest &b);

inline std::ostream& operator<<(std::ostream& out, const CreateCatalogRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GetCatalogRequest__isset {
  _GetCatalogRequest__isset() : name(false) {}
  bool name :1;
} _GetCatalogRequest__isset;

class GetCatalogRequest {
 public:

  GetCatalogRequest(const GetCatalogRequest&);
  GetCatalogRequest& operator=(const GetCatalogRequest&);
  GetCatalogRequest() : name() {
  }

  virtual ~GetCatalogRequest() throw();
  std::string name;

  _GetCatalogRequest__isset __isset;

  void __set_name(const std::string& val);

  bool operator == (const GetCatalogRequest & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const GetCatalogRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetCatalogRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetCatalogRequest &a, GetCatalogRequest &b);

inline std::ostream& operator<<(std::ostream& out, const GetCatalogRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GetCatalogResponse__isset {
  _GetCatalogResponse__isset() : catalog(false) {}
  bool catalog :1;
} _GetCatalogResponse__isset;

class GetCatalogResponse {
 public:

  GetCatalogResponse(const GetCatalogResponse&);
  GetCatalogResponse& operator=(const GetCatalogResponse&);
  GetCatalogResponse() {
  }

  virtual ~GetCatalogResponse() throw();
  Catalog catalog;

  _GetCatalogResponse__isset __isset;

  void __set_catalog(const Catalog& val);

  bool operator == (const GetCatalogResponse & rhs) const
  {
    if (!(catalog == rhs.catalog))
      return false;
    return true;
  }
  bool operator != (const GetCatalogResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetCatalogResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetCatalogResponse &a, GetCatalogResponse &b);

inline std::ostream& operator<<(std::ostream& out, const GetCatalogResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GetCatalogsResponse__isset {
  _GetCatalogsResponse__isset() : names(false) {}
  bool names :1;
} _GetCatalogsResponse__isset;

class GetCatalogsResponse {
 public:

  GetCatalogsResponse(const GetCatalogsResponse&);
  GetCatalogsResponse& operator=(const GetCatalogsResponse&);
  GetCatalogsResponse() {
  }

  virtual ~GetCatalogsResponse() throw();
  std::vector<std::string>  names;

  _GetCatalogsResponse__isset __isset;

  void __set_names(const std::vector<std::string> & val);

  bool operator == (const GetCatalogsResponse & rhs) const
  {
    if (!(names == rhs.names))
      return false;
    return true;
  }
  bool operator != (const GetCatalogsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetCatalogsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetCatalogsResponse &a, GetCatalogsResponse &b);

inline std::ostream& operator<<(std::ostream& out, const GetCatalogsResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DropCatalogRequest__isset {
  _DropCatalogRequest__isset() : name(false) {}
  bool name :1;
} _DropCatalogRequest__isset;

class DropCatalogRequest {
 public:

  DropCatalogRequest(const DropCatalogRequest&);
  DropCatalogRequest& operator=(const DropCatalogRequest&);
  DropCatalogRequest() : name() {
  }

  virtual ~DropCatalogRequest() throw();
  std::string name;

  _DropCatalogRequest__isset __isset;

  void __set_name(const std::string& val);

  bool operator == (const DropCatalogRequest & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const DropCatalogRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DropCatalogRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DropCatalogRequest &a, DropCatalogRequest &b);

inline std::ostream& operator<<(std::ostream& out, const DropCatalogRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Database__isset {
  _Database__isset() : name(false), description(false), locationUri(false), parameters(false), privileges(false), ownerName(false), ownerType(false), catalogName(false) {}
  bool name :1;
  bool description :1;
  bool locationUri :1;
  bool parameters :1;
  bool privileges :1;
  bool ownerName :1;
  bool ownerType :1;
  bool catalogName :1;
} _Database__isset;

class Database {
 public:

  Database(const Database&);
  Database& operator=(const Database&);
  Database() : name(), description(), locationUri(), ownerName(), ownerType((PrincipalType::type)0), catalogName() {
  }

  virtual ~Database() throw();
  std::string name;
  std::string description;
  std::string locationUri;
  std::map<std::string, std::string>  parameters;
  PrincipalPrivilegeSet privileges;
  std::string ownerName;
  PrincipalType::type ownerType;
  std::string catalogName;

  _Database__isset __isset;

  void __set_name(const std::string& val);

  void __set_description(const std::string& val);

  void __set_locationUri(const std::string& val);

  void __set_parameters(const std::map<std::string, std::string> & val);

  void __set_privileges(const PrincipalPrivilegeSet& val);

  void __set_ownerName(const std::string& val);

  void __set_ownerType(const PrincipalType::type val);

  void __set_catalogName(const std::string& val);

  bool operator == (const Database & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(description == rhs.description))
      return false;
    if (!(locationUri == rhs.locationUri))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (__isset.privileges != rhs.__isset.privileges)
      return false;
    else if (__isset.privileges && !(privileges == rhs.privileges))
      return false;
    if (__isset.ownerName != rhs.__isset.ownerName)
      return false;
    else if (__isset.ownerName && !(ownerName == rhs.ownerName))
      return false;
    if (__isset.ownerType != rhs.__isset.ownerType)
      return false;
    else if (__isset.ownerType && !(ownerType == rhs.ownerType))
      return false;
    if (__isset.catalogName != rhs.__isset.catalogName)
      return false;
    else if (__isset.catalogName && !(catalogName == rhs.catalogName))
      return false;
    return true;
  }
  bool operator != (const Database &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Database & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Database &a, Database &b);

inline std::ostream& operator<<(std::ostream& out, const Database& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SerDeInfo__isset {
  _SerDeInfo__isset() : name(false), serializationLib(false), parameters(false), description(false), serializerClass(false), deserializerClass(false), serdeType(false) {}
  bool name :1;
  bool serializationLib :1;
  bool parameters :1;
  bool description :1;
  bool serializerClass :1;
  bool deserializerClass :1;
  bool serdeType :1;
} _SerDeInfo__isset;

class SerDeInfo {
 public:

  SerDeInfo(const SerDeInfo&);
  SerDeInfo& operator=(const SerDeInfo&);
  SerDeInfo() : name(), serializationLib(), description(), serializerClass(), deserializerClass(), serdeType((SerdeType::type)0) {
  }

  virtual ~SerDeInfo() throw();
  std::string name;
  std::string serializationLib;
  std::map<std::string, std::string>  parameters;
  std::string description;
  std::string serializerClass;
  std::string deserializerClass;
  SerdeType::type serdeType;

  _SerDeInfo__isset __isset;

  void __set_name(const std::string& val);

  void __set_serializationLib(const std::string& val);

  void __set_parameters(const std::map<std::string, std::string> & val);

  void __set_description(const std::string& val);

  void __set_serializerClass(const std::string& val);

  void __set_deserializerClass(const std::string& val);

  void __set_serdeType(const SerdeType::type val);

  bool operator == (const SerDeInfo & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(serializationLib == rhs.serializationLib))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    if (__isset.serializerClass != rhs.__isset.serializerClass)
      return false;
    else if (__isset.serializerClass && !(serializerClass == rhs.serializerClass))
      return false;
    if (__isset.deserializerClass != rhs.__isset.deserializerClass)
      return false;
    else if (__isset.deserializerClass && !(deserializerClass == rhs.deserializerClass))
      return false;
    if (__isset.serdeType != rhs.__isset.serdeType)
      return false;
    else if (__isset.serdeType && !(serdeType == rhs.serdeType))
      return false;
    return true;
  }
  bool operator != (const SerDeInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SerDeInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SerDeInfo &a, SerDeInfo &b);

inline std::ostream& operator<<(std::ostream& out, const SerDeInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Order__isset {
  _Order__isset() : col(false), order(false) {}
  bool col :1;
  bool order :1;
} _Order__isset;

class Order {
 public:

  Order(const Order&);
  Order& operator=(const Order&);
  Order() : col(), order(0) {
  }

  virtual ~Order() throw();
  std::string col;
  int32_t order;

  _Order__isset __isset;

  void __set_col(const std::string& val);

  void __set_order(const int32_t val);

  bool operator == (const Order & rhs) const
  {
    if (!(col == rhs.col))
      return false;
    if (!(order == rhs.order))
      return false;
    return true;
  }
  bool operator != (const Order &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Order & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Order &a, Order &b);

inline std::ostream& operator<<(std::ostream& out, const Order& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SkewedInfo__isset {
  _SkewedInfo__isset() : skewedColNames(false), skewedColValues(false), skewedColValueLocationMaps(false) {}
  bool skewedColNames :1;
  bool skewedColValues :1;
  bool skewedColValueLocationMaps :1;
} _SkewedInfo__isset;

class SkewedInfo {
 public:

  SkewedInfo(const SkewedInfo&);
  SkewedInfo& operator=(const SkewedInfo&);
  SkewedInfo() {
  }

  virtual ~SkewedInfo() throw();
  std::vector<std::string>  skewedColNames;
  std::vector<std::vector<std::string> >  skewedColValues;
  std::map<std::vector<std::string> , std::string>  skewedColValueLocationMaps;

  _SkewedInfo__isset __isset;

  void __set_skewedColNames(const std::vector<std::string> & val);

  void __set_skewedColValues(const std::vector<std::vector<std::string> > & val);

  void __set_skewedColValueLocationMaps(const std::map<std::vector<std::string> , std::string> & val);

  bool operator == (const SkewedInfo & rhs) const
  {
    if (!(skewedColNames == rhs.skewedColNames))
      return false;
    if (!(skewedColValues == rhs.skewedColValues))
      return false;
    if (!(skewedColValueLocationMaps == rhs.skewedColValueLocationMaps))
      return false;
    return true;
  }
  bool operator != (const SkewedInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SkewedInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SkewedInfo &a, SkewedInfo &b);

inline std::ostream& operator<<(std::ostream& out, const SkewedInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _StorageDescriptor__isset {
  _StorageDescriptor__isset() : cols(false), location(false), inputFormat(false), outputFormat(false), compressed(false), numBuckets(false), serdeInfo(false), bucketCols(false), sortCols(false), parameters(false), skewedInfo(false), storedAsSubDirectories(false) {}
  bool cols :1;
  bool location :1;
  bool inputFormat :1;
  bool outputFormat :1;
  bool compressed :1;
  bool numBuckets :1;
  bool serdeInfo :1;
  bool bucketCols :1;
  bool sortCols :1;
  bool parameters :1;
  bool skewedInfo :1;
  bool storedAsSubDirectories :1;
} _StorageDescriptor__isset;

class StorageDescriptor {
 public:

  StorageDescriptor(const StorageDescriptor&);
  StorageDescriptor& operator=(const StorageDescriptor&);
  StorageDescriptor() : location(), inputFormat(), outputFormat(), compressed(0), numBuckets(0), storedAsSubDirectories(0) {
  }

  virtual ~StorageDescriptor() throw();
  std::vector<FieldSchema>  cols;
  std::string location;
  std::string inputFormat;
  std::string outputFormat;
  bool compressed;
  int32_t numBuckets;
  SerDeInfo serdeInfo;
  std::vector<std::string>  bucketCols;
  std::vector<Order>  sortCols;
  std::map<std::string, std::string>  parameters;
  SkewedInfo skewedInfo;
  bool storedAsSubDirectories;

  _StorageDescriptor__isset __isset;

  void __set_cols(const std::vector<FieldSchema> & val);

  void __set_location(const std::string& val);

  void __set_inputFormat(const std::string& val);

  void __set_outputFormat(const std::string& val);

  void __set_compressed(const bool val);

  void __set_numBuckets(const int32_t val);

  void __set_serdeInfo(const SerDeInfo& val);

  void __set_bucketCols(const std::vector<std::string> & val);

  void __set_sortCols(const std::vector<Order> & val);

  void __set_parameters(const std::map<std::string, std::string> & val);

  void __set_skewedInfo(const SkewedInfo& val);

  void __set_storedAsSubDirectories(const bool val);

  bool operator == (const StorageDescriptor & rhs) const
  {
    if (!(cols == rhs.cols))
      return false;
    if (!(location == rhs.location))
      return false;
    if (!(inputFormat == rhs.inputFormat))
      return false;
    if (!(outputFormat == rhs.outputFormat))
      return false;
    if (!(compressed == rhs.compressed))
      return false;
    if (!(numBuckets == rhs.numBuckets))
      return false;
    if (!(serdeInfo == rhs.serdeInfo))
      return false;
    if (!(bucketCols == rhs.bucketCols))
      return false;
    if (!(sortCols == rhs.sortCols))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (__isset.skewedInfo != rhs.__isset.skewedInfo)
      return false;
    else if (__isset.skewedInfo && !(skewedInfo == rhs.skewedInfo))
      return false;
    if (__isset.storedAsSubDirectories != rhs.__isset.storedAsSubDirectories)
      return false;
    else if (__isset.storedAsSubDirectories && !(storedAsSubDirectories == rhs.storedAsSubDirectories))
      return false;
    return true;
  }
  bool operator != (const StorageDescriptor &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StorageDescriptor & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(StorageDescriptor &a, StorageDescriptor &b);

inline std::ostream& operator<<(std::ostream& out, const StorageDescriptor& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Table__isset {
  _Table__isset() : tableName(false), dbName(false), owner(false), createTime(false), lastAccessTime(false), retention(false), sd(false), partitionKeys(false), parameters(false), viewOriginalText(false), viewExpandedText(false), tableType(false), privileges(false), temporary(true), rewriteEnabled(false), creationMetadata(false), catName(false) {}
  bool tableName :1;
  bool dbName :1;
  bool owner :1;
  bool createTime :1;
  bool lastAccessTime :1;
  bool retention :1;
  bool sd :1;
  bool partitionKeys :1;
  bool parameters :1;
  bool viewOriginalText :1;
  bool viewExpandedText :1;
  bool tableType :1;
  bool privileges :1;
  bool temporary :1;
  bool rewriteEnabled :1;
  bool creationMetadata :1;
  bool catName :1;
} _Table__isset;

class Table {
 public:

  Table(const Table&);
  Table& operator=(const Table&);
  Table() : tableName(), dbName(), owner(), createTime(0), lastAccessTime(0), retention(0), viewOriginalText(), viewExpandedText(), tableType(), temporary(false), rewriteEnabled(0), catName() {
  }

  virtual ~Table() throw();
  std::string tableName;
  std::string dbName;
  std::string owner;
  int32_t createTime;
  int32_t lastAccessTime;
  int32_t retention;
  StorageDescriptor sd;
  std::vector<FieldSchema>  partitionKeys;
  std::map<std::string, std::string>  parameters;
  std::string viewOriginalText;
  std::string viewExpandedText;
  std::string tableType;
  PrincipalPrivilegeSet privileges;
  bool temporary;
  bool rewriteEnabled;
  CreationMetadata creationMetadata;
  std::string catName;

  _Table__isset __isset;

  void __set_tableName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_owner(const std::string& val);

  void __set_createTime(const int32_t val);

  void __set_lastAccessTime(const int32_t val);

  void __set_retention(const int32_t val);

  void __set_sd(const StorageDescriptor& val);

  void __set_partitionKeys(const std::vector<FieldSchema> & val);

  void __set_parameters(const std::map<std::string, std::string> & val);

  void __set_viewOriginalText(const std::string& val);

  void __set_viewExpandedText(const std::string& val);

  void __set_tableType(const std::string& val);

  void __set_privileges(const PrincipalPrivilegeSet& val);

  void __set_temporary(const bool val);

  void __set_rewriteEnabled(const bool val);

  void __set_creationMetadata(const CreationMetadata& val);

  void __set_catName(const std::string& val);

  bool operator == (const Table & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(owner == rhs.owner))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(lastAccessTime == rhs.lastAccessTime))
      return false;
    if (!(retention == rhs.retention))
      return false;
    if (!(sd == rhs.sd))
      return false;
    if (!(partitionKeys == rhs.partitionKeys))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (!(viewOriginalText == rhs.viewOriginalText))
      return false;
    if (!(viewExpandedText == rhs.viewExpandedText))
      return false;
    if (!(tableType == rhs.tableType))
      return false;
    if (__isset.privileges != rhs.__isset.privileges)
      return false;
    else if (__isset.privileges && !(privileges == rhs.privileges))
      return false;
    if (__isset.temporary != rhs.__isset.temporary)
      return false;
    else if (__isset.temporary && !(temporary == rhs.temporary))
      return false;
    if (__isset.rewriteEnabled != rhs.__isset.rewriteEnabled)
      return false;
    else if (__isset.rewriteEnabled && !(rewriteEnabled == rhs.rewriteEnabled))
      return false;
    if (__isset.creationMetadata != rhs.__isset.creationMetadata)
      return false;
    else if (__isset.creationMetadata && !(creationMetadata == rhs.creationMetadata))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const Table &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Table & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Table &a, Table &b);

inline std::ostream& operator<<(std::ostream& out, const Table& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Partition__isset {
  _Partition__isset() : values(false), dbName(false), tableName(false), createTime(false), lastAccessTime(false), sd(false), parameters(false), privileges(false), catName(false) {}
  bool values :1;
  bool dbName :1;
  bool tableName :1;
  bool createTime :1;
  bool lastAccessTime :1;
  bool sd :1;
  bool parameters :1;
  bool privileges :1;
  bool catName :1;
} _Partition__isset;

class Partition {
 public:

  Partition(const Partition&);
  Partition& operator=(const Partition&);
  Partition() : dbName(), tableName(), createTime(0), lastAccessTime(0), catName() {
  }

  virtual ~Partition() throw();
  std::vector<std::string>  values;
  std::string dbName;
  std::string tableName;
  int32_t createTime;
  int32_t lastAccessTime;
  StorageDescriptor sd;
  std::map<std::string, std::string>  parameters;
  PrincipalPrivilegeSet privileges;
  std::string catName;

  _Partition__isset __isset;

  void __set_values(const std::vector<std::string> & val);

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_createTime(const int32_t val);

  void __set_lastAccessTime(const int32_t val);

  void __set_sd(const StorageDescriptor& val);

  void __set_parameters(const std::map<std::string, std::string> & val);

  void __set_privileges(const PrincipalPrivilegeSet& val);

  void __set_catName(const std::string& val);

  bool operator == (const Partition & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(lastAccessTime == rhs.lastAccessTime))
      return false;
    if (!(sd == rhs.sd))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (__isset.privileges != rhs.__isset.privileges)
      return false;
    else if (__isset.privileges && !(privileges == rhs.privileges))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const Partition &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Partition & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Partition &a, Partition &b);

inline std::ostream& operator<<(std::ostream& out, const Partition& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _PartitionWithoutSD__isset {
  _PartitionWithoutSD__isset() : values(false), createTime(false), lastAccessTime(false), relativePath(false), parameters(false), privileges(false) {}
  bool values :1;
  bool createTime :1;
  bool lastAccessTime :1;
  bool relativePath :1;
  bool parameters :1;
  bool privileges :1;
} _PartitionWithoutSD__isset;

class PartitionWithoutSD {
 public:

  PartitionWithoutSD(const PartitionWithoutSD&);
  PartitionWithoutSD& operator=(const PartitionWithoutSD&);
  PartitionWithoutSD() : createTime(0), lastAccessTime(0), relativePath() {
  }

  virtual ~PartitionWithoutSD() throw();
  std::vector<std::string>  values;
  int32_t createTime;
  int32_t lastAccessTime;
  std::string relativePath;
  std::map<std::string, std::string>  parameters;
  PrincipalPrivilegeSet privileges;

  _PartitionWithoutSD__isset __isset;

  void __set_values(const std::vector<std::string> & val);

  void __set_createTime(const int32_t val);

  void __set_lastAccessTime(const int32_t val);

  void __set_relativePath(const std::string& val);

  void __set_parameters(const std::map<std::string, std::string> & val);

  void __set_privileges(const PrincipalPrivilegeSet& val);

  bool operator == (const PartitionWithoutSD & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(lastAccessTime == rhs.lastAccessTime))
      return false;
    if (!(relativePath == rhs.relativePath))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (__isset.privileges != rhs.__isset.privileges)
      return false;
    else if (__isset.privileges && !(privileges == rhs.privileges))
      return false;
    return true;
  }
  bool operator != (const PartitionWithoutSD &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionWithoutSD & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionWithoutSD &a, PartitionWithoutSD &b);

inline std::ostream& operator<<(std::ostream& out, const PartitionWithoutSD& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _PartitionSpecWithSharedSD__isset {
  _PartitionSpecWithSharedSD__isset() : partitions(false), sd(false) {}
  bool partitions :1;
  bool sd :1;
} _PartitionSpecWithSharedSD__isset;

class PartitionSpecWithSharedSD {
 public:

  PartitionSpecWithSharedSD(const PartitionSpecWithSharedSD&);
  PartitionSpecWithSharedSD& operator=(const PartitionSpecWithSharedSD&);
  PartitionSpecWithSharedSD() {
  }

  virtual ~PartitionSpecWithSharedSD() throw();
  std::vector<PartitionWithoutSD>  partitions;
  StorageDescriptor sd;

  _PartitionSpecWithSharedSD__isset __isset;

  void __set_partitions(const std::vector<PartitionWithoutSD> & val);

  void __set_sd(const StorageDescriptor& val);

  bool operator == (const PartitionSpecWithSharedSD & rhs) const
  {
    if (!(partitions == rhs.partitions))
      return false;
    if (!(sd == rhs.sd))
      return false;
    return true;
  }
  bool operator != (const PartitionSpecWithSharedSD &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionSpecWithSharedSD & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionSpecWithSharedSD &a, PartitionSpecWithSharedSD &b);

inline std::ostream& operator<<(std::ostream& out, const PartitionSpecWithSharedSD& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _PartitionListComposingSpec__isset {
  _PartitionListComposingSpec__isset() : partitions(false) {}
  bool partitions :1;
} _PartitionListComposingSpec__isset;

class PartitionListComposingSpec {
 public:

  PartitionListComposingSpec(const PartitionListComposingSpec&);
  PartitionListComposingSpec& operator=(const PartitionListComposingSpec&);
  PartitionListComposingSpec() {
  }

  virtual ~PartitionListComposingSpec() throw();
  std::vector<Partition>  partitions;

  _PartitionListComposingSpec__isset __isset;

  void __set_partitions(const std::vector<Partition> & val);

  bool operator == (const PartitionListComposingSpec & rhs) const
  {
    if (!(partitions == rhs.partitions))
      return false;
    return true;
  }
  bool operator != (const PartitionListComposingSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionListComposingSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionListComposingSpec &a, PartitionListComposingSpec &b);

inline std::ostream& operator<<(std::ostream& out, const PartitionListComposingSpec& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _PartitionSpec__isset {
  _PartitionSpec__isset() : dbName(false), tableName(false), rootPath(false), sharedSDPartitionSpec(false), partitionList(false), catName(false) {}
  bool dbName :1;
  bool tableName :1;
  bool rootPath :1;
  bool sharedSDPartitionSpec :1;
  bool partitionList :1;
  bool catName :1;
} _PartitionSpec__isset;

class PartitionSpec {
 public:

  PartitionSpec(const PartitionSpec&);
  PartitionSpec& operator=(const PartitionSpec&);
  PartitionSpec() : dbName(), tableName(), rootPath(), catName() {
  }

  virtual ~PartitionSpec() throw();
  std::string dbName;
  std::string tableName;
  std::string rootPath;
  PartitionSpecWithSharedSD sharedSDPartitionSpec;
  PartitionListComposingSpec partitionList;
  std::string catName;

  _PartitionSpec__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_rootPath(const std::string& val);

  void __set_sharedSDPartitionSpec(const PartitionSpecWithSharedSD& val);

  void __set_partitionList(const PartitionListComposingSpec& val);

  void __set_catName(const std::string& val);

  bool operator == (const PartitionSpec & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rootPath == rhs.rootPath))
      return false;
    if (__isset.sharedSDPartitionSpec != rhs.__isset.sharedSDPartitionSpec)
      return false;
    else if (__isset.sharedSDPartitionSpec && !(sharedSDPartitionSpec == rhs.sharedSDPartitionSpec))
      return false;
    if (__isset.partitionList != rhs.__isset.partitionList)
      return false;
    else if (__isset.partitionList && !(partitionList == rhs.partitionList))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const PartitionSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionSpec &a, PartitionSpec &b);

inline std::ostream& operator<<(std::ostream& out, const PartitionSpec& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _BooleanColumnStatsData__isset {
  _BooleanColumnStatsData__isset() : bitVectors(false) {}
  bool bitVectors :1;
} _BooleanColumnStatsData__isset;

class BooleanColumnStatsData {
 public:

  BooleanColumnStatsData(const BooleanColumnStatsData&);
  BooleanColumnStatsData& operator=(const BooleanColumnStatsData&);
  BooleanColumnStatsData() : numTrues(0), numFalses(0), numNulls(0), bitVectors() {
  }

  virtual ~BooleanColumnStatsData() throw();
  int64_t numTrues;
  int64_t numFalses;
  int64_t numNulls;
  std::string bitVectors;

  _BooleanColumnStatsData__isset __isset;

  void __set_numTrues(const int64_t val);

  void __set_numFalses(const int64_t val);

  void __set_numNulls(const int64_t val);

  void __set_bitVectors(const std::string& val);

  bool operator == (const BooleanColumnStatsData & rhs) const
  {
    if (!(numTrues == rhs.numTrues))
      return false;
    if (!(numFalses == rhs.numFalses))
      return false;
    if (!(numNulls == rhs.numNulls))
      return false;
    if (__isset.bitVectors != rhs.__isset.bitVectors)
      return false;
    else if (__isset.bitVectors && !(bitVectors == rhs.bitVectors))
      return false;
    return true;
  }
  bool operator != (const BooleanColumnStatsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BooleanColumnStatsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BooleanColumnStatsData &a, BooleanColumnStatsData &b);

inline std::ostream& operator<<(std::ostream& out, const BooleanColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DoubleColumnStatsData__isset {
  _DoubleColumnStatsData__isset() : lowValue(false), highValue(false), bitVectors(false) {}
  bool lowValue :1;
  bool highValue :1;
  bool bitVectors :1;
} _DoubleColumnStatsData__isset;

class DoubleColumnStatsData {
 public:

  DoubleColumnStatsData(const DoubleColumnStatsData&);
  DoubleColumnStatsData& operator=(const DoubleColumnStatsData&);
  DoubleColumnStatsData() : lowValue(0), highValue(0), numNulls(0), numDVs(0), bitVectors() {
  }

  virtual ~DoubleColumnStatsData() throw();
  double lowValue;
  double highValue;
  int64_t numNulls;
  int64_t numDVs;
  std::string bitVectors;

  _DoubleColumnStatsData__isset __isset;

  void __set_lowValue(const double val);

  void __set_highValue(const double val);

  void __set_numNulls(const int64_t val);

  void __set_numDVs(const int64_t val);

  void __set_bitVectors(const std::string& val);

  bool operator == (const DoubleColumnStatsData & rhs) const
  {
    if (__isset.lowValue != rhs.__isset.lowValue)
      return false;
    else if (__isset.lowValue && !(lowValue == rhs.lowValue))
      return false;
    if (__isset.highValue != rhs.__isset.highValue)
      return false;
    else if (__isset.highValue && !(highValue == rhs.highValue))
      return false;
    if (!(numNulls == rhs.numNulls))
      return false;
    if (!(numDVs == rhs.numDVs))
      return false;
    if (__isset.bitVectors != rhs.__isset.bitVectors)
      return false;
    else if (__isset.bitVectors && !(bitVectors == rhs.bitVectors))
      return false;
    return true;
  }
  bool operator != (const DoubleColumnStatsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DoubleColumnStatsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DoubleColumnStatsData &a, DoubleColumnStatsData &b);

inline std::ostream& operator<<(std::ostream& out, const DoubleColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _LongColumnStatsData__isset {
  _LongColumnStatsData__isset() : lowValue(false), highValue(false), bitVectors(false) {}
  bool lowValue :1;
  bool highValue :1;
  bool bitVectors :1;
} _LongColumnStatsData__isset;

class LongColumnStatsData {
 public:

  LongColumnStatsData(const LongColumnStatsData&);
  LongColumnStatsData& operator=(const LongColumnStatsData&);
  LongColumnStatsData() : lowValue(0), highValue(0), numNulls(0), numDVs(0), bitVectors() {
  }

  virtual ~LongColumnStatsData() throw();
  int64_t lowValue;
  int64_t highValue;
  int64_t numNulls;
  int64_t numDVs;
  std::string bitVectors;

  _LongColumnStatsData__isset __isset;

  void __set_lowValue(const int64_t val);

  void __set_highValue(const int64_t val);

  void __set_numNulls(const int64_t val);

  void __set_numDVs(const int64_t val);

  void __set_bitVectors(const std::string& val);

  bool operator == (const LongColumnStatsData & rhs) const
  {
    if (__isset.lowValue != rhs.__isset.lowValue)
      return false;
    else if (__isset.lowValue && !(lowValue == rhs.lowValue))
      return false;
    if (__isset.highValue != rhs.__isset.highValue)
      return false;
    else if (__isset.highValue && !(highValue == rhs.highValue))
      return false;
    if (!(numNulls == rhs.numNulls))
      return false;
    if (!(numDVs == rhs.numDVs))
      return false;
    if (__isset.bitVectors != rhs.__isset.bitVectors)
      return false;
    else if (__isset.bitVectors && !(bitVectors == rhs.bitVectors))
      return false;
    return true;
  }
  bool operator != (const LongColumnStatsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LongColumnStatsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LongColumnStatsData &a, LongColumnStatsData &b);

inline std::ostream& operator<<(std::ostream& out, const LongColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _StringColumnStatsData__isset {
  _StringColumnStatsData__isset() : bitVectors(false) {}
  bool bitVectors :1;
} _StringColumnStatsData__isset;

class StringColumnStatsData {
 public:

  StringColumnStatsData(const StringColumnStatsData&);
  StringColumnStatsData& operator=(const StringColumnStatsData&);
  StringColumnStatsData() : maxColLen(0), avgColLen(0), numNulls(0), numDVs(0), bitVectors() {
  }

  virtual ~StringColumnStatsData() throw();
  int64_t maxColLen;
  double avgColLen;
  int64_t numNulls;
  int64_t numDVs;
  std::string bitVectors;

  _StringColumnStatsData__isset __isset;

  void __set_maxColLen(const int64_t val);

  void __set_avgColLen(const double val);

  void __set_numNulls(const int64_t val);

  void __set_numDVs(const int64_t val);

  void __set_bitVectors(const std::string& val);

  bool operator == (const StringColumnStatsData & rhs) const
  {
    if (!(maxColLen == rhs.maxColLen))
      return false;
    if (!(avgColLen == rhs.avgColLen))
      return false;
    if (!(numNulls == rhs.numNulls))
      return false;
    if (!(numDVs == rhs.numDVs))
      return false;
    if (__isset.bitVectors != rhs.__isset.bitVectors)
      return false;
    else if (__isset.bitVectors && !(bitVectors == rhs.bitVectors))
      return false;
    return true;
  }
  bool operator != (const StringColumnStatsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StringColumnStatsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(StringColumnStatsData &a, StringColumnStatsData &b);

inline std::ostream& operator<<(std::ostream& out, const StringColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _BinaryColumnStatsData__isset {
  _BinaryColumnStatsData__isset() : bitVectors(false) {}
  bool bitVectors :1;
} _BinaryColumnStatsData__isset;

class BinaryColumnStatsData {
 public:

  BinaryColumnStatsData(const BinaryColumnStatsData&);
  BinaryColumnStatsData& operator=(const BinaryColumnStatsData&);
  BinaryColumnStatsData() : maxColLen(0), avgColLen(0), numNulls(0), bitVectors() {
  }

  virtual ~BinaryColumnStatsData() throw();
  int64_t maxColLen;
  double avgColLen;
  int64_t numNulls;
  std::string bitVectors;

  _BinaryColumnStatsData__isset __isset;

  void __set_maxColLen(const int64_t val);

  void __set_avgColLen(const double val);

  void __set_numNulls(const int64_t val);

  void __set_bitVectors(const std::string& val);

  bool operator == (const BinaryColumnStatsData & rhs) const
  {
    if (!(maxColLen == rhs.maxColLen))
      return false;
    if (!(avgColLen == rhs.avgColLen))
      return false;
    if (!(numNulls == rhs.numNulls))
      return false;
    if (__isset.bitVectors != rhs.__isset.bitVectors)
      return false;
    else if (__isset.bitVectors && !(bitVectors == rhs.bitVectors))
      return false;
    return true;
  }
  bool operator != (const BinaryColumnStatsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BinaryColumnStatsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BinaryColumnStatsData &a, BinaryColumnStatsData &b);

inline std::ostream& operator<<(std::ostream& out, const BinaryColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


class Decimal {
 public:

  Decimal(const Decimal&);
  Decimal& operator=(const Decimal&);
  Decimal() : unscaled(), scale(0) {
  }

  virtual ~Decimal() throw();
  std::string unscaled;
  int16_t scale;

  void __set_unscaled(const std::string& val);

  void __set_scale(const int16_t val);

  bool operator == (const Decimal & rhs) const
  {
    if (!(unscaled == rhs.unscaled))
      return false;
    if (!(scale == rhs.scale))
      return false;
    return true;
  }
  bool operator != (const Decimal &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Decimal & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Decimal &a, Decimal &b);

inline std::ostream& operator<<(std::ostream& out, const Decimal& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DecimalColumnStatsData__isset {
  _DecimalColumnStatsData__isset() : lowValue(false), highValue(false), bitVectors(false) {}
  bool lowValue :1;
  bool highValue :1;
  bool bitVectors :1;
} _DecimalColumnStatsData__isset;

class DecimalColumnStatsData {
 public:

  DecimalColumnStatsData(const DecimalColumnStatsData&);
  DecimalColumnStatsData& operator=(const DecimalColumnStatsData&);
  DecimalColumnStatsData() : numNulls(0), numDVs(0), bitVectors() {
  }

  virtual ~DecimalColumnStatsData() throw();
  Decimal lowValue;
  Decimal highValue;
  int64_t numNulls;
  int64_t numDVs;
  std::string bitVectors;

  _DecimalColumnStatsData__isset __isset;

  void __set_lowValue(const Decimal& val);

  void __set_highValue(const Decimal& val);

  void __set_numNulls(const int64_t val);

  void __set_numDVs(const int64_t val);

  void __set_bitVectors(const std::string& val);

  bool operator == (const DecimalColumnStatsData & rhs) const
  {
    if (__isset.lowValue != rhs.__isset.lowValue)
      return false;
    else if (__isset.lowValue && !(lowValue == rhs.lowValue))
      return false;
    if (__isset.highValue != rhs.__isset.highValue)
      return false;
    else if (__isset.highValue && !(highValue == rhs.highValue))
      return false;
    if (!(numNulls == rhs.numNulls))
      return false;
    if (!(numDVs == rhs.numDVs))
      return false;
    if (__isset.bitVectors != rhs.__isset.bitVectors)
      return false;
    else if (__isset.bitVectors && !(bitVectors == rhs.bitVectors))
      return false;
    return true;
  }
  bool operator != (const DecimalColumnStatsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DecimalColumnStatsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DecimalColumnStatsData &a, DecimalColumnStatsData &b);

inline std::ostream& operator<<(std::ostream& out, const DecimalColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


class Date {
 public:

  Date(const Date&);
  Date& operator=(const Date&);
  Date() : daysSinceEpoch(0) {
  }

  virtual ~Date() throw();
  int64_t daysSinceEpoch;

  void __set_daysSinceEpoch(const int64_t val);

  bool operator == (const Date & rhs) const
  {
    if (!(daysSinceEpoch == rhs.daysSinceEpoch))
      return false;
    return true;
  }
  bool operator != (const Date &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Date & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Date &a, Date &b);

inline std::ostream& operator<<(std::ostream& out, const Date& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DateColumnStatsData__isset {
  _DateColumnStatsData__isset() : lowValue(false), highValue(false), bitVectors(false) {}
  bool lowValue :1;
  bool highValue :1;
  bool bitVectors :1;
} _DateColumnStatsData__isset;

class DateColumnStatsData {
 public:

  DateColumnStatsData(const DateColumnStatsData&);
  DateColumnStatsData& operator=(const DateColumnStatsData&);
  DateColumnStatsData() : numNulls(0), numDVs(0), bitVectors() {
  }

  virtual ~DateColumnStatsData() throw();
  Date lowValue;
  Date highValue;
  int64_t numNulls;
  int64_t numDVs;
  std::string bitVectors;

  _DateColumnStatsData__isset __isset;

  void __set_lowValue(const Date& val);

  void __set_highValue(const Date& val);

  void __set_numNulls(const int64_t val);

  void __set_numDVs(const int64_t val);

  void __set_bitVectors(const std::string& val);

  bool operator == (const DateColumnStatsData & rhs) const
  {
    if (__isset.lowValue != rhs.__isset.lowValue)
      return false;
    else if (__isset.lowValue && !(lowValue == rhs.lowValue))
      return false;
    if (__isset.highValue != rhs.__isset.highValue)
      return false;
    else if (__isset.highValue && !(highValue == rhs.highValue))
      return false;
    if (!(numNulls == rhs.numNulls))
      return false;
    if (!(numDVs == rhs.numDVs))
      return false;
    if (__isset.bitVectors != rhs.__isset.bitVectors)
      return false;
    else if (__isset.bitVectors && !(bitVectors == rhs.bitVectors))
      return false;
    return true;
  }
  bool operator != (const DateColumnStatsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DateColumnStatsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DateColumnStatsData &a, DateColumnStatsData &b);

inline std::ostream& operator<<(std::ostream& out, const DateColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ColumnStatisticsData__isset {
  _ColumnStatisticsData__isset() : booleanStats(false), longStats(false), doubleStats(false), stringStats(false), binaryStats(false), decimalStats(false), dateStats(false) {}
  bool booleanStats :1;
  bool longStats :1;
  bool doubleStats :1;
  bool stringStats :1;
  bool binaryStats :1;
  bool decimalStats :1;
  bool dateStats :1;
} _ColumnStatisticsData__isset;

class ColumnStatisticsData {
 public:

  ColumnStatisticsData(const ColumnStatisticsData&);
  ColumnStatisticsData& operator=(const ColumnStatisticsData&);
  ColumnStatisticsData() {
  }

  virtual ~ColumnStatisticsData() throw();
  BooleanColumnStatsData booleanStats;
  LongColumnStatsData longStats;
  DoubleColumnStatsData doubleStats;
  StringColumnStatsData stringStats;
  BinaryColumnStatsData binaryStats;
  DecimalColumnStatsData decimalStats;
  DateColumnStatsData dateStats;

  _ColumnStatisticsData__isset __isset;

  void __set_booleanStats(const BooleanColumnStatsData& val);

  void __set_longStats(const LongColumnStatsData& val);

  void __set_doubleStats(const DoubleColumnStatsData& val);

  void __set_stringStats(const StringColumnStatsData& val);

  void __set_binaryStats(const BinaryColumnStatsData& val);

  void __set_decimalStats(const DecimalColumnStatsData& val);

  void __set_dateStats(const DateColumnStatsData& val);

  bool operator == (const ColumnStatisticsData & rhs) const
  {
    if (!(booleanStats == rhs.booleanStats))
      return false;
    if (!(longStats == rhs.longStats))
      return false;
    if (!(doubleStats == rhs.doubleStats))
      return false;
    if (!(stringStats == rhs.stringStats))
      return false;
    if (!(binaryStats == rhs.binaryStats))
      return false;
    if (!(decimalStats == rhs.decimalStats))
      return false;
    if (!(dateStats == rhs.dateStats))
      return false;
    return true;
  }
  bool operator != (const ColumnStatisticsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnStatisticsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ColumnStatisticsData &a, ColumnStatisticsData &b);

inline std::ostream& operator<<(std::ostream& out, const ColumnStatisticsData& obj)
{
  obj.printTo(out);
  return out;
}


class ColumnStatisticsObj {
 public:

  ColumnStatisticsObj(const ColumnStatisticsObj&);
  ColumnStatisticsObj& operator=(const ColumnStatisticsObj&);
  ColumnStatisticsObj() : colName(), colType() {
  }

  virtual ~ColumnStatisticsObj() throw();
  std::string colName;
  std::string colType;
  ColumnStatisticsData statsData;

  void __set_colName(const std::string& val);

  void __set_colType(const std::string& val);

  void __set_statsData(const ColumnStatisticsData& val);

  bool operator == (const ColumnStatisticsObj & rhs) const
  {
    if (!(colName == rhs.colName))
      return false;
    if (!(colType == rhs.colType))
      return false;
    if (!(statsData == rhs.statsData))
      return false;
    return true;
  }
  bool operator != (const ColumnStatisticsObj &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnStatisticsObj & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ColumnStatisticsObj &a, ColumnStatisticsObj &b);

inline std::ostream& operator<<(std::ostream& out, const ColumnStatisticsObj& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ColumnStatisticsDesc__isset {
  _ColumnStatisticsDesc__isset() : partName(false), lastAnalyzed(false), catName(false) {}
  bool partName :1;
  bool lastAnalyzed :1;
  bool catName :1;
} _ColumnStatisticsDesc__isset;

class ColumnStatisticsDesc {
 public:

  ColumnStatisticsDesc(const ColumnStatisticsDesc&);
  ColumnStatisticsDesc& operator=(const ColumnStatisticsDesc&);
  ColumnStatisticsDesc() : isTblLevel(0), dbName(), tableName(), partName(), lastAnalyzed(0), catName() {
  }

  virtual ~ColumnStatisticsDesc() throw();
  bool isTblLevel;
  std::string dbName;
  std::string tableName;
  std::string partName;
  int64_t lastAnalyzed;
  std::string catName;

  _ColumnStatisticsDesc__isset __isset;

  void __set_isTblLevel(const bool val);

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_partName(const std::string& val);

  void __set_lastAnalyzed(const int64_t val);

  void __set_catName(const std::string& val);

  bool operator == (const ColumnStatisticsDesc & rhs) const
  {
    if (!(isTblLevel == rhs.isTblLevel))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (__isset.partName != rhs.__isset.partName)
      return false;
    else if (__isset.partName && !(partName == rhs.partName))
      return false;
    if (__isset.lastAnalyzed != rhs.__isset.lastAnalyzed)
      return false;
    else if (__isset.lastAnalyzed && !(lastAnalyzed == rhs.lastAnalyzed))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const ColumnStatisticsDesc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnStatisticsDesc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ColumnStatisticsDesc &a, ColumnStatisticsDesc &b);

inline std::ostream& operator<<(std::ostream& out, const ColumnStatisticsDesc& obj)
{
  obj.printTo(out);
  return out;
}


class ColumnStatistics {
 public:

  ColumnStatistics(const ColumnStatistics&);
  ColumnStatistics& operator=(const ColumnStatistics&);
  ColumnStatistics() {
  }

  virtual ~ColumnStatistics() throw();
  ColumnStatisticsDesc statsDesc;
  std::vector<ColumnStatisticsObj>  statsObj;

  void __set_statsDesc(const ColumnStatisticsDesc& val);

  void __set_statsObj(const std::vector<ColumnStatisticsObj> & val);

  bool operator == (const ColumnStatistics & rhs) const
  {
    if (!(statsDesc == rhs.statsDesc))
      return false;
    if (!(statsObj == rhs.statsObj))
      return false;
    return true;
  }
  bool operator != (const ColumnStatistics &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnStatistics & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ColumnStatistics &a, ColumnStatistics &b);

inline std::ostream& operator<<(std::ostream& out, const ColumnStatistics& obj)
{
  obj.printTo(out);
  return out;
}


class AggrStats {
 public:

  AggrStats(const AggrStats&);
  AggrStats& operator=(const AggrStats&);
  AggrStats() : partsFound(0) {
  }

  virtual ~AggrStats() throw();
  std::vector<ColumnStatisticsObj>  colStats;
  int64_t partsFound;

  void __set_colStats(const std::vector<ColumnStatisticsObj> & val);

  void __set_partsFound(const int64_t val);

  bool operator == (const AggrStats & rhs) const
  {
    if (!(colStats == rhs.colStats))
      return false;
    if (!(partsFound == rhs.partsFound))
      return false;
    return true;
  }
  bool operator != (const AggrStats &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AggrStats & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AggrStats &a, AggrStats &b);

inline std::ostream& operator<<(std::ostream& out, const AggrStats& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SetPartitionsStatsRequest__isset {
  _SetPartitionsStatsRequest__isset() : needMerge(false) {}
  bool needMerge :1;
} _SetPartitionsStatsRequest__isset;

class SetPartitionsStatsRequest {
 public:

  SetPartitionsStatsRequest(const SetPartitionsStatsRequest&);
  SetPartitionsStatsRequest& operator=(const SetPartitionsStatsRequest&);
  SetPartitionsStatsRequest() : needMerge(0) {
  }

  virtual ~SetPartitionsStatsRequest() throw();
  std::vector<ColumnStatistics>  colStats;
  bool needMerge;

  _SetPartitionsStatsRequest__isset __isset;

  void __set_colStats(const std::vector<ColumnStatistics> & val);

  void __set_needMerge(const bool val);

  bool operator == (const SetPartitionsStatsRequest & rhs) const
  {
    if (!(colStats == rhs.colStats))
      return false;
    if (__isset.needMerge != rhs.__isset.needMerge)
      return false;
    else if (__isset.needMerge && !(needMerge == rhs.needMerge))
      return false;
    return true;
  }
  bool operator != (const SetPartitionsStatsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SetPartitionsStatsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SetPartitionsStatsRequest &a, SetPartitionsStatsRequest &b);

inline std::ostream& operator<<(std::ostream& out, const SetPartitionsStatsRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Schema__isset {
  _Schema__isset() : fieldSchemas(false), properties(false) {}
  bool fieldSchemas :1;
  bool properties :1;
} _Schema__isset;

class Schema {
 public:

  Schema(const Schema&);
  Schema& operator=(const Schema&);
  Schema() {
  }

  virtual ~Schema() throw();
  std::vector<FieldSchema>  fieldSchemas;
  std::map<std::string, std::string>  properties;

  _Schema__isset __isset;

  void __set_fieldSchemas(const std::vector<FieldSchema> & val);

  void __set_properties(const std::map<std::string, std::string> & val);

  bool operator == (const Schema & rhs) const
  {
    if (!(fieldSchemas == rhs.fieldSchemas))
      return false;
    if (!(properties == rhs.properties))
      return false;
    return true;
  }
  bool operator != (const Schema &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Schema & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Schema &a, Schema &b);

inline std::ostream& operator<<(std::ostream& out, const Schema& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _EnvironmentContext__isset {
  _EnvironmentContext__isset() : properties(false) {}
  bool properties :1;
} _EnvironmentContext__isset;

class EnvironmentContext {
 public:

  EnvironmentContext(const EnvironmentContext&);
  EnvironmentContext& operator=(const EnvironmentContext&);
  EnvironmentContext() {
  }

  virtual ~EnvironmentContext() throw();
  std::map<std::string, std::string>  properties;

  _EnvironmentContext__isset __isset;

  void __set_properties(const std::map<std::string, std::string> & val);

  bool operator == (const EnvironmentContext & rhs) const
  {
    if (!(properties == rhs.properties))
      return false;
    return true;
  }
  bool operator != (const EnvironmentContext &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const EnvironmentContext & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(EnvironmentContext &a, EnvironmentContext &b);

inline std::ostream& operator<<(std::ostream& out, const EnvironmentContext& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _PrimaryKeysRequest__isset {
  _PrimaryKeysRequest__isset() : catName(false) {}
  bool catName :1;
} _PrimaryKeysRequest__isset;

class PrimaryKeysRequest {
 public:

  PrimaryKeysRequest(const PrimaryKeysRequest&);
  PrimaryKeysRequest& operator=(const PrimaryKeysRequest&);
  PrimaryKeysRequest() : db_name(), tbl_name(), catName() {
  }

  virtual ~PrimaryKeysRequest() throw();
  std::string db_name;
  std::string tbl_name;
  std::string catName;

  _PrimaryKeysRequest__isset __isset;

  void __set_db_name(const std::string& val);

  void __set_tbl_name(const std::string& val);

  void __set_catName(const std::string& val);

  bool operator == (const PrimaryKeysRequest & rhs) const
  {
    if (!(db_name == rhs.db_name))
      return false;
    if (!(tbl_name == rhs.tbl_name))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const PrimaryKeysRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrimaryKeysRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PrimaryKeysRequest &a, PrimaryKeysRequest &b);

inline std::ostream& operator<<(std::ostream& out, const PrimaryKeysRequest& obj)
{
  obj.printTo(out);
  return out;
}


class PrimaryKeysResponse {
 public:

  PrimaryKeysResponse(const PrimaryKeysResponse&);
  PrimaryKeysResponse& operator=(const PrimaryKeysResponse&);
  PrimaryKeysResponse() {
  }

  virtual ~PrimaryKeysResponse() throw();
  std::vector<SQLPrimaryKey>  primaryKeys;

  void __set_primaryKeys(const std::vector<SQLPrimaryKey> & val);

  bool operator == (const PrimaryKeysResponse & rhs) const
  {
    if (!(primaryKeys == rhs.primaryKeys))
      return false;
    return true;
  }
  bool operator != (const PrimaryKeysResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrimaryKeysResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PrimaryKeysResponse &a, PrimaryKeysResponse &b);

inline std::ostream& operator<<(std::ostream& out, const PrimaryKeysResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ForeignKeysRequest__isset {
  _ForeignKeysRequest__isset() : parent_db_name(false), parent_tbl_name(false), foreign_db_name(false), foreign_tbl_name(false), catName(false) {}
  bool parent_db_name :1;
  bool parent_tbl_name :1;
  bool foreign_db_name :1;
  bool foreign_tbl_name :1;
  bool catName :1;
} _ForeignKeysRequest__isset;

class ForeignKeysRequest {
 public:

  ForeignKeysRequest(const ForeignKeysRequest&);
  ForeignKeysRequest& operator=(const ForeignKeysRequest&);
  ForeignKeysRequest() : parent_db_name(), parent_tbl_name(), foreign_db_name(), foreign_tbl_name(), catName() {
  }

  virtual ~ForeignKeysRequest() throw();
  std::string parent_db_name;
  std::string parent_tbl_name;
  std::string foreign_db_name;
  std::string foreign_tbl_name;
  std::string catName;

  _ForeignKeysRequest__isset __isset;

  void __set_parent_db_name(const std::string& val);

  void __set_parent_tbl_name(const std::string& val);

  void __set_foreign_db_name(const std::string& val);

  void __set_foreign_tbl_name(const std::string& val);

  void __set_catName(const std::string& val);

  bool operator == (const ForeignKeysRequest & rhs) const
  {
    if (!(parent_db_name == rhs.parent_db_name))
      return false;
    if (!(parent_tbl_name == rhs.parent_tbl_name))
      return false;
    if (!(foreign_db_name == rhs.foreign_db_name))
      return false;
    if (!(foreign_tbl_name == rhs.foreign_tbl_name))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const ForeignKeysRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ForeignKeysRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ForeignKeysRequest &a, ForeignKeysRequest &b);

inline std::ostream& operator<<(std::ostream& out, const ForeignKeysRequest& obj)
{
  obj.printTo(out);
  return out;
}


class ForeignKeysResponse {
 public:

  ForeignKeysResponse(const ForeignKeysResponse&);
  ForeignKeysResponse& operator=(const ForeignKeysResponse&);
  ForeignKeysResponse() {
  }

  virtual ~ForeignKeysResponse() throw();
  std::vector<SQLForeignKey>  foreignKeys;

  void __set_foreignKeys(const std::vector<SQLForeignKey> & val);

  bool operator == (const ForeignKeysResponse & rhs) const
  {
    if (!(foreignKeys == rhs.foreignKeys))
      return false;
    return true;
  }
  bool operator != (const ForeignKeysResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ForeignKeysResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ForeignKeysResponse &a, ForeignKeysResponse &b);

inline std::ostream& operator<<(std::ostream& out, const ForeignKeysResponse& obj)
{
  obj.printTo(out);
  return out;
}


class UniqueConstraintsRequest {
 public:

  UniqueConstraintsRequest(const UniqueConstraintsRequest&);
  UniqueConstraintsRequest& operator=(const UniqueConstraintsRequest&);
  UniqueConstraintsRequest() : catName(), db_name(), tbl_name() {
  }

  virtual ~UniqueConstraintsRequest() throw();
  std::string catName;
  std::string db_name;
  std::string tbl_name;

  void __set_catName(const std::string& val);

  void __set_db_name(const std::string& val);

  void __set_tbl_name(const std::string& val);

  bool operator == (const UniqueConstraintsRequest & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(db_name == rhs.db_name))
      return false;
    if (!(tbl_name == rhs.tbl_name))
      return false;
    return true;
  }
  bool operator != (const UniqueConstraintsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UniqueConstraintsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(UniqueConstraintsRequest &a, UniqueConstraintsRequest &b);

inline std::ostream& operator<<(std::ostream& out, const UniqueConstraintsRequest& obj)
{
  obj.printTo(out);
  return out;
}


class UniqueConstraintsResponse {
 public:

  UniqueConstraintsResponse(const UniqueConstraintsResponse&);
  UniqueConstraintsResponse& operator=(const UniqueConstraintsResponse&);
  UniqueConstraintsResponse() {
  }

  virtual ~UniqueConstraintsResponse() throw();
  std::vector<SQLUniqueConstraint>  uniqueConstraints;

  void __set_uniqueConstraints(const std::vector<SQLUniqueConstraint> & val);

  bool operator == (const UniqueConstraintsResponse & rhs) const
  {
    if (!(uniqueConstraints == rhs.uniqueConstraints))
      return false;
    return true;
  }
  bool operator != (const UniqueConstraintsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UniqueConstraintsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(UniqueConstraintsResponse &a, UniqueConstraintsResponse &b);

inline std::ostream& operator<<(std::ostream& out, const UniqueConstraintsResponse& obj)
{
  obj.printTo(out);
  return out;
}


class NotNullConstraintsRequest {
 public:

  NotNullConstraintsRequest(const NotNullConstraintsRequest&);
  NotNullConstraintsRequest& operator=(const NotNullConstraintsRequest&);
  NotNullConstraintsRequest() : catName(), db_name(), tbl_name() {
  }

  virtual ~NotNullConstraintsRequest() throw();
  std::string catName;
  std::string db_name;
  std::string tbl_name;

  void __set_catName(const std::string& val);

  void __set_db_name(const std::string& val);

  void __set_tbl_name(const std::string& val);

  bool operator == (const NotNullConstraintsRequest & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(db_name == rhs.db_name))
      return false;
    if (!(tbl_name == rhs.tbl_name))
      return false;
    return true;
  }
  bool operator != (const NotNullConstraintsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NotNullConstraintsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NotNullConstraintsRequest &a, NotNullConstraintsRequest &b);

inline std::ostream& operator<<(std::ostream& out, const NotNullConstraintsRequest& obj)
{
  obj.printTo(out);
  return out;
}


class NotNullConstraintsResponse {
 public:

  NotNullConstraintsResponse(const NotNullConstraintsResponse&);
  NotNullConstraintsResponse& operator=(const NotNullConstraintsResponse&);
  NotNullConstraintsResponse() {
  }

  virtual ~NotNullConstraintsResponse() throw();
  std::vector<SQLNotNullConstraint>  notNullConstraints;

  void __set_notNullConstraints(const std::vector<SQLNotNullConstraint> & val);

  bool operator == (const NotNullConstraintsResponse & rhs) const
  {
    if (!(notNullConstraints == rhs.notNullConstraints))
      return false;
    return true;
  }
  bool operator != (const NotNullConstraintsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NotNullConstraintsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NotNullConstraintsResponse &a, NotNullConstraintsResponse &b);

inline std::ostream& operator<<(std::ostream& out, const NotNullConstraintsResponse& obj)
{
  obj.printTo(out);
  return out;
}


class DefaultConstraintsRequest {
 public:

  DefaultConstraintsRequest(const DefaultConstraintsRequest&);
  DefaultConstraintsRequest& operator=(const DefaultConstraintsRequest&);
  DefaultConstraintsRequest() : catName(), db_name(), tbl_name() {
  }

  virtual ~DefaultConstraintsRequest() throw();
  std::string catName;
  std::string db_name;
  std::string tbl_name;

  void __set_catName(const std::string& val);

  void __set_db_name(const std::string& val);

  void __set_tbl_name(const std::string& val);

  bool operator == (const DefaultConstraintsRequest & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(db_name == rhs.db_name))
      return false;
    if (!(tbl_name == rhs.tbl_name))
      return false;
    return true;
  }
  bool operator != (const DefaultConstraintsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DefaultConstraintsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DefaultConstraintsRequest &a, DefaultConstraintsRequest &b);

inline std::ostream& operator<<(std::ostream& out, const DefaultConstraintsRequest& obj)
{
  obj.printTo(out);
  return out;
}


class DefaultConstraintsResponse {
 public:

  DefaultConstraintsResponse(const DefaultConstraintsResponse&);
  DefaultConstraintsResponse& operator=(const DefaultConstraintsResponse&);
  DefaultConstraintsResponse() {
  }

  virtual ~DefaultConstraintsResponse() throw();
  std::vector<SQLDefaultConstraint>  defaultConstraints;

  void __set_defaultConstraints(const std::vector<SQLDefaultConstraint> & val);

  bool operator == (const DefaultConstraintsResponse & rhs) const
  {
    if (!(defaultConstraints == rhs.defaultConstraints))
      return false;
    return true;
  }
  bool operator != (const DefaultConstraintsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DefaultConstraintsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DefaultConstraintsResponse &a, DefaultConstraintsResponse &b);

inline std::ostream& operator<<(std::ostream& out, const DefaultConstraintsResponse& obj)
{
  obj.printTo(out);
  return out;
}


class CheckConstraintsRequest {
 public:

  CheckConstraintsRequest(const CheckConstraintsRequest&);
  CheckConstraintsRequest& operator=(const CheckConstraintsRequest&);
  CheckConstraintsRequest() : catName(), db_name(), tbl_name() {
  }

  virtual ~CheckConstraintsRequest() throw();
  std::string catName;
  std::string db_name;
  std::string tbl_name;

  void __set_catName(const std::string& val);

  void __set_db_name(const std::string& val);

  void __set_tbl_name(const std::string& val);

  bool operator == (const CheckConstraintsRequest & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(db_name == rhs.db_name))
      return false;
    if (!(tbl_name == rhs.tbl_name))
      return false;
    return true;
  }
  bool operator != (const CheckConstraintsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CheckConstraintsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CheckConstraintsRequest &a, CheckConstraintsRequest &b);

inline std::ostream& operator<<(std::ostream& out, const CheckConstraintsRequest& obj)
{
  obj.printTo(out);
  return out;
}


class CheckConstraintsResponse {
 public:

  CheckConstraintsResponse(const CheckConstraintsResponse&);
  CheckConstraintsResponse& operator=(const CheckConstraintsResponse&);
  CheckConstraintsResponse() {
  }

  virtual ~CheckConstraintsResponse() throw();
  std::vector<SQLCheckConstraint>  checkConstraints;

  void __set_checkConstraints(const std::vector<SQLCheckConstraint> & val);

  bool operator == (const CheckConstraintsResponse & rhs) const
  {
    if (!(checkConstraints == rhs.checkConstraints))
      return false;
    return true;
  }
  bool operator != (const CheckConstraintsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CheckConstraintsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CheckConstraintsResponse &a, CheckConstraintsResponse &b);

inline std::ostream& operator<<(std::ostream& out, const CheckConstraintsResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DropConstraintRequest__isset {
  _DropConstraintRequest__isset() : catName(false) {}
  bool catName :1;
} _DropConstraintRequest__isset;

class DropConstraintRequest {
 public:

  DropConstraintRequest(const DropConstraintRequest&);
  DropConstraintRequest& operator=(const DropConstraintRequest&);
  DropConstraintRequest() : dbname(), tablename(), constraintname(), catName() {
  }

  virtual ~DropConstraintRequest() throw();
  std::string dbname;
  std::string tablename;
  std::string constraintname;
  std::string catName;

  _DropConstraintRequest__isset __isset;

  void __set_dbname(const std::string& val);

  void __set_tablename(const std::string& val);

  void __set_constraintname(const std::string& val);

  void __set_catName(const std::string& val);

  bool operator == (const DropConstraintRequest & rhs) const
  {
    if (!(dbname == rhs.dbname))
      return false;
    if (!(tablename == rhs.tablename))
      return false;
    if (!(constraintname == rhs.constraintname))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const DropConstraintRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DropConstraintRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DropConstraintRequest &a, DropConstraintRequest &b);

inline std::ostream& operator<<(std::ostream& out, const DropConstraintRequest& obj)
{
  obj.printTo(out);
  return out;
}


class AddPrimaryKeyRequest {
 public:

  AddPrimaryKeyRequest(const AddPrimaryKeyRequest&);
  AddPrimaryKeyRequest& operator=(const AddPrimaryKeyRequest&);
  AddPrimaryKeyRequest() {
  }

  virtual ~AddPrimaryKeyRequest() throw();
  std::vector<SQLPrimaryKey>  primaryKeyCols;

  void __set_primaryKeyCols(const std::vector<SQLPrimaryKey> & val);

  bool operator == (const AddPrimaryKeyRequest & rhs) const
  {
    if (!(primaryKeyCols == rhs.primaryKeyCols))
      return false;
    return true;
  }
  bool operator != (const AddPrimaryKeyRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddPrimaryKeyRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddPrimaryKeyRequest &a, AddPrimaryKeyRequest &b);

inline std::ostream& operator<<(std::ostream& out, const AddPrimaryKeyRequest& obj)
{
  obj.printTo(out);
  return out;
}


class AddForeignKeyRequest {
 public:

  AddForeignKeyRequest(const AddForeignKeyRequest&);
  AddForeignKeyRequest& operator=(const AddForeignKeyRequest&);
  AddForeignKeyRequest() {
  }

  virtual ~AddForeignKeyRequest() throw();
  std::vector<SQLForeignKey>  foreignKeyCols;

  void __set_foreignKeyCols(const std::vector<SQLForeignKey> & val);

  bool operator == (const AddForeignKeyRequest & rhs) const
  {
    if (!(foreignKeyCols == rhs.foreignKeyCols))
      return false;
    return true;
  }
  bool operator != (const AddForeignKeyRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddForeignKeyRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddForeignKeyRequest &a, AddForeignKeyRequest &b);

inline std::ostream& operator<<(std::ostream& out, const AddForeignKeyRequest& obj)
{
  obj.printTo(out);
  return out;
}


class AddUniqueConstraintRequest {
 public:

  AddUniqueConstraintRequest(const AddUniqueConstraintRequest&);
  AddUniqueConstraintRequest& operator=(const AddUniqueConstraintRequest&);
  AddUniqueConstraintRequest() {
  }

  virtual ~AddUniqueConstraintRequest() throw();
  std::vector<SQLUniqueConstraint>  uniqueConstraintCols;

  void __set_uniqueConstraintCols(const std::vector<SQLUniqueConstraint> & val);

  bool operator == (const AddUniqueConstraintRequest & rhs) const
  {
    if (!(uniqueConstraintCols == rhs.uniqueConstraintCols))
      return false;
    return true;
  }
  bool operator != (const AddUniqueConstraintRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddUniqueConstraintRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddUniqueConstraintRequest &a, AddUniqueConstraintRequest &b);

inline std::ostream& operator<<(std::ostream& out, const AddUniqueConstraintRequest& obj)
{
  obj.printTo(out);
  return out;
}


class AddNotNullConstraintRequest {
 public:

  AddNotNullConstraintRequest(const AddNotNullConstraintRequest&);
  AddNotNullConstraintRequest& operator=(const AddNotNullConstraintRequest&);
  AddNotNullConstraintRequest() {
  }

  virtual ~AddNotNullConstraintRequest() throw();
  std::vector<SQLNotNullConstraint>  notNullConstraintCols;

  void __set_notNullConstraintCols(const std::vector<SQLNotNullConstraint> & val);

  bool operator == (const AddNotNullConstraintRequest & rhs) const
  {
    if (!(notNullConstraintCols == rhs.notNullConstraintCols))
      return false;
    return true;
  }
  bool operator != (const AddNotNullConstraintRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddNotNullConstraintRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddNotNullConstraintRequest &a, AddNotNullConstraintRequest &b);

inline std::ostream& operator<<(std::ostream& out, const AddNotNullConstraintRequest& obj)
{
  obj.printTo(out);
  return out;
}


class AddDefaultConstraintRequest {
 public:

  AddDefaultConstraintRequest(const AddDefaultConstraintRequest&);
  AddDefaultConstraintRequest& operator=(const AddDefaultConstraintRequest&);
  AddDefaultConstraintRequest() {
  }

  virtual ~AddDefaultConstraintRequest() throw();
  std::vector<SQLDefaultConstraint>  defaultConstraintCols;

  void __set_defaultConstraintCols(const std::vector<SQLDefaultConstraint> & val);

  bool operator == (const AddDefaultConstraintRequest & rhs) const
  {
    if (!(defaultConstraintCols == rhs.defaultConstraintCols))
      return false;
    return true;
  }
  bool operator != (const AddDefaultConstraintRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddDefaultConstraintRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddDefaultConstraintRequest &a, AddDefaultConstraintRequest &b);

inline std::ostream& operator<<(std::ostream& out, const AddDefaultConstraintRequest& obj)
{
  obj.printTo(out);
  return out;
}


class AddCheckConstraintRequest {
 public:

  AddCheckConstraintRequest(const AddCheckConstraintRequest&);
  AddCheckConstraintRequest& operator=(const AddCheckConstraintRequest&);
  AddCheckConstraintRequest() {
  }

  virtual ~AddCheckConstraintRequest() throw();
  std::vector<SQLCheckConstraint>  checkConstraintCols;

  void __set_checkConstraintCols(const std::vector<SQLCheckConstraint> & val);

  bool operator == (const AddCheckConstraintRequest & rhs) const
  {
    if (!(checkConstraintCols == rhs.checkConstraintCols))
      return false;
    return true;
  }
  bool operator != (const AddCheckConstraintRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddCheckConstraintRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddCheckConstraintRequest &a, AddCheckConstraintRequest &b);

inline std::ostream& operator<<(std::ostream& out, const AddCheckConstraintRequest& obj)
{
  obj.printTo(out);
  return out;
}


class PartitionsByExprResult {
 public:

  PartitionsByExprResult(const PartitionsByExprResult&);
  PartitionsByExprResult& operator=(const PartitionsByExprResult&);
  PartitionsByExprResult() : hasUnknownPartitions(0) {
  }

  virtual ~PartitionsByExprResult() throw();
  std::vector<Partition>  partitions;
  bool hasUnknownPartitions;

  void __set_partitions(const std::vector<Partition> & val);

  void __set_hasUnknownPartitions(const bool val);

  bool operator == (const PartitionsByExprResult & rhs) const
  {
    if (!(partitions == rhs.partitions))
      return false;
    if (!(hasUnknownPartitions == rhs.hasUnknownPartitions))
      return false;
    return true;
  }
  bool operator != (const PartitionsByExprResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionsByExprResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionsByExprResult &a, PartitionsByExprResult &b);

inline std::ostream& operator<<(std::ostream& out, const PartitionsByExprResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _PartitionsByExprRequest__isset {
  _PartitionsByExprRequest__isset() : defaultPartitionName(false), maxParts(true), catName(false) {}
  bool defaultPartitionName :1;
  bool maxParts :1;
  bool catName :1;
} _PartitionsByExprRequest__isset;

class PartitionsByExprRequest {
 public:

  PartitionsByExprRequest(const PartitionsByExprRequest&);
  PartitionsByExprRequest& operator=(const PartitionsByExprRequest&);
  PartitionsByExprRequest() : dbName(), tblName(), expr(), defaultPartitionName(), maxParts(-1), catName() {
  }

  virtual ~PartitionsByExprRequest() throw();
  std::string dbName;
  std::string tblName;
  std::string expr;
  std::string defaultPartitionName;
  int16_t maxParts;
  std::string catName;

  _PartitionsByExprRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_expr(const std::string& val);

  void __set_defaultPartitionName(const std::string& val);

  void __set_maxParts(const int16_t val);

  void __set_catName(const std::string& val);

  bool operator == (const PartitionsByExprRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (!(expr == rhs.expr))
      return false;
    if (__isset.defaultPartitionName != rhs.__isset.defaultPartitionName)
      return false;
    else if (__isset.defaultPartitionName && !(defaultPartitionName == rhs.defaultPartitionName))
      return false;
    if (__isset.maxParts != rhs.__isset.maxParts)
      return false;
    else if (__isset.maxParts && !(maxParts == rhs.maxParts))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const PartitionsByExprRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionsByExprRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionsByExprRequest &a, PartitionsByExprRequest &b);

inline std::ostream& operator<<(std::ostream& out, const PartitionsByExprRequest& obj)
{
  obj.printTo(out);
  return out;
}


class TableStatsResult {
 public:

  TableStatsResult(const TableStatsResult&);
  TableStatsResult& operator=(const TableStatsResult&);
  TableStatsResult() {
  }

  virtual ~TableStatsResult() throw();
  std::vector<ColumnStatisticsObj>  tableStats;

  void __set_tableStats(const std::vector<ColumnStatisticsObj> & val);

  bool operator == (const TableStatsResult & rhs) const
  {
    if (!(tableStats == rhs.tableStats))
      return false;
    return true;
  }
  bool operator != (const TableStatsResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TableStatsResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TableStatsResult &a, TableStatsResult &b);

inline std::ostream& operator<<(std::ostream& out, const TableStatsResult& obj)
{
  obj.printTo(out);
  return out;
}


class PartitionsStatsResult {
 public:

  PartitionsStatsResult(const PartitionsStatsResult&);
  PartitionsStatsResult& operator=(const PartitionsStatsResult&);
  PartitionsStatsResult() {
  }

  virtual ~PartitionsStatsResult() throw();
  std::map<std::string, std::vector<ColumnStatisticsObj> >  partStats;

  void __set_partStats(const std::map<std::string, std::vector<ColumnStatisticsObj> > & val);

  bool operator == (const PartitionsStatsResult & rhs) const
  {
    if (!(partStats == rhs.partStats))
      return false;
    return true;
  }
  bool operator != (const PartitionsStatsResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionsStatsResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionsStatsResult &a, PartitionsStatsResult &b);

inline std::ostream& operator<<(std::ostream& out, const PartitionsStatsResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TableStatsRequest__isset {
  _TableStatsRequest__isset() : catName(false) {}
  bool catName :1;
} _TableStatsRequest__isset;

class TableStatsRequest {
 public:

  TableStatsRequest(const TableStatsRequest&);
  TableStatsRequest& operator=(const TableStatsRequest&);
  TableStatsRequest() : dbName(), tblName(), catName() {
  }

  virtual ~TableStatsRequest() throw();
  std::string dbName;
  std::string tblName;
  std::vector<std::string>  colNames;
  std::string catName;

  _TableStatsRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_colNames(const std::vector<std::string> & val);

  void __set_catName(const std::string& val);

  bool operator == (const TableStatsRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (!(colNames == rhs.colNames))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const TableStatsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TableStatsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TableStatsRequest &a, TableStatsRequest &b);

inline std::ostream& operator<<(std::ostream& out, const TableStatsRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _PartitionsStatsRequest__isset {
  _PartitionsStatsRequest__isset() : catName(false) {}
  bool catName :1;
} _PartitionsStatsRequest__isset;

class PartitionsStatsRequest {
 public:

  PartitionsStatsRequest(const PartitionsStatsRequest&);
  PartitionsStatsRequest& operator=(const PartitionsStatsRequest&);
  PartitionsStatsRequest() : dbName(), tblName(), catName() {
  }

  virtual ~PartitionsStatsRequest() throw();
  std::string dbName;
  std::string tblName;
  std::vector<std::string>  colNames;
  std::vector<std::string>  partNames;
  std::string catName;

  _PartitionsStatsRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_colNames(const std::vector<std::string> & val);

  void __set_partNames(const std::vector<std::string> & val);

  void __set_catName(const std::string& val);

  bool operator == (const PartitionsStatsRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (!(colNames == rhs.colNames))
      return false;
    if (!(partNames == rhs.partNames))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const PartitionsStatsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionsStatsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionsStatsRequest &a, PartitionsStatsRequest &b);

inline std::ostream& operator<<(std::ostream& out, const PartitionsStatsRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _AddPartitionsResult__isset {
  _AddPartitionsResult__isset() : partitions(false) {}
  bool partitions :1;
} _AddPartitionsResult__isset;

class AddPartitionsResult {
 public:

  AddPartitionsResult(const AddPartitionsResult&);
  AddPartitionsResult& operator=(const AddPartitionsResult&);
  AddPartitionsResult() {
  }

  virtual ~AddPartitionsResult() throw();
  std::vector<Partition>  partitions;

  _AddPartitionsResult__isset __isset;

  void __set_partitions(const std::vector<Partition> & val);

  bool operator == (const AddPartitionsResult & rhs) const
  {
    if (__isset.partitions != rhs.__isset.partitions)
      return false;
    else if (__isset.partitions && !(partitions == rhs.partitions))
      return false;
    return true;
  }
  bool operator != (const AddPartitionsResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddPartitionsResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddPartitionsResult &a, AddPartitionsResult &b);

inline std::ostream& operator<<(std::ostream& out, const AddPartitionsResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _AddPartitionsRequest__isset {
  _AddPartitionsRequest__isset() : needResult(true), catName(false) {}
  bool needResult :1;
  bool catName :1;
} _AddPartitionsRequest__isset;

class AddPartitionsRequest {
 public:

  AddPartitionsRequest(const AddPartitionsRequest&);
  AddPartitionsRequest& operator=(const AddPartitionsRequest&);
  AddPartitionsRequest() : dbName(), tblName(), ifNotExists(0), needResult(true), catName() {
  }

  virtual ~AddPartitionsRequest() throw();
  std::string dbName;
  std::string tblName;
  std::vector<Partition>  parts;
  bool ifNotExists;
  bool needResult;
  std::string catName;

  _AddPartitionsRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_parts(const std::vector<Partition> & val);

  void __set_ifNotExists(const bool val);

  void __set_needResult(const bool val);

  void __set_catName(const std::string& val);

  bool operator == (const AddPartitionsRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (!(parts == rhs.parts))
      return false;
    if (!(ifNotExists == rhs.ifNotExists))
      return false;
    if (__isset.needResult != rhs.__isset.needResult)
      return false;
    else if (__isset.needResult && !(needResult == rhs.needResult))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const AddPartitionsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddPartitionsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddPartitionsRequest &a, AddPartitionsRequest &b);

inline std::ostream& operator<<(std::ostream& out, const AddPartitionsRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DropPartitionsResult__isset {
  _DropPartitionsResult__isset() : partitions(false) {}
  bool partitions :1;
} _DropPartitionsResult__isset;

class DropPartitionsResult {
 public:

  DropPartitionsResult(const DropPartitionsResult&);
  DropPartitionsResult& operator=(const DropPartitionsResult&);
  DropPartitionsResult() {
  }

  virtual ~DropPartitionsResult() throw();
  std::vector<Partition>  partitions;

  _DropPartitionsResult__isset __isset;

  void __set_partitions(const std::vector<Partition> & val);

  bool operator == (const DropPartitionsResult & rhs) const
  {
    if (__isset.partitions != rhs.__isset.partitions)
      return false;
    else if (__isset.partitions && !(partitions == rhs.partitions))
      return false;
    return true;
  }
  bool operator != (const DropPartitionsResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DropPartitionsResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DropPartitionsResult &a, DropPartitionsResult &b);

inline std::ostream& operator<<(std::ostream& out, const DropPartitionsResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DropPartitionsExpr__isset {
  _DropPartitionsExpr__isset() : partArchiveLevel(false) {}
  bool partArchiveLevel :1;
} _DropPartitionsExpr__isset;

class DropPartitionsExpr {
 public:

  DropPartitionsExpr(const DropPartitionsExpr&);
  DropPartitionsExpr& operator=(const DropPartitionsExpr&);
  DropPartitionsExpr() : expr(), partArchiveLevel(0) {
  }

  virtual ~DropPartitionsExpr() throw();
  std::string expr;
  int32_t partArchiveLevel;

  _DropPartitionsExpr__isset __isset;

  void __set_expr(const std::string& val);

  void __set_partArchiveLevel(const int32_t val);

  bool operator == (const DropPartitionsExpr & rhs) const
  {
    if (!(expr == rhs.expr))
      return false;
    if (__isset.partArchiveLevel != rhs.__isset.partArchiveLevel)
      return false;
    else if (__isset.partArchiveLevel && !(partArchiveLevel == rhs.partArchiveLevel))
      return false;
    return true;
  }
  bool operator != (const DropPartitionsExpr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DropPartitionsExpr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DropPartitionsExpr &a, DropPartitionsExpr &b);

inline std::ostream& operator<<(std::ostream& out, const DropPartitionsExpr& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _RequestPartsSpec__isset {
  _RequestPartsSpec__isset() : names(false), exprs(false) {}
  bool names :1;
  bool exprs :1;
} _RequestPartsSpec__isset;

class RequestPartsSpec {
 public:

  RequestPartsSpec(const RequestPartsSpec&);
  RequestPartsSpec& operator=(const RequestPartsSpec&);
  RequestPartsSpec() {
  }

  virtual ~RequestPartsSpec() throw();
  std::vector<std::string>  names;
  std::vector<DropPartitionsExpr>  exprs;

  _RequestPartsSpec__isset __isset;

  void __set_names(const std::vector<std::string> & val);

  void __set_exprs(const std::vector<DropPartitionsExpr> & val);

  bool operator == (const RequestPartsSpec & rhs) const
  {
    if (!(names == rhs.names))
      return false;
    if (!(exprs == rhs.exprs))
      return false;
    return true;
  }
  bool operator != (const RequestPartsSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RequestPartsSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RequestPartsSpec &a, RequestPartsSpec &b);

inline std::ostream& operator<<(std::ostream& out, const RequestPartsSpec& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DropPartitionsRequest__isset {
  _DropPartitionsRequest__isset() : deleteData(false), ifExists(true), ignoreProtection(false), environmentContext(false), needResult(true), catName(false) {}
  bool deleteData :1;
  bool ifExists :1;
  bool ignoreProtection :1;
  bool environmentContext :1;
  bool needResult :1;
  bool catName :1;
} _DropPartitionsRequest__isset;

class DropPartitionsRequest {
 public:

  DropPartitionsRequest(const DropPartitionsRequest&);
  DropPartitionsRequest& operator=(const DropPartitionsRequest&);
  DropPartitionsRequest() : dbName(), tblName(), deleteData(0), ifExists(true), ignoreProtection(0), needResult(true), catName() {
  }

  virtual ~DropPartitionsRequest() throw();
  std::string dbName;
  std::string tblName;
  RequestPartsSpec parts;
  bool deleteData;
  bool ifExists;
  bool ignoreProtection;
  EnvironmentContext environmentContext;
  bool needResult;
  std::string catName;

  _DropPartitionsRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_parts(const RequestPartsSpec& val);

  void __set_deleteData(const bool val);

  void __set_ifExists(const bool val);

  void __set_ignoreProtection(const bool val);

  void __set_environmentContext(const EnvironmentContext& val);

  void __set_needResult(const bool val);

  void __set_catName(const std::string& val);

  bool operator == (const DropPartitionsRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (!(parts == rhs.parts))
      return false;
    if (__isset.deleteData != rhs.__isset.deleteData)
      return false;
    else if (__isset.deleteData && !(deleteData == rhs.deleteData))
      return false;
    if (__isset.ifExists != rhs.__isset.ifExists)
      return false;
    else if (__isset.ifExists && !(ifExists == rhs.ifExists))
      return false;
    if (__isset.ignoreProtection != rhs.__isset.ignoreProtection)
      return false;
    else if (__isset.ignoreProtection && !(ignoreProtection == rhs.ignoreProtection))
      return false;
    if (__isset.environmentContext != rhs.__isset.environmentContext)
      return false;
    else if (__isset.environmentContext && !(environmentContext == rhs.environmentContext))
      return false;
    if (__isset.needResult != rhs.__isset.needResult)
      return false;
    else if (__isset.needResult && !(needResult == rhs.needResult))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const DropPartitionsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DropPartitionsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DropPartitionsRequest &a, DropPartitionsRequest &b);

inline std::ostream& operator<<(std::ostream& out, const DropPartitionsRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _PartitionValuesRequest__isset {
  _PartitionValuesRequest__isset() : applyDistinct(true), filter(false), partitionOrder(false), ascending(true), maxParts(true), catName(false) {}
  bool applyDistinct :1;
  bool filter :1;
  bool partitionOrder :1;
  bool ascending :1;
  bool maxParts :1;
  bool catName :1;
} _PartitionValuesRequest__isset;

class PartitionValuesRequest {
 public:

  PartitionValuesRequest(const PartitionValuesRequest&);
  PartitionValuesRequest& operator=(const PartitionValuesRequest&);
  PartitionValuesRequest() : dbName(), tblName(), applyDistinct(true), filter(), ascending(true), maxParts(-1LL), catName() {
  }

  virtual ~PartitionValuesRequest() throw();
  std::string dbName;
  std::string tblName;
  std::vector<FieldSchema>  partitionKeys;
  bool applyDistinct;
  std::string filter;
  std::vector<FieldSchema>  partitionOrder;
  bool ascending;
  int64_t maxParts;
  std::string catName;

  _PartitionValuesRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_partitionKeys(const std::vector<FieldSchema> & val);

  void __set_applyDistinct(const bool val);

  void __set_filter(const std::string& val);

  void __set_partitionOrder(const std::vector<FieldSchema> & val);

  void __set_ascending(const bool val);

  void __set_maxParts(const int64_t val);

  void __set_catName(const std::string& val);

  bool operator == (const PartitionValuesRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (!(partitionKeys == rhs.partitionKeys))
      return false;
    if (__isset.applyDistinct != rhs.__isset.applyDistinct)
      return false;
    else if (__isset.applyDistinct && !(applyDistinct == rhs.applyDistinct))
      return false;
    if (__isset.filter != rhs.__isset.filter)
      return false;
    else if (__isset.filter && !(filter == rhs.filter))
      return false;
    if (__isset.partitionOrder != rhs.__isset.partitionOrder)
      return false;
    else if (__isset.partitionOrder && !(partitionOrder == rhs.partitionOrder))
      return false;
    if (__isset.ascending != rhs.__isset.ascending)
      return false;
    else if (__isset.ascending && !(ascending == rhs.ascending))
      return false;
    if (__isset.maxParts != rhs.__isset.maxParts)
      return false;
    else if (__isset.maxParts && !(maxParts == rhs.maxParts))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const PartitionValuesRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionValuesRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionValuesRequest &a, PartitionValuesRequest &b);

inline std::ostream& operator<<(std::ostream& out, const PartitionValuesRequest& obj)
{
  obj.printTo(out);
  return out;
}


class PartitionValuesRow {
 public:

  PartitionValuesRow(const PartitionValuesRow&);
  PartitionValuesRow& operator=(const PartitionValuesRow&);
  PartitionValuesRow() {
  }

  virtual ~PartitionValuesRow() throw();
  std::vector<std::string>  row;

  void __set_row(const std::vector<std::string> & val);

  bool operator == (const PartitionValuesRow & rhs) const
  {
    if (!(row == rhs.row))
      return false;
    return true;
  }
  bool operator != (const PartitionValuesRow &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionValuesRow & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionValuesRow &a, PartitionValuesRow &b);

inline std::ostream& operator<<(std::ostream& out, const PartitionValuesRow& obj)
{
  obj.printTo(out);
  return out;
}


class PartitionValuesResponse {
 public:

  PartitionValuesResponse(const PartitionValuesResponse&);
  PartitionValuesResponse& operator=(const PartitionValuesResponse&);
  PartitionValuesResponse() {
  }

  virtual ~PartitionValuesResponse() throw();
  std::vector<PartitionValuesRow>  partitionValues;

  void __set_partitionValues(const std::vector<PartitionValuesRow> & val);

  bool operator == (const PartitionValuesResponse & rhs) const
  {
    if (!(partitionValues == rhs.partitionValues))
      return false;
    return true;
  }
  bool operator != (const PartitionValuesResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionValuesResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionValuesResponse &a, PartitionValuesResponse &b);

inline std::ostream& operator<<(std::ostream& out, const PartitionValuesResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ResourceUri__isset {
  _ResourceUri__isset() : resourceType(false), uri(false) {}
  bool resourceType :1;
  bool uri :1;
} _ResourceUri__isset;

class ResourceUri {
 public:

  ResourceUri(const ResourceUri&);
  ResourceUri& operator=(const ResourceUri&);
  ResourceUri() : resourceType((ResourceType::type)0), uri() {
  }

  virtual ~ResourceUri() throw();
  ResourceType::type resourceType;
  std::string uri;

  _ResourceUri__isset __isset;

  void __set_resourceType(const ResourceType::type val);

  void __set_uri(const std::string& val);

  bool operator == (const ResourceUri & rhs) const
  {
    if (!(resourceType == rhs.resourceType))
      return false;
    if (!(uri == rhs.uri))
      return false;
    return true;
  }
  bool operator != (const ResourceUri &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ResourceUri & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ResourceUri &a, ResourceUri &b);

inline std::ostream& operator<<(std::ostream& out, const ResourceUri& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Function__isset {
  _Function__isset() : functionName(false), dbName(false), className(false), ownerName(false), ownerType(false), createTime(false), functionType(false), resourceUris(false), catName(false) {}
  bool functionName :1;
  bool dbName :1;
  bool className :1;
  bool ownerName :1;
  bool ownerType :1;
  bool createTime :1;
  bool functionType :1;
  bool resourceUris :1;
  bool catName :1;
} _Function__isset;

class Function {
 public:

  Function(const Function&);
  Function& operator=(const Function&);
  Function() : functionName(), dbName(), className(), ownerName(), ownerType((PrincipalType::type)0), createTime(0), functionType((FunctionType::type)0), catName() {
  }

  virtual ~Function() throw();
  std::string functionName;
  std::string dbName;
  std::string className;
  std::string ownerName;
  PrincipalType::type ownerType;
  int32_t createTime;
  FunctionType::type functionType;
  std::vector<ResourceUri>  resourceUris;
  std::string catName;

  _Function__isset __isset;

  void __set_functionName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_className(const std::string& val);

  void __set_ownerName(const std::string& val);

  void __set_ownerType(const PrincipalType::type val);

  void __set_createTime(const int32_t val);

  void __set_functionType(const FunctionType::type val);

  void __set_resourceUris(const std::vector<ResourceUri> & val);

  void __set_catName(const std::string& val);

  bool operator == (const Function & rhs) const
  {
    if (!(functionName == rhs.functionName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(className == rhs.className))
      return false;
    if (!(ownerName == rhs.ownerName))
      return false;
    if (!(ownerType == rhs.ownerType))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(functionType == rhs.functionType))
      return false;
    if (!(resourceUris == rhs.resourceUris))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const Function &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Function & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Function &a, Function &b);

inline std::ostream& operator<<(std::ostream& out, const Function& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TxnInfo__isset {
  _TxnInfo__isset() : agentInfo(true), heartbeatCount(true), metaInfo(false), startedTime(false), lastHeartbeatTime(false) {}
  bool agentInfo :1;
  bool heartbeatCount :1;
  bool metaInfo :1;
  bool startedTime :1;
  bool lastHeartbeatTime :1;
} _TxnInfo__isset;

class TxnInfo {
 public:

  TxnInfo(const TxnInfo&);
  TxnInfo& operator=(const TxnInfo&);
  TxnInfo() : id(0), state((TxnState::type)0), user(), hostname(), agentInfo("Unknown"), heartbeatCount(0), metaInfo(), startedTime(0), lastHeartbeatTime(0) {
  }

  virtual ~TxnInfo() throw();
  int64_t id;
  TxnState::type state;
  std::string user;
  std::string hostname;
  std::string agentInfo;
  int32_t heartbeatCount;
  std::string metaInfo;
  int64_t startedTime;
  int64_t lastHeartbeatTime;

  _TxnInfo__isset __isset;

  void __set_id(const int64_t val);

  void __set_state(const TxnState::type val);

  void __set_user(const std::string& val);

  void __set_hostname(const std::string& val);

  void __set_agentInfo(const std::string& val);

  void __set_heartbeatCount(const int32_t val);

  void __set_metaInfo(const std::string& val);

  void __set_startedTime(const int64_t val);

  void __set_lastHeartbeatTime(const int64_t val);

  bool operator == (const TxnInfo & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(hostname == rhs.hostname))
      return false;
    if (__isset.agentInfo != rhs.__isset.agentInfo)
      return false;
    else if (__isset.agentInfo && !(agentInfo == rhs.agentInfo))
      return false;
    if (__isset.heartbeatCount != rhs.__isset.heartbeatCount)
      return false;
    else if (__isset.heartbeatCount && !(heartbeatCount == rhs.heartbeatCount))
      return false;
    if (__isset.metaInfo != rhs.__isset.metaInfo)
      return false;
    else if (__isset.metaInfo && !(metaInfo == rhs.metaInfo))
      return false;
    if (__isset.startedTime != rhs.__isset.startedTime)
      return false;
    else if (__isset.startedTime && !(startedTime == rhs.startedTime))
      return false;
    if (__isset.lastHeartbeatTime != rhs.__isset.lastHeartbeatTime)
      return false;
    else if (__isset.lastHeartbeatTime && !(lastHeartbeatTime == rhs.lastHeartbeatTime))
      return false;
    return true;
  }
  bool operator != (const TxnInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TxnInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TxnInfo &a, TxnInfo &b);

inline std::ostream& operator<<(std::ostream& out, const TxnInfo& obj)
{
  obj.printTo(out);
  return out;
}


class GetOpenTxnsInfoResponse {
 public:

  GetOpenTxnsInfoResponse(const GetOpenTxnsInfoResponse&);
  GetOpenTxnsInfoResponse& operator=(const GetOpenTxnsInfoResponse&);
  GetOpenTxnsInfoResponse() : txn_high_water_mark(0) {
  }

  virtual ~GetOpenTxnsInfoResponse() throw();
  int64_t txn_high_water_mark;
  std::vector<TxnInfo>  open_txns;

  void __set_txn_high_water_mark(const int64_t val);

  void __set_open_txns(const std::vector<TxnInfo> & val);

  bool operator == (const GetOpenTxnsInfoResponse & rhs) const
  {
    if (!(txn_high_water_mark == rhs.txn_high_water_mark))
      return false;
    if (!(open_txns == rhs.open_txns))
      return false;
    return true;
  }
  bool operator != (const GetOpenTxnsInfoResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetOpenTxnsInfoResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetOpenTxnsInfoResponse &a, GetOpenTxnsInfoResponse &b);

inline std::ostream& operator<<(std::ostream& out, const GetOpenTxnsInfoResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GetOpenTxnsResponse__isset {
  _GetOpenTxnsResponse__isset() : min_open_txn(false) {}
  bool min_open_txn :1;
} _GetOpenTxnsResponse__isset;

class GetOpenTxnsResponse {
 public:

  GetOpenTxnsResponse(const GetOpenTxnsResponse&);
  GetOpenTxnsResponse& operator=(const GetOpenTxnsResponse&);
  GetOpenTxnsResponse() : txn_high_water_mark(0), min_open_txn(0), abortedBits() {
  }

  virtual ~GetOpenTxnsResponse() throw();
  int64_t txn_high_water_mark;
  std::vector<int64_t>  open_txns;
  int64_t min_open_txn;
  std::string abortedBits;

  _GetOpenTxnsResponse__isset __isset;

  void __set_txn_high_water_mark(const int64_t val);

  void __set_open_txns(const std::vector<int64_t> & val);

  void __set_min_open_txn(const int64_t val);

  void __set_abortedBits(const std::string& val);

  bool operator == (const GetOpenTxnsResponse & rhs) const
  {
    if (!(txn_high_water_mark == rhs.txn_high_water_mark))
      return false;
    if (!(open_txns == rhs.open_txns))
      return false;
    if (__isset.min_open_txn != rhs.__isset.min_open_txn)
      return false;
    else if (__isset.min_open_txn && !(min_open_txn == rhs.min_open_txn))
      return false;
    if (!(abortedBits == rhs.abortedBits))
      return false;
    return true;
  }
  bool operator != (const GetOpenTxnsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetOpenTxnsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetOpenTxnsResponse &a, GetOpenTxnsResponse &b);

inline std::ostream& operator<<(std::ostream& out, const GetOpenTxnsResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _OpenTxnRequest__isset {
  _OpenTxnRequest__isset() : agentInfo(true), replPolicy(false), replSrcTxnIds(false) {}
  bool agentInfo :1;
  bool replPolicy :1;
  bool replSrcTxnIds :1;
} _OpenTxnRequest__isset;

class OpenTxnRequest {
 public:

  OpenTxnRequest(const OpenTxnRequest&);
  OpenTxnRequest& operator=(const OpenTxnRequest&);
  OpenTxnRequest() : num_txns(0), user(), hostname(), agentInfo("Unknown"), replPolicy() {
  }

  virtual ~OpenTxnRequest() throw();
  int32_t num_txns;
  std::string user;
  std::string hostname;
  std::string agentInfo;
  std::string replPolicy;
  std::vector<int64_t>  replSrcTxnIds;

  _OpenTxnRequest__isset __isset;

  void __set_num_txns(const int32_t val);

  void __set_user(const std::string& val);

  void __set_hostname(const std::string& val);

  void __set_agentInfo(const std::string& val);

  void __set_replPolicy(const std::string& val);

  void __set_replSrcTxnIds(const std::vector<int64_t> & val);

  bool operator == (const OpenTxnRequest & rhs) const
  {
    if (!(num_txns == rhs.num_txns))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(hostname == rhs.hostname))
      return false;
    if (__isset.agentInfo != rhs.__isset.agentInfo)
      return false;
    else if (__isset.agentInfo && !(agentInfo == rhs.agentInfo))
      return false;
    if (__isset.replPolicy != rhs.__isset.replPolicy)
      return false;
    else if (__isset.replPolicy && !(replPolicy == rhs.replPolicy))
      return false;
    if (__isset.replSrcTxnIds != rhs.__isset.replSrcTxnIds)
      return false;
    else if (__isset.replSrcTxnIds && !(replSrcTxnIds == rhs.replSrcTxnIds))
      return false;
    return true;
  }
  bool operator != (const OpenTxnRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OpenTxnRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(OpenTxnRequest &a, OpenTxnRequest &b);

inline std::ostream& operator<<(std::ostream& out, const OpenTxnRequest& obj)
{
  obj.printTo(out);
  return out;
}


class OpenTxnsResponse {
 public:

  OpenTxnsResponse(const OpenTxnsResponse&);
  OpenTxnsResponse& operator=(const OpenTxnsResponse&);
  OpenTxnsResponse() {
  }

  virtual ~OpenTxnsResponse() throw();
  std::vector<int64_t>  txn_ids;

  void __set_txn_ids(const std::vector<int64_t> & val);

  bool operator == (const OpenTxnsResponse & rhs) const
  {
    if (!(txn_ids == rhs.txn_ids))
      return false;
    return true;
  }
  bool operator != (const OpenTxnsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OpenTxnsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(OpenTxnsResponse &a, OpenTxnsResponse &b);

inline std::ostream& operator<<(std::ostream& out, const OpenTxnsResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _AbortTxnRequest__isset {
  _AbortTxnRequest__isset() : replPolicy(false) {}
  bool replPolicy :1;
} _AbortTxnRequest__isset;

class AbortTxnRequest {
 public:

  AbortTxnRequest(const AbortTxnRequest&);
  AbortTxnRequest& operator=(const AbortTxnRequest&);
  AbortTxnRequest() : txnid(0), replPolicy() {
  }

  virtual ~AbortTxnRequest() throw();
  int64_t txnid;
  std::string replPolicy;

  _AbortTxnRequest__isset __isset;

  void __set_txnid(const int64_t val);

  void __set_replPolicy(const std::string& val);

  bool operator == (const AbortTxnRequest & rhs) const
  {
    if (!(txnid == rhs.txnid))
      return false;
    if (__isset.replPolicy != rhs.__isset.replPolicy)
      return false;
    else if (__isset.replPolicy && !(replPolicy == rhs.replPolicy))
      return false;
    return true;
  }
  bool operator != (const AbortTxnRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AbortTxnRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AbortTxnRequest &a, AbortTxnRequest &b);

inline std::ostream& operator<<(std::ostream& out, const AbortTxnRequest& obj)
{
  obj.printTo(out);
  return out;
}


class AbortTxnsRequest {
 public:

  AbortTxnsRequest(const AbortTxnsRequest&);
  AbortTxnsRequest& operator=(const AbortTxnsRequest&);
  AbortTxnsRequest() {
  }

  virtual ~AbortTxnsRequest() throw();
  std::vector<int64_t>  txn_ids;

  void __set_txn_ids(const std::vector<int64_t> & val);

  bool operator == (const AbortTxnsRequest & rhs) const
  {
    if (!(txn_ids == rhs.txn_ids))
      return false;
    return true;
  }
  bool operator != (const AbortTxnsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AbortTxnsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AbortTxnsRequest &a, AbortTxnsRequest &b);

inline std::ostream& operator<<(std::ostream& out, const AbortTxnsRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _CommitTxnRequest__isset {
  _CommitTxnRequest__isset() : replPolicy(false) {}
  bool replPolicy :1;
} _CommitTxnRequest__isset;

class CommitTxnRequest {
 public:

  CommitTxnRequest(const CommitTxnRequest&);
  CommitTxnRequest& operator=(const CommitTxnRequest&);
  CommitTxnRequest() : txnid(0), replPolicy() {
  }

  virtual ~CommitTxnRequest() throw();
  int64_t txnid;
  std::string replPolicy;

  _CommitTxnRequest__isset __isset;

  void __set_txnid(const int64_t val);

  void __set_replPolicy(const std::string& val);

  bool operator == (const CommitTxnRequest & rhs) const
  {
    if (!(txnid == rhs.txnid))
      return false;
    if (__isset.replPolicy != rhs.__isset.replPolicy)
      return false;
    else if (__isset.replPolicy && !(replPolicy == rhs.replPolicy))
      return false;
    return true;
  }
  bool operator != (const CommitTxnRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CommitTxnRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CommitTxnRequest &a, CommitTxnRequest &b);

inline std::ostream& operator<<(std::ostream& out, const CommitTxnRequest& obj)
{
  obj.printTo(out);
  return out;
}


class GetValidWriteIdsRequest {
 public:

  GetValidWriteIdsRequest(const GetValidWriteIdsRequest&);
  GetValidWriteIdsRequest& operator=(const GetValidWriteIdsRequest&);
  GetValidWriteIdsRequest() : validTxnList() {
  }

  virtual ~GetValidWriteIdsRequest() throw();
  std::vector<std::string>  fullTableNames;
  std::string validTxnList;

  void __set_fullTableNames(const std::vector<std::string> & val);

  void __set_validTxnList(const std::string& val);

  bool operator == (const GetValidWriteIdsRequest & rhs) const
  {
    if (!(fullTableNames == rhs.fullTableNames))
      return false;
    if (!(validTxnList == rhs.validTxnList))
      return false;
    return true;
  }
  bool operator != (const GetValidWriteIdsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetValidWriteIdsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetValidWriteIdsRequest &a, GetValidWriteIdsRequest &b);

inline std::ostream& operator<<(std::ostream& out, const GetValidWriteIdsRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TableValidWriteIds__isset {
  _TableValidWriteIds__isset() : minOpenWriteId(false) {}
  bool minOpenWriteId :1;
} _TableValidWriteIds__isset;

class TableValidWriteIds {
 public:

  TableValidWriteIds(const TableValidWriteIds&);
  TableValidWriteIds& operator=(const TableValidWriteIds&);
  TableValidWriteIds() : fullTableName(), writeIdHighWaterMark(0), minOpenWriteId(0), abortedBits() {
  }

  virtual ~TableValidWriteIds() throw();
  std::string fullTableName;
  int64_t writeIdHighWaterMark;
  std::vector<int64_t>  invalidWriteIds;
  int64_t minOpenWriteId;
  std::string abortedBits;

  _TableValidWriteIds__isset __isset;

  void __set_fullTableName(const std::string& val);

  void __set_writeIdHighWaterMark(const int64_t val);

  void __set_invalidWriteIds(const std::vector<int64_t> & val);

  void __set_minOpenWriteId(const int64_t val);

  void __set_abortedBits(const std::string& val);

  bool operator == (const TableValidWriteIds & rhs) const
  {
    if (!(fullTableName == rhs.fullTableName))
      return false;
    if (!(writeIdHighWaterMark == rhs.writeIdHighWaterMark))
      return false;
    if (!(invalidWriteIds == rhs.invalidWriteIds))
      return false;
    if (__isset.minOpenWriteId != rhs.__isset.minOpenWriteId)
      return false;
    else if (__isset.minOpenWriteId && !(minOpenWriteId == rhs.minOpenWriteId))
      return false;
    if (!(abortedBits == rhs.abortedBits))
      return false;
    return true;
  }
  bool operator != (const TableValidWriteIds &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TableValidWriteIds & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TableValidWriteIds &a, TableValidWriteIds &b);

inline std::ostream& operator<<(std::ostream& out, const TableValidWriteIds& obj)
{
  obj.printTo(out);
  return out;
}


class GetValidWriteIdsResponse {
 public:

  GetValidWriteIdsResponse(const GetValidWriteIdsResponse&);
  GetValidWriteIdsResponse& operator=(const GetValidWriteIdsResponse&);
  GetValidWriteIdsResponse() {
  }

  virtual ~GetValidWriteIdsResponse() throw();
  std::vector<TableValidWriteIds>  tblValidWriteIds;

  void __set_tblValidWriteIds(const std::vector<TableValidWriteIds> & val);

  bool operator == (const GetValidWriteIdsResponse & rhs) const
  {
    if (!(tblValidWriteIds == rhs.tblValidWriteIds))
      return false;
    return true;
  }
  bool operator != (const GetValidWriteIdsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetValidWriteIdsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetValidWriteIdsResponse &a, GetValidWriteIdsResponse &b);

inline std::ostream& operator<<(std::ostream& out, const GetValidWriteIdsResponse& obj)
{
  obj.printTo(out);
  return out;
}


class AllocateTableWriteIdsRequest {
 public:

  AllocateTableWriteIdsRequest(const AllocateTableWriteIdsRequest&);
  AllocateTableWriteIdsRequest& operator=(const AllocateTableWriteIdsRequest&);
  AllocateTableWriteIdsRequest() : dbName(), tableName() {
  }

  virtual ~AllocateTableWriteIdsRequest() throw();
  std::vector<int64_t>  txnIds;
  std::string dbName;
  std::string tableName;

  void __set_txnIds(const std::vector<int64_t> & val);

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  bool operator == (const AllocateTableWriteIdsRequest & rhs) const
  {
    if (!(txnIds == rhs.txnIds))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const AllocateTableWriteIdsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AllocateTableWriteIdsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AllocateTableWriteIdsRequest &a, AllocateTableWriteIdsRequest &b);

inline std::ostream& operator<<(std::ostream& out, const AllocateTableWriteIdsRequest& obj)
{
  obj.printTo(out);
  return out;
}


class TxnToWriteId {
 public:

  TxnToWriteId(const TxnToWriteId&);
  TxnToWriteId& operator=(const TxnToWriteId&);
  TxnToWriteId() : txnId(0), writeId(0) {
  }

  virtual ~TxnToWriteId() throw();
  int64_t txnId;
  int64_t writeId;

  void __set_txnId(const int64_t val);

  void __set_writeId(const int64_t val);

  bool operator == (const TxnToWriteId & rhs) const
  {
    if (!(txnId == rhs.txnId))
      return false;
    if (!(writeId == rhs.writeId))
      return false;
    return true;
  }
  bool operator != (const TxnToWriteId &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TxnToWriteId & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TxnToWriteId &a, TxnToWriteId &b);

inline std::ostream& operator<<(std::ostream& out, const TxnToWriteId& obj)
{
  obj.printTo(out);
  return out;
}


class AllocateTableWriteIdsResponse {
 public:

  AllocateTableWriteIdsResponse(const AllocateTableWriteIdsResponse&);
  AllocateTableWriteIdsResponse& operator=(const AllocateTableWriteIdsResponse&);
  AllocateTableWriteIdsResponse() {
  }

  virtual ~AllocateTableWriteIdsResponse() throw();
  std::vector<TxnToWriteId>  txnToWriteIds;

  void __set_txnToWriteIds(const std::vector<TxnToWriteId> & val);

  bool operator == (const AllocateTableWriteIdsResponse & rhs) const
  {
    if (!(txnToWriteIds == rhs.txnToWriteIds))
      return false;
    return true;
  }
  bool operator != (const AllocateTableWriteIdsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AllocateTableWriteIdsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AllocateTableWriteIdsResponse &a, AllocateTableWriteIdsResponse &b);

inline std::ostream& operator<<(std::ostream& out, const AllocateTableWriteIdsResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _LockComponent__isset {
  _LockComponent__isset() : tablename(false), partitionname(false), operationType(true), isTransactional(true), isDynamicPartitionWrite(true) {}
  bool tablename :1;
  bool partitionname :1;
  bool operationType :1;
  bool isTransactional :1;
  bool isDynamicPartitionWrite :1;
} _LockComponent__isset;

class LockComponent {
 public:

  LockComponent(const LockComponent&);
  LockComponent& operator=(const LockComponent&);
  LockComponent() : type((LockType::type)0), level((LockLevel::type)0), dbname(), tablename(), partitionname(), operationType((DataOperationType::type)5), isTransactional(false), isDynamicPartitionWrite(false) {
    operationType = (DataOperationType::type)5;

  }

  virtual ~LockComponent() throw();
  LockType::type type;
  LockLevel::type level;
  std::string dbname;
  std::string tablename;
  std::string partitionname;
  DataOperationType::type operationType;
  bool isTransactional;
  bool isDynamicPartitionWrite;

  _LockComponent__isset __isset;

  void __set_type(const LockType::type val);

  void __set_level(const LockLevel::type val);

  void __set_dbname(const std::string& val);

  void __set_tablename(const std::string& val);

  void __set_partitionname(const std::string& val);

  void __set_operationType(const DataOperationType::type val);

  void __set_isTransactional(const bool val);

  void __set_isDynamicPartitionWrite(const bool val);

  bool operator == (const LockComponent & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(level == rhs.level))
      return false;
    if (!(dbname == rhs.dbname))
      return false;
    if (__isset.tablename != rhs.__isset.tablename)
      return false;
    else if (__isset.tablename && !(tablename == rhs.tablename))
      return false;
    if (__isset.partitionname != rhs.__isset.partitionname)
      return false;
    else if (__isset.partitionname && !(partitionname == rhs.partitionname))
      return false;
    if (__isset.operationType != rhs.__isset.operationType)
      return false;
    else if (__isset.operationType && !(operationType == rhs.operationType))
      return false;
    if (__isset.isTransactional != rhs.__isset.isTransactional)
      return false;
    else if (__isset.isTransactional && !(isTransactional == rhs.isTransactional))
      return false;
    if (__isset.isDynamicPartitionWrite != rhs.__isset.isDynamicPartitionWrite)
      return false;
    else if (__isset.isDynamicPartitionWrite && !(isDynamicPartitionWrite == rhs.isDynamicPartitionWrite))
      return false;
    return true;
  }
  bool operator != (const LockComponent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LockComponent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LockComponent &a, LockComponent &b);

inline std::ostream& operator<<(std::ostream& out, const LockComponent& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _LockRequest__isset {
  _LockRequest__isset() : txnid(false), agentInfo(true) {}
  bool txnid :1;
  bool agentInfo :1;
} _LockRequest__isset;

class LockRequest {
 public:

  LockRequest(const LockRequest&);
  LockRequest& operator=(const LockRequest&);
  LockRequest() : txnid(0), user(), hostname(), agentInfo("Unknown") {
  }

  virtual ~LockRequest() throw();
  std::vector<LockComponent>  component;
  int64_t txnid;
  std::string user;
  std::string hostname;
  std::string agentInfo;

  _LockRequest__isset __isset;

  void __set_component(const std::vector<LockComponent> & val);

  void __set_txnid(const int64_t val);

  void __set_user(const std::string& val);

  void __set_hostname(const std::string& val);

  void __set_agentInfo(const std::string& val);

  bool operator == (const LockRequest & rhs) const
  {
    if (!(component == rhs.component))
      return false;
    if (__isset.txnid != rhs.__isset.txnid)
      return false;
    else if (__isset.txnid && !(txnid == rhs.txnid))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(hostname == rhs.hostname))
      return false;
    if (__isset.agentInfo != rhs.__isset.agentInfo)
      return false;
    else if (__isset.agentInfo && !(agentInfo == rhs.agentInfo))
      return false;
    return true;
  }
  bool operator != (const LockRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LockRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LockRequest &a, LockRequest &b);

inline std::ostream& operator<<(std::ostream& out, const LockRequest& obj)
{
  obj.printTo(out);
  return out;
}


class LockResponse {
 public:

  LockResponse(const LockResponse&);
  LockResponse& operator=(const LockResponse&);
  LockResponse() : lockid(0), state((LockState::type)0) {
  }

  virtual ~LockResponse() throw();
  int64_t lockid;
  LockState::type state;

  void __set_lockid(const int64_t val);

  void __set_state(const LockState::type val);

  bool operator == (const LockResponse & rhs) const
  {
    if (!(lockid == rhs.lockid))
      return false;
    if (!(state == rhs.state))
      return false;
    return true;
  }
  bool operator != (const LockResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LockResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LockResponse &a, LockResponse &b);

inline std::ostream& operator<<(std::ostream& out, const LockResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _CheckLockRequest__isset {
  _CheckLockRequest__isset() : txnid(false), elapsed_ms(false) {}
  bool txnid :1;
  bool elapsed_ms :1;
} _CheckLockRequest__isset;

class CheckLockRequest {
 public:

  CheckLockRequest(const CheckLockRequest&);
  CheckLockRequest& operator=(const CheckLockRequest&);
  CheckLockRequest() : lockid(0), txnid(0), elapsed_ms(0) {
  }

  virtual ~CheckLockRequest() throw();
  int64_t lockid;
  int64_t txnid;
  int64_t elapsed_ms;

  _CheckLockRequest__isset __isset;

  void __set_lockid(const int64_t val);

  void __set_txnid(const int64_t val);

  void __set_elapsed_ms(const int64_t val);

  bool operator == (const CheckLockRequest & rhs) const
  {
    if (!(lockid == rhs.lockid))
      return false;
    if (__isset.txnid != rhs.__isset.txnid)
      return false;
    else if (__isset.txnid && !(txnid == rhs.txnid))
      return false;
    if (__isset.elapsed_ms != rhs.__isset.elapsed_ms)
      return false;
    else if (__isset.elapsed_ms && !(elapsed_ms == rhs.elapsed_ms))
      return false;
    return true;
  }
  bool operator != (const CheckLockRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CheckLockRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CheckLockRequest &a, CheckLockRequest &b);

inline std::ostream& operator<<(std::ostream& out, const CheckLockRequest& obj)
{
  obj.printTo(out);
  return out;
}


class UnlockRequest {
 public:

  UnlockRequest(const UnlockRequest&);
  UnlockRequest& operator=(const UnlockRequest&);
  UnlockRequest() : lockid(0) {
  }

  virtual ~UnlockRequest() throw();
  int64_t lockid;

  void __set_lockid(const int64_t val);

  bool operator == (const UnlockRequest & rhs) const
  {
    if (!(lockid == rhs.lockid))
      return false;
    return true;
  }
  bool operator != (const UnlockRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnlockRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(UnlockRequest &a, UnlockRequest &b);

inline std::ostream& operator<<(std::ostream& out, const UnlockRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ShowLocksRequest__isset {
  _ShowLocksRequest__isset() : dbname(false), tablename(false), partname(false), isExtended(true) {}
  bool dbname :1;
  bool tablename :1;
  bool partname :1;
  bool isExtended :1;
} _ShowLocksRequest__isset;

class ShowLocksRequest {
 public:

  ShowLocksRequest(const ShowLocksRequest&);
  ShowLocksRequest& operator=(const ShowLocksRequest&);
  ShowLocksRequest() : dbname(), tablename(), partname(), isExtended(false) {
  }

  virtual ~ShowLocksRequest() throw();
  std::string dbname;
  std::string tablename;
  std::string partname;
  bool isExtended;

  _ShowLocksRequest__isset __isset;

  void __set_dbname(const std::string& val);

  void __set_tablename(const std::string& val);

  void __set_partname(const std::string& val);

  void __set_isExtended(const bool val);

  bool operator == (const ShowLocksRequest & rhs) const
  {
    if (__isset.dbname != rhs.__isset.dbname)
      return false;
    else if (__isset.dbname && !(dbname == rhs.dbname))
      return false;
    if (__isset.tablename != rhs.__isset.tablename)
      return false;
    else if (__isset.tablename && !(tablename == rhs.tablename))
      return false;
    if (__isset.partname != rhs.__isset.partname)
      return false;
    else if (__isset.partname && !(partname == rhs.partname))
      return false;
    if (__isset.isExtended != rhs.__isset.isExtended)
      return false;
    else if (__isset.isExtended && !(isExtended == rhs.isExtended))
      return false;
    return true;
  }
  bool operator != (const ShowLocksRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ShowLocksRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ShowLocksRequest &a, ShowLocksRequest &b);

inline std::ostream& operator<<(std::ostream& out, const ShowLocksRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ShowLocksResponseElement__isset {
  _ShowLocksResponseElement__isset() : tablename(false), partname(false), txnid(false), acquiredat(false), heartbeatCount(true), agentInfo(false), blockedByExtId(false), blockedByIntId(false), lockIdInternal(false) {}
  bool tablename :1;
  bool partname :1;
  bool txnid :1;
  bool acquiredat :1;
  bool heartbeatCount :1;
  bool agentInfo :1;
  bool blockedByExtId :1;
  bool blockedByIntId :1;
  bool lockIdInternal :1;
} _ShowLocksResponseElement__isset;

class ShowLocksResponseElement {
 public:

  ShowLocksResponseElement(const ShowLocksResponseElement&);
  ShowLocksResponseElement& operator=(const ShowLocksResponseElement&);
  ShowLocksResponseElement() : lockid(0), dbname(), tablename(), partname(), state((LockState::type)0), type((LockType::type)0), txnid(0), lastheartbeat(0), acquiredat(0), user(), hostname(), heartbeatCount(0), agentInfo(), blockedByExtId(0), blockedByIntId(0), lockIdInternal(0) {
  }

  virtual ~ShowLocksResponseElement() throw();
  int64_t lockid;
  std::string dbname;
  std::string tablename;
  std::string partname;
  LockState::type state;
  LockType::type type;
  int64_t txnid;
  int64_t lastheartbeat;
  int64_t acquiredat;
  std::string user;
  std::string hostname;
  int32_t heartbeatCount;
  std::string agentInfo;
  int64_t blockedByExtId;
  int64_t blockedByIntId;
  int64_t lockIdInternal;

  _ShowLocksResponseElement__isset __isset;

  void __set_lockid(const int64_t val);

  void __set_dbname(const std::string& val);

  void __set_tablename(const std::string& val);

  void __set_partname(const std::string& val);

  void __set_state(const LockState::type val);

  void __set_type(const LockType::type val);

  void __set_txnid(const int64_t val);

  void __set_lastheartbeat(const int64_t val);

  void __set_acquiredat(const int64_t val);

  void __set_user(const std::string& val);

  void __set_hostname(const std::string& val);

  void __set_heartbeatCount(const int32_t val);

  void __set_agentInfo(const std::string& val);

  void __set_blockedByExtId(const int64_t val);

  void __set_blockedByIntId(const int64_t val);

  void __set_lockIdInternal(const int64_t val);

  bool operator == (const ShowLocksResponseElement & rhs) const
  {
    if (!(lockid == rhs.lockid))
      return false;
    if (!(dbname == rhs.dbname))
      return false;
    if (__isset.tablename != rhs.__isset.tablename)
      return false;
    else if (__isset.tablename && !(tablename == rhs.tablename))
      return false;
    if (__isset.partname != rhs.__isset.partname)
      return false;
    else if (__isset.partname && !(partname == rhs.partname))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(type == rhs.type))
      return false;
    if (__isset.txnid != rhs.__isset.txnid)
      return false;
    else if (__isset.txnid && !(txnid == rhs.txnid))
      return false;
    if (!(lastheartbeat == rhs.lastheartbeat))
      return false;
    if (__isset.acquiredat != rhs.__isset.acquiredat)
      return false;
    else if (__isset.acquiredat && !(acquiredat == rhs.acquiredat))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(hostname == rhs.hostname))
      return false;
    if (__isset.heartbeatCount != rhs.__isset.heartbeatCount)
      return false;
    else if (__isset.heartbeatCount && !(heartbeatCount == rhs.heartbeatCount))
      return false;
    if (__isset.agentInfo != rhs.__isset.agentInfo)
      return false;
    else if (__isset.agentInfo && !(agentInfo == rhs.agentInfo))
      return false;
    if (__isset.blockedByExtId != rhs.__isset.blockedByExtId)
      return false;
    else if (__isset.blockedByExtId && !(blockedByExtId == rhs.blockedByExtId))
      return false;
    if (__isset.blockedByIntId != rhs.__isset.blockedByIntId)
      return false;
    else if (__isset.blockedByIntId && !(blockedByIntId == rhs.blockedByIntId))
      return false;
    if (__isset.lockIdInternal != rhs.__isset.lockIdInternal)
      return false;
    else if (__isset.lockIdInternal && !(lockIdInternal == rhs.lockIdInternal))
      return false;
    return true;
  }
  bool operator != (const ShowLocksResponseElement &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ShowLocksResponseElement & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ShowLocksResponseElement &a, ShowLocksResponseElement &b);

inline std::ostream& operator<<(std::ostream& out, const ShowLocksResponseElement& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ShowLocksResponse__isset {
  _ShowLocksResponse__isset() : locks(false) {}
  bool locks :1;
} _ShowLocksResponse__isset;

class ShowLocksResponse {
 public:

  ShowLocksResponse(const ShowLocksResponse&);
  ShowLocksResponse& operator=(const ShowLocksResponse&);
  ShowLocksResponse() {
  }

  virtual ~ShowLocksResponse() throw();
  std::vector<ShowLocksResponseElement>  locks;

  _ShowLocksResponse__isset __isset;

  void __set_locks(const std::vector<ShowLocksResponseElement> & val);

  bool operator == (const ShowLocksResponse & rhs) const
  {
    if (!(locks == rhs.locks))
      return false;
    return true;
  }
  bool operator != (const ShowLocksResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ShowLocksResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ShowLocksResponse &a, ShowLocksResponse &b);

inline std::ostream& operator<<(std::ostream& out, const ShowLocksResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _HeartbeatRequest__isset {
  _HeartbeatRequest__isset() : lockid(false), txnid(false) {}
  bool lockid :1;
  bool txnid :1;
} _HeartbeatRequest__isset;

class HeartbeatRequest {
 public:

  HeartbeatRequest(const HeartbeatRequest&);
  HeartbeatRequest& operator=(const HeartbeatRequest&);
  HeartbeatRequest() : lockid(0), txnid(0) {
  }

  virtual ~HeartbeatRequest() throw();
  int64_t lockid;
  int64_t txnid;

  _HeartbeatRequest__isset __isset;

  void __set_lockid(const int64_t val);

  void __set_txnid(const int64_t val);

  bool operator == (const HeartbeatRequest & rhs) const
  {
    if (__isset.lockid != rhs.__isset.lockid)
      return false;
    else if (__isset.lockid && !(lockid == rhs.lockid))
      return false;
    if (__isset.txnid != rhs.__isset.txnid)
      return false;
    else if (__isset.txnid && !(txnid == rhs.txnid))
      return false;
    return true;
  }
  bool operator != (const HeartbeatRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HeartbeatRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HeartbeatRequest &a, HeartbeatRequest &b);

inline std::ostream& operator<<(std::ostream& out, const HeartbeatRequest& obj)
{
  obj.printTo(out);
  return out;
}


class HeartbeatTxnRangeRequest {
 public:

  HeartbeatTxnRangeRequest(const HeartbeatTxnRangeRequest&);
  HeartbeatTxnRangeRequest& operator=(const HeartbeatTxnRangeRequest&);
  HeartbeatTxnRangeRequest() : min(0), max(0) {
  }

  virtual ~HeartbeatTxnRangeRequest() throw();
  int64_t min;
  int64_t max;

  void __set_min(const int64_t val);

  void __set_max(const int64_t val);

  bool operator == (const HeartbeatTxnRangeRequest & rhs) const
  {
    if (!(min == rhs.min))
      return false;
    if (!(max == rhs.max))
      return false;
    return true;
  }
  bool operator != (const HeartbeatTxnRangeRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HeartbeatTxnRangeRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HeartbeatTxnRangeRequest &a, HeartbeatTxnRangeRequest &b);

inline std::ostream& operator<<(std::ostream& out, const HeartbeatTxnRangeRequest& obj)
{
  obj.printTo(out);
  return out;
}


class HeartbeatTxnRangeResponse {
 public:

  HeartbeatTxnRangeResponse(const HeartbeatTxnRangeResponse&);
  HeartbeatTxnRangeResponse& operator=(const HeartbeatTxnRangeResponse&);
  HeartbeatTxnRangeResponse() {
  }

  virtual ~HeartbeatTxnRangeResponse() throw();
  std::set<int64_t>  aborted;
  std::set<int64_t>  nosuch;

  void __set_aborted(const std::set<int64_t> & val);

  void __set_nosuch(const std::set<int64_t> & val);

  bool operator == (const HeartbeatTxnRangeResponse & rhs) const
  {
    if (!(aborted == rhs.aborted))
      return false;
    if (!(nosuch == rhs.nosuch))
      return false;
    return true;
  }
  bool operator != (const HeartbeatTxnRangeResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HeartbeatTxnRangeResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HeartbeatTxnRangeResponse &a, HeartbeatTxnRangeResponse &b);

inline std::ostream& operator<<(std::ostream& out, const HeartbeatTxnRangeResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _CompactionRequest__isset {
  _CompactionRequest__isset() : partitionname(false), runas(false), properties(false) {}
  bool partitionname :1;
  bool runas :1;
  bool properties :1;
} _CompactionRequest__isset;

class CompactionRequest {
 public:

  CompactionRequest(const CompactionRequest&);
  CompactionRequest& operator=(const CompactionRequest&);
  CompactionRequest() : dbname(), tablename(), partitionname(), type((CompactionType::type)0), runas() {
  }

  virtual ~CompactionRequest() throw();
  std::string dbname;
  std::string tablename;
  std::string partitionname;
  CompactionType::type type;
  std::string runas;
  std::map<std::string, std::string>  properties;

  _CompactionRequest__isset __isset;

  void __set_dbname(const std::string& val);

  void __set_tablename(const std::string& val);

  void __set_partitionname(const std::string& val);

  void __set_type(const CompactionType::type val);

  void __set_runas(const std::string& val);

  void __set_properties(const std::map<std::string, std::string> & val);

  bool operator == (const CompactionRequest & rhs) const
  {
    if (!(dbname == rhs.dbname))
      return false;
    if (!(tablename == rhs.tablename))
      return false;
    if (__isset.partitionname != rhs.__isset.partitionname)
      return false;
    else if (__isset.partitionname && !(partitionname == rhs.partitionname))
      return false;
    if (!(type == rhs.type))
      return false;
    if (__isset.runas != rhs.__isset.runas)
      return false;
    else if (__isset.runas && !(runas == rhs.runas))
      return false;
    if (__isset.properties != rhs.__isset.properties)
      return false;
    else if (__isset.properties && !(properties == rhs.properties))
      return false;
    return true;
  }
  bool operator != (const CompactionRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CompactionRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CompactionRequest &a, CompactionRequest &b);

inline std::ostream& operator<<(std::ostream& out, const CompactionRequest& obj)
{
  obj.printTo(out);
  return out;
}


class CompactionResponse {
 public:

  CompactionResponse(const CompactionResponse&);
  CompactionResponse& operator=(const CompactionResponse&);
  CompactionResponse() : id(0), state(), accepted(0) {
  }

  virtual ~CompactionResponse() throw();
  int64_t id;
  std::string state;
  bool accepted;

  void __set_id(const int64_t val);

  void __set_state(const std::string& val);

  void __set_accepted(const bool val);

  bool operator == (const CompactionResponse & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(accepted == rhs.accepted))
      return false;
    return true;
  }
  bool operator != (const CompactionResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CompactionResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CompactionResponse &a, CompactionResponse &b);

inline std::ostream& operator<<(std::ostream& out, const CompactionResponse& obj)
{
  obj.printTo(out);
  return out;
}


class ShowCompactRequest {
 public:

  ShowCompactRequest(const ShowCompactRequest&);
  ShowCompactRequest& operator=(const ShowCompactRequest&);
  ShowCompactRequest() {
  }

  virtual ~ShowCompactRequest() throw();

  bool operator == (const ShowCompactRequest & /* rhs */) const
  {
    return true;
  }
  bool operator != (const ShowCompactRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ShowCompactRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ShowCompactRequest &a, ShowCompactRequest &b);

inline std::ostream& operator<<(std::ostream& out, const ShowCompactRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ShowCompactResponseElement__isset {
  _ShowCompactResponseElement__isset() : partitionname(false), workerid(false), start(false), runAs(false), hightestTxnId(false), metaInfo(false), endTime(false), hadoopJobId(true), id(false) {}
  bool partitionname :1;
  bool workerid :1;
  bool start :1;
  bool runAs :1;
  bool hightestTxnId :1;
  bool metaInfo :1;
  bool endTime :1;
  bool hadoopJobId :1;
  bool id :1;
} _ShowCompactResponseElement__isset;

class ShowCompactResponseElement {
 public:

  ShowCompactResponseElement(const ShowCompactResponseElement&);
  ShowCompactResponseElement& operator=(const ShowCompactResponseElement&);
  ShowCompactResponseElement() : dbname(), tablename(), partitionname(), type((CompactionType::type)0), state(), workerid(), start(0), runAs(), hightestTxnId(0), metaInfo(), endTime(0), hadoopJobId("None"), id(0) {
  }

  virtual ~ShowCompactResponseElement() throw();
  std::string dbname;
  std::string tablename;
  std::string partitionname;
  CompactionType::type type;
  std::string state;
  std::string workerid;
  int64_t start;
  std::string runAs;
  int64_t hightestTxnId;
  std::string metaInfo;
  int64_t endTime;
  std::string hadoopJobId;
  int64_t id;

  _ShowCompactResponseElement__isset __isset;

  void __set_dbname(const std::string& val);

  void __set_tablename(const std::string& val);

  void __set_partitionname(const std::string& val);

  void __set_type(const CompactionType::type val);

  void __set_state(const std::string& val);

  void __set_workerid(const std::string& val);

  void __set_start(const int64_t val);

  void __set_runAs(const std::string& val);

  void __set_hightestTxnId(const int64_t val);

  void __set_metaInfo(const std::string& val);

  void __set_endTime(const int64_t val);

  void __set_hadoopJobId(const std::string& val);

  void __set_id(const int64_t val);

  bool operator == (const ShowCompactResponseElement & rhs) const
  {
    if (!(dbname == rhs.dbname))
      return false;
    if (!(tablename == rhs.tablename))
      return false;
    if (__isset.partitionname != rhs.__isset.partitionname)
      return false;
    else if (__isset.partitionname && !(partitionname == rhs.partitionname))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(state == rhs.state))
      return false;
    if (__isset.workerid != rhs.__isset.workerid)
      return false;
    else if (__isset.workerid && !(workerid == rhs.workerid))
      return false;
    if (__isset.start != rhs.__isset.start)
      return false;
    else if (__isset.start && !(start == rhs.start))
      return false;
    if (__isset.runAs != rhs.__isset.runAs)
      return false;
    else if (__isset.runAs && !(runAs == rhs.runAs))
      return false;
    if (__isset.hightestTxnId != rhs.__isset.hightestTxnId)
      return false;
    else if (__isset.hightestTxnId && !(hightestTxnId == rhs.hightestTxnId))
      return false;
    if (__isset.metaInfo != rhs.__isset.metaInfo)
      return false;
    else if (__isset.metaInfo && !(metaInfo == rhs.metaInfo))
      return false;
    if (__isset.endTime != rhs.__isset.endTime)
      return false;
    else if (__isset.endTime && !(endTime == rhs.endTime))
      return false;
    if (__isset.hadoopJobId != rhs.__isset.hadoopJobId)
      return false;
    else if (__isset.hadoopJobId && !(hadoopJobId == rhs.hadoopJobId))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const ShowCompactResponseElement &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ShowCompactResponseElement & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ShowCompactResponseElement &a, ShowCompactResponseElement &b);

inline std::ostream& operator<<(std::ostream& out, const ShowCompactResponseElement& obj)
{
  obj.printTo(out);
  return out;
}


class ShowCompactResponse {
 public:

  ShowCompactResponse(const ShowCompactResponse&);
  ShowCompactResponse& operator=(const ShowCompactResponse&);
  ShowCompactResponse() {
  }

  virtual ~ShowCompactResponse() throw();
  std::vector<ShowCompactResponseElement>  compacts;

  void __set_compacts(const std::vector<ShowCompactResponseElement> & val);

  bool operator == (const ShowCompactResponse & rhs) const
  {
    if (!(compacts == rhs.compacts))
      return false;
    return true;
  }
  bool operator != (const ShowCompactResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ShowCompactResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ShowCompactResponse &a, ShowCompactResponse &b);

inline std::ostream& operator<<(std::ostream& out, const ShowCompactResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _AddDynamicPartitions__isset {
  _AddDynamicPartitions__isset() : operationType(true) {}
  bool operationType :1;
} _AddDynamicPartitions__isset;

class AddDynamicPartitions {
 public:

  AddDynamicPartitions(const AddDynamicPartitions&);
  AddDynamicPartitions& operator=(const AddDynamicPartitions&);
  AddDynamicPartitions() : txnid(0), writeid(0), dbname(), tablename(), operationType((DataOperationType::type)5) {
    operationType = (DataOperationType::type)5;

  }

  virtual ~AddDynamicPartitions() throw();
  int64_t txnid;
  int64_t writeid;
  std::string dbname;
  std::string tablename;
  std::vector<std::string>  partitionnames;
  DataOperationType::type operationType;

  _AddDynamicPartitions__isset __isset;

  void __set_txnid(const int64_t val);

  void __set_writeid(const int64_t val);

  void __set_dbname(const std::string& val);

  void __set_tablename(const std::string& val);

  void __set_partitionnames(const std::vector<std::string> & val);

  void __set_operationType(const DataOperationType::type val);

  bool operator == (const AddDynamicPartitions & rhs) const
  {
    if (!(txnid == rhs.txnid))
      return false;
    if (!(writeid == rhs.writeid))
      return false;
    if (!(dbname == rhs.dbname))
      return false;
    if (!(tablename == rhs.tablename))
      return false;
    if (!(partitionnames == rhs.partitionnames))
      return false;
    if (__isset.operationType != rhs.__isset.operationType)
      return false;
    else if (__isset.operationType && !(operationType == rhs.operationType))
      return false;
    return true;
  }
  bool operator != (const AddDynamicPartitions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddDynamicPartitions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddDynamicPartitions &a, AddDynamicPartitions &b);

inline std::ostream& operator<<(std::ostream& out, const AddDynamicPartitions& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _BasicTxnInfo__isset {
  _BasicTxnInfo__isset() : time(false), txnid(false), dbname(false), tablename(false), partitionname(false) {}
  bool time :1;
  bool txnid :1;
  bool dbname :1;
  bool tablename :1;
  bool partitionname :1;
} _BasicTxnInfo__isset;

class BasicTxnInfo {
 public:

  BasicTxnInfo(const BasicTxnInfo&);
  BasicTxnInfo& operator=(const BasicTxnInfo&);
  BasicTxnInfo() : isnull(0), time(0), txnid(0), dbname(), tablename(), partitionname() {
  }

  virtual ~BasicTxnInfo() throw();
  bool isnull;
  int64_t time;
  int64_t txnid;
  std::string dbname;
  std::string tablename;
  std::string partitionname;

  _BasicTxnInfo__isset __isset;

  void __set_isnull(const bool val);

  void __set_time(const int64_t val);

  void __set_txnid(const int64_t val);

  void __set_dbname(const std::string& val);

  void __set_tablename(const std::string& val);

  void __set_partitionname(const std::string& val);

  bool operator == (const BasicTxnInfo & rhs) const
  {
    if (!(isnull == rhs.isnull))
      return false;
    if (__isset.time != rhs.__isset.time)
      return false;
    else if (__isset.time && !(time == rhs.time))
      return false;
    if (__isset.txnid != rhs.__isset.txnid)
      return false;
    else if (__isset.txnid && !(txnid == rhs.txnid))
      return false;
    if (__isset.dbname != rhs.__isset.dbname)
      return false;
    else if (__isset.dbname && !(dbname == rhs.dbname))
      return false;
    if (__isset.tablename != rhs.__isset.tablename)
      return false;
    else if (__isset.tablename && !(tablename == rhs.tablename))
      return false;
    if (__isset.partitionname != rhs.__isset.partitionname)
      return false;
    else if (__isset.partitionname && !(partitionname == rhs.partitionname))
      return false;
    return true;
  }
  bool operator != (const BasicTxnInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BasicTxnInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BasicTxnInfo &a, BasicTxnInfo &b);

inline std::ostream& operator<<(std::ostream& out, const BasicTxnInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _CreationMetadata__isset {
  _CreationMetadata__isset() : validTxnList(false) {}
  bool validTxnList :1;
} _CreationMetadata__isset;

class CreationMetadata {
 public:

  CreationMetadata(const CreationMetadata&);
  CreationMetadata& operator=(const CreationMetadata&);
  CreationMetadata() : catName(), dbName(), tblName(), validTxnList() {
  }

  virtual ~CreationMetadata() throw();
  std::string catName;
  std::string dbName;
  std::string tblName;
  std::set<std::string>  tablesUsed;
  std::string validTxnList;

  _CreationMetadata__isset __isset;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_tablesUsed(const std::set<std::string> & val);

  void __set_validTxnList(const std::string& val);

  bool operator == (const CreationMetadata & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (!(tablesUsed == rhs.tablesUsed))
      return false;
    if (__isset.validTxnList != rhs.__isset.validTxnList)
      return false;
    else if (__isset.validTxnList && !(validTxnList == rhs.validTxnList))
      return false;
    return true;
  }
  bool operator != (const CreationMetadata &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CreationMetadata & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CreationMetadata &a, CreationMetadata &b);

inline std::ostream& operator<<(std::ostream& out, const CreationMetadata& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NotificationEventRequest__isset {
  _NotificationEventRequest__isset() : maxEvents(false) {}
  bool maxEvents :1;
} _NotificationEventRequest__isset;

class NotificationEventRequest {
 public:

  NotificationEventRequest(const NotificationEventRequest&);
  NotificationEventRequest& operator=(const NotificationEventRequest&);
  NotificationEventRequest() : lastEvent(0), maxEvents(0) {
  }

  virtual ~NotificationEventRequest() throw();
  int64_t lastEvent;
  int32_t maxEvents;

  _NotificationEventRequest__isset __isset;

  void __set_lastEvent(const int64_t val);

  void __set_maxEvents(const int32_t val);

  bool operator == (const NotificationEventRequest & rhs) const
  {
    if (!(lastEvent == rhs.lastEvent))
      return false;
    if (__isset.maxEvents != rhs.__isset.maxEvents)
      return false;
    else if (__isset.maxEvents && !(maxEvents == rhs.maxEvents))
      return false;
    return true;
  }
  bool operator != (const NotificationEventRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NotificationEventRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NotificationEventRequest &a, NotificationEventRequest &b);

inline std::ostream& operator<<(std::ostream& out, const NotificationEventRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NotificationEvent__isset {
  _NotificationEvent__isset() : dbName(false), tableName(false), messageFormat(false), catName(false) {}
  bool dbName :1;
  bool tableName :1;
  bool messageFormat :1;
  bool catName :1;
} _NotificationEvent__isset;

class NotificationEvent {
 public:

  NotificationEvent(const NotificationEvent&);
  NotificationEvent& operator=(const NotificationEvent&);
  NotificationEvent() : eventId(0), eventTime(0), eventType(), dbName(), tableName(), message(), messageFormat(), catName() {
  }

  virtual ~NotificationEvent() throw();
  int64_t eventId;
  int32_t eventTime;
  std::string eventType;
  std::string dbName;
  std::string tableName;
  std::string message;
  std::string messageFormat;
  std::string catName;

  _NotificationEvent__isset __isset;

  void __set_eventId(const int64_t val);

  void __set_eventTime(const int32_t val);

  void __set_eventType(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_message(const std::string& val);

  void __set_messageFormat(const std::string& val);

  void __set_catName(const std::string& val);

  bool operator == (const NotificationEvent & rhs) const
  {
    if (!(eventId == rhs.eventId))
      return false;
    if (!(eventTime == rhs.eventTime))
      return false;
    if (!(eventType == rhs.eventType))
      return false;
    if (__isset.dbName != rhs.__isset.dbName)
      return false;
    else if (__isset.dbName && !(dbName == rhs.dbName))
      return false;
    if (__isset.tableName != rhs.__isset.tableName)
      return false;
    else if (__isset.tableName && !(tableName == rhs.tableName))
      return false;
    if (!(message == rhs.message))
      return false;
    if (__isset.messageFormat != rhs.__isset.messageFormat)
      return false;
    else if (__isset.messageFormat && !(messageFormat == rhs.messageFormat))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const NotificationEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NotificationEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NotificationEvent &a, NotificationEvent &b);

inline std::ostream& operator<<(std::ostream& out, const NotificationEvent& obj)
{
  obj.printTo(out);
  return out;
}


class NotificationEventResponse {
 public:

  NotificationEventResponse(const NotificationEventResponse&);
  NotificationEventResponse& operator=(const NotificationEventResponse&);
  NotificationEventResponse() {
  }

  virtual ~NotificationEventResponse() throw();
  std::vector<NotificationEvent>  events;

  void __set_events(const std::vector<NotificationEvent> & val);

  bool operator == (const NotificationEventResponse & rhs) const
  {
    if (!(events == rhs.events))
      return false;
    return true;
  }
  bool operator != (const NotificationEventResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NotificationEventResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NotificationEventResponse &a, NotificationEventResponse &b);

inline std::ostream& operator<<(std::ostream& out, const NotificationEventResponse& obj)
{
  obj.printTo(out);
  return out;
}


class CurrentNotificationEventId {
 public:

  CurrentNotificationEventId(const CurrentNotificationEventId&);
  CurrentNotificationEventId& operator=(const CurrentNotificationEventId&);
  CurrentNotificationEventId() : eventId(0) {
  }

  virtual ~CurrentNotificationEventId() throw();
  int64_t eventId;

  void __set_eventId(const int64_t val);

  bool operator == (const CurrentNotificationEventId & rhs) const
  {
    if (!(eventId == rhs.eventId))
      return false;
    return true;
  }
  bool operator != (const CurrentNotificationEventId &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CurrentNotificationEventId & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CurrentNotificationEventId &a, CurrentNotificationEventId &b);

inline std::ostream& operator<<(std::ostream& out, const CurrentNotificationEventId& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NotificationEventsCountRequest__isset {
  _NotificationEventsCountRequest__isset() : catName(false) {}
  bool catName :1;
} _NotificationEventsCountRequest__isset;

class NotificationEventsCountRequest {
 public:

  NotificationEventsCountRequest(const NotificationEventsCountRequest&);
  NotificationEventsCountRequest& operator=(const NotificationEventsCountRequest&);
  NotificationEventsCountRequest() : fromEventId(0), dbName(), catName() {
  }

  virtual ~NotificationEventsCountRequest() throw();
  int64_t fromEventId;
  std::string dbName;
  std::string catName;

  _NotificationEventsCountRequest__isset __isset;

  void __set_fromEventId(const int64_t val);

  void __set_dbName(const std::string& val);

  void __set_catName(const std::string& val);

  bool operator == (const NotificationEventsCountRequest & rhs) const
  {
    if (!(fromEventId == rhs.fromEventId))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const NotificationEventsCountRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NotificationEventsCountRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NotificationEventsCountRequest &a, NotificationEventsCountRequest &b);

inline std::ostream& operator<<(std::ostream& out, const NotificationEventsCountRequest& obj)
{
  obj.printTo(out);
  return out;
}


class NotificationEventsCountResponse {
 public:

  NotificationEventsCountResponse(const NotificationEventsCountResponse&);
  NotificationEventsCountResponse& operator=(const NotificationEventsCountResponse&);
  NotificationEventsCountResponse() : eventsCount(0) {
  }

  virtual ~NotificationEventsCountResponse() throw();
  int64_t eventsCount;

  void __set_eventsCount(const int64_t val);

  bool operator == (const NotificationEventsCountResponse & rhs) const
  {
    if (!(eventsCount == rhs.eventsCount))
      return false;
    return true;
  }
  bool operator != (const NotificationEventsCountResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NotificationEventsCountResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NotificationEventsCountResponse &a, NotificationEventsCountResponse &b);

inline std::ostream& operator<<(std::ostream& out, const NotificationEventsCountResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _InsertEventRequestData__isset {
  _InsertEventRequestData__isset() : replace(false), filesAddedChecksum(false) {}
  bool replace :1;
  bool filesAddedChecksum :1;
} _InsertEventRequestData__isset;

class InsertEventRequestData {
 public:

  InsertEventRequestData(const InsertEventRequestData&);
  InsertEventRequestData& operator=(const InsertEventRequestData&);
  InsertEventRequestData() : replace(0) {
  }

  virtual ~InsertEventRequestData() throw();
  bool replace;
  std::vector<std::string>  filesAdded;
  std::vector<std::string>  filesAddedChecksum;

  _InsertEventRequestData__isset __isset;

  void __set_replace(const bool val);

  void __set_filesAdded(const std::vector<std::string> & val);

  void __set_filesAddedChecksum(const std::vector<std::string> & val);

  bool operator == (const InsertEventRequestData & rhs) const
  {
    if (__isset.replace != rhs.__isset.replace)
      return false;
    else if (__isset.replace && !(replace == rhs.replace))
      return false;
    if (!(filesAdded == rhs.filesAdded))
      return false;
    if (__isset.filesAddedChecksum != rhs.__isset.filesAddedChecksum)
      return false;
    else if (__isset.filesAddedChecksum && !(filesAddedChecksum == rhs.filesAddedChecksum))
      return false;
    return true;
  }
  bool operator != (const InsertEventRequestData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InsertEventRequestData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(InsertEventRequestData &a, InsertEventRequestData &b);

inline std::ostream& operator<<(std::ostream& out, const InsertEventRequestData& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _FireEventRequestData__isset {
  _FireEventRequestData__isset() : insertData(false) {}
  bool insertData :1;
} _FireEventRequestData__isset;

class FireEventRequestData {
 public:

  FireEventRequestData(const FireEventRequestData&);
  FireEventRequestData& operator=(const FireEventRequestData&);
  FireEventRequestData() {
  }

  virtual ~FireEventRequestData() throw();
  InsertEventRequestData insertData;

  _FireEventRequestData__isset __isset;

  void __set_insertData(const InsertEventRequestData& val);

  bool operator == (const FireEventRequestData & rhs) const
  {
    if (!(insertData == rhs.insertData))
      return false;
    return true;
  }
  bool operator != (const FireEventRequestData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FireEventRequestData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FireEventRequestData &a, FireEventRequestData &b);

inline std::ostream& operator<<(std::ostream& out, const FireEventRequestData& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _FireEventRequest__isset {
  _FireEventRequest__isset() : dbName(false), tableName(false), partitionVals(false), catName(false) {}
  bool dbName :1;
  bool tableName :1;
  bool partitionVals :1;
  bool catName :1;
} _FireEventRequest__isset;

class FireEventRequest {
 public:

  FireEventRequest(const FireEventRequest&);
  FireEventRequest& operator=(const FireEventRequest&);
  FireEventRequest() : successful(0), dbName(), tableName(), catName() {
  }

  virtual ~FireEventRequest() throw();
  bool successful;
  FireEventRequestData data;
  std::string dbName;
  std::string tableName;
  std::vector<std::string>  partitionVals;
  std::string catName;

  _FireEventRequest__isset __isset;

  void __set_successful(const bool val);

  void __set_data(const FireEventRequestData& val);

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_partitionVals(const std::vector<std::string> & val);

  void __set_catName(const std::string& val);

  bool operator == (const FireEventRequest & rhs) const
  {
    if (!(successful == rhs.successful))
      return false;
    if (!(data == rhs.data))
      return false;
    if (__isset.dbName != rhs.__isset.dbName)
      return false;
    else if (__isset.dbName && !(dbName == rhs.dbName))
      return false;
    if (__isset.tableName != rhs.__isset.tableName)
      return false;
    else if (__isset.tableName && !(tableName == rhs.tableName))
      return false;
    if (__isset.partitionVals != rhs.__isset.partitionVals)
      return false;
    else if (__isset.partitionVals && !(partitionVals == rhs.partitionVals))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const FireEventRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FireEventRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FireEventRequest &a, FireEventRequest &b);

inline std::ostream& operator<<(std::ostream& out, const FireEventRequest& obj)
{
  obj.printTo(out);
  return out;
}


class FireEventResponse {
 public:

  FireEventResponse(const FireEventResponse&);
  FireEventResponse& operator=(const FireEventResponse&);
  FireEventResponse() {
  }

  virtual ~FireEventResponse() throw();

  bool operator == (const FireEventResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const FireEventResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FireEventResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FireEventResponse &a, FireEventResponse &b);

inline std::ostream& operator<<(std::ostream& out, const FireEventResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _MetadataPpdResult__isset {
  _MetadataPpdResult__isset() : metadata(false), includeBitset(false) {}
  bool metadata :1;
  bool includeBitset :1;
} _MetadataPpdResult__isset;

class MetadataPpdResult {
 public:

  MetadataPpdResult(const MetadataPpdResult&);
  MetadataPpdResult& operator=(const MetadataPpdResult&);
  MetadataPpdResult() : metadata(), includeBitset() {
  }

  virtual ~MetadataPpdResult() throw();
  std::string metadata;
  std::string includeBitset;

  _MetadataPpdResult__isset __isset;

  void __set_metadata(const std::string& val);

  void __set_includeBitset(const std::string& val);

  bool operator == (const MetadataPpdResult & rhs) const
  {
    if (__isset.metadata != rhs.__isset.metadata)
      return false;
    else if (__isset.metadata && !(metadata == rhs.metadata))
      return false;
    if (__isset.includeBitset != rhs.__isset.includeBitset)
      return false;
    else if (__isset.includeBitset && !(includeBitset == rhs.includeBitset))
      return false;
    return true;
  }
  bool operator != (const MetadataPpdResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MetadataPpdResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MetadataPpdResult &a, MetadataPpdResult &b);

inline std::ostream& operator<<(std::ostream& out, const MetadataPpdResult& obj)
{
  obj.printTo(out);
  return out;
}


class GetFileMetadataByExprResult {
 public:

  GetFileMetadataByExprResult(const GetFileMetadataByExprResult&);
  GetFileMetadataByExprResult& operator=(const GetFileMetadataByExprResult&);
  GetFileMetadataByExprResult() : isSupported(0) {
  }

  virtual ~GetFileMetadataByExprResult() throw();
  std::map<int64_t, MetadataPpdResult>  metadata;
  bool isSupported;

  void __set_metadata(const std::map<int64_t, MetadataPpdResult> & val);

  void __set_isSupported(const bool val);

  bool operator == (const GetFileMetadataByExprResult & rhs) const
  {
    if (!(metadata == rhs.metadata))
      return false;
    if (!(isSupported == rhs.isSupported))
      return false;
    return true;
  }
  bool operator != (const GetFileMetadataByExprResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetFileMetadataByExprResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetFileMetadataByExprResult &a, GetFileMetadataByExprResult &b);

inline std::ostream& operator<<(std::ostream& out, const GetFileMetadataByExprResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GetFileMetadataByExprRequest__isset {
  _GetFileMetadataByExprRequest__isset() : doGetFooters(false), type(false) {}
  bool doGetFooters :1;
  bool type :1;
} _GetFileMetadataByExprRequest__isset;

class GetFileMetadataByExprRequest {
 public:

  GetFileMetadataByExprRequest(const GetFileMetadataByExprRequest&);
  GetFileMetadataByExprRequest& operator=(const GetFileMetadataByExprRequest&);
  GetFileMetadataByExprRequest() : expr(), doGetFooters(0), type((FileMetadataExprType::type)0) {
  }

  virtual ~GetFileMetadataByExprRequest() throw();
  std::vector<int64_t>  fileIds;
  std::string expr;
  bool doGetFooters;
  FileMetadataExprType::type type;

  _GetFileMetadataByExprRequest__isset __isset;

  void __set_fileIds(const std::vector<int64_t> & val);

  void __set_expr(const std::string& val);

  void __set_doGetFooters(const bool val);

  void __set_type(const FileMetadataExprType::type val);

  bool operator == (const GetFileMetadataByExprRequest & rhs) const
  {
    if (!(fileIds == rhs.fileIds))
      return false;
    if (!(expr == rhs.expr))
      return false;
    if (__isset.doGetFooters != rhs.__isset.doGetFooters)
      return false;
    else if (__isset.doGetFooters && !(doGetFooters == rhs.doGetFooters))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const GetFileMetadataByExprRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetFileMetadataByExprRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetFileMetadataByExprRequest &a, GetFileMetadataByExprRequest &b);

inline std::ostream& operator<<(std::ostream& out, const GetFileMetadataByExprRequest& obj)
{
  obj.printTo(out);
  return out;
}


class GetFileMetadataResult {
 public:

  GetFileMetadataResult(const GetFileMetadataResult&);
  GetFileMetadataResult& operator=(const GetFileMetadataResult&);
  GetFileMetadataResult() : isSupported(0) {
  }

  virtual ~GetFileMetadataResult() throw();
  std::map<int64_t, std::string>  metadata;
  bool isSupported;

  void __set_metadata(const std::map<int64_t, std::string> & val);

  void __set_isSupported(const bool val);

  bool operator == (const GetFileMetadataResult & rhs) const
  {
    if (!(metadata == rhs.metadata))
      return false;
    if (!(isSupported == rhs.isSupported))
      return false;
    return true;
  }
  bool operator != (const GetFileMetadataResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetFileMetadataResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetFileMetadataResult &a, GetFileMetadataResult &b);

inline std::ostream& operator<<(std::ostream& out, const GetFileMetadataResult& obj)
{
  obj.printTo(out);
  return out;
}


class GetFileMetadataRequest {
 public:

  GetFileMetadataRequest(const GetFileMetadataRequest&);
  GetFileMetadataRequest& operator=(const GetFileMetadataRequest&);
  GetFileMetadataRequest() {
  }

  virtual ~GetFileMetadataRequest() throw();
  std::vector<int64_t>  fileIds;

  void __set_fileIds(const std::vector<int64_t> & val);

  bool operator == (const GetFileMetadataRequest & rhs) const
  {
    if (!(fileIds == rhs.fileIds))
      return false;
    return true;
  }
  bool operator != (const GetFileMetadataRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetFileMetadataRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetFileMetadataRequest &a, GetFileMetadataRequest &b);

inline std::ostream& operator<<(std::ostream& out, const GetFileMetadataRequest& obj)
{
  obj.printTo(out);
  return out;
}


class PutFileMetadataResult {
 public:

  PutFileMetadataResult(const PutFileMetadataResult&);
  PutFileMetadataResult& operator=(const PutFileMetadataResult&);
  PutFileMetadataResult() {
  }

  virtual ~PutFileMetadataResult() throw();

  bool operator == (const PutFileMetadataResult & /* rhs */) const
  {
    return true;
  }
  bool operator != (const PutFileMetadataResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PutFileMetadataResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PutFileMetadataResult &a, PutFileMetadataResult &b);

inline std::ostream& operator<<(std::ostream& out, const PutFileMetadataResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _PutFileMetadataRequest__isset {
  _PutFileMetadataRequest__isset() : type(false) {}
  bool type :1;
} _PutFileMetadataRequest__isset;

class PutFileMetadataRequest {
 public:

  PutFileMetadataRequest(const PutFileMetadataRequest&);
  PutFileMetadataRequest& operator=(const PutFileMetadataRequest&);
  PutFileMetadataRequest() : type((FileMetadataExprType::type)0) {
  }

  virtual ~PutFileMetadataRequest() throw();
  std::vector<int64_t>  fileIds;
  std::vector<std::string>  metadata;
  FileMetadataExprType::type type;

  _PutFileMetadataRequest__isset __isset;

  void __set_fileIds(const std::vector<int64_t> & val);

  void __set_metadata(const std::vector<std::string> & val);

  void __set_type(const FileMetadataExprType::type val);

  bool operator == (const PutFileMetadataRequest & rhs) const
  {
    if (!(fileIds == rhs.fileIds))
      return false;
    if (!(metadata == rhs.metadata))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const PutFileMetadataRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PutFileMetadataRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PutFileMetadataRequest &a, PutFileMetadataRequest &b);

inline std::ostream& operator<<(std::ostream& out, const PutFileMetadataRequest& obj)
{
  obj.printTo(out);
  return out;
}


class ClearFileMetadataResult {
 public:

  ClearFileMetadataResult(const ClearFileMetadataResult&);
  ClearFileMetadataResult& operator=(const ClearFileMetadataResult&);
  ClearFileMetadataResult() {
  }

  virtual ~ClearFileMetadataResult() throw();

  bool operator == (const ClearFileMetadataResult & /* rhs */) const
  {
    return true;
  }
  bool operator != (const ClearFileMetadataResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClearFileMetadataResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ClearFileMetadataResult &a, ClearFileMetadataResult &b);

inline std::ostream& operator<<(std::ostream& out, const ClearFileMetadataResult& obj)
{
  obj.printTo(out);
  return out;
}


class ClearFileMetadataRequest {
 public:

  ClearFileMetadataRequest(const ClearFileMetadataRequest&);
  ClearFileMetadataRequest& operator=(const ClearFileMetadataRequest&);
  ClearFileMetadataRequest() {
  }

  virtual ~ClearFileMetadataRequest() throw();
  std::vector<int64_t>  fileIds;

  void __set_fileIds(const std::vector<int64_t> & val);

  bool operator == (const ClearFileMetadataRequest & rhs) const
  {
    if (!(fileIds == rhs.fileIds))
      return false;
    return true;
  }
  bool operator != (const ClearFileMetadataRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClearFileMetadataRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ClearFileMetadataRequest &a, ClearFileMetadataRequest &b);

inline std::ostream& operator<<(std::ostream& out, const ClearFileMetadataRequest& obj)
{
  obj.printTo(out);
  return out;
}


class CacheFileMetadataResult {
 public:

  CacheFileMetadataResult(const CacheFileMetadataResult&);
  CacheFileMetadataResult& operator=(const CacheFileMetadataResult&);
  CacheFileMetadataResult() : isSupported(0) {
  }

  virtual ~CacheFileMetadataResult() throw();
  bool isSupported;

  void __set_isSupported(const bool val);

  bool operator == (const CacheFileMetadataResult & rhs) const
  {
    if (!(isSupported == rhs.isSupported))
      return false;
    return true;
  }
  bool operator != (const CacheFileMetadataResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CacheFileMetadataResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CacheFileMetadataResult &a, CacheFileMetadataResult &b);

inline std::ostream& operator<<(std::ostream& out, const CacheFileMetadataResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _CacheFileMetadataRequest__isset {
  _CacheFileMetadataRequest__isset() : partName(false), isAllParts(false) {}
  bool partName :1;
  bool isAllParts :1;
} _CacheFileMetadataRequest__isset;

class CacheFileMetadataRequest {
 public:

  CacheFileMetadataRequest(const CacheFileMetadataRequest&);
  CacheFileMetadataRequest& operator=(const CacheFileMetadataRequest&);
  CacheFileMetadataRequest() : dbName(), tblName(), partName(), isAllParts(0) {
  }

  virtual ~CacheFileMetadataRequest() throw();
  std::string dbName;
  std::string tblName;
  std::string partName;
  bool isAllParts;

  _CacheFileMetadataRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_partName(const std::string& val);

  void __set_isAllParts(const bool val);

  bool operator == (const CacheFileMetadataRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (__isset.partName != rhs.__isset.partName)
      return false;
    else if (__isset.partName && !(partName == rhs.partName))
      return false;
    if (__isset.isAllParts != rhs.__isset.isAllParts)
      return false;
    else if (__isset.isAllParts && !(isAllParts == rhs.isAllParts))
      return false;
    return true;
  }
  bool operator != (const CacheFileMetadataRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CacheFileMetadataRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CacheFileMetadataRequest &a, CacheFileMetadataRequest &b);

inline std::ostream& operator<<(std::ostream& out, const CacheFileMetadataRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GetAllFunctionsResponse__isset {
  _GetAllFunctionsResponse__isset() : functions(false) {}
  bool functions :1;
} _GetAllFunctionsResponse__isset;

class GetAllFunctionsResponse {
 public:

  GetAllFunctionsResponse(const GetAllFunctionsResponse&);
  GetAllFunctionsResponse& operator=(const GetAllFunctionsResponse&);
  GetAllFunctionsResponse() {
  }

  virtual ~GetAllFunctionsResponse() throw();
  std::vector<Function>  functions;

  _GetAllFunctionsResponse__isset __isset;

  void __set_functions(const std::vector<Function> & val);

  bool operator == (const GetAllFunctionsResponse & rhs) const
  {
    if (__isset.functions != rhs.__isset.functions)
      return false;
    else if (__isset.functions && !(functions == rhs.functions))
      return false;
    return true;
  }
  bool operator != (const GetAllFunctionsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetAllFunctionsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetAllFunctionsResponse &a, GetAllFunctionsResponse &b);

inline std::ostream& operator<<(std::ostream& out, const GetAllFunctionsResponse& obj)
{
  obj.printTo(out);
  return out;
}


class ClientCapabilities {
 public:

  ClientCapabilities(const ClientCapabilities&);
  ClientCapabilities& operator=(const ClientCapabilities&);
  ClientCapabilities() {
  }

  virtual ~ClientCapabilities() throw();
  std::vector<ClientCapability::type>  values;

  void __set_values(const std::vector<ClientCapability::type> & val);

  bool operator == (const ClientCapabilities & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    return true;
  }
  bool operator != (const ClientCapabilities &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientCapabilities & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ClientCapabilities &a, ClientCapabilities &b);

inline std::ostream& operator<<(std::ostream& out, const ClientCapabilities& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GetTableRequest__isset {
  _GetTableRequest__isset() : capabilities(false), catName(false) {}
  bool capabilities :1;
  bool catName :1;
} _GetTableRequest__isset;

class GetTableRequest {
 public:

  GetTableRequest(const GetTableRequest&);
  GetTableRequest& operator=(const GetTableRequest&);
  GetTableRequest() : dbName(), tblName(), catName() {
  }

  virtual ~GetTableRequest() throw();
  std::string dbName;
  std::string tblName;
  ClientCapabilities capabilities;
  std::string catName;

  _GetTableRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_capabilities(const ClientCapabilities& val);

  void __set_catName(const std::string& val);

  bool operator == (const GetTableRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (__isset.capabilities != rhs.__isset.capabilities)
      return false;
    else if (__isset.capabilities && !(capabilities == rhs.capabilities))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const GetTableRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetTableRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetTableRequest &a, GetTableRequest &b);

inline std::ostream& operator<<(std::ostream& out, const GetTableRequest& obj)
{
  obj.printTo(out);
  return out;
}


class GetTableResult {
 public:

  GetTableResult(const GetTableResult&);
  GetTableResult& operator=(const GetTableResult&);
  GetTableResult() {
  }

  virtual ~GetTableResult() throw();
  Table table;

  void __set_table(const Table& val);

  bool operator == (const GetTableResult & rhs) const
  {
    if (!(table == rhs.table))
      return false;
    return true;
  }
  bool operator != (const GetTableResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetTableResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetTableResult &a, GetTableResult &b);

inline std::ostream& operator<<(std::ostream& out, const GetTableResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GetTablesRequest__isset {
  _GetTablesRequest__isset() : tblNames(false), capabilities(false), catName(false) {}
  bool tblNames :1;
  bool capabilities :1;
  bool catName :1;
} _GetTablesRequest__isset;

class GetTablesRequest {
 public:

  GetTablesRequest(const GetTablesRequest&);
  GetTablesRequest& operator=(const GetTablesRequest&);
  GetTablesRequest() : dbName(), catName() {
  }

  virtual ~GetTablesRequest() throw();
  std::string dbName;
  std::vector<std::string>  tblNames;
  ClientCapabilities capabilities;
  std::string catName;

  _GetTablesRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tblNames(const std::vector<std::string> & val);

  void __set_capabilities(const ClientCapabilities& val);

  void __set_catName(const std::string& val);

  bool operator == (const GetTablesRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (__isset.tblNames != rhs.__isset.tblNames)
      return false;
    else if (__isset.tblNames && !(tblNames == rhs.tblNames))
      return false;
    if (__isset.capabilities != rhs.__isset.capabilities)
      return false;
    else if (__isset.capabilities && !(capabilities == rhs.capabilities))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const GetTablesRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetTablesRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetTablesRequest &a, GetTablesRequest &b);

inline std::ostream& operator<<(std::ostream& out, const GetTablesRequest& obj)
{
  obj.printTo(out);
  return out;
}


class GetTablesResult {
 public:

  GetTablesResult(const GetTablesResult&);
  GetTablesResult& operator=(const GetTablesResult&);
  GetTablesResult() {
  }

  virtual ~GetTablesResult() throw();
  std::vector<Table>  tables;

  void __set_tables(const std::vector<Table> & val);

  bool operator == (const GetTablesResult & rhs) const
  {
    if (!(tables == rhs.tables))
      return false;
    return true;
  }
  bool operator != (const GetTablesResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetTablesResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetTablesResult &a, GetTablesResult &b);

inline std::ostream& operator<<(std::ostream& out, const GetTablesResult& obj)
{
  obj.printTo(out);
  return out;
}


class CmRecycleRequest {
 public:

  CmRecycleRequest(const CmRecycleRequest&);
  CmRecycleRequest& operator=(const CmRecycleRequest&);
  CmRecycleRequest() : dataPath(), purge(0) {
  }

  virtual ~CmRecycleRequest() throw();
  std::string dataPath;
  bool purge;

  void __set_dataPath(const std::string& val);

  void __set_purge(const bool val);

  bool operator == (const CmRecycleRequest & rhs) const
  {
    if (!(dataPath == rhs.dataPath))
      return false;
    if (!(purge == rhs.purge))
      return false;
    return true;
  }
  bool operator != (const CmRecycleRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CmRecycleRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CmRecycleRequest &a, CmRecycleRequest &b);

inline std::ostream& operator<<(std::ostream& out, const CmRecycleRequest& obj)
{
  obj.printTo(out);
  return out;
}


class CmRecycleResponse {
 public:

  CmRecycleResponse(const CmRecycleResponse&);
  CmRecycleResponse& operator=(const CmRecycleResponse&);
  CmRecycleResponse() {
  }

  virtual ~CmRecycleResponse() throw();

  bool operator == (const CmRecycleResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const CmRecycleResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CmRecycleResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CmRecycleResponse &a, CmRecycleResponse &b);

inline std::ostream& operator<<(std::ostream& out, const CmRecycleResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TableMeta__isset {
  _TableMeta__isset() : comments(false), catName(false) {}
  bool comments :1;
  bool catName :1;
} _TableMeta__isset;

class TableMeta {
 public:

  TableMeta(const TableMeta&);
  TableMeta& operator=(const TableMeta&);
  TableMeta() : dbName(), tableName(), tableType(), comments(), catName() {
  }

  virtual ~TableMeta() throw();
  std::string dbName;
  std::string tableName;
  std::string tableType;
  std::string comments;
  std::string catName;

  _TableMeta__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_tableType(const std::string& val);

  void __set_comments(const std::string& val);

  void __set_catName(const std::string& val);

  bool operator == (const TableMeta & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(tableType == rhs.tableType))
      return false;
    if (__isset.comments != rhs.__isset.comments)
      return false;
    else if (__isset.comments && !(comments == rhs.comments))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const TableMeta &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TableMeta & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TableMeta &a, TableMeta &b);

inline std::ostream& operator<<(std::ostream& out, const TableMeta& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Materialization__isset {
  _Materialization__isset() : validTxnList(false), invalidationTime(false), sourceTablesUpdateDeleteModified(false) {}
  bool validTxnList :1;
  bool invalidationTime :1;
  bool sourceTablesUpdateDeleteModified :1;
} _Materialization__isset;

class Materialization {
 public:

  Materialization(const Materialization&);
  Materialization& operator=(const Materialization&);
  Materialization() : validTxnList(), invalidationTime(0), sourceTablesUpdateDeleteModified(0) {
  }

  virtual ~Materialization() throw();
  std::set<std::string>  tablesUsed;
  std::string validTxnList;
  int64_t invalidationTime;
  bool sourceTablesUpdateDeleteModified;

  _Materialization__isset __isset;

  void __set_tablesUsed(const std::set<std::string> & val);

  void __set_validTxnList(const std::string& val);

  void __set_invalidationTime(const int64_t val);

  void __set_sourceTablesUpdateDeleteModified(const bool val);

  bool operator == (const Materialization & rhs) const
  {
    if (!(tablesUsed == rhs.tablesUsed))
      return false;
    if (__isset.validTxnList != rhs.__isset.validTxnList)
      return false;
    else if (__isset.validTxnList && !(validTxnList == rhs.validTxnList))
      return false;
    if (__isset.invalidationTime != rhs.__isset.invalidationTime)
      return false;
    else if (__isset.invalidationTime && !(invalidationTime == rhs.invalidationTime))
      return false;
    if (__isset.sourceTablesUpdateDeleteModified != rhs.__isset.sourceTablesUpdateDeleteModified)
      return false;
    else if (__isset.sourceTablesUpdateDeleteModified && !(sourceTablesUpdateDeleteModified == rhs.sourceTablesUpdateDeleteModified))
      return false;
    return true;
  }
  bool operator != (const Materialization &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Materialization & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Materialization &a, Materialization &b);

inline std::ostream& operator<<(std::ostream& out, const Materialization& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMResourcePlan__isset {
  _WMResourcePlan__isset() : status(false), queryParallelism(false), defaultPoolPath(false) {}
  bool status :1;
  bool queryParallelism :1;
  bool defaultPoolPath :1;
} _WMResourcePlan__isset;

class WMResourcePlan {
 public:

  WMResourcePlan(const WMResourcePlan&);
  WMResourcePlan& operator=(const WMResourcePlan&);
  WMResourcePlan() : name(), status((WMResourcePlanStatus::type)0), queryParallelism(0), defaultPoolPath() {
  }

  virtual ~WMResourcePlan() throw();
  std::string name;
  WMResourcePlanStatus::type status;
  int32_t queryParallelism;
  std::string defaultPoolPath;

  _WMResourcePlan__isset __isset;

  void __set_name(const std::string& val);

  void __set_status(const WMResourcePlanStatus::type val);

  void __set_queryParallelism(const int32_t val);

  void __set_defaultPoolPath(const std::string& val);

  bool operator == (const WMResourcePlan & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    if (__isset.queryParallelism != rhs.__isset.queryParallelism)
      return false;
    else if (__isset.queryParallelism && !(queryParallelism == rhs.queryParallelism))
      return false;
    if (__isset.defaultPoolPath != rhs.__isset.defaultPoolPath)
      return false;
    else if (__isset.defaultPoolPath && !(defaultPoolPath == rhs.defaultPoolPath))
      return false;
    return true;
  }
  bool operator != (const WMResourcePlan &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMResourcePlan & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMResourcePlan &a, WMResourcePlan &b);

inline std::ostream& operator<<(std::ostream& out, const WMResourcePlan& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMNullableResourcePlan__isset {
  _WMNullableResourcePlan__isset() : name(false), status(false), queryParallelism(false), isSetQueryParallelism(false), defaultPoolPath(false), isSetDefaultPoolPath(false) {}
  bool name :1;
  bool status :1;
  bool queryParallelism :1;
  bool isSetQueryParallelism :1;
  bool defaultPoolPath :1;
  bool isSetDefaultPoolPath :1;
} _WMNullableResourcePlan__isset;

class WMNullableResourcePlan {
 public:

  WMNullableResourcePlan(const WMNullableResourcePlan&);
  WMNullableResourcePlan& operator=(const WMNullableResourcePlan&);
  WMNullableResourcePlan() : name(), status((WMResourcePlanStatus::type)0), queryParallelism(0), isSetQueryParallelism(0), defaultPoolPath(), isSetDefaultPoolPath(0) {
  }

  virtual ~WMNullableResourcePlan() throw();
  std::string name;
  WMResourcePlanStatus::type status;
  int32_t queryParallelism;
  bool isSetQueryParallelism;
  std::string defaultPoolPath;
  bool isSetDefaultPoolPath;

  _WMNullableResourcePlan__isset __isset;

  void __set_name(const std::string& val);

  void __set_status(const WMResourcePlanStatus::type val);

  void __set_queryParallelism(const int32_t val);

  void __set_isSetQueryParallelism(const bool val);

  void __set_defaultPoolPath(const std::string& val);

  void __set_isSetDefaultPoolPath(const bool val);

  bool operator == (const WMNullableResourcePlan & rhs) const
  {
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    if (__isset.queryParallelism != rhs.__isset.queryParallelism)
      return false;
    else if (__isset.queryParallelism && !(queryParallelism == rhs.queryParallelism))
      return false;
    if (__isset.isSetQueryParallelism != rhs.__isset.isSetQueryParallelism)
      return false;
    else if (__isset.isSetQueryParallelism && !(isSetQueryParallelism == rhs.isSetQueryParallelism))
      return false;
    if (__isset.defaultPoolPath != rhs.__isset.defaultPoolPath)
      return false;
    else if (__isset.defaultPoolPath && !(defaultPoolPath == rhs.defaultPoolPath))
      return false;
    if (__isset.isSetDefaultPoolPath != rhs.__isset.isSetDefaultPoolPath)
      return false;
    else if (__isset.isSetDefaultPoolPath && !(isSetDefaultPoolPath == rhs.isSetDefaultPoolPath))
      return false;
    return true;
  }
  bool operator != (const WMNullableResourcePlan &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMNullableResourcePlan & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMNullableResourcePlan &a, WMNullableResourcePlan &b);

inline std::ostream& operator<<(std::ostream& out, const WMNullableResourcePlan& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMPool__isset {
  _WMPool__isset() : allocFraction(false), queryParallelism(false), schedulingPolicy(false) {}
  bool allocFraction :1;
  bool queryParallelism :1;
  bool schedulingPolicy :1;
} _WMPool__isset;

class WMPool {
 public:

  WMPool(const WMPool&);
  WMPool& operator=(const WMPool&);
  WMPool() : resourcePlanName(), poolPath(), allocFraction(0), queryParallelism(0), schedulingPolicy() {
  }

  virtual ~WMPool() throw();
  std::string resourcePlanName;
  std::string poolPath;
  double allocFraction;
  int32_t queryParallelism;
  std::string schedulingPolicy;

  _WMPool__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  void __set_poolPath(const std::string& val);

  void __set_allocFraction(const double val);

  void __set_queryParallelism(const int32_t val);

  void __set_schedulingPolicy(const std::string& val);

  bool operator == (const WMPool & rhs) const
  {
    if (!(resourcePlanName == rhs.resourcePlanName))
      return false;
    if (!(poolPath == rhs.poolPath))
      return false;
    if (__isset.allocFraction != rhs.__isset.allocFraction)
      return false;
    else if (__isset.allocFraction && !(allocFraction == rhs.allocFraction))
      return false;
    if (__isset.queryParallelism != rhs.__isset.queryParallelism)
      return false;
    else if (__isset.queryParallelism && !(queryParallelism == rhs.queryParallelism))
      return false;
    if (__isset.schedulingPolicy != rhs.__isset.schedulingPolicy)
      return false;
    else if (__isset.schedulingPolicy && !(schedulingPolicy == rhs.schedulingPolicy))
      return false;
    return true;
  }
  bool operator != (const WMPool &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMPool & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMPool &a, WMPool &b);

inline std::ostream& operator<<(std::ostream& out, const WMPool& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMNullablePool__isset {
  _WMNullablePool__isset() : allocFraction(false), queryParallelism(false), schedulingPolicy(false), isSetSchedulingPolicy(false) {}
  bool allocFraction :1;
  bool queryParallelism :1;
  bool schedulingPolicy :1;
  bool isSetSchedulingPolicy :1;
} _WMNullablePool__isset;

class WMNullablePool {
 public:

  WMNullablePool(const WMNullablePool&);
  WMNullablePool& operator=(const WMNullablePool&);
  WMNullablePool() : resourcePlanName(), poolPath(), allocFraction(0), queryParallelism(0), schedulingPolicy(), isSetSchedulingPolicy(0) {
  }

  virtual ~WMNullablePool() throw();
  std::string resourcePlanName;
  std::string poolPath;
  double allocFraction;
  int32_t queryParallelism;
  std::string schedulingPolicy;
  bool isSetSchedulingPolicy;

  _WMNullablePool__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  void __set_poolPath(const std::string& val);

  void __set_allocFraction(const double val);

  void __set_queryParallelism(const int32_t val);

  void __set_schedulingPolicy(const std::string& val);

  void __set_isSetSchedulingPolicy(const bool val);

  bool operator == (const WMNullablePool & rhs) const
  {
    if (!(resourcePlanName == rhs.resourcePlanName))
      return false;
    if (!(poolPath == rhs.poolPath))
      return false;
    if (__isset.allocFraction != rhs.__isset.allocFraction)
      return false;
    else if (__isset.allocFraction && !(allocFraction == rhs.allocFraction))
      return false;
    if (__isset.queryParallelism != rhs.__isset.queryParallelism)
      return false;
    else if (__isset.queryParallelism && !(queryParallelism == rhs.queryParallelism))
      return false;
    if (__isset.schedulingPolicy != rhs.__isset.schedulingPolicy)
      return false;
    else if (__isset.schedulingPolicy && !(schedulingPolicy == rhs.schedulingPolicy))
      return false;
    if (__isset.isSetSchedulingPolicy != rhs.__isset.isSetSchedulingPolicy)
      return false;
    else if (__isset.isSetSchedulingPolicy && !(isSetSchedulingPolicy == rhs.isSetSchedulingPolicy))
      return false;
    return true;
  }
  bool operator != (const WMNullablePool &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMNullablePool & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMNullablePool &a, WMNullablePool &b);

inline std::ostream& operator<<(std::ostream& out, const WMNullablePool& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMTrigger__isset {
  _WMTrigger__isset() : triggerExpression(false), actionExpression(false), isInUnmanaged(false) {}
  bool triggerExpression :1;
  bool actionExpression :1;
  bool isInUnmanaged :1;
} _WMTrigger__isset;

class WMTrigger {
 public:

  WMTrigger(const WMTrigger&);
  WMTrigger& operator=(const WMTrigger&);
  WMTrigger() : resourcePlanName(), triggerName(), triggerExpression(), actionExpression(), isInUnmanaged(0) {
  }

  virtual ~WMTrigger() throw();
  std::string resourcePlanName;
  std::string triggerName;
  std::string triggerExpression;
  std::string actionExpression;
  bool isInUnmanaged;

  _WMTrigger__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  void __set_triggerName(const std::string& val);

  void __set_triggerExpression(const std::string& val);

  void __set_actionExpression(const std::string& val);

  void __set_isInUnmanaged(const bool val);

  bool operator == (const WMTrigger & rhs) const
  {
    if (!(resourcePlanName == rhs.resourcePlanName))
      return false;
    if (!(triggerName == rhs.triggerName))
      return false;
    if (__isset.triggerExpression != rhs.__isset.triggerExpression)
      return false;
    else if (__isset.triggerExpression && !(triggerExpression == rhs.triggerExpression))
      return false;
    if (__isset.actionExpression != rhs.__isset.actionExpression)
      return false;
    else if (__isset.actionExpression && !(actionExpression == rhs.actionExpression))
      return false;
    if (__isset.isInUnmanaged != rhs.__isset.isInUnmanaged)
      return false;
    else if (__isset.isInUnmanaged && !(isInUnmanaged == rhs.isInUnmanaged))
      return false;
    return true;
  }
  bool operator != (const WMTrigger &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMTrigger & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMTrigger &a, WMTrigger &b);

inline std::ostream& operator<<(std::ostream& out, const WMTrigger& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMMapping__isset {
  _WMMapping__isset() : poolPath(false), ordering(false) {}
  bool poolPath :1;
  bool ordering :1;
} _WMMapping__isset;

class WMMapping {
 public:

  WMMapping(const WMMapping&);
  WMMapping& operator=(const WMMapping&);
  WMMapping() : resourcePlanName(), entityType(), entityName(), poolPath(), ordering(0) {
  }

  virtual ~WMMapping() throw();
  std::string resourcePlanName;
  std::string entityType;
  std::string entityName;
  std::string poolPath;
  int32_t ordering;

  _WMMapping__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  void __set_entityType(const std::string& val);

  void __set_entityName(const std::string& val);

  void __set_poolPath(const std::string& val);

  void __set_ordering(const int32_t val);

  bool operator == (const WMMapping & rhs) const
  {
    if (!(resourcePlanName == rhs.resourcePlanName))
      return false;
    if (!(entityType == rhs.entityType))
      return false;
    if (!(entityName == rhs.entityName))
      return false;
    if (__isset.poolPath != rhs.__isset.poolPath)
      return false;
    else if (__isset.poolPath && !(poolPath == rhs.poolPath))
      return false;
    if (__isset.ordering != rhs.__isset.ordering)
      return false;
    else if (__isset.ordering && !(ordering == rhs.ordering))
      return false;
    return true;
  }
  bool operator != (const WMMapping &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMMapping & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMMapping &a, WMMapping &b);

inline std::ostream& operator<<(std::ostream& out, const WMMapping& obj)
{
  obj.printTo(out);
  return out;
}


class WMPoolTrigger {
 public:

  WMPoolTrigger(const WMPoolTrigger&);
  WMPoolTrigger& operator=(const WMPoolTrigger&);
  WMPoolTrigger() : pool(), trigger() {
  }

  virtual ~WMPoolTrigger() throw();
  std::string pool;
  std::string trigger;

  void __set_pool(const std::string& val);

  void __set_trigger(const std::string& val);

  bool operator == (const WMPoolTrigger & rhs) const
  {
    if (!(pool == rhs.pool))
      return false;
    if (!(trigger == rhs.trigger))
      return false;
    return true;
  }
  bool operator != (const WMPoolTrigger &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMPoolTrigger & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMPoolTrigger &a, WMPoolTrigger &b);

inline std::ostream& operator<<(std::ostream& out, const WMPoolTrigger& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMFullResourcePlan__isset {
  _WMFullResourcePlan__isset() : mappings(false), triggers(false), poolTriggers(false) {}
  bool mappings :1;
  bool triggers :1;
  bool poolTriggers :1;
} _WMFullResourcePlan__isset;

class WMFullResourcePlan {
 public:

  WMFullResourcePlan(const WMFullResourcePlan&);
  WMFullResourcePlan& operator=(const WMFullResourcePlan&);
  WMFullResourcePlan() {
  }

  virtual ~WMFullResourcePlan() throw();
  WMResourcePlan plan;
  std::vector<WMPool>  pools;
  std::vector<WMMapping>  mappings;
  std::vector<WMTrigger>  triggers;
  std::vector<WMPoolTrigger>  poolTriggers;

  _WMFullResourcePlan__isset __isset;

  void __set_plan(const WMResourcePlan& val);

  void __set_pools(const std::vector<WMPool> & val);

  void __set_mappings(const std::vector<WMMapping> & val);

  void __set_triggers(const std::vector<WMTrigger> & val);

  void __set_poolTriggers(const std::vector<WMPoolTrigger> & val);

  bool operator == (const WMFullResourcePlan & rhs) const
  {
    if (!(plan == rhs.plan))
      return false;
    if (!(pools == rhs.pools))
      return false;
    if (__isset.mappings != rhs.__isset.mappings)
      return false;
    else if (__isset.mappings && !(mappings == rhs.mappings))
      return false;
    if (__isset.triggers != rhs.__isset.triggers)
      return false;
    else if (__isset.triggers && !(triggers == rhs.triggers))
      return false;
    if (__isset.poolTriggers != rhs.__isset.poolTriggers)
      return false;
    else if (__isset.poolTriggers && !(poolTriggers == rhs.poolTriggers))
      return false;
    return true;
  }
  bool operator != (const WMFullResourcePlan &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMFullResourcePlan & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMFullResourcePlan &a, WMFullResourcePlan &b);

inline std::ostream& operator<<(std::ostream& out, const WMFullResourcePlan& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMCreateResourcePlanRequest__isset {
  _WMCreateResourcePlanRequest__isset() : resourcePlan(false), copyFrom(false) {}
  bool resourcePlan :1;
  bool copyFrom :1;
} _WMCreateResourcePlanRequest__isset;

class WMCreateResourcePlanRequest {
 public:

  WMCreateResourcePlanRequest(const WMCreateResourcePlanRequest&);
  WMCreateResourcePlanRequest& operator=(const WMCreateResourcePlanRequest&);
  WMCreateResourcePlanRequest() : copyFrom() {
  }

  virtual ~WMCreateResourcePlanRequest() throw();
  WMResourcePlan resourcePlan;
  std::string copyFrom;

  _WMCreateResourcePlanRequest__isset __isset;

  void __set_resourcePlan(const WMResourcePlan& val);

  void __set_copyFrom(const std::string& val);

  bool operator == (const WMCreateResourcePlanRequest & rhs) const
  {
    if (__isset.resourcePlan != rhs.__isset.resourcePlan)
      return false;
    else if (__isset.resourcePlan && !(resourcePlan == rhs.resourcePlan))
      return false;
    if (__isset.copyFrom != rhs.__isset.copyFrom)
      return false;
    else if (__isset.copyFrom && !(copyFrom == rhs.copyFrom))
      return false;
    return true;
  }
  bool operator != (const WMCreateResourcePlanRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMCreateResourcePlanRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMCreateResourcePlanRequest &a, WMCreateResourcePlanRequest &b);

inline std::ostream& operator<<(std::ostream& out, const WMCreateResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


class WMCreateResourcePlanResponse {
 public:

  WMCreateResourcePlanResponse(const WMCreateResourcePlanResponse&);
  WMCreateResourcePlanResponse& operator=(const WMCreateResourcePlanResponse&);
  WMCreateResourcePlanResponse() {
  }

  virtual ~WMCreateResourcePlanResponse() throw();

  bool operator == (const WMCreateResourcePlanResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMCreateResourcePlanResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMCreateResourcePlanResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMCreateResourcePlanResponse &a, WMCreateResourcePlanResponse &b);

inline std::ostream& operator<<(std::ostream& out, const WMCreateResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


class WMGetActiveResourcePlanRequest {
 public:

  WMGetActiveResourcePlanRequest(const WMGetActiveResourcePlanRequest&);
  WMGetActiveResourcePlanRequest& operator=(const WMGetActiveResourcePlanRequest&);
  WMGetActiveResourcePlanRequest() {
  }

  virtual ~WMGetActiveResourcePlanRequest() throw();

  bool operator == (const WMGetActiveResourcePlanRequest & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMGetActiveResourcePlanRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMGetActiveResourcePlanRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMGetActiveResourcePlanRequest &a, WMGetActiveResourcePlanRequest &b);

inline std::ostream& operator<<(std::ostream& out, const WMGetActiveResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMGetActiveResourcePlanResponse__isset {
  _WMGetActiveResourcePlanResponse__isset() : resourcePlan(false) {}
  bool resourcePlan :1;
} _WMGetActiveResourcePlanResponse__isset;

class WMGetActiveResourcePlanResponse {
 public:

  WMGetActiveResourcePlanResponse(const WMGetActiveResourcePlanResponse&);
  WMGetActiveResourcePlanResponse& operator=(const WMGetActiveResourcePlanResponse&);
  WMGetActiveResourcePlanResponse() {
  }

  virtual ~WMGetActiveResourcePlanResponse() throw();
  WMFullResourcePlan resourcePlan;

  _WMGetActiveResourcePlanResponse__isset __isset;

  void __set_resourcePlan(const WMFullResourcePlan& val);

  bool operator == (const WMGetActiveResourcePlanResponse & rhs) const
  {
    if (__isset.resourcePlan != rhs.__isset.resourcePlan)
      return false;
    else if (__isset.resourcePlan && !(resourcePlan == rhs.resourcePlan))
      return false;
    return true;
  }
  bool operator != (const WMGetActiveResourcePlanResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMGetActiveResourcePlanResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMGetActiveResourcePlanResponse &a, WMGetActiveResourcePlanResponse &b);

inline std::ostream& operator<<(std::ostream& out, const WMGetActiveResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMGetResourcePlanRequest__isset {
  _WMGetResourcePlanRequest__isset() : resourcePlanName(false) {}
  bool resourcePlanName :1;
} _WMGetResourcePlanRequest__isset;

class WMGetResourcePlanRequest {
 public:

  WMGetResourcePlanRequest(const WMGetResourcePlanRequest&);
  WMGetResourcePlanRequest& operator=(const WMGetResourcePlanRequest&);
  WMGetResourcePlanRequest() : resourcePlanName() {
  }

  virtual ~WMGetResourcePlanRequest() throw();
  std::string resourcePlanName;

  _WMGetResourcePlanRequest__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  bool operator == (const WMGetResourcePlanRequest & rhs) const
  {
    if (__isset.resourcePlanName != rhs.__isset.resourcePlanName)
      return false;
    else if (__isset.resourcePlanName && !(resourcePlanName == rhs.resourcePlanName))
      return false;
    return true;
  }
  bool operator != (const WMGetResourcePlanRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMGetResourcePlanRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMGetResourcePlanRequest &a, WMGetResourcePlanRequest &b);

inline std::ostream& operator<<(std::ostream& out, const WMGetResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMGetResourcePlanResponse__isset {
  _WMGetResourcePlanResponse__isset() : resourcePlan(false) {}
  bool resourcePlan :1;
} _WMGetResourcePlanResponse__isset;

class WMGetResourcePlanResponse {
 public:

  WMGetResourcePlanResponse(const WMGetResourcePlanResponse&);
  WMGetResourcePlanResponse& operator=(const WMGetResourcePlanResponse&);
  WMGetResourcePlanResponse() {
  }

  virtual ~WMGetResourcePlanResponse() throw();
  WMFullResourcePlan resourcePlan;

  _WMGetResourcePlanResponse__isset __isset;

  void __set_resourcePlan(const WMFullResourcePlan& val);

  bool operator == (const WMGetResourcePlanResponse & rhs) const
  {
    if (__isset.resourcePlan != rhs.__isset.resourcePlan)
      return false;
    else if (__isset.resourcePlan && !(resourcePlan == rhs.resourcePlan))
      return false;
    return true;
  }
  bool operator != (const WMGetResourcePlanResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMGetResourcePlanResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMGetResourcePlanResponse &a, WMGetResourcePlanResponse &b);

inline std::ostream& operator<<(std::ostream& out, const WMGetResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


class WMGetAllResourcePlanRequest {
 public:

  WMGetAllResourcePlanRequest(const WMGetAllResourcePlanRequest&);
  WMGetAllResourcePlanRequest& operator=(const WMGetAllResourcePlanRequest&);
  WMGetAllResourcePlanRequest() {
  }

  virtual ~WMGetAllResourcePlanRequest() throw();

  bool operator == (const WMGetAllResourcePlanRequest & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMGetAllResourcePlanRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMGetAllResourcePlanRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMGetAllResourcePlanRequest &a, WMGetAllResourcePlanRequest &b);

inline std::ostream& operator<<(std::ostream& out, const WMGetAllResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMGetAllResourcePlanResponse__isset {
  _WMGetAllResourcePlanResponse__isset() : resourcePlans(false) {}
  bool resourcePlans :1;
} _WMGetAllResourcePlanResponse__isset;

class WMGetAllResourcePlanResponse {
 public:

  WMGetAllResourcePlanResponse(const WMGetAllResourcePlanResponse&);
  WMGetAllResourcePlanResponse& operator=(const WMGetAllResourcePlanResponse&);
  WMGetAllResourcePlanResponse() {
  }

  virtual ~WMGetAllResourcePlanResponse() throw();
  std::vector<WMResourcePlan>  resourcePlans;

  _WMGetAllResourcePlanResponse__isset __isset;

  void __set_resourcePlans(const std::vector<WMResourcePlan> & val);

  bool operator == (const WMGetAllResourcePlanResponse & rhs) const
  {
    if (__isset.resourcePlans != rhs.__isset.resourcePlans)
      return false;
    else if (__isset.resourcePlans && !(resourcePlans == rhs.resourcePlans))
      return false;
    return true;
  }
  bool operator != (const WMGetAllResourcePlanResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMGetAllResourcePlanResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMGetAllResourcePlanResponse &a, WMGetAllResourcePlanResponse &b);

inline std::ostream& operator<<(std::ostream& out, const WMGetAllResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMAlterResourcePlanRequest__isset {
  _WMAlterResourcePlanRequest__isset() : resourcePlanName(false), resourcePlan(false), isEnableAndActivate(false), isForceDeactivate(false), isReplace(false) {}
  bool resourcePlanName :1;
  bool resourcePlan :1;
  bool isEnableAndActivate :1;
  bool isForceDeactivate :1;
  bool isReplace :1;
} _WMAlterResourcePlanRequest__isset;

class WMAlterResourcePlanRequest {
 public:

  WMAlterResourcePlanRequest(const WMAlterResourcePlanRequest&);
  WMAlterResourcePlanRequest& operator=(const WMAlterResourcePlanRequest&);
  WMAlterResourcePlanRequest() : resourcePlanName(), isEnableAndActivate(0), isForceDeactivate(0), isReplace(0) {
  }

  virtual ~WMAlterResourcePlanRequest() throw();
  std::string resourcePlanName;
  WMNullableResourcePlan resourcePlan;
  bool isEnableAndActivate;
  bool isForceDeactivate;
  bool isReplace;

  _WMAlterResourcePlanRequest__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  void __set_resourcePlan(const WMNullableResourcePlan& val);

  void __set_isEnableAndActivate(const bool val);

  void __set_isForceDeactivate(const bool val);

  void __set_isReplace(const bool val);

  bool operator == (const WMAlterResourcePlanRequest & rhs) const
  {
    if (__isset.resourcePlanName != rhs.__isset.resourcePlanName)
      return false;
    else if (__isset.resourcePlanName && !(resourcePlanName == rhs.resourcePlanName))
      return false;
    if (__isset.resourcePlan != rhs.__isset.resourcePlan)
      return false;
    else if (__isset.resourcePlan && !(resourcePlan == rhs.resourcePlan))
      return false;
    if (__isset.isEnableAndActivate != rhs.__isset.isEnableAndActivate)
      return false;
    else if (__isset.isEnableAndActivate && !(isEnableAndActivate == rhs.isEnableAndActivate))
      return false;
    if (__isset.isForceDeactivate != rhs.__isset.isForceDeactivate)
      return false;
    else if (__isset.isForceDeactivate && !(isForceDeactivate == rhs.isForceDeactivate))
      return false;
    if (__isset.isReplace != rhs.__isset.isReplace)
      return false;
    else if (__isset.isReplace && !(isReplace == rhs.isReplace))
      return false;
    return true;
  }
  bool operator != (const WMAlterResourcePlanRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMAlterResourcePlanRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMAlterResourcePlanRequest &a, WMAlterResourcePlanRequest &b);

inline std::ostream& operator<<(std::ostream& out, const WMAlterResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMAlterResourcePlanResponse__isset {
  _WMAlterResourcePlanResponse__isset() : fullResourcePlan(false) {}
  bool fullResourcePlan :1;
} _WMAlterResourcePlanResponse__isset;

class WMAlterResourcePlanResponse {
 public:

  WMAlterResourcePlanResponse(const WMAlterResourcePlanResponse&);
  WMAlterResourcePlanResponse& operator=(const WMAlterResourcePlanResponse&);
  WMAlterResourcePlanResponse() {
  }

  virtual ~WMAlterResourcePlanResponse() throw();
  WMFullResourcePlan fullResourcePlan;

  _WMAlterResourcePlanResponse__isset __isset;

  void __set_fullResourcePlan(const WMFullResourcePlan& val);

  bool operator == (const WMAlterResourcePlanResponse & rhs) const
  {
    if (__isset.fullResourcePlan != rhs.__isset.fullResourcePlan)
      return false;
    else if (__isset.fullResourcePlan && !(fullResourcePlan == rhs.fullResourcePlan))
      return false;
    return true;
  }
  bool operator != (const WMAlterResourcePlanResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMAlterResourcePlanResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMAlterResourcePlanResponse &a, WMAlterResourcePlanResponse &b);

inline std::ostream& operator<<(std::ostream& out, const WMAlterResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMValidateResourcePlanRequest__isset {
  _WMValidateResourcePlanRequest__isset() : resourcePlanName(false) {}
  bool resourcePlanName :1;
} _WMValidateResourcePlanRequest__isset;

class WMValidateResourcePlanRequest {
 public:

  WMValidateResourcePlanRequest(const WMValidateResourcePlanRequest&);
  WMValidateResourcePlanRequest& operator=(const WMValidateResourcePlanRequest&);
  WMValidateResourcePlanRequest() : resourcePlanName() {
  }

  virtual ~WMValidateResourcePlanRequest() throw();
  std::string resourcePlanName;

  _WMValidateResourcePlanRequest__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  bool operator == (const WMValidateResourcePlanRequest & rhs) const
  {
    if (__isset.resourcePlanName != rhs.__isset.resourcePlanName)
      return false;
    else if (__isset.resourcePlanName && !(resourcePlanName == rhs.resourcePlanName))
      return false;
    return true;
  }
  bool operator != (const WMValidateResourcePlanRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMValidateResourcePlanRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMValidateResourcePlanRequest &a, WMValidateResourcePlanRequest &b);

inline std::ostream& operator<<(std::ostream& out, const WMValidateResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMValidateResourcePlanResponse__isset {
  _WMValidateResourcePlanResponse__isset() : errors(false), warnings(false) {}
  bool errors :1;
  bool warnings :1;
} _WMValidateResourcePlanResponse__isset;

class WMValidateResourcePlanResponse {
 public:

  WMValidateResourcePlanResponse(const WMValidateResourcePlanResponse&);
  WMValidateResourcePlanResponse& operator=(const WMValidateResourcePlanResponse&);
  WMValidateResourcePlanResponse() {
  }

  virtual ~WMValidateResourcePlanResponse() throw();
  std::vector<std::string>  errors;
  std::vector<std::string>  warnings;

  _WMValidateResourcePlanResponse__isset __isset;

  void __set_errors(const std::vector<std::string> & val);

  void __set_warnings(const std::vector<std::string> & val);

  bool operator == (const WMValidateResourcePlanResponse & rhs) const
  {
    if (__isset.errors != rhs.__isset.errors)
      return false;
    else if (__isset.errors && !(errors == rhs.errors))
      return false;
    if (__isset.warnings != rhs.__isset.warnings)
      return false;
    else if (__isset.warnings && !(warnings == rhs.warnings))
      return false;
    return true;
  }
  bool operator != (const WMValidateResourcePlanResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMValidateResourcePlanResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMValidateResourcePlanResponse &a, WMValidateResourcePlanResponse &b);

inline std::ostream& operator<<(std::ostream& out, const WMValidateResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMDropResourcePlanRequest__isset {
  _WMDropResourcePlanRequest__isset() : resourcePlanName(false) {}
  bool resourcePlanName :1;
} _WMDropResourcePlanRequest__isset;

class WMDropResourcePlanRequest {
 public:

  WMDropResourcePlanRequest(const WMDropResourcePlanRequest&);
  WMDropResourcePlanRequest& operator=(const WMDropResourcePlanRequest&);
  WMDropResourcePlanRequest() : resourcePlanName() {
  }

  virtual ~WMDropResourcePlanRequest() throw();
  std::string resourcePlanName;

  _WMDropResourcePlanRequest__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  bool operator == (const WMDropResourcePlanRequest & rhs) const
  {
    if (__isset.resourcePlanName != rhs.__isset.resourcePlanName)
      return false;
    else if (__isset.resourcePlanName && !(resourcePlanName == rhs.resourcePlanName))
      return false;
    return true;
  }
  bool operator != (const WMDropResourcePlanRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMDropResourcePlanRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMDropResourcePlanRequest &a, WMDropResourcePlanRequest &b);

inline std::ostream& operator<<(std::ostream& out, const WMDropResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


class WMDropResourcePlanResponse {
 public:

  WMDropResourcePlanResponse(const WMDropResourcePlanResponse&);
  WMDropResourcePlanResponse& operator=(const WMDropResourcePlanResponse&);
  WMDropResourcePlanResponse() {
  }

  virtual ~WMDropResourcePlanResponse() throw();

  bool operator == (const WMDropResourcePlanResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMDropResourcePlanResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMDropResourcePlanResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMDropResourcePlanResponse &a, WMDropResourcePlanResponse &b);

inline std::ostream& operator<<(std::ostream& out, const WMDropResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMCreateTriggerRequest__isset {
  _WMCreateTriggerRequest__isset() : trigger(false) {}
  bool trigger :1;
} _WMCreateTriggerRequest__isset;

class WMCreateTriggerRequest {
 public:

  WMCreateTriggerRequest(const WMCreateTriggerRequest&);
  WMCreateTriggerRequest& operator=(const WMCreateTriggerRequest&);
  WMCreateTriggerRequest() {
  }

  virtual ~WMCreateTriggerRequest() throw();
  WMTrigger trigger;

  _WMCreateTriggerRequest__isset __isset;

  void __set_trigger(const WMTrigger& val);

  bool operator == (const WMCreateTriggerRequest & rhs) const
  {
    if (__isset.trigger != rhs.__isset.trigger)
      return false;
    else if (__isset.trigger && !(trigger == rhs.trigger))
      return false;
    return true;
  }
  bool operator != (const WMCreateTriggerRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMCreateTriggerRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMCreateTriggerRequest &a, WMCreateTriggerRequest &b);

inline std::ostream& operator<<(std::ostream& out, const WMCreateTriggerRequest& obj)
{
  obj.printTo(out);
  return out;
}


class WMCreateTriggerResponse {
 public:

  WMCreateTriggerResponse(const WMCreateTriggerResponse&);
  WMCreateTriggerResponse& operator=(const WMCreateTriggerResponse&);
  WMCreateTriggerResponse() {
  }

  virtual ~WMCreateTriggerResponse() throw();

  bool operator == (const WMCreateTriggerResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMCreateTriggerResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMCreateTriggerResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMCreateTriggerResponse &a, WMCreateTriggerResponse &b);

inline std::ostream& operator<<(std::ostream& out, const WMCreateTriggerResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMAlterTriggerRequest__isset {
  _WMAlterTriggerRequest__isset() : trigger(false) {}
  bool trigger :1;
} _WMAlterTriggerRequest__isset;

class WMAlterTriggerRequest {
 public:

  WMAlterTriggerRequest(const WMAlterTriggerRequest&);
  WMAlterTriggerRequest& operator=(const WMAlterTriggerRequest&);
  WMAlterTriggerRequest() {
  }

  virtual ~WMAlterTriggerRequest() throw();
  WMTrigger trigger;

  _WMAlterTriggerRequest__isset __isset;

  void __set_trigger(const WMTrigger& val);

  bool operator == (const WMAlterTriggerRequest & rhs) const
  {
    if (__isset.trigger != rhs.__isset.trigger)
      return false;
    else if (__isset.trigger && !(trigger == rhs.trigger))
      return false;
    return true;
  }
  bool operator != (const WMAlterTriggerRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMAlterTriggerRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMAlterTriggerRequest &a, WMAlterTriggerRequest &b);

inline std::ostream& operator<<(std::ostream& out, const WMAlterTriggerRequest& obj)
{
  obj.printTo(out);
  return out;
}


class WMAlterTriggerResponse {
 public:

  WMAlterTriggerResponse(const WMAlterTriggerResponse&);
  WMAlterTriggerResponse& operator=(const WMAlterTriggerResponse&);
  WMAlterTriggerResponse() {
  }

  virtual ~WMAlterTriggerResponse() throw();

  bool operator == (const WMAlterTriggerResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMAlterTriggerResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMAlterTriggerResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMAlterTriggerResponse &a, WMAlterTriggerResponse &b);

inline std::ostream& operator<<(std::ostream& out, const WMAlterTriggerResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMDropTriggerRequest__isset {
  _WMDropTriggerRequest__isset() : resourcePlanName(false), triggerName(false) {}
  bool resourcePlanName :1;
  bool triggerName :1;
} _WMDropTriggerRequest__isset;

class WMDropTriggerRequest {
 public:

  WMDropTriggerRequest(const WMDropTriggerRequest&);
  WMDropTriggerRequest& operator=(const WMDropTriggerRequest&);
  WMDropTriggerRequest() : resourcePlanName(), triggerName() {
  }

  virtual ~WMDropTriggerRequest() throw();
  std::string resourcePlanName;
  std::string triggerName;

  _WMDropTriggerRequest__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  void __set_triggerName(const std::string& val);

  bool operator == (const WMDropTriggerRequest & rhs) const
  {
    if (__isset.resourcePlanName != rhs.__isset.resourcePlanName)
      return false;
    else if (__isset.resourcePlanName && !(resourcePlanName == rhs.resourcePlanName))
      return false;
    if (__isset.triggerName != rhs.__isset.triggerName)
      return false;
    else if (__isset.triggerName && !(triggerName == rhs.triggerName))
      return false;
    return true;
  }
  bool operator != (const WMDropTriggerRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMDropTriggerRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMDropTriggerRequest &a, WMDropTriggerRequest &b);

inline std::ostream& operator<<(std::ostream& out, const WMDropTriggerRequest& obj)
{
  obj.printTo(out);
  return out;
}


class WMDropTriggerResponse {
 public:

  WMDropTriggerResponse(const WMDropTriggerResponse&);
  WMDropTriggerResponse& operator=(const WMDropTriggerResponse&);
  WMDropTriggerResponse() {
  }

  virtual ~WMDropTriggerResponse() throw();

  bool operator == (const WMDropTriggerResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMDropTriggerResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMDropTriggerResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMDropTriggerResponse &a, WMDropTriggerResponse &b);

inline std::ostream& operator<<(std::ostream& out, const WMDropTriggerResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMGetTriggersForResourePlanRequest__isset {
  _WMGetTriggersForResourePlanRequest__isset() : resourcePlanName(false) {}
  bool resourcePlanName :1;
} _WMGetTriggersForResourePlanRequest__isset;

class WMGetTriggersForResourePlanRequest {
 public:

  WMGetTriggersForResourePlanRequest(const WMGetTriggersForResourePlanRequest&);
  WMGetTriggersForResourePlanRequest& operator=(const WMGetTriggersForResourePlanRequest&);
  WMGetTriggersForResourePlanRequest() : resourcePlanName() {
  }

  virtual ~WMGetTriggersForResourePlanRequest() throw();
  std::string resourcePlanName;

  _WMGetTriggersForResourePlanRequest__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  bool operator == (const WMGetTriggersForResourePlanRequest & rhs) const
  {
    if (__isset.resourcePlanName != rhs.__isset.resourcePlanName)
      return false;
    else if (__isset.resourcePlanName && !(resourcePlanName == rhs.resourcePlanName))
      return false;
    return true;
  }
  bool operator != (const WMGetTriggersForResourePlanRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMGetTriggersForResourePlanRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMGetTriggersForResourePlanRequest &a, WMGetTriggersForResourePlanRequest &b);

inline std::ostream& operator<<(std::ostream& out, const WMGetTriggersForResourePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMGetTriggersForResourePlanResponse__isset {
  _WMGetTriggersForResourePlanResponse__isset() : triggers(false) {}
  bool triggers :1;
} _WMGetTriggersForResourePlanResponse__isset;

class WMGetTriggersForResourePlanResponse {
 public:

  WMGetTriggersForResourePlanResponse(const WMGetTriggersForResourePlanResponse&);
  WMGetTriggersForResourePlanResponse& operator=(const WMGetTriggersForResourePlanResponse&);
  WMGetTriggersForResourePlanResponse() {
  }

  virtual ~WMGetTriggersForResourePlanResponse() throw();
  std::vector<WMTrigger>  triggers;

  _WMGetTriggersForResourePlanResponse__isset __isset;

  void __set_triggers(const std::vector<WMTrigger> & val);

  bool operator == (const WMGetTriggersForResourePlanResponse & rhs) const
  {
    if (__isset.triggers != rhs.__isset.triggers)
      return false;
    else if (__isset.triggers && !(triggers == rhs.triggers))
      return false;
    return true;
  }
  bool operator != (const WMGetTriggersForResourePlanResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMGetTriggersForResourePlanResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMGetTriggersForResourePlanResponse &a, WMGetTriggersForResourePlanResponse &b);

inline std::ostream& operator<<(std::ostream& out, const WMGetTriggersForResourePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMCreatePoolRequest__isset {
  _WMCreatePoolRequest__isset() : pool(false) {}
  bool pool :1;
} _WMCreatePoolRequest__isset;

class WMCreatePoolRequest {
 public:

  WMCreatePoolRequest(const WMCreatePoolRequest&);
  WMCreatePoolRequest& operator=(const WMCreatePoolRequest&);
  WMCreatePoolRequest() {
  }

  virtual ~WMCreatePoolRequest() throw();
  WMPool pool;

  _WMCreatePoolRequest__isset __isset;

  void __set_pool(const WMPool& val);

  bool operator == (const WMCreatePoolRequest & rhs) const
  {
    if (__isset.pool != rhs.__isset.pool)
      return false;
    else if (__isset.pool && !(pool == rhs.pool))
      return false;
    return true;
  }
  bool operator != (const WMCreatePoolRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMCreatePoolRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMCreatePoolRequest &a, WMCreatePoolRequest &b);

inline std::ostream& operator<<(std::ostream& out, const WMCreatePoolRequest& obj)
{
  obj.printTo(out);
  return out;
}


class WMCreatePoolResponse {
 public:

  WMCreatePoolResponse(const WMCreatePoolResponse&);
  WMCreatePoolResponse& operator=(const WMCreatePoolResponse&);
  WMCreatePoolResponse() {
  }

  virtual ~WMCreatePoolResponse() throw();

  bool operator == (const WMCreatePoolResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMCreatePoolResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMCreatePoolResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMCreatePoolResponse &a, WMCreatePoolResponse &b);

inline std::ostream& operator<<(std::ostream& out, const WMCreatePoolResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMAlterPoolRequest__isset {
  _WMAlterPoolRequest__isset() : pool(false), poolPath(false) {}
  bool pool :1;
  bool poolPath :1;
} _WMAlterPoolRequest__isset;

class WMAlterPoolRequest {
 public:

  WMAlterPoolRequest(const WMAlterPoolRequest&);
  WMAlterPoolRequest& operator=(const WMAlterPoolRequest&);
  WMAlterPoolRequest() : poolPath() {
  }

  virtual ~WMAlterPoolRequest() throw();
  WMNullablePool pool;
  std::string poolPath;

  _WMAlterPoolRequest__isset __isset;

  void __set_pool(const WMNullablePool& val);

  void __set_poolPath(const std::string& val);

  bool operator == (const WMAlterPoolRequest & rhs) const
  {
    if (__isset.pool != rhs.__isset.pool)
      return false;
    else if (__isset.pool && !(pool == rhs.pool))
      return false;
    if (__isset.poolPath != rhs.__isset.poolPath)
      return false;
    else if (__isset.poolPath && !(poolPath == rhs.poolPath))
      return false;
    return true;
  }
  bool operator != (const WMAlterPoolRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMAlterPoolRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMAlterPoolRequest &a, WMAlterPoolRequest &b);

inline std::ostream& operator<<(std::ostream& out, const WMAlterPoolRequest& obj)
{
  obj.printTo(out);
  return out;
}


class WMAlterPoolResponse {
 public:

  WMAlterPoolResponse(const WMAlterPoolResponse&);
  WMAlterPoolResponse& operator=(const WMAlterPoolResponse&);
  WMAlterPoolResponse() {
  }

  virtual ~WMAlterPoolResponse() throw();

  bool operator == (const WMAlterPoolResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMAlterPoolResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMAlterPoolResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMAlterPoolResponse &a, WMAlterPoolResponse &b);

inline std::ostream& operator<<(std::ostream& out, const WMAlterPoolResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMDropPoolRequest__isset {
  _WMDropPoolRequest__isset() : resourcePlanName(false), poolPath(false) {}
  bool resourcePlanName :1;
  bool poolPath :1;
} _WMDropPoolRequest__isset;

class WMDropPoolRequest {
 public:

  WMDropPoolRequest(const WMDropPoolRequest&);
  WMDropPoolRequest& operator=(const WMDropPoolRequest&);
  WMDropPoolRequest() : resourcePlanName(), poolPath() {
  }

  virtual ~WMDropPoolRequest() throw();
  std::string resourcePlanName;
  std::string poolPath;

  _WMDropPoolRequest__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  void __set_poolPath(const std::string& val);

  bool operator == (const WMDropPoolRequest & rhs) const
  {
    if (__isset.resourcePlanName != rhs.__isset.resourcePlanName)
      return false;
    else if (__isset.resourcePlanName && !(resourcePlanName == rhs.resourcePlanName))
      return false;
    if (__isset.poolPath != rhs.__isset.poolPath)
      return false;
    else if (__isset.poolPath && !(poolPath == rhs.poolPath))
      return false;
    return true;
  }
  bool operator != (const WMDropPoolRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMDropPoolRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMDropPoolRequest &a, WMDropPoolRequest &b);

inline std::ostream& operator<<(std::ostream& out, const WMDropPoolRequest& obj)
{
  obj.printTo(out);
  return out;
}


class WMDropPoolResponse {
 public:

  WMDropPoolResponse(const WMDropPoolResponse&);
  WMDropPoolResponse& operator=(const WMDropPoolResponse&);
  WMDropPoolResponse() {
  }

  virtual ~WMDropPoolResponse() throw();

  bool operator == (const WMDropPoolResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMDropPoolResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMDropPoolResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMDropPoolResponse &a, WMDropPoolResponse &b);

inline std::ostream& operator<<(std::ostream& out, const WMDropPoolResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMCreateOrUpdateMappingRequest__isset {
  _WMCreateOrUpdateMappingRequest__isset() : mapping(false), update(false) {}
  bool mapping :1;
  bool update :1;
} _WMCreateOrUpdateMappingRequest__isset;

class WMCreateOrUpdateMappingRequest {
 public:

  WMCreateOrUpdateMappingRequest(const WMCreateOrUpdateMappingRequest&);
  WMCreateOrUpdateMappingRequest& operator=(const WMCreateOrUpdateMappingRequest&);
  WMCreateOrUpdateMappingRequest() : update(0) {
  }

  virtual ~WMCreateOrUpdateMappingRequest() throw();
  WMMapping mapping;
  bool update;

  _WMCreateOrUpdateMappingRequest__isset __isset;

  void __set_mapping(const WMMapping& val);

  void __set_update(const bool val);

  bool operator == (const WMCreateOrUpdateMappingRequest & rhs) const
  {
    if (__isset.mapping != rhs.__isset.mapping)
      return false;
    else if (__isset.mapping && !(mapping == rhs.mapping))
      return false;
    if (__isset.update != rhs.__isset.update)
      return false;
    else if (__isset.update && !(update == rhs.update))
      return false;
    return true;
  }
  bool operator != (const WMCreateOrUpdateMappingRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMCreateOrUpdateMappingRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMCreateOrUpdateMappingRequest &a, WMCreateOrUpdateMappingRequest &b);

inline std::ostream& operator<<(std::ostream& out, const WMCreateOrUpdateMappingRequest& obj)
{
  obj.printTo(out);
  return out;
}


class WMCreateOrUpdateMappingResponse {
 public:

  WMCreateOrUpdateMappingResponse(const WMCreateOrUpdateMappingResponse&);
  WMCreateOrUpdateMappingResponse& operator=(const WMCreateOrUpdateMappingResponse&);
  WMCreateOrUpdateMappingResponse() {
  }

  virtual ~WMCreateOrUpdateMappingResponse() throw();

  bool operator == (const WMCreateOrUpdateMappingResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMCreateOrUpdateMappingResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMCreateOrUpdateMappingResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMCreateOrUpdateMappingResponse &a, WMCreateOrUpdateMappingResponse &b);

inline std::ostream& operator<<(std::ostream& out, const WMCreateOrUpdateMappingResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMDropMappingRequest__isset {
  _WMDropMappingRequest__isset() : mapping(false) {}
  bool mapping :1;
} _WMDropMappingRequest__isset;

class WMDropMappingRequest {
 public:

  WMDropMappingRequest(const WMDropMappingRequest&);
  WMDropMappingRequest& operator=(const WMDropMappingRequest&);
  WMDropMappingRequest() {
  }

  virtual ~WMDropMappingRequest() throw();
  WMMapping mapping;

  _WMDropMappingRequest__isset __isset;

  void __set_mapping(const WMMapping& val);

  bool operator == (const WMDropMappingRequest & rhs) const
  {
    if (__isset.mapping != rhs.__isset.mapping)
      return false;
    else if (__isset.mapping && !(mapping == rhs.mapping))
      return false;
    return true;
  }
  bool operator != (const WMDropMappingRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMDropMappingRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMDropMappingRequest &a, WMDropMappingRequest &b);

inline std::ostream& operator<<(std::ostream& out, const WMDropMappingRequest& obj)
{
  obj.printTo(out);
  return out;
}


class WMDropMappingResponse {
 public:

  WMDropMappingResponse(const WMDropMappingResponse&);
  WMDropMappingResponse& operator=(const WMDropMappingResponse&);
  WMDropMappingResponse() {
  }

  virtual ~WMDropMappingResponse() throw();

  bool operator == (const WMDropMappingResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMDropMappingResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMDropMappingResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMDropMappingResponse &a, WMDropMappingResponse &b);

inline std::ostream& operator<<(std::ostream& out, const WMDropMappingResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WMCreateOrDropTriggerToPoolMappingRequest__isset {
  _WMCreateOrDropTriggerToPoolMappingRequest__isset() : resourcePlanName(false), triggerName(false), poolPath(false), drop(false) {}
  bool resourcePlanName :1;
  bool triggerName :1;
  bool poolPath :1;
  bool drop :1;
} _WMCreateOrDropTriggerToPoolMappingRequest__isset;

class WMCreateOrDropTriggerToPoolMappingRequest {
 public:

  WMCreateOrDropTriggerToPoolMappingRequest(const WMCreateOrDropTriggerToPoolMappingRequest&);
  WMCreateOrDropTriggerToPoolMappingRequest& operator=(const WMCreateOrDropTriggerToPoolMappingRequest&);
  WMCreateOrDropTriggerToPoolMappingRequest() : resourcePlanName(), triggerName(), poolPath(), drop(0) {
  }

  virtual ~WMCreateOrDropTriggerToPoolMappingRequest() throw();
  std::string resourcePlanName;
  std::string triggerName;
  std::string poolPath;
  bool drop;

  _WMCreateOrDropTriggerToPoolMappingRequest__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  void __set_triggerName(const std::string& val);

  void __set_poolPath(const std::string& val);

  void __set_drop(const bool val);

  bool operator == (const WMCreateOrDropTriggerToPoolMappingRequest & rhs) const
  {
    if (__isset.resourcePlanName != rhs.__isset.resourcePlanName)
      return false;
    else if (__isset.resourcePlanName && !(resourcePlanName == rhs.resourcePlanName))
      return false;
    if (__isset.triggerName != rhs.__isset.triggerName)
      return false;
    else if (__isset.triggerName && !(triggerName == rhs.triggerName))
      return false;
    if (__isset.poolPath != rhs.__isset.poolPath)
      return false;
    else if (__isset.poolPath && !(poolPath == rhs.poolPath))
      return false;
    if (__isset.drop != rhs.__isset.drop)
      return false;
    else if (__isset.drop && !(drop == rhs.drop))
      return false;
    return true;
  }
  bool operator != (const WMCreateOrDropTriggerToPoolMappingRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMCreateOrDropTriggerToPoolMappingRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMCreateOrDropTriggerToPoolMappingRequest &a, WMCreateOrDropTriggerToPoolMappingRequest &b);

inline std::ostream& operator<<(std::ostream& out, const WMCreateOrDropTriggerToPoolMappingRequest& obj)
{
  obj.printTo(out);
  return out;
}


class WMCreateOrDropTriggerToPoolMappingResponse {
 public:

  WMCreateOrDropTriggerToPoolMappingResponse(const WMCreateOrDropTriggerToPoolMappingResponse&);
  WMCreateOrDropTriggerToPoolMappingResponse& operator=(const WMCreateOrDropTriggerToPoolMappingResponse&);
  WMCreateOrDropTriggerToPoolMappingResponse() {
  }

  virtual ~WMCreateOrDropTriggerToPoolMappingResponse() throw();

  bool operator == (const WMCreateOrDropTriggerToPoolMappingResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMCreateOrDropTriggerToPoolMappingResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMCreateOrDropTriggerToPoolMappingResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMCreateOrDropTriggerToPoolMappingResponse &a, WMCreateOrDropTriggerToPoolMappingResponse &b);

inline std::ostream& operator<<(std::ostream& out, const WMCreateOrDropTriggerToPoolMappingResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ISchema__isset {
  _ISchema__isset() : schemaType(false), name(false), catName(false), dbName(false), compatibility(false), validationLevel(false), canEvolve(false), schemaGroup(false), description(false) {}
  bool schemaType :1;
  bool name :1;
  bool catName :1;
  bool dbName :1;
  bool compatibility :1;
  bool validationLevel :1;
  bool canEvolve :1;
  bool schemaGroup :1;
  bool description :1;
} _ISchema__isset;

class ISchema {
 public:

  ISchema(const ISchema&);
  ISchema& operator=(const ISchema&);
  ISchema() : schemaType((SchemaType::type)0), name(), catName(), dbName(), compatibility((SchemaCompatibility::type)0), validationLevel((SchemaValidation::type)0), canEvolve(0), schemaGroup(), description() {
  }

  virtual ~ISchema() throw();
  SchemaType::type schemaType;
  std::string name;
  std::string catName;
  std::string dbName;
  SchemaCompatibility::type compatibility;
  SchemaValidation::type validationLevel;
  bool canEvolve;
  std::string schemaGroup;
  std::string description;

  _ISchema__isset __isset;

  void __set_schemaType(const SchemaType::type val);

  void __set_name(const std::string& val);

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_compatibility(const SchemaCompatibility::type val);

  void __set_validationLevel(const SchemaValidation::type val);

  void __set_canEvolve(const bool val);

  void __set_schemaGroup(const std::string& val);

  void __set_description(const std::string& val);

  bool operator == (const ISchema & rhs) const
  {
    if (!(schemaType == rhs.schemaType))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(compatibility == rhs.compatibility))
      return false;
    if (!(validationLevel == rhs.validationLevel))
      return false;
    if (!(canEvolve == rhs.canEvolve))
      return false;
    if (__isset.schemaGroup != rhs.__isset.schemaGroup)
      return false;
    else if (__isset.schemaGroup && !(schemaGroup == rhs.schemaGroup))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    return true;
  }
  bool operator != (const ISchema &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ISchema & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ISchema &a, ISchema &b);

inline std::ostream& operator<<(std::ostream& out, const ISchema& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ISchemaName__isset {
  _ISchemaName__isset() : catName(false), dbName(false), schemaName(false) {}
  bool catName :1;
  bool dbName :1;
  bool schemaName :1;
} _ISchemaName__isset;

class ISchemaName {
 public:

  ISchemaName(const ISchemaName&);
  ISchemaName& operator=(const ISchemaName&);
  ISchemaName() : catName(), dbName(), schemaName() {
  }

  virtual ~ISchemaName() throw();
  std::string catName;
  std::string dbName;
  std::string schemaName;

  _ISchemaName__isset __isset;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_schemaName(const std::string& val);

  bool operator == (const ISchemaName & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(schemaName == rhs.schemaName))
      return false;
    return true;
  }
  bool operator != (const ISchemaName &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ISchemaName & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ISchemaName &a, ISchemaName &b);

inline std::ostream& operator<<(std::ostream& out, const ISchemaName& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _AlterISchemaRequest__isset {
  _AlterISchemaRequest__isset() : name(false), newSchema(false) {}
  bool name :1;
  bool newSchema :1;
} _AlterISchemaRequest__isset;

class AlterISchemaRequest {
 public:

  AlterISchemaRequest(const AlterISchemaRequest&);
  AlterISchemaRequest& operator=(const AlterISchemaRequest&);
  AlterISchemaRequest() {
  }

  virtual ~AlterISchemaRequest() throw();
  ISchemaName name;
  ISchema newSchema;

  _AlterISchemaRequest__isset __isset;

  void __set_name(const ISchemaName& val);

  void __set_newSchema(const ISchema& val);

  bool operator == (const AlterISchemaRequest & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(newSchema == rhs.newSchema))
      return false;
    return true;
  }
  bool operator != (const AlterISchemaRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AlterISchemaRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AlterISchemaRequest &a, AlterISchemaRequest &b);

inline std::ostream& operator<<(std::ostream& out, const AlterISchemaRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SchemaVersion__isset {
  _SchemaVersion__isset() : schema(false), version(false), createdAt(false), cols(false), state(false), description(false), schemaText(false), fingerprint(false), name(false), serDe(false) {}
  bool schema :1;
  bool version :1;
  bool createdAt :1;
  bool cols :1;
  bool state :1;
  bool description :1;
  bool schemaText :1;
  bool fingerprint :1;
  bool name :1;
  bool serDe :1;
} _SchemaVersion__isset;

class SchemaVersion {
 public:

  SchemaVersion(const SchemaVersion&);
  SchemaVersion& operator=(const SchemaVersion&);
  SchemaVersion() : version(0), createdAt(0), state((SchemaVersionState::type)0), description(), schemaText(), fingerprint(), name() {
  }

  virtual ~SchemaVersion() throw();
  ISchemaName schema;
  int32_t version;
  int64_t createdAt;
  std::vector<FieldSchema>  cols;
  SchemaVersionState::type state;
  std::string description;
  std::string schemaText;
  std::string fingerprint;
  std::string name;
  SerDeInfo serDe;

  _SchemaVersion__isset __isset;

  void __set_schema(const ISchemaName& val);

  void __set_version(const int32_t val);

  void __set_createdAt(const int64_t val);

  void __set_cols(const std::vector<FieldSchema> & val);

  void __set_state(const SchemaVersionState::type val);

  void __set_description(const std::string& val);

  void __set_schemaText(const std::string& val);

  void __set_fingerprint(const std::string& val);

  void __set_name(const std::string& val);

  void __set_serDe(const SerDeInfo& val);

  bool operator == (const SchemaVersion & rhs) const
  {
    if (!(schema == rhs.schema))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(createdAt == rhs.createdAt))
      return false;
    if (!(cols == rhs.cols))
      return false;
    if (__isset.state != rhs.__isset.state)
      return false;
    else if (__isset.state && !(state == rhs.state))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    if (__isset.schemaText != rhs.__isset.schemaText)
      return false;
    else if (__isset.schemaText && !(schemaText == rhs.schemaText))
      return false;
    if (__isset.fingerprint != rhs.__isset.fingerprint)
      return false;
    else if (__isset.fingerprint && !(fingerprint == rhs.fingerprint))
      return false;
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.serDe != rhs.__isset.serDe)
      return false;
    else if (__isset.serDe && !(serDe == rhs.serDe))
      return false;
    return true;
  }
  bool operator != (const SchemaVersion &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SchemaVersion & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SchemaVersion &a, SchemaVersion &b);

inline std::ostream& operator<<(std::ostream& out, const SchemaVersion& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SchemaVersionDescriptor__isset {
  _SchemaVersionDescriptor__isset() : schema(false), version(false) {}
  bool schema :1;
  bool version :1;
} _SchemaVersionDescriptor__isset;

class SchemaVersionDescriptor {
 public:

  SchemaVersionDescriptor(const SchemaVersionDescriptor&);
  SchemaVersionDescriptor& operator=(const SchemaVersionDescriptor&);
  SchemaVersionDescriptor() : version(0) {
  }

  virtual ~SchemaVersionDescriptor() throw();
  ISchemaName schema;
  int32_t version;

  _SchemaVersionDescriptor__isset __isset;

  void __set_schema(const ISchemaName& val);

  void __set_version(const int32_t val);

  bool operator == (const SchemaVersionDescriptor & rhs) const
  {
    if (!(schema == rhs.schema))
      return false;
    if (!(version == rhs.version))
      return false;
    return true;
  }
  bool operator != (const SchemaVersionDescriptor &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SchemaVersionDescriptor & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SchemaVersionDescriptor &a, SchemaVersionDescriptor &b);

inline std::ostream& operator<<(std::ostream& out, const SchemaVersionDescriptor& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _FindSchemasByColsRqst__isset {
  _FindSchemasByColsRqst__isset() : colName(false), colNamespace(false), type(false) {}
  bool colName :1;
  bool colNamespace :1;
  bool type :1;
} _FindSchemasByColsRqst__isset;

class FindSchemasByColsRqst {
 public:

  FindSchemasByColsRqst(const FindSchemasByColsRqst&);
  FindSchemasByColsRqst& operator=(const FindSchemasByColsRqst&);
  FindSchemasByColsRqst() : colName(), colNamespace(), type() {
  }

  virtual ~FindSchemasByColsRqst() throw();
  std::string colName;
  std::string colNamespace;
  std::string type;

  _FindSchemasByColsRqst__isset __isset;

  void __set_colName(const std::string& val);

  void __set_colNamespace(const std::string& val);

  void __set_type(const std::string& val);

  bool operator == (const FindSchemasByColsRqst & rhs) const
  {
    if (__isset.colName != rhs.__isset.colName)
      return false;
    else if (__isset.colName && !(colName == rhs.colName))
      return false;
    if (__isset.colNamespace != rhs.__isset.colNamespace)
      return false;
    else if (__isset.colNamespace && !(colNamespace == rhs.colNamespace))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const FindSchemasByColsRqst &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FindSchemasByColsRqst & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FindSchemasByColsRqst &a, FindSchemasByColsRqst &b);

inline std::ostream& operator<<(std::ostream& out, const FindSchemasByColsRqst& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _FindSchemasByColsResp__isset {
  _FindSchemasByColsResp__isset() : schemaVersions(false) {}
  bool schemaVersions :1;
} _FindSchemasByColsResp__isset;

class FindSchemasByColsResp {
 public:

  FindSchemasByColsResp(const FindSchemasByColsResp&);
  FindSchemasByColsResp& operator=(const FindSchemasByColsResp&);
  FindSchemasByColsResp() {
  }

  virtual ~FindSchemasByColsResp() throw();
  std::vector<SchemaVersionDescriptor>  schemaVersions;

  _FindSchemasByColsResp__isset __isset;

  void __set_schemaVersions(const std::vector<SchemaVersionDescriptor> & val);

  bool operator == (const FindSchemasByColsResp & rhs) const
  {
    if (!(schemaVersions == rhs.schemaVersions))
      return false;
    return true;
  }
  bool operator != (const FindSchemasByColsResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FindSchemasByColsResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FindSchemasByColsResp &a, FindSchemasByColsResp &b);

inline std::ostream& operator<<(std::ostream& out, const FindSchemasByColsResp& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _MapSchemaVersionToSerdeRequest__isset {
  _MapSchemaVersionToSerdeRequest__isset() : schemaVersion(false), serdeName(false) {}
  bool schemaVersion :1;
  bool serdeName :1;
} _MapSchemaVersionToSerdeRequest__isset;

class MapSchemaVersionToSerdeRequest {
 public:

  MapSchemaVersionToSerdeRequest(const MapSchemaVersionToSerdeRequest&);
  MapSchemaVersionToSerdeRequest& operator=(const MapSchemaVersionToSerdeRequest&);
  MapSchemaVersionToSerdeRequest() : serdeName() {
  }

  virtual ~MapSchemaVersionToSerdeRequest() throw();
  SchemaVersionDescriptor schemaVersion;
  std::string serdeName;

  _MapSchemaVersionToSerdeRequest__isset __isset;

  void __set_schemaVersion(const SchemaVersionDescriptor& val);

  void __set_serdeName(const std::string& val);

  bool operator == (const MapSchemaVersionToSerdeRequest & rhs) const
  {
    if (!(schemaVersion == rhs.schemaVersion))
      return false;
    if (!(serdeName == rhs.serdeName))
      return false;
    return true;
  }
  bool operator != (const MapSchemaVersionToSerdeRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MapSchemaVersionToSerdeRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MapSchemaVersionToSerdeRequest &a, MapSchemaVersionToSerdeRequest &b);

inline std::ostream& operator<<(std::ostream& out, const MapSchemaVersionToSerdeRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SetSchemaVersionStateRequest__isset {
  _SetSchemaVersionStateRequest__isset() : schemaVersion(false), state(false) {}
  bool schemaVersion :1;
  bool state :1;
} _SetSchemaVersionStateRequest__isset;

class SetSchemaVersionStateRequest {
 public:

  SetSchemaVersionStateRequest(const SetSchemaVersionStateRequest&);
  SetSchemaVersionStateRequest& operator=(const SetSchemaVersionStateRequest&);
  SetSchemaVersionStateRequest() : state((SchemaVersionState::type)0) {
  }

  virtual ~SetSchemaVersionStateRequest() throw();
  SchemaVersionDescriptor schemaVersion;
  SchemaVersionState::type state;

  _SetSchemaVersionStateRequest__isset __isset;

  void __set_schemaVersion(const SchemaVersionDescriptor& val);

  void __set_state(const SchemaVersionState::type val);

  bool operator == (const SetSchemaVersionStateRequest & rhs) const
  {
    if (!(schemaVersion == rhs.schemaVersion))
      return false;
    if (!(state == rhs.state))
      return false;
    return true;
  }
  bool operator != (const SetSchemaVersionStateRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SetSchemaVersionStateRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SetSchemaVersionStateRequest &a, SetSchemaVersionStateRequest &b);

inline std::ostream& operator<<(std::ostream& out, const SetSchemaVersionStateRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GetSerdeRequest__isset {
  _GetSerdeRequest__isset() : serdeName(false) {}
  bool serdeName :1;
} _GetSerdeRequest__isset;

class GetSerdeRequest {
 public:

  GetSerdeRequest(const GetSerdeRequest&);
  GetSerdeRequest& operator=(const GetSerdeRequest&);
  GetSerdeRequest() : serdeName() {
  }

  virtual ~GetSerdeRequest() throw();
  std::string serdeName;

  _GetSerdeRequest__isset __isset;

  void __set_serdeName(const std::string& val);

  bool operator == (const GetSerdeRequest & rhs) const
  {
    if (!(serdeName == rhs.serdeName))
      return false;
    return true;
  }
  bool operator != (const GetSerdeRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetSerdeRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetSerdeRequest &a, GetSerdeRequest &b);

inline std::ostream& operator<<(std::ostream& out, const GetSerdeRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _MetaException__isset {
  _MetaException__isset() : message(false) {}
  bool message :1;
} _MetaException__isset;

class MetaException : public ::apache::thrift::TException {
 public:

  MetaException(const MetaException&);
  MetaException& operator=(const MetaException&);
  MetaException() : message() {
  }

  virtual ~MetaException() throw();
  std::string message;

  _MetaException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const MetaException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const MetaException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MetaException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(MetaException &a, MetaException &b);

inline std::ostream& operator<<(std::ostream& out, const MetaException& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _UnknownTableException__isset {
  _UnknownTableException__isset() : message(false) {}
  bool message :1;
} _UnknownTableException__isset;

class UnknownTableException : public ::apache::thrift::TException {
 public:

  UnknownTableException(const UnknownTableException&);
  UnknownTableException& operator=(const UnknownTableException&);
  UnknownTableException() : message() {
  }

  virtual ~UnknownTableException() throw();
  std::string message;

  _UnknownTableException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const UnknownTableException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const UnknownTableException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnknownTableException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(UnknownTableException &a, UnknownTableException &b);

inline std::ostream& operator<<(std::ostream& out, const UnknownTableException& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _UnknownDBException__isset {
  _UnknownDBException__isset() : message(false) {}
  bool message :1;
} _UnknownDBException__isset;

class UnknownDBException : public ::apache::thrift::TException {
 public:

  UnknownDBException(const UnknownDBException&);
  UnknownDBException& operator=(const UnknownDBException&);
  UnknownDBException() : message() {
  }

  virtual ~UnknownDBException() throw();
  std::string message;

  _UnknownDBException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const UnknownDBException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const UnknownDBException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnknownDBException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(UnknownDBException &a, UnknownDBException &b);

inline std::ostream& operator<<(std::ostream& out, const UnknownDBException& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _AlreadyExistsException__isset {
  _AlreadyExistsException__isset() : message(false) {}
  bool message :1;
} _AlreadyExistsException__isset;

class AlreadyExistsException : public ::apache::thrift::TException {
 public:

  AlreadyExistsException(const AlreadyExistsException&);
  AlreadyExistsException& operator=(const AlreadyExistsException&);
  AlreadyExistsException() : message() {
  }

  virtual ~AlreadyExistsException() throw();
  std::string message;

  _AlreadyExistsException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const AlreadyExistsException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const AlreadyExistsException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AlreadyExistsException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(AlreadyExistsException &a, AlreadyExistsException &b);

inline std::ostream& operator<<(std::ostream& out, const AlreadyExistsException& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _InvalidPartitionException__isset {
  _InvalidPartitionException__isset() : message(false) {}
  bool message :1;
} _InvalidPartitionException__isset;

class InvalidPartitionException : public ::apache::thrift::TException {
 public:

  InvalidPartitionException(const InvalidPartitionException&);
  InvalidPartitionException& operator=(const InvalidPartitionException&);
  InvalidPartitionException() : message() {
  }

  virtual ~InvalidPartitionException() throw();
  std::string message;

  _InvalidPartitionException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const InvalidPartitionException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const InvalidPartitionException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidPartitionException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(InvalidPartitionException &a, InvalidPartitionException &b);

inline std::ostream& operator<<(std::ostream& out, const InvalidPartitionException& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _UnknownPartitionException__isset {
  _UnknownPartitionException__isset() : message(false) {}
  bool message :1;
} _UnknownPartitionException__isset;

class UnknownPartitionException : public ::apache::thrift::TException {
 public:

  UnknownPartitionException(const UnknownPartitionException&);
  UnknownPartitionException& operator=(const UnknownPartitionException&);
  UnknownPartitionException() : message() {
  }

  virtual ~UnknownPartitionException() throw();
  std::string message;

  _UnknownPartitionException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const UnknownPartitionException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const UnknownPartitionException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnknownPartitionException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(UnknownPartitionException &a, UnknownPartitionException &b);

inline std::ostream& operator<<(std::ostream& out, const UnknownPartitionException& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _InvalidObjectException__isset {
  _InvalidObjectException__isset() : message(false) {}
  bool message :1;
} _InvalidObjectException__isset;

class InvalidObjectException : public ::apache::thrift::TException {
 public:

  InvalidObjectException(const InvalidObjectException&);
  InvalidObjectException& operator=(const InvalidObjectException&);
  InvalidObjectException() : message() {
  }

  virtual ~InvalidObjectException() throw();
  std::string message;

  _InvalidObjectException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const InvalidObjectException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const InvalidObjectException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidObjectException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(InvalidObjectException &a, InvalidObjectException &b);

inline std::ostream& operator<<(std::ostream& out, const InvalidObjectException& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NoSuchObjectException__isset {
  _NoSuchObjectException__isset() : message(false) {}
  bool message :1;
} _NoSuchObjectException__isset;

class NoSuchObjectException : public ::apache::thrift::TException {
 public:

  NoSuchObjectException(const NoSuchObjectException&);
  NoSuchObjectException& operator=(const NoSuchObjectException&);
  NoSuchObjectException() : message() {
  }

  virtual ~NoSuchObjectException() throw();
  std::string message;

  _NoSuchObjectException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const NoSuchObjectException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const NoSuchObjectException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoSuchObjectException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(NoSuchObjectException &a, NoSuchObjectException &b);

inline std::ostream& operator<<(std::ostream& out, const NoSuchObjectException& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _InvalidOperationException__isset {
  _InvalidOperationException__isset() : message(false) {}
  bool message :1;
} _InvalidOperationException__isset;

class InvalidOperationException : public ::apache::thrift::TException {
 public:

  InvalidOperationException(const InvalidOperationException&);
  InvalidOperationException& operator=(const InvalidOperationException&);
  InvalidOperationException() : message() {
  }

  virtual ~InvalidOperationException() throw();
  std::string message;

  _InvalidOperationException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const InvalidOperationException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const InvalidOperationException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidOperationException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(InvalidOperationException &a, InvalidOperationException &b);

inline std::ostream& operator<<(std::ostream& out, const InvalidOperationException& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ConfigValSecurityException__isset {
  _ConfigValSecurityException__isset() : message(false) {}
  bool message :1;
} _ConfigValSecurityException__isset;

class ConfigValSecurityException : public ::apache::thrift::TException {
 public:

  ConfigValSecurityException(const ConfigValSecurityException&);
  ConfigValSecurityException& operator=(const ConfigValSecurityException&);
  ConfigValSecurityException() : message() {
  }

  virtual ~ConfigValSecurityException() throw();
  std::string message;

  _ConfigValSecurityException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const ConfigValSecurityException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const ConfigValSecurityException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ConfigValSecurityException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(ConfigValSecurityException &a, ConfigValSecurityException &b);

inline std::ostream& operator<<(std::ostream& out, const ConfigValSecurityException& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _InvalidInputException__isset {
  _InvalidInputException__isset() : message(false) {}
  bool message :1;
} _InvalidInputException__isset;

class InvalidInputException : public ::apache::thrift::TException {
 public:

  InvalidInputException(const InvalidInputException&);
  InvalidInputException& operator=(const InvalidInputException&);
  InvalidInputException() : message() {
  }

  virtual ~InvalidInputException() throw();
  std::string message;

  _InvalidInputException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const InvalidInputException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const InvalidInputException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidInputException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(InvalidInputException &a, InvalidInputException &b);

inline std::ostream& operator<<(std::ostream& out, const InvalidInputException& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NoSuchTxnException__isset {
  _NoSuchTxnException__isset() : message(false) {}
  bool message :1;
} _NoSuchTxnException__isset;

class NoSuchTxnException : public ::apache::thrift::TException {
 public:

  NoSuchTxnException(const NoSuchTxnException&);
  NoSuchTxnException& operator=(const NoSuchTxnException&);
  NoSuchTxnException() : message() {
  }

  virtual ~NoSuchTxnException() throw();
  std::string message;

  _NoSuchTxnException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const NoSuchTxnException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const NoSuchTxnException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoSuchTxnException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(NoSuchTxnException &a, NoSuchTxnException &b);

inline std::ostream& operator<<(std::ostream& out, const NoSuchTxnException& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TxnAbortedException__isset {
  _TxnAbortedException__isset() : message(false) {}
  bool message :1;
} _TxnAbortedException__isset;

class TxnAbortedException : public ::apache::thrift::TException {
 public:

  TxnAbortedException(const TxnAbortedException&);
  TxnAbortedException& operator=(const TxnAbortedException&);
  TxnAbortedException() : message() {
  }

  virtual ~TxnAbortedException() throw();
  std::string message;

  _TxnAbortedException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const TxnAbortedException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const TxnAbortedException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TxnAbortedException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(TxnAbortedException &a, TxnAbortedException &b);

inline std::ostream& operator<<(std::ostream& out, const TxnAbortedException& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TxnOpenException__isset {
  _TxnOpenException__isset() : message(false) {}
  bool message :1;
} _TxnOpenException__isset;

class TxnOpenException : public ::apache::thrift::TException {
 public:

  TxnOpenException(const TxnOpenException&);
  TxnOpenException& operator=(const TxnOpenException&);
  TxnOpenException() : message() {
  }

  virtual ~TxnOpenException() throw();
  std::string message;

  _TxnOpenException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const TxnOpenException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const TxnOpenException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TxnOpenException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(TxnOpenException &a, TxnOpenException &b);

inline std::ostream& operator<<(std::ostream& out, const TxnOpenException& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NoSuchLockException__isset {
  _NoSuchLockException__isset() : message(false) {}
  bool message :1;
} _NoSuchLockException__isset;

class NoSuchLockException : public ::apache::thrift::TException {
 public:

  NoSuchLockException(const NoSuchLockException&);
  NoSuchLockException& operator=(const NoSuchLockException&);
  NoSuchLockException() : message() {
  }

  virtual ~NoSuchLockException() throw();
  std::string message;

  _NoSuchLockException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const NoSuchLockException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const NoSuchLockException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoSuchLockException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(NoSuchLockException &a, NoSuchLockException &b);

inline std::ostream& operator<<(std::ostream& out, const NoSuchLockException& obj)
{
  obj.printTo(out);
  return out;
}

}}} // namespace

#endif
