#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import fb303.FacebookService
import logging
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(fb303.FacebookService.Iface):
  """
  This interface is live.
  """
  def getMetaConf(self, key):
    """
    Parameters:
     - key
    """
    pass

  def setMetaConf(self, key, value):
    """
    Parameters:
     - key
     - value
    """
    pass

  def create_database(self, database):
    """
    Parameters:
     - database
    """
    pass

  def get_database(self, name):
    """
    Parameters:
     - name
    """
    pass

  def drop_database(self, name, deleteData, cascade):
    """
    Parameters:
     - name
     - deleteData
     - cascade
    """
    pass

  def get_databases(self, pattern):
    """
    Parameters:
     - pattern
    """
    pass

  def get_all_databases(self):
    pass

  def alter_database(self, dbname, db):
    """
    Parameters:
     - dbname
     - db
    """
    pass

  def get_type(self, name):
    """
    Parameters:
     - name
    """
    pass

  def create_type(self, type):
    """
    Parameters:
     - type
    """
    pass

  def drop_type(self, type):
    """
    Parameters:
     - type
    """
    pass

  def get_type_all(self, name):
    """
    Parameters:
     - name
    """
    pass

  def get_fields(self, db_name, table_name):
    """
    Parameters:
     - db_name
     - table_name
    """
    pass

  def get_fields_with_environment_context(self, db_name, table_name, environment_context):
    """
    Parameters:
     - db_name
     - table_name
     - environment_context
    """
    pass

  def get_schema(self, db_name, table_name):
    """
    Parameters:
     - db_name
     - table_name
    """
    pass

  def get_schema_with_environment_context(self, db_name, table_name, environment_context):
    """
    Parameters:
     - db_name
     - table_name
     - environment_context
    """
    pass

  def create_table(self, tbl):
    """
    Parameters:
     - tbl
    """
    pass

  def create_table_with_environment_context(self, tbl, environment_context):
    """
    Parameters:
     - tbl
     - environment_context
    """
    pass

  def create_table_with_constraints(self, tbl, primaryKeys, foreignKeys, uniqueConstraints, notNullConstraints):
    """
    Parameters:
     - tbl
     - primaryKeys
     - foreignKeys
     - uniqueConstraints
     - notNullConstraints
    """
    pass

  def drop_constraint(self, req):
    """
    Parameters:
     - req
    """
    pass

  def add_primary_key(self, req):
    """
    Parameters:
     - req
    """
    pass

  def add_foreign_key(self, req):
    """
    Parameters:
     - req
    """
    pass

  def add_unique_constraint(self, req):
    """
    Parameters:
     - req
    """
    pass

  def add_not_null_constraint(self, req):
    """
    Parameters:
     - req
    """
    pass

  def drop_table(self, dbname, name, deleteData):
    """
    Parameters:
     - dbname
     - name
     - deleteData
    """
    pass

  def drop_table_with_environment_context(self, dbname, name, deleteData, environment_context):
    """
    Parameters:
     - dbname
     - name
     - deleteData
     - environment_context
    """
    pass

  def truncate_table(self, dbName, tableName, partNames):
    """
    Parameters:
     - dbName
     - tableName
     - partNames
    """
    pass

  def get_tables(self, db_name, pattern):
    """
    Parameters:
     - db_name
     - pattern
    """
    pass

  def get_tables_by_type(self, db_name, pattern, tableType):
    """
    Parameters:
     - db_name
     - pattern
     - tableType
    """
    pass

  def get_materialized_views_for_rewriting(self, db_name):
    """
    Parameters:
     - db_name
    """
    pass

  def get_table_meta(self, db_patterns, tbl_patterns, tbl_types):
    """
    Parameters:
     - db_patterns
     - tbl_patterns
     - tbl_types
    """
    pass

  def get_all_tables(self, db_name):
    """
    Parameters:
     - db_name
    """
    pass

  def get_table(self, dbname, tbl_name):
    """
    Parameters:
     - dbname
     - tbl_name
    """
    pass

  def get_table_objects_by_name(self, dbname, tbl_names):
    """
    Parameters:
     - dbname
     - tbl_names
    """
    pass

  def get_table_req(self, req):
    """
    Parameters:
     - req
    """
    pass

  def get_table_objects_by_name_req(self, req):
    """
    Parameters:
     - req
    """
    pass

  def get_materialization_invalidation_info(self, dbname, tbl_names):
    """
    Parameters:
     - dbname
     - tbl_names
    """
    pass

  def get_table_names_by_filter(self, dbname, filter, max_tables):
    """
    Parameters:
     - dbname
     - filter
     - max_tables
    """
    pass

  def alter_table(self, dbname, tbl_name, new_tbl):
    """
    Parameters:
     - dbname
     - tbl_name
     - new_tbl
    """
    pass

  def alter_table_with_environment_context(self, dbname, tbl_name, new_tbl, environment_context):
    """
    Parameters:
     - dbname
     - tbl_name
     - new_tbl
     - environment_context
    """
    pass

  def alter_table_with_cascade(self, dbname, tbl_name, new_tbl, cascade):
    """
    Parameters:
     - dbname
     - tbl_name
     - new_tbl
     - cascade
    """
    pass

  def add_partition(self, new_part):
    """
    Parameters:
     - new_part
    """
    pass

  def add_partition_with_environment_context(self, new_part, environment_context):
    """
    Parameters:
     - new_part
     - environment_context
    """
    pass

  def add_partitions(self, new_parts):
    """
    Parameters:
     - new_parts
    """
    pass

  def add_partitions_pspec(self, new_parts):
    """
    Parameters:
     - new_parts
    """
    pass

  def append_partition(self, db_name, tbl_name, part_vals):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
    """
    pass

  def add_partitions_req(self, request):
    """
    Parameters:
     - request
    """
    pass

  def append_partition_with_environment_context(self, db_name, tbl_name, part_vals, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - environment_context
    """
    pass

  def append_partition_by_name(self, db_name, tbl_name, part_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
    """
    pass

  def append_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - environment_context
    """
    pass

  def drop_partition(self, db_name, tbl_name, part_vals, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - deleteData
    """
    pass

  def drop_partition_with_environment_context(self, db_name, tbl_name, part_vals, deleteData, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - deleteData
     - environment_context
    """
    pass

  def drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - deleteData
    """
    pass

  def drop_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, deleteData, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - deleteData
     - environment_context
    """
    pass

  def drop_partitions_req(self, req):
    """
    Parameters:
     - req
    """
    pass

  def get_partition(self, db_name, tbl_name, part_vals):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
    """
    pass

  def exchange_partition(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
    """
    Parameters:
     - partitionSpecs
     - source_db
     - source_table_name
     - dest_db
     - dest_table_name
    """
    pass

  def exchange_partitions(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
    """
    Parameters:
     - partitionSpecs
     - source_db
     - source_table_name
     - dest_db
     - dest_table_name
    """
    pass

  def get_partition_with_auth(self, db_name, tbl_name, part_vals, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - user_name
     - group_names
    """
    pass

  def get_partition_by_name(self, db_name, tbl_name, part_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
    """
    pass

  def get_partitions(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    pass

  def get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
     - user_name
     - group_names
    """
    pass

  def get_partitions_pspec(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    pass

  def get_partition_names(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    pass

  def get_partition_values(self, request):
    """
    Parameters:
     - request
    """
    pass

  def get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """
    pass

  def get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
     - user_name
     - group_names
    """
    pass

  def get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """
    pass

  def get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - filter
     - max_parts
    """
    pass

  def get_part_specs_by_filter(self, db_name, tbl_name, filter, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - filter
     - max_parts
    """
    pass

  def get_partitions_by_expr(self, req):
    """
    Parameters:
     - req
    """
    pass

  def get_num_partitions_by_filter(self, db_name, tbl_name, filter):
    """
    Parameters:
     - db_name
     - tbl_name
     - filter
    """
    pass

  def get_partitions_by_names(self, db_name, tbl_name, names):
    """
    Parameters:
     - db_name
     - tbl_name
     - names
    """
    pass

  def alter_partition(self, db_name, tbl_name, new_part):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_part
    """
    pass

  def alter_partitions(self, db_name, tbl_name, new_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_parts
    """
    pass

  def alter_partitions_with_environment_context(self, db_name, tbl_name, new_parts, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_parts
     - environment_context
    """
    pass

  def alter_partition_with_environment_context(self, db_name, tbl_name, new_part, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_part
     - environment_context
    """
    pass

  def rename_partition(self, db_name, tbl_name, part_vals, new_part):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - new_part
    """
    pass

  def partition_name_has_valid_characters(self, part_vals, throw_exception):
    """
    Parameters:
     - part_vals
     - throw_exception
    """
    pass

  def get_config_value(self, name, defaultValue):
    """
    Parameters:
     - name
     - defaultValue
    """
    pass

  def partition_name_to_vals(self, part_name):
    """
    Parameters:
     - part_name
    """
    pass

  def partition_name_to_spec(self, part_name):
    """
    Parameters:
     - part_name
    """
    pass

  def markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - eventType
    """
    pass

  def isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - eventType
    """
    pass

  def add_index(self, new_index, index_table):
    """
    Parameters:
     - new_index
     - index_table
    """
    pass

  def alter_index(self, dbname, base_tbl_name, idx_name, new_idx):
    """
    Parameters:
     - dbname
     - base_tbl_name
     - idx_name
     - new_idx
    """
    pass

  def drop_index_by_name(self, db_name, tbl_name, index_name, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - index_name
     - deleteData
    """
    pass

  def get_index_by_name(self, db_name, tbl_name, index_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - index_name
    """
    pass

  def get_indexes(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    pass

  def get_index_names(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    pass

  def get_primary_keys(self, request):
    """
    Parameters:
     - request
    """
    pass

  def get_foreign_keys(self, request):
    """
    Parameters:
     - request
    """
    pass

  def get_unique_constraints(self, request):
    """
    Parameters:
     - request
    """
    pass

  def get_not_null_constraints(self, request):
    """
    Parameters:
     - request
    """
    pass

  def update_table_column_statistics(self, stats_obj):
    """
    Parameters:
     - stats_obj
    """
    pass

  def update_partition_column_statistics(self, stats_obj):
    """
    Parameters:
     - stats_obj
    """
    pass

  def get_table_column_statistics(self, db_name, tbl_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - col_name
    """
    pass

  def get_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - col_name
    """
    pass

  def get_table_statistics_req(self, request):
    """
    Parameters:
     - request
    """
    pass

  def get_partitions_statistics_req(self, request):
    """
    Parameters:
     - request
    """
    pass

  def get_aggr_stats_for(self, request):
    """
    Parameters:
     - request
    """
    pass

  def set_aggr_stats_for(self, request):
    """
    Parameters:
     - request
    """
    pass

  def delete_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - col_name
    """
    pass

  def delete_table_column_statistics(self, db_name, tbl_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - col_name
    """
    pass

  def create_function(self, func):
    """
    Parameters:
     - func
    """
    pass

  def drop_function(self, dbName, funcName):
    """
    Parameters:
     - dbName
     - funcName
    """
    pass

  def alter_function(self, dbName, funcName, newFunc):
    """
    Parameters:
     - dbName
     - funcName
     - newFunc
    """
    pass

  def get_functions(self, dbName, pattern):
    """
    Parameters:
     - dbName
     - pattern
    """
    pass

  def get_function(self, dbName, funcName):
    """
    Parameters:
     - dbName
     - funcName
    """
    pass

  def get_all_functions(self):
    pass

  def create_role(self, role):
    """
    Parameters:
     - role
    """
    pass

  def drop_role(self, role_name):
    """
    Parameters:
     - role_name
    """
    pass

  def get_role_names(self):
    pass

  def grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):
    """
    Parameters:
     - role_name
     - principal_name
     - principal_type
     - grantor
     - grantorType
     - grant_option
    """
    pass

  def revoke_role(self, role_name, principal_name, principal_type):
    """
    Parameters:
     - role_name
     - principal_name
     - principal_type
    """
    pass

  def list_roles(self, principal_name, principal_type):
    """
    Parameters:
     - principal_name
     - principal_type
    """
    pass

  def grant_revoke_role(self, request):
    """
    Parameters:
     - request
    """
    pass

  def get_principals_in_role(self, request):
    """
    Parameters:
     - request
    """
    pass

  def get_role_grants_for_principal(self, request):
    """
    Parameters:
     - request
    """
    pass

  def get_privilege_set(self, hiveObject, user_name, group_names):
    """
    Parameters:
     - hiveObject
     - user_name
     - group_names
    """
    pass

  def list_privileges(self, principal_name, principal_type, hiveObject):
    """
    Parameters:
     - principal_name
     - principal_type
     - hiveObject
    """
    pass

  def grant_privileges(self, privileges):
    """
    Parameters:
     - privileges
    """
    pass

  def revoke_privileges(self, privileges):
    """
    Parameters:
     - privileges
    """
    pass

  def grant_revoke_privileges(self, request):
    """
    Parameters:
     - request
    """
    pass

  def set_ugi(self, user_name, group_names):
    """
    Parameters:
     - user_name
     - group_names
    """
    pass

  def get_delegation_token(self, token_owner, renewer_kerberos_principal_name):
    """
    Parameters:
     - token_owner
     - renewer_kerberos_principal_name
    """
    pass

  def renew_delegation_token(self, token_str_form):
    """
    Parameters:
     - token_str_form
    """
    pass

  def cancel_delegation_token(self, token_str_form):
    """
    Parameters:
     - token_str_form
    """
    pass

  def add_token(self, token_identifier, delegation_token):
    """
    Parameters:
     - token_identifier
     - delegation_token
    """
    pass

  def remove_token(self, token_identifier):
    """
    Parameters:
     - token_identifier
    """
    pass

  def get_token(self, token_identifier):
    """
    Parameters:
     - token_identifier
    """
    pass

  def get_all_token_identifiers(self):
    pass

  def add_master_key(self, key):
    """
    Parameters:
     - key
    """
    pass

  def update_master_key(self, seq_number, key):
    """
    Parameters:
     - seq_number
     - key
    """
    pass

  def remove_master_key(self, key_seq):
    """
    Parameters:
     - key_seq
    """
    pass

  def get_master_keys(self):
    pass

  def get_open_txns(self):
    pass

  def get_open_txns_info(self):
    pass

  def open_txns(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def abort_txn(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def abort_txns(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def commit_txn(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def lock(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def check_lock(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def unlock(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def show_locks(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def heartbeat(self, ids):
    """
    Parameters:
     - ids
    """
    pass

  def heartbeat_txn_range(self, txns):
    """
    Parameters:
     - txns
    """
    pass

  def compact(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def compact2(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def show_compact(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def add_dynamic_partitions(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def get_next_notification(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def get_current_notificationEventId(self):
    pass

  def get_notification_events_count(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def fire_listener_event(self, rqst):
    """
    Parameters:
     - rqst
    """
    pass

  def flushCache(self):
    pass

  def cm_recycle(self, request):
    """
    Parameters:
     - request
    """
    pass

  def get_file_metadata_by_expr(self, req):
    """
    Parameters:
     - req
    """
    pass

  def get_file_metadata(self, req):
    """
    Parameters:
     - req
    """
    pass

  def put_file_metadata(self, req):
    """
    Parameters:
     - req
    """
    pass

  def clear_file_metadata(self, req):
    """
    Parameters:
     - req
    """
    pass

  def cache_file_metadata(self, req):
    """
    Parameters:
     - req
    """
    pass

  def get_metastore_db_uuid(self):
    pass

  def create_resource_plan(self, request):
    """
    Parameters:
     - request
    """
    pass

  def get_resource_plan(self, request):
    """
    Parameters:
     - request
    """
    pass

  def get_active_resource_plan(self, request):
    """
    Parameters:
     - request
    """
    pass

  def get_all_resource_plans(self, request):
    """
    Parameters:
     - request
    """
    pass

  def alter_resource_plan(self, request):
    """
    Parameters:
     - request
    """
    pass

  def validate_resource_plan(self, request):
    """
    Parameters:
     - request
    """
    pass

  def drop_resource_plan(self, request):
    """
    Parameters:
     - request
    """
    pass

  def create_wm_trigger(self, request):
    """
    Parameters:
     - request
    """
    pass

  def alter_wm_trigger(self, request):
    """
    Parameters:
     - request
    """
    pass

  def drop_wm_trigger(self, request):
    """
    Parameters:
     - request
    """
    pass

  def get_triggers_for_resourceplan(self, request):
    """
    Parameters:
     - request
    """
    pass

  def create_wm_pool(self, request):
    """
    Parameters:
     - request
    """
    pass

  def alter_wm_pool(self, request):
    """
    Parameters:
     - request
    """
    pass

  def drop_wm_pool(self, request):
    """
    Parameters:
     - request
    """
    pass

  def create_or_update_wm_mapping(self, request):
    """
    Parameters:
     - request
    """
    pass

  def drop_wm_mapping(self, request):
    """
    Parameters:
     - request
    """
    pass

  def create_or_drop_wm_trigger_to_pool_mapping(self, request):
    """
    Parameters:
     - request
    """
    pass


class Client(fb303.FacebookService.Client, Iface):
  """
  This interface is live.
  """
  def __init__(self, iprot, oprot=None):
    fb303.FacebookService.Client.__init__(self, iprot, oprot)

  def getMetaConf(self, key):
    """
    Parameters:
     - key
    """
    self.send_getMetaConf(key)
    return self.recv_getMetaConf()

  def send_getMetaConf(self, key):
    self._oprot.writeMessageBegin('getMetaConf', TMessageType.CALL, self._seqid)
    args = getMetaConf_args()
    args.key = key
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getMetaConf(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getMetaConf_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getMetaConf failed: unknown result")

  def setMetaConf(self, key, value):
    """
    Parameters:
     - key
     - value
    """
    self.send_setMetaConf(key, value)
    self.recv_setMetaConf()

  def send_setMetaConf(self, key, value):
    self._oprot.writeMessageBegin('setMetaConf', TMessageType.CALL, self._seqid)
    args = setMetaConf_args()
    args.key = key
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setMetaConf(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setMetaConf_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    return

  def create_database(self, database):
    """
    Parameters:
     - database
    """
    self.send_create_database(database)
    self.recv_create_database()

  def send_create_database(self, database):
    self._oprot.writeMessageBegin('create_database', TMessageType.CALL, self._seqid)
    args = create_database_args()
    args.database = database
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_database(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_database_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    return

  def get_database(self, name):
    """
    Parameters:
     - name
    """
    self.send_get_database(name)
    return self.recv_get_database()

  def send_get_database(self, name):
    self._oprot.writeMessageBegin('get_database', TMessageType.CALL, self._seqid)
    args = get_database_args()
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_database(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_database_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_database failed: unknown result")

  def drop_database(self, name, deleteData, cascade):
    """
    Parameters:
     - name
     - deleteData
     - cascade
    """
    self.send_drop_database(name, deleteData, cascade)
    self.recv_drop_database()

  def send_drop_database(self, name, deleteData, cascade):
    self._oprot.writeMessageBegin('drop_database', TMessageType.CALL, self._seqid)
    args = drop_database_args()
    args.name = name
    args.deleteData = deleteData
    args.cascade = cascade
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_database(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_database_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    return

  def get_databases(self, pattern):
    """
    Parameters:
     - pattern
    """
    self.send_get_databases(pattern)
    return self.recv_get_databases()

  def send_get_databases(self, pattern):
    self._oprot.writeMessageBegin('get_databases', TMessageType.CALL, self._seqid)
    args = get_databases_args()
    args.pattern = pattern
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_databases(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_databases_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_databases failed: unknown result")

  def get_all_databases(self):
    self.send_get_all_databases()
    return self.recv_get_all_databases()

  def send_get_all_databases(self):
    self._oprot.writeMessageBegin('get_all_databases', TMessageType.CALL, self._seqid)
    args = get_all_databases_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_databases(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_databases_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_databases failed: unknown result")

  def alter_database(self, dbname, db):
    """
    Parameters:
     - dbname
     - db
    """
    self.send_alter_database(dbname, db)
    self.recv_alter_database()

  def send_alter_database(self, dbname, db):
    self._oprot.writeMessageBegin('alter_database', TMessageType.CALL, self._seqid)
    args = alter_database_args()
    args.dbname = dbname
    args.db = db
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_database(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_database_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def get_type(self, name):
    """
    Parameters:
     - name
    """
    self.send_get_type(name)
    return self.recv_get_type()

  def send_get_type(self, name):
    self._oprot.writeMessageBegin('get_type', TMessageType.CALL, self._seqid)
    args = get_type_args()
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_type(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_type_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_type failed: unknown result")

  def create_type(self, type):
    """
    Parameters:
     - type
    """
    self.send_create_type(type)
    return self.recv_create_type()

  def send_create_type(self, type):
    self._oprot.writeMessageBegin('create_type', TMessageType.CALL, self._seqid)
    args = create_type_args()
    args.type = type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_type(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_type_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_type failed: unknown result")

  def drop_type(self, type):
    """
    Parameters:
     - type
    """
    self.send_drop_type(type)
    return self.recv_drop_type()

  def send_drop_type(self, type):
    self._oprot.writeMessageBegin('drop_type', TMessageType.CALL, self._seqid)
    args = drop_type_args()
    args.type = type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_type(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_type_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_type failed: unknown result")

  def get_type_all(self, name):
    """
    Parameters:
     - name
    """
    self.send_get_type_all(name)
    return self.recv_get_type_all()

  def send_get_type_all(self, name):
    self._oprot.writeMessageBegin('get_type_all', TMessageType.CALL, self._seqid)
    args = get_type_all_args()
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_type_all(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_type_all_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_type_all failed: unknown result")

  def get_fields(self, db_name, table_name):
    """
    Parameters:
     - db_name
     - table_name
    """
    self.send_get_fields(db_name, table_name)
    return self.recv_get_fields()

  def send_get_fields(self, db_name, table_name):
    self._oprot.writeMessageBegin('get_fields', TMessageType.CALL, self._seqid)
    args = get_fields_args()
    args.db_name = db_name
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_fields(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_fields_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_fields failed: unknown result")

  def get_fields_with_environment_context(self, db_name, table_name, environment_context):
    """
    Parameters:
     - db_name
     - table_name
     - environment_context
    """
    self.send_get_fields_with_environment_context(db_name, table_name, environment_context)
    return self.recv_get_fields_with_environment_context()

  def send_get_fields_with_environment_context(self, db_name, table_name, environment_context):
    self._oprot.writeMessageBegin('get_fields_with_environment_context', TMessageType.CALL, self._seqid)
    args = get_fields_with_environment_context_args()
    args.db_name = db_name
    args.table_name = table_name
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_fields_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_fields_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_fields_with_environment_context failed: unknown result")

  def get_schema(self, db_name, table_name):
    """
    Parameters:
     - db_name
     - table_name
    """
    self.send_get_schema(db_name, table_name)
    return self.recv_get_schema()

  def send_get_schema(self, db_name, table_name):
    self._oprot.writeMessageBegin('get_schema', TMessageType.CALL, self._seqid)
    args = get_schema_args()
    args.db_name = db_name
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_schema(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_schema_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schema failed: unknown result")

  def get_schema_with_environment_context(self, db_name, table_name, environment_context):
    """
    Parameters:
     - db_name
     - table_name
     - environment_context
    """
    self.send_get_schema_with_environment_context(db_name, table_name, environment_context)
    return self.recv_get_schema_with_environment_context()

  def send_get_schema_with_environment_context(self, db_name, table_name, environment_context):
    self._oprot.writeMessageBegin('get_schema_with_environment_context', TMessageType.CALL, self._seqid)
    args = get_schema_with_environment_context_args()
    args.db_name = db_name
    args.table_name = table_name
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_schema_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_schema_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schema_with_environment_context failed: unknown result")

  def create_table(self, tbl):
    """
    Parameters:
     - tbl
    """
    self.send_create_table(tbl)
    self.recv_create_table()

  def send_create_table(self, tbl):
    self._oprot.writeMessageBegin('create_table', TMessageType.CALL, self._seqid)
    args = create_table_args()
    args.tbl = tbl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_table(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_table_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    return

  def create_table_with_environment_context(self, tbl, environment_context):
    """
    Parameters:
     - tbl
     - environment_context
    """
    self.send_create_table_with_environment_context(tbl, environment_context)
    self.recv_create_table_with_environment_context()

  def send_create_table_with_environment_context(self, tbl, environment_context):
    self._oprot.writeMessageBegin('create_table_with_environment_context', TMessageType.CALL, self._seqid)
    args = create_table_with_environment_context_args()
    args.tbl = tbl
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_table_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_table_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    return

  def create_table_with_constraints(self, tbl, primaryKeys, foreignKeys, uniqueConstraints, notNullConstraints):
    """
    Parameters:
     - tbl
     - primaryKeys
     - foreignKeys
     - uniqueConstraints
     - notNullConstraints
    """
    self.send_create_table_with_constraints(tbl, primaryKeys, foreignKeys, uniqueConstraints, notNullConstraints)
    self.recv_create_table_with_constraints()

  def send_create_table_with_constraints(self, tbl, primaryKeys, foreignKeys, uniqueConstraints, notNullConstraints):
    self._oprot.writeMessageBegin('create_table_with_constraints', TMessageType.CALL, self._seqid)
    args = create_table_with_constraints_args()
    args.tbl = tbl
    args.primaryKeys = primaryKeys
    args.foreignKeys = foreignKeys
    args.uniqueConstraints = uniqueConstraints
    args.notNullConstraints = notNullConstraints
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_table_with_constraints(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_table_with_constraints_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    return

  def drop_constraint(self, req):
    """
    Parameters:
     - req
    """
    self.send_drop_constraint(req)
    self.recv_drop_constraint()

  def send_drop_constraint(self, req):
    self._oprot.writeMessageBegin('drop_constraint', TMessageType.CALL, self._seqid)
    args = drop_constraint_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_constraint(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_constraint_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o3 is not None:
      raise result.o3
    return

  def add_primary_key(self, req):
    """
    Parameters:
     - req
    """
    self.send_add_primary_key(req)
    self.recv_add_primary_key()

  def send_add_primary_key(self, req):
    self._oprot.writeMessageBegin('add_primary_key', TMessageType.CALL, self._seqid)
    args = add_primary_key_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_primary_key(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_primary_key_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def add_foreign_key(self, req):
    """
    Parameters:
     - req
    """
    self.send_add_foreign_key(req)
    self.recv_add_foreign_key()

  def send_add_foreign_key(self, req):
    self._oprot.writeMessageBegin('add_foreign_key', TMessageType.CALL, self._seqid)
    args = add_foreign_key_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_foreign_key(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_foreign_key_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def add_unique_constraint(self, req):
    """
    Parameters:
     - req
    """
    self.send_add_unique_constraint(req)
    self.recv_add_unique_constraint()

  def send_add_unique_constraint(self, req):
    self._oprot.writeMessageBegin('add_unique_constraint', TMessageType.CALL, self._seqid)
    args = add_unique_constraint_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_unique_constraint(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_unique_constraint_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def add_not_null_constraint(self, req):
    """
    Parameters:
     - req
    """
    self.send_add_not_null_constraint(req)
    self.recv_add_not_null_constraint()

  def send_add_not_null_constraint(self, req):
    self._oprot.writeMessageBegin('add_not_null_constraint', TMessageType.CALL, self._seqid)
    args = add_not_null_constraint_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_not_null_constraint(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_not_null_constraint_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def drop_table(self, dbname, name, deleteData):
    """
    Parameters:
     - dbname
     - name
     - deleteData
    """
    self.send_drop_table(dbname, name, deleteData)
    self.recv_drop_table()

  def send_drop_table(self, dbname, name, deleteData):
    self._oprot.writeMessageBegin('drop_table', TMessageType.CALL, self._seqid)
    args = drop_table_args()
    args.dbname = dbname
    args.name = name
    args.deleteData = deleteData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_table(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_table_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o3 is not None:
      raise result.o3
    return

  def drop_table_with_environment_context(self, dbname, name, deleteData, environment_context):
    """
    Parameters:
     - dbname
     - name
     - deleteData
     - environment_context
    """
    self.send_drop_table_with_environment_context(dbname, name, deleteData, environment_context)
    self.recv_drop_table_with_environment_context()

  def send_drop_table_with_environment_context(self, dbname, name, deleteData, environment_context):
    self._oprot.writeMessageBegin('drop_table_with_environment_context', TMessageType.CALL, self._seqid)
    args = drop_table_with_environment_context_args()
    args.dbname = dbname
    args.name = name
    args.deleteData = deleteData
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_table_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_table_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o3 is not None:
      raise result.o3
    return

  def truncate_table(self, dbName, tableName, partNames):
    """
    Parameters:
     - dbName
     - tableName
     - partNames
    """
    self.send_truncate_table(dbName, tableName, partNames)
    self.recv_truncate_table()

  def send_truncate_table(self, dbName, tableName, partNames):
    self._oprot.writeMessageBegin('truncate_table', TMessageType.CALL, self._seqid)
    args = truncate_table_args()
    args.dbName = dbName
    args.tableName = tableName
    args.partNames = partNames
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_truncate_table(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = truncate_table_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    return

  def get_tables(self, db_name, pattern):
    """
    Parameters:
     - db_name
     - pattern
    """
    self.send_get_tables(db_name, pattern)
    return self.recv_get_tables()

  def send_get_tables(self, db_name, pattern):
    self._oprot.writeMessageBegin('get_tables', TMessageType.CALL, self._seqid)
    args = get_tables_args()
    args.db_name = db_name
    args.pattern = pattern
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_tables(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_tables_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tables failed: unknown result")

  def get_tables_by_type(self, db_name, pattern, tableType):
    """
    Parameters:
     - db_name
     - pattern
     - tableType
    """
    self.send_get_tables_by_type(db_name, pattern, tableType)
    return self.recv_get_tables_by_type()

  def send_get_tables_by_type(self, db_name, pattern, tableType):
    self._oprot.writeMessageBegin('get_tables_by_type', TMessageType.CALL, self._seqid)
    args = get_tables_by_type_args()
    args.db_name = db_name
    args.pattern = pattern
    args.tableType = tableType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_tables_by_type(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_tables_by_type_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tables_by_type failed: unknown result")

  def get_materialized_views_for_rewriting(self, db_name):
    """
    Parameters:
     - db_name
    """
    self.send_get_materialized_views_for_rewriting(db_name)
    return self.recv_get_materialized_views_for_rewriting()

  def send_get_materialized_views_for_rewriting(self, db_name):
    self._oprot.writeMessageBegin('get_materialized_views_for_rewriting', TMessageType.CALL, self._seqid)
    args = get_materialized_views_for_rewriting_args()
    args.db_name = db_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_materialized_views_for_rewriting(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_materialized_views_for_rewriting_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_materialized_views_for_rewriting failed: unknown result")

  def get_table_meta(self, db_patterns, tbl_patterns, tbl_types):
    """
    Parameters:
     - db_patterns
     - tbl_patterns
     - tbl_types
    """
    self.send_get_table_meta(db_patterns, tbl_patterns, tbl_types)
    return self.recv_get_table_meta()

  def send_get_table_meta(self, db_patterns, tbl_patterns, tbl_types):
    self._oprot.writeMessageBegin('get_table_meta', TMessageType.CALL, self._seqid)
    args = get_table_meta_args()
    args.db_patterns = db_patterns
    args.tbl_patterns = tbl_patterns
    args.tbl_types = tbl_types
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_meta(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_table_meta_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_meta failed: unknown result")

  def get_all_tables(self, db_name):
    """
    Parameters:
     - db_name
    """
    self.send_get_all_tables(db_name)
    return self.recv_get_all_tables()

  def send_get_all_tables(self, db_name):
    self._oprot.writeMessageBegin('get_all_tables', TMessageType.CALL, self._seqid)
    args = get_all_tables_args()
    args.db_name = db_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_tables(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_tables_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_tables failed: unknown result")

  def get_table(self, dbname, tbl_name):
    """
    Parameters:
     - dbname
     - tbl_name
    """
    self.send_get_table(dbname, tbl_name)
    return self.recv_get_table()

  def send_get_table(self, dbname, tbl_name):
    self._oprot.writeMessageBegin('get_table', TMessageType.CALL, self._seqid)
    args = get_table_args()
    args.dbname = dbname
    args.tbl_name = tbl_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_table_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table failed: unknown result")

  def get_table_objects_by_name(self, dbname, tbl_names):
    """
    Parameters:
     - dbname
     - tbl_names
    """
    self.send_get_table_objects_by_name(dbname, tbl_names)
    return self.recv_get_table_objects_by_name()

  def send_get_table_objects_by_name(self, dbname, tbl_names):
    self._oprot.writeMessageBegin('get_table_objects_by_name', TMessageType.CALL, self._seqid)
    args = get_table_objects_by_name_args()
    args.dbname = dbname
    args.tbl_names = tbl_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_objects_by_name(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_table_objects_by_name_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_objects_by_name failed: unknown result")

  def get_table_req(self, req):
    """
    Parameters:
     - req
    """
    self.send_get_table_req(req)
    return self.recv_get_table_req()

  def send_get_table_req(self, req):
    self._oprot.writeMessageBegin('get_table_req', TMessageType.CALL, self._seqid)
    args = get_table_req_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_req(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_table_req_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_req failed: unknown result")

  def get_table_objects_by_name_req(self, req):
    """
    Parameters:
     - req
    """
    self.send_get_table_objects_by_name_req(req)
    return self.recv_get_table_objects_by_name_req()

  def send_get_table_objects_by_name_req(self, req):
    self._oprot.writeMessageBegin('get_table_objects_by_name_req', TMessageType.CALL, self._seqid)
    args = get_table_objects_by_name_req_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_objects_by_name_req(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_table_objects_by_name_req_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_objects_by_name_req failed: unknown result")

  def get_materialization_invalidation_info(self, dbname, tbl_names):
    """
    Parameters:
     - dbname
     - tbl_names
    """
    self.send_get_materialization_invalidation_info(dbname, tbl_names)
    return self.recv_get_materialization_invalidation_info()

  def send_get_materialization_invalidation_info(self, dbname, tbl_names):
    self._oprot.writeMessageBegin('get_materialization_invalidation_info', TMessageType.CALL, self._seqid)
    args = get_materialization_invalidation_info_args()
    args.dbname = dbname
    args.tbl_names = tbl_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_materialization_invalidation_info(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_materialization_invalidation_info_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_materialization_invalidation_info failed: unknown result")

  def get_table_names_by_filter(self, dbname, filter, max_tables):
    """
    Parameters:
     - dbname
     - filter
     - max_tables
    """
    self.send_get_table_names_by_filter(dbname, filter, max_tables)
    return self.recv_get_table_names_by_filter()

  def send_get_table_names_by_filter(self, dbname, filter, max_tables):
    self._oprot.writeMessageBegin('get_table_names_by_filter', TMessageType.CALL, self._seqid)
    args = get_table_names_by_filter_args()
    args.dbname = dbname
    args.filter = filter
    args.max_tables = max_tables
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_names_by_filter(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_table_names_by_filter_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_names_by_filter failed: unknown result")

  def alter_table(self, dbname, tbl_name, new_tbl):
    """
    Parameters:
     - dbname
     - tbl_name
     - new_tbl
    """
    self.send_alter_table(dbname, tbl_name, new_tbl)
    self.recv_alter_table()

  def send_alter_table(self, dbname, tbl_name, new_tbl):
    self._oprot.writeMessageBegin('alter_table', TMessageType.CALL, self._seqid)
    args = alter_table_args()
    args.dbname = dbname
    args.tbl_name = tbl_name
    args.new_tbl = new_tbl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_table(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_table_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def alter_table_with_environment_context(self, dbname, tbl_name, new_tbl, environment_context):
    """
    Parameters:
     - dbname
     - tbl_name
     - new_tbl
     - environment_context
    """
    self.send_alter_table_with_environment_context(dbname, tbl_name, new_tbl, environment_context)
    self.recv_alter_table_with_environment_context()

  def send_alter_table_with_environment_context(self, dbname, tbl_name, new_tbl, environment_context):
    self._oprot.writeMessageBegin('alter_table_with_environment_context', TMessageType.CALL, self._seqid)
    args = alter_table_with_environment_context_args()
    args.dbname = dbname
    args.tbl_name = tbl_name
    args.new_tbl = new_tbl
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_table_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_table_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def alter_table_with_cascade(self, dbname, tbl_name, new_tbl, cascade):
    """
    Parameters:
     - dbname
     - tbl_name
     - new_tbl
     - cascade
    """
    self.send_alter_table_with_cascade(dbname, tbl_name, new_tbl, cascade)
    self.recv_alter_table_with_cascade()

  def send_alter_table_with_cascade(self, dbname, tbl_name, new_tbl, cascade):
    self._oprot.writeMessageBegin('alter_table_with_cascade', TMessageType.CALL, self._seqid)
    args = alter_table_with_cascade_args()
    args.dbname = dbname
    args.tbl_name = tbl_name
    args.new_tbl = new_tbl
    args.cascade = cascade
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_table_with_cascade(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_table_with_cascade_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def add_partition(self, new_part):
    """
    Parameters:
     - new_part
    """
    self.send_add_partition(new_part)
    return self.recv_add_partition()

  def send_add_partition(self, new_part):
    self._oprot.writeMessageBegin('add_partition', TMessageType.CALL, self._seqid)
    args = add_partition_args()
    args.new_part = new_part
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_partition(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_partition_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partition failed: unknown result")

  def add_partition_with_environment_context(self, new_part, environment_context):
    """
    Parameters:
     - new_part
     - environment_context
    """
    self.send_add_partition_with_environment_context(new_part, environment_context)
    return self.recv_add_partition_with_environment_context()

  def send_add_partition_with_environment_context(self, new_part, environment_context):
    self._oprot.writeMessageBegin('add_partition_with_environment_context', TMessageType.CALL, self._seqid)
    args = add_partition_with_environment_context_args()
    args.new_part = new_part
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_partition_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_partition_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partition_with_environment_context failed: unknown result")

  def add_partitions(self, new_parts):
    """
    Parameters:
     - new_parts
    """
    self.send_add_partitions(new_parts)
    return self.recv_add_partitions()

  def send_add_partitions(self, new_parts):
    self._oprot.writeMessageBegin('add_partitions', TMessageType.CALL, self._seqid)
    args = add_partitions_args()
    args.new_parts = new_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_partitions(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_partitions_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partitions failed: unknown result")

  def add_partitions_pspec(self, new_parts):
    """
    Parameters:
     - new_parts
    """
    self.send_add_partitions_pspec(new_parts)
    return self.recv_add_partitions_pspec()

  def send_add_partitions_pspec(self, new_parts):
    self._oprot.writeMessageBegin('add_partitions_pspec', TMessageType.CALL, self._seqid)
    args = add_partitions_pspec_args()
    args.new_parts = new_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_partitions_pspec(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_partitions_pspec_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partitions_pspec failed: unknown result")

  def append_partition(self, db_name, tbl_name, part_vals):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
    """
    self.send_append_partition(db_name, tbl_name, part_vals)
    return self.recv_append_partition()

  def send_append_partition(self, db_name, tbl_name, part_vals):
    self._oprot.writeMessageBegin('append_partition', TMessageType.CALL, self._seqid)
    args = append_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_append_partition(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = append_partition_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition failed: unknown result")

  def add_partitions_req(self, request):
    """
    Parameters:
     - request
    """
    self.send_add_partitions_req(request)
    return self.recv_add_partitions_req()

  def send_add_partitions_req(self, request):
    self._oprot.writeMessageBegin('add_partitions_req', TMessageType.CALL, self._seqid)
    args = add_partitions_req_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_partitions_req(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_partitions_req_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partitions_req failed: unknown result")

  def append_partition_with_environment_context(self, db_name, tbl_name, part_vals, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - environment_context
    """
    self.send_append_partition_with_environment_context(db_name, tbl_name, part_vals, environment_context)
    return self.recv_append_partition_with_environment_context()

  def send_append_partition_with_environment_context(self, db_name, tbl_name, part_vals, environment_context):
    self._oprot.writeMessageBegin('append_partition_with_environment_context', TMessageType.CALL, self._seqid)
    args = append_partition_with_environment_context_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_append_partition_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = append_partition_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition_with_environment_context failed: unknown result")

  def append_partition_by_name(self, db_name, tbl_name, part_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
    """
    self.send_append_partition_by_name(db_name, tbl_name, part_name)
    return self.recv_append_partition_by_name()

  def send_append_partition_by_name(self, db_name, tbl_name, part_name):
    self._oprot.writeMessageBegin('append_partition_by_name', TMessageType.CALL, self._seqid)
    args = append_partition_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_append_partition_by_name(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = append_partition_by_name_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition_by_name failed: unknown result")

  def append_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - environment_context
    """
    self.send_append_partition_by_name_with_environment_context(db_name, tbl_name, part_name, environment_context)
    return self.recv_append_partition_by_name_with_environment_context()

  def send_append_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, environment_context):
    self._oprot.writeMessageBegin('append_partition_by_name_with_environment_context', TMessageType.CALL, self._seqid)
    args = append_partition_by_name_with_environment_context_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_append_partition_by_name_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = append_partition_by_name_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition_by_name_with_environment_context failed: unknown result")

  def drop_partition(self, db_name, tbl_name, part_vals, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - deleteData
    """
    self.send_drop_partition(db_name, tbl_name, part_vals, deleteData)
    return self.recv_drop_partition()

  def send_drop_partition(self, db_name, tbl_name, part_vals, deleteData):
    self._oprot.writeMessageBegin('drop_partition', TMessageType.CALL, self._seqid)
    args = drop_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.deleteData = deleteData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_partition(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_partition_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition failed: unknown result")

  def drop_partition_with_environment_context(self, db_name, tbl_name, part_vals, deleteData, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - deleteData
     - environment_context
    """
    self.send_drop_partition_with_environment_context(db_name, tbl_name, part_vals, deleteData, environment_context)
    return self.recv_drop_partition_with_environment_context()

  def send_drop_partition_with_environment_context(self, db_name, tbl_name, part_vals, deleteData, environment_context):
    self._oprot.writeMessageBegin('drop_partition_with_environment_context', TMessageType.CALL, self._seqid)
    args = drop_partition_with_environment_context_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.deleteData = deleteData
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_partition_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_partition_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition_with_environment_context failed: unknown result")

  def drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - deleteData
    """
    self.send_drop_partition_by_name(db_name, tbl_name, part_name, deleteData)
    return self.recv_drop_partition_by_name()

  def send_drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
    self._oprot.writeMessageBegin('drop_partition_by_name', TMessageType.CALL, self._seqid)
    args = drop_partition_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.deleteData = deleteData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_partition_by_name(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_partition_by_name_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition_by_name failed: unknown result")

  def drop_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, deleteData, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - deleteData
     - environment_context
    """
    self.send_drop_partition_by_name_with_environment_context(db_name, tbl_name, part_name, deleteData, environment_context)
    return self.recv_drop_partition_by_name_with_environment_context()

  def send_drop_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, deleteData, environment_context):
    self._oprot.writeMessageBegin('drop_partition_by_name_with_environment_context', TMessageType.CALL, self._seqid)
    args = drop_partition_by_name_with_environment_context_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.deleteData = deleteData
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_partition_by_name_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_partition_by_name_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition_by_name_with_environment_context failed: unknown result")

  def drop_partitions_req(self, req):
    """
    Parameters:
     - req
    """
    self.send_drop_partitions_req(req)
    return self.recv_drop_partitions_req()

  def send_drop_partitions_req(self, req):
    self._oprot.writeMessageBegin('drop_partitions_req', TMessageType.CALL, self._seqid)
    args = drop_partitions_req_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_partitions_req(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_partitions_req_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partitions_req failed: unknown result")

  def get_partition(self, db_name, tbl_name, part_vals):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
    """
    self.send_get_partition(db_name, tbl_name, part_vals)
    return self.recv_get_partition()

  def send_get_partition(self, db_name, tbl_name, part_vals):
    self._oprot.writeMessageBegin('get_partition', TMessageType.CALL, self._seqid)
    args = get_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partition_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition failed: unknown result")

  def exchange_partition(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
    """
    Parameters:
     - partitionSpecs
     - source_db
     - source_table_name
     - dest_db
     - dest_table_name
    """
    self.send_exchange_partition(partitionSpecs, source_db, source_table_name, dest_db, dest_table_name)
    return self.recv_exchange_partition()

  def send_exchange_partition(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
    self._oprot.writeMessageBegin('exchange_partition', TMessageType.CALL, self._seqid)
    args = exchange_partition_args()
    args.partitionSpecs = partitionSpecs
    args.source_db = source_db
    args.source_table_name = source_table_name
    args.dest_db = dest_db
    args.dest_table_name = dest_table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_exchange_partition(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = exchange_partition_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "exchange_partition failed: unknown result")

  def exchange_partitions(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
    """
    Parameters:
     - partitionSpecs
     - source_db
     - source_table_name
     - dest_db
     - dest_table_name
    """
    self.send_exchange_partitions(partitionSpecs, source_db, source_table_name, dest_db, dest_table_name)
    return self.recv_exchange_partitions()

  def send_exchange_partitions(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
    self._oprot.writeMessageBegin('exchange_partitions', TMessageType.CALL, self._seqid)
    args = exchange_partitions_args()
    args.partitionSpecs = partitionSpecs
    args.source_db = source_db
    args.source_table_name = source_table_name
    args.dest_db = dest_db
    args.dest_table_name = dest_table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_exchange_partitions(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = exchange_partitions_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "exchange_partitions failed: unknown result")

  def get_partition_with_auth(self, db_name, tbl_name, part_vals, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - user_name
     - group_names
    """
    self.send_get_partition_with_auth(db_name, tbl_name, part_vals, user_name, group_names)
    return self.recv_get_partition_with_auth()

  def send_get_partition_with_auth(self, db_name, tbl_name, part_vals, user_name, group_names):
    self._oprot.writeMessageBegin('get_partition_with_auth', TMessageType.CALL, self._seqid)
    args = get_partition_with_auth_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.user_name = user_name
    args.group_names = group_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_with_auth(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partition_with_auth_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_with_auth failed: unknown result")

  def get_partition_by_name(self, db_name, tbl_name, part_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
    """
    self.send_get_partition_by_name(db_name, tbl_name, part_name)
    return self.recv_get_partition_by_name()

  def send_get_partition_by_name(self, db_name, tbl_name, part_name):
    self._oprot.writeMessageBegin('get_partition_by_name', TMessageType.CALL, self._seqid)
    args = get_partition_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_by_name(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partition_by_name_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_by_name failed: unknown result")

  def get_partitions(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    self.send_get_partitions(db_name, tbl_name, max_parts)
    return self.recv_get_partitions()

  def send_get_partitions(self, db_name, tbl_name, max_parts):
    self._oprot.writeMessageBegin('get_partitions', TMessageType.CALL, self._seqid)
    args = get_partitions_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partitions_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions failed: unknown result")

  def get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
     - user_name
     - group_names
    """
    self.send_get_partitions_with_auth(db_name, tbl_name, max_parts, user_name, group_names)
    return self.recv_get_partitions_with_auth()

  def send_get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):
    self._oprot.writeMessageBegin('get_partitions_with_auth', TMessageType.CALL, self._seqid)
    args = get_partitions_with_auth_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_parts = max_parts
    args.user_name = user_name
    args.group_names = group_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_with_auth(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partitions_with_auth_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_with_auth failed: unknown result")

  def get_partitions_pspec(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    self.send_get_partitions_pspec(db_name, tbl_name, max_parts)
    return self.recv_get_partitions_pspec()

  def send_get_partitions_pspec(self, db_name, tbl_name, max_parts):
    self._oprot.writeMessageBegin('get_partitions_pspec', TMessageType.CALL, self._seqid)
    args = get_partitions_pspec_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_pspec(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partitions_pspec_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_pspec failed: unknown result")

  def get_partition_names(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    self.send_get_partition_names(db_name, tbl_name, max_parts)
    return self.recv_get_partition_names()

  def send_get_partition_names(self, db_name, tbl_name, max_parts):
    self._oprot.writeMessageBegin('get_partition_names', TMessageType.CALL, self._seqid)
    args = get_partition_names_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_names(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partition_names_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_names failed: unknown result")

  def get_partition_values(self, request):
    """
    Parameters:
     - request
    """
    self.send_get_partition_values(request)
    return self.recv_get_partition_values()

  def send_get_partition_values(self, request):
    self._oprot.writeMessageBegin('get_partition_values', TMessageType.CALL, self._seqid)
    args = get_partition_values_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_values(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partition_values_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_values failed: unknown result")

  def get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """
    self.send_get_partitions_ps(db_name, tbl_name, part_vals, max_parts)
    return self.recv_get_partitions_ps()

  def send_get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
    self._oprot.writeMessageBegin('get_partitions_ps', TMessageType.CALL, self._seqid)
    args = get_partitions_ps_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_ps(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partitions_ps_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_ps failed: unknown result")

  def get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
     - user_name
     - group_names
    """
    self.send_get_partitions_ps_with_auth(db_name, tbl_name, part_vals, max_parts, user_name, group_names)
    return self.recv_get_partitions_ps_with_auth()

  def send_get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):
    self._oprot.writeMessageBegin('get_partitions_ps_with_auth', TMessageType.CALL, self._seqid)
    args = get_partitions_ps_with_auth_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.max_parts = max_parts
    args.user_name = user_name
    args.group_names = group_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_ps_with_auth(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partitions_ps_with_auth_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_ps_with_auth failed: unknown result")

  def get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """
    self.send_get_partition_names_ps(db_name, tbl_name, part_vals, max_parts)
    return self.recv_get_partition_names_ps()

  def send_get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
    self._oprot.writeMessageBegin('get_partition_names_ps', TMessageType.CALL, self._seqid)
    args = get_partition_names_ps_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_names_ps(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partition_names_ps_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_names_ps failed: unknown result")

  def get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - filter
     - max_parts
    """
    self.send_get_partitions_by_filter(db_name, tbl_name, filter, max_parts)
    return self.recv_get_partitions_by_filter()

  def send_get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):
    self._oprot.writeMessageBegin('get_partitions_by_filter', TMessageType.CALL, self._seqid)
    args = get_partitions_by_filter_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.filter = filter
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_by_filter(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partitions_by_filter_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_by_filter failed: unknown result")

  def get_part_specs_by_filter(self, db_name, tbl_name, filter, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - filter
     - max_parts
    """
    self.send_get_part_specs_by_filter(db_name, tbl_name, filter, max_parts)
    return self.recv_get_part_specs_by_filter()

  def send_get_part_specs_by_filter(self, db_name, tbl_name, filter, max_parts):
    self._oprot.writeMessageBegin('get_part_specs_by_filter', TMessageType.CALL, self._seqid)
    args = get_part_specs_by_filter_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.filter = filter
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_part_specs_by_filter(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_part_specs_by_filter_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_part_specs_by_filter failed: unknown result")

  def get_partitions_by_expr(self, req):
    """
    Parameters:
     - req
    """
    self.send_get_partitions_by_expr(req)
    return self.recv_get_partitions_by_expr()

  def send_get_partitions_by_expr(self, req):
    self._oprot.writeMessageBegin('get_partitions_by_expr', TMessageType.CALL, self._seqid)
    args = get_partitions_by_expr_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_by_expr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partitions_by_expr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_by_expr failed: unknown result")

  def get_num_partitions_by_filter(self, db_name, tbl_name, filter):
    """
    Parameters:
     - db_name
     - tbl_name
     - filter
    """
    self.send_get_num_partitions_by_filter(db_name, tbl_name, filter)
    return self.recv_get_num_partitions_by_filter()

  def send_get_num_partitions_by_filter(self, db_name, tbl_name, filter):
    self._oprot.writeMessageBegin('get_num_partitions_by_filter', TMessageType.CALL, self._seqid)
    args = get_num_partitions_by_filter_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.filter = filter
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_num_partitions_by_filter(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_num_partitions_by_filter_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_num_partitions_by_filter failed: unknown result")

  def get_partitions_by_names(self, db_name, tbl_name, names):
    """
    Parameters:
     - db_name
     - tbl_name
     - names
    """
    self.send_get_partitions_by_names(db_name, tbl_name, names)
    return self.recv_get_partitions_by_names()

  def send_get_partitions_by_names(self, db_name, tbl_name, names):
    self._oprot.writeMessageBegin('get_partitions_by_names', TMessageType.CALL, self._seqid)
    args = get_partitions_by_names_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.names = names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_by_names(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partitions_by_names_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_by_names failed: unknown result")

  def alter_partition(self, db_name, tbl_name, new_part):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_part
    """
    self.send_alter_partition(db_name, tbl_name, new_part)
    self.recv_alter_partition()

  def send_alter_partition(self, db_name, tbl_name, new_part):
    self._oprot.writeMessageBegin('alter_partition', TMessageType.CALL, self._seqid)
    args = alter_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.new_part = new_part
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_partition(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_partition_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def alter_partitions(self, db_name, tbl_name, new_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_parts
    """
    self.send_alter_partitions(db_name, tbl_name, new_parts)
    self.recv_alter_partitions()

  def send_alter_partitions(self, db_name, tbl_name, new_parts):
    self._oprot.writeMessageBegin('alter_partitions', TMessageType.CALL, self._seqid)
    args = alter_partitions_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.new_parts = new_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_partitions(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_partitions_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def alter_partitions_with_environment_context(self, db_name, tbl_name, new_parts, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_parts
     - environment_context
    """
    self.send_alter_partitions_with_environment_context(db_name, tbl_name, new_parts, environment_context)
    self.recv_alter_partitions_with_environment_context()

  def send_alter_partitions_with_environment_context(self, db_name, tbl_name, new_parts, environment_context):
    self._oprot.writeMessageBegin('alter_partitions_with_environment_context', TMessageType.CALL, self._seqid)
    args = alter_partitions_with_environment_context_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.new_parts = new_parts
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_partitions_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_partitions_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def alter_partition_with_environment_context(self, db_name, tbl_name, new_part, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_part
     - environment_context
    """
    self.send_alter_partition_with_environment_context(db_name, tbl_name, new_part, environment_context)
    self.recv_alter_partition_with_environment_context()

  def send_alter_partition_with_environment_context(self, db_name, tbl_name, new_part, environment_context):
    self._oprot.writeMessageBegin('alter_partition_with_environment_context', TMessageType.CALL, self._seqid)
    args = alter_partition_with_environment_context_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.new_part = new_part
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_partition_with_environment_context(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_partition_with_environment_context_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def rename_partition(self, db_name, tbl_name, part_vals, new_part):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - new_part
    """
    self.send_rename_partition(db_name, tbl_name, part_vals, new_part)
    self.recv_rename_partition()

  def send_rename_partition(self, db_name, tbl_name, part_vals, new_part):
    self._oprot.writeMessageBegin('rename_partition', TMessageType.CALL, self._seqid)
    args = rename_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.new_part = new_part
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_rename_partition(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = rename_partition_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def partition_name_has_valid_characters(self, part_vals, throw_exception):
    """
    Parameters:
     - part_vals
     - throw_exception
    """
    self.send_partition_name_has_valid_characters(part_vals, throw_exception)
    return self.recv_partition_name_has_valid_characters()

  def send_partition_name_has_valid_characters(self, part_vals, throw_exception):
    self._oprot.writeMessageBegin('partition_name_has_valid_characters', TMessageType.CALL, self._seqid)
    args = partition_name_has_valid_characters_args()
    args.part_vals = part_vals
    args.throw_exception = throw_exception
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_partition_name_has_valid_characters(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = partition_name_has_valid_characters_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_has_valid_characters failed: unknown result")

  def get_config_value(self, name, defaultValue):
    """
    Parameters:
     - name
     - defaultValue
    """
    self.send_get_config_value(name, defaultValue)
    return self.recv_get_config_value()

  def send_get_config_value(self, name, defaultValue):
    self._oprot.writeMessageBegin('get_config_value', TMessageType.CALL, self._seqid)
    args = get_config_value_args()
    args.name = name
    args.defaultValue = defaultValue
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_config_value(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_config_value_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_config_value failed: unknown result")

  def partition_name_to_vals(self, part_name):
    """
    Parameters:
     - part_name
    """
    self.send_partition_name_to_vals(part_name)
    return self.recv_partition_name_to_vals()

  def send_partition_name_to_vals(self, part_name):
    self._oprot.writeMessageBegin('partition_name_to_vals', TMessageType.CALL, self._seqid)
    args = partition_name_to_vals_args()
    args.part_name = part_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_partition_name_to_vals(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = partition_name_to_vals_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_to_vals failed: unknown result")

  def partition_name_to_spec(self, part_name):
    """
    Parameters:
     - part_name
    """
    self.send_partition_name_to_spec(part_name)
    return self.recv_partition_name_to_spec()

  def send_partition_name_to_spec(self, part_name):
    self._oprot.writeMessageBegin('partition_name_to_spec', TMessageType.CALL, self._seqid)
    args = partition_name_to_spec_args()
    args.part_name = part_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_partition_name_to_spec(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = partition_name_to_spec_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_to_spec failed: unknown result")

  def markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - eventType
    """
    self.send_markPartitionForEvent(db_name, tbl_name, part_vals, eventType)
    self.recv_markPartitionForEvent()

  def send_markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):
    self._oprot.writeMessageBegin('markPartitionForEvent', TMessageType.CALL, self._seqid)
    args = markPartitionForEvent_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.eventType = eventType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_markPartitionForEvent(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = markPartitionForEvent_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    if result.o5 is not None:
      raise result.o5
    if result.o6 is not None:
      raise result.o6
    return

  def isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - eventType
    """
    self.send_isPartitionMarkedForEvent(db_name, tbl_name, part_vals, eventType)
    return self.recv_isPartitionMarkedForEvent()

  def send_isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):
    self._oprot.writeMessageBegin('isPartitionMarkedForEvent', TMessageType.CALL, self._seqid)
    args = isPartitionMarkedForEvent_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.eventType = eventType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_isPartitionMarkedForEvent(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = isPartitionMarkedForEvent_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    if result.o5 is not None:
      raise result.o5
    if result.o6 is not None:
      raise result.o6
    raise TApplicationException(TApplicationException.MISSING_RESULT, "isPartitionMarkedForEvent failed: unknown result")

  def add_index(self, new_index, index_table):
    """
    Parameters:
     - new_index
     - index_table
    """
    self.send_add_index(new_index, index_table)
    return self.recv_add_index()

  def send_add_index(self, new_index, index_table):
    self._oprot.writeMessageBegin('add_index', TMessageType.CALL, self._seqid)
    args = add_index_args()
    args.new_index = new_index
    args.index_table = index_table
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_index(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_index_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_index failed: unknown result")

  def alter_index(self, dbname, base_tbl_name, idx_name, new_idx):
    """
    Parameters:
     - dbname
     - base_tbl_name
     - idx_name
     - new_idx
    """
    self.send_alter_index(dbname, base_tbl_name, idx_name, new_idx)
    self.recv_alter_index()

  def send_alter_index(self, dbname, base_tbl_name, idx_name, new_idx):
    self._oprot.writeMessageBegin('alter_index', TMessageType.CALL, self._seqid)
    args = alter_index_args()
    args.dbname = dbname
    args.base_tbl_name = base_tbl_name
    args.idx_name = idx_name
    args.new_idx = new_idx
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_index(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_index_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def drop_index_by_name(self, db_name, tbl_name, index_name, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - index_name
     - deleteData
    """
    self.send_drop_index_by_name(db_name, tbl_name, index_name, deleteData)
    return self.recv_drop_index_by_name()

  def send_drop_index_by_name(self, db_name, tbl_name, index_name, deleteData):
    self._oprot.writeMessageBegin('drop_index_by_name', TMessageType.CALL, self._seqid)
    args = drop_index_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.index_name = index_name
    args.deleteData = deleteData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_index_by_name(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_index_by_name_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_index_by_name failed: unknown result")

  def get_index_by_name(self, db_name, tbl_name, index_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - index_name
    """
    self.send_get_index_by_name(db_name, tbl_name, index_name)
    return self.recv_get_index_by_name()

  def send_get_index_by_name(self, db_name, tbl_name, index_name):
    self._oprot.writeMessageBegin('get_index_by_name', TMessageType.CALL, self._seqid)
    args = get_index_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.index_name = index_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_index_by_name(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_index_by_name_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_index_by_name failed: unknown result")

  def get_indexes(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    self.send_get_indexes(db_name, tbl_name, max_indexes)
    return self.recv_get_indexes()

  def send_get_indexes(self, db_name, tbl_name, max_indexes):
    self._oprot.writeMessageBegin('get_indexes', TMessageType.CALL, self._seqid)
    args = get_indexes_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_indexes = max_indexes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_indexes(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_indexes_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_indexes failed: unknown result")

  def get_index_names(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    self.send_get_index_names(db_name, tbl_name, max_indexes)
    return self.recv_get_index_names()

  def send_get_index_names(self, db_name, tbl_name, max_indexes):
    self._oprot.writeMessageBegin('get_index_names', TMessageType.CALL, self._seqid)
    args = get_index_names_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_indexes = max_indexes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_index_names(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_index_names_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_index_names failed: unknown result")

  def get_primary_keys(self, request):
    """
    Parameters:
     - request
    """
    self.send_get_primary_keys(request)
    return self.recv_get_primary_keys()

  def send_get_primary_keys(self, request):
    self._oprot.writeMessageBegin('get_primary_keys', TMessageType.CALL, self._seqid)
    args = get_primary_keys_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_primary_keys(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_primary_keys_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_primary_keys failed: unknown result")

  def get_foreign_keys(self, request):
    """
    Parameters:
     - request
    """
    self.send_get_foreign_keys(request)
    return self.recv_get_foreign_keys()

  def send_get_foreign_keys(self, request):
    self._oprot.writeMessageBegin('get_foreign_keys', TMessageType.CALL, self._seqid)
    args = get_foreign_keys_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_foreign_keys(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_foreign_keys_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_foreign_keys failed: unknown result")

  def get_unique_constraints(self, request):
    """
    Parameters:
     - request
    """
    self.send_get_unique_constraints(request)
    return self.recv_get_unique_constraints()

  def send_get_unique_constraints(self, request):
    self._oprot.writeMessageBegin('get_unique_constraints', TMessageType.CALL, self._seqid)
    args = get_unique_constraints_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_unique_constraints(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_unique_constraints_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_unique_constraints failed: unknown result")

  def get_not_null_constraints(self, request):
    """
    Parameters:
     - request
    """
    self.send_get_not_null_constraints(request)
    return self.recv_get_not_null_constraints()

  def send_get_not_null_constraints(self, request):
    self._oprot.writeMessageBegin('get_not_null_constraints', TMessageType.CALL, self._seqid)
    args = get_not_null_constraints_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_not_null_constraints(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_not_null_constraints_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_not_null_constraints failed: unknown result")

  def update_table_column_statistics(self, stats_obj):
    """
    Parameters:
     - stats_obj
    """
    self.send_update_table_column_statistics(stats_obj)
    return self.recv_update_table_column_statistics()

  def send_update_table_column_statistics(self, stats_obj):
    self._oprot.writeMessageBegin('update_table_column_statistics', TMessageType.CALL, self._seqid)
    args = update_table_column_statistics_args()
    args.stats_obj = stats_obj
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_table_column_statistics(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = update_table_column_statistics_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "update_table_column_statistics failed: unknown result")

  def update_partition_column_statistics(self, stats_obj):
    """
    Parameters:
     - stats_obj
    """
    self.send_update_partition_column_statistics(stats_obj)
    return self.recv_update_partition_column_statistics()

  def send_update_partition_column_statistics(self, stats_obj):
    self._oprot.writeMessageBegin('update_partition_column_statistics', TMessageType.CALL, self._seqid)
    args = update_partition_column_statistics_args()
    args.stats_obj = stats_obj
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_partition_column_statistics(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = update_partition_column_statistics_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "update_partition_column_statistics failed: unknown result")

  def get_table_column_statistics(self, db_name, tbl_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - col_name
    """
    self.send_get_table_column_statistics(db_name, tbl_name, col_name)
    return self.recv_get_table_column_statistics()

  def send_get_table_column_statistics(self, db_name, tbl_name, col_name):
    self._oprot.writeMessageBegin('get_table_column_statistics', TMessageType.CALL, self._seqid)
    args = get_table_column_statistics_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.col_name = col_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_column_statistics(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_table_column_statistics_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_column_statistics failed: unknown result")

  def get_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - col_name
    """
    self.send_get_partition_column_statistics(db_name, tbl_name, part_name, col_name)
    return self.recv_get_partition_column_statistics()

  def send_get_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
    self._oprot.writeMessageBegin('get_partition_column_statistics', TMessageType.CALL, self._seqid)
    args = get_partition_column_statistics_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.col_name = col_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_column_statistics(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partition_column_statistics_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_column_statistics failed: unknown result")

  def get_table_statistics_req(self, request):
    """
    Parameters:
     - request
    """
    self.send_get_table_statistics_req(request)
    return self.recv_get_table_statistics_req()

  def send_get_table_statistics_req(self, request):
    self._oprot.writeMessageBegin('get_table_statistics_req', TMessageType.CALL, self._seqid)
    args = get_table_statistics_req_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_statistics_req(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_table_statistics_req_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_statistics_req failed: unknown result")

  def get_partitions_statistics_req(self, request):
    """
    Parameters:
     - request
    """
    self.send_get_partitions_statistics_req(request)
    return self.recv_get_partitions_statistics_req()

  def send_get_partitions_statistics_req(self, request):
    self._oprot.writeMessageBegin('get_partitions_statistics_req', TMessageType.CALL, self._seqid)
    args = get_partitions_statistics_req_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_statistics_req(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_partitions_statistics_req_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_statistics_req failed: unknown result")

  def get_aggr_stats_for(self, request):
    """
    Parameters:
     - request
    """
    self.send_get_aggr_stats_for(request)
    return self.recv_get_aggr_stats_for()

  def send_get_aggr_stats_for(self, request):
    self._oprot.writeMessageBegin('get_aggr_stats_for', TMessageType.CALL, self._seqid)
    args = get_aggr_stats_for_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_aggr_stats_for(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_aggr_stats_for_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_aggr_stats_for failed: unknown result")

  def set_aggr_stats_for(self, request):
    """
    Parameters:
     - request
    """
    self.send_set_aggr_stats_for(request)
    return self.recv_set_aggr_stats_for()

  def send_set_aggr_stats_for(self, request):
    self._oprot.writeMessageBegin('set_aggr_stats_for', TMessageType.CALL, self._seqid)
    args = set_aggr_stats_for_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_aggr_stats_for(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = set_aggr_stats_for_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "set_aggr_stats_for failed: unknown result")

  def delete_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - col_name
    """
    self.send_delete_partition_column_statistics(db_name, tbl_name, part_name, col_name)
    return self.recv_delete_partition_column_statistics()

  def send_delete_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
    self._oprot.writeMessageBegin('delete_partition_column_statistics', TMessageType.CALL, self._seqid)
    args = delete_partition_column_statistics_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.col_name = col_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_delete_partition_column_statistics(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = delete_partition_column_statistics_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_partition_column_statistics failed: unknown result")

  def delete_table_column_statistics(self, db_name, tbl_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - col_name
    """
    self.send_delete_table_column_statistics(db_name, tbl_name, col_name)
    return self.recv_delete_table_column_statistics()

  def send_delete_table_column_statistics(self, db_name, tbl_name, col_name):
    self._oprot.writeMessageBegin('delete_table_column_statistics', TMessageType.CALL, self._seqid)
    args = delete_table_column_statistics_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.col_name = col_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_delete_table_column_statistics(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = delete_table_column_statistics_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_table_column_statistics failed: unknown result")

  def create_function(self, func):
    """
    Parameters:
     - func
    """
    self.send_create_function(func)
    self.recv_create_function()

  def send_create_function(self, func):
    self._oprot.writeMessageBegin('create_function', TMessageType.CALL, self._seqid)
    args = create_function_args()
    args.func = func
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_function(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_function_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    return

  def drop_function(self, dbName, funcName):
    """
    Parameters:
     - dbName
     - funcName
    """
    self.send_drop_function(dbName, funcName)
    self.recv_drop_function()

  def send_drop_function(self, dbName, funcName):
    self._oprot.writeMessageBegin('drop_function', TMessageType.CALL, self._seqid)
    args = drop_function_args()
    args.dbName = dbName
    args.funcName = funcName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_function(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_function_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o3 is not None:
      raise result.o3
    return

  def alter_function(self, dbName, funcName, newFunc):
    """
    Parameters:
     - dbName
     - funcName
     - newFunc
    """
    self.send_alter_function(dbName, funcName, newFunc)
    self.recv_alter_function()

  def send_alter_function(self, dbName, funcName, newFunc):
    self._oprot.writeMessageBegin('alter_function', TMessageType.CALL, self._seqid)
    args = alter_function_args()
    args.dbName = dbName
    args.funcName = funcName
    args.newFunc = newFunc
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_function(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_function_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def get_functions(self, dbName, pattern):
    """
    Parameters:
     - dbName
     - pattern
    """
    self.send_get_functions(dbName, pattern)
    return self.recv_get_functions()

  def send_get_functions(self, dbName, pattern):
    self._oprot.writeMessageBegin('get_functions', TMessageType.CALL, self._seqid)
    args = get_functions_args()
    args.dbName = dbName
    args.pattern = pattern
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_functions(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_functions_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_functions failed: unknown result")

  def get_function(self, dbName, funcName):
    """
    Parameters:
     - dbName
     - funcName
    """
    self.send_get_function(dbName, funcName)
    return self.recv_get_function()

  def send_get_function(self, dbName, funcName):
    self._oprot.writeMessageBegin('get_function', TMessageType.CALL, self._seqid)
    args = get_function_args()
    args.dbName = dbName
    args.funcName = funcName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_function(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_function_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_function failed: unknown result")

  def get_all_functions(self):
    self.send_get_all_functions()
    return self.recv_get_all_functions()

  def send_get_all_functions(self):
    self._oprot.writeMessageBegin('get_all_functions', TMessageType.CALL, self._seqid)
    args = get_all_functions_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_functions(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_functions_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_functions failed: unknown result")

  def create_role(self, role):
    """
    Parameters:
     - role
    """
    self.send_create_role(role)
    return self.recv_create_role()

  def send_create_role(self, role):
    self._oprot.writeMessageBegin('create_role', TMessageType.CALL, self._seqid)
    args = create_role_args()
    args.role = role
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_role(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_role_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_role failed: unknown result")

  def drop_role(self, role_name):
    """
    Parameters:
     - role_name
    """
    self.send_drop_role(role_name)
    return self.recv_drop_role()

  def send_drop_role(self, role_name):
    self._oprot.writeMessageBegin('drop_role', TMessageType.CALL, self._seqid)
    args = drop_role_args()
    args.role_name = role_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_role(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_role_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_role failed: unknown result")

  def get_role_names(self):
    self.send_get_role_names()
    return self.recv_get_role_names()

  def send_get_role_names(self):
    self._oprot.writeMessageBegin('get_role_names', TMessageType.CALL, self._seqid)
    args = get_role_names_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_role_names(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_role_names_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_role_names failed: unknown result")

  def grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):
    """
    Parameters:
     - role_name
     - principal_name
     - principal_type
     - grantor
     - grantorType
     - grant_option
    """
    self.send_grant_role(role_name, principal_name, principal_type, grantor, grantorType, grant_option)
    return self.recv_grant_role()

  def send_grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):
    self._oprot.writeMessageBegin('grant_role', TMessageType.CALL, self._seqid)
    args = grant_role_args()
    args.role_name = role_name
    args.principal_name = principal_name
    args.principal_type = principal_type
    args.grantor = grantor
    args.grantorType = grantorType
    args.grant_option = grant_option
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_grant_role(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = grant_role_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_role failed: unknown result")

  def revoke_role(self, role_name, principal_name, principal_type):
    """
    Parameters:
     - role_name
     - principal_name
     - principal_type
    """
    self.send_revoke_role(role_name, principal_name, principal_type)
    return self.recv_revoke_role()

  def send_revoke_role(self, role_name, principal_name, principal_type):
    self._oprot.writeMessageBegin('revoke_role', TMessageType.CALL, self._seqid)
    args = revoke_role_args()
    args.role_name = role_name
    args.principal_name = principal_name
    args.principal_type = principal_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revoke_role(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revoke_role_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "revoke_role failed: unknown result")

  def list_roles(self, principal_name, principal_type):
    """
    Parameters:
     - principal_name
     - principal_type
    """
    self.send_list_roles(principal_name, principal_type)
    return self.recv_list_roles()

  def send_list_roles(self, principal_name, principal_type):
    self._oprot.writeMessageBegin('list_roles', TMessageType.CALL, self._seqid)
    args = list_roles_args()
    args.principal_name = principal_name
    args.principal_type = principal_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_list_roles(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = list_roles_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "list_roles failed: unknown result")

  def grant_revoke_role(self, request):
    """
    Parameters:
     - request
    """
    self.send_grant_revoke_role(request)
    return self.recv_grant_revoke_role()

  def send_grant_revoke_role(self, request):
    self._oprot.writeMessageBegin('grant_revoke_role', TMessageType.CALL, self._seqid)
    args = grant_revoke_role_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_grant_revoke_role(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = grant_revoke_role_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_revoke_role failed: unknown result")

  def get_principals_in_role(self, request):
    """
    Parameters:
     - request
    """
    self.send_get_principals_in_role(request)
    return self.recv_get_principals_in_role()

  def send_get_principals_in_role(self, request):
    self._oprot.writeMessageBegin('get_principals_in_role', TMessageType.CALL, self._seqid)
    args = get_principals_in_role_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_principals_in_role(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_principals_in_role_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_principals_in_role failed: unknown result")

  def get_role_grants_for_principal(self, request):
    """
    Parameters:
     - request
    """
    self.send_get_role_grants_for_principal(request)
    return self.recv_get_role_grants_for_principal()

  def send_get_role_grants_for_principal(self, request):
    self._oprot.writeMessageBegin('get_role_grants_for_principal', TMessageType.CALL, self._seqid)
    args = get_role_grants_for_principal_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_role_grants_for_principal(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_role_grants_for_principal_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_role_grants_for_principal failed: unknown result")

  def get_privilege_set(self, hiveObject, user_name, group_names):
    """
    Parameters:
     - hiveObject
     - user_name
     - group_names
    """
    self.send_get_privilege_set(hiveObject, user_name, group_names)
    return self.recv_get_privilege_set()

  def send_get_privilege_set(self, hiveObject, user_name, group_names):
    self._oprot.writeMessageBegin('get_privilege_set', TMessageType.CALL, self._seqid)
    args = get_privilege_set_args()
    args.hiveObject = hiveObject
    args.user_name = user_name
    args.group_names = group_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_privilege_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_privilege_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_privilege_set failed: unknown result")

  def list_privileges(self, principal_name, principal_type, hiveObject):
    """
    Parameters:
     - principal_name
     - principal_type
     - hiveObject
    """
    self.send_list_privileges(principal_name, principal_type, hiveObject)
    return self.recv_list_privileges()

  def send_list_privileges(self, principal_name, principal_type, hiveObject):
    self._oprot.writeMessageBegin('list_privileges', TMessageType.CALL, self._seqid)
    args = list_privileges_args()
    args.principal_name = principal_name
    args.principal_type = principal_type
    args.hiveObject = hiveObject
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_list_privileges(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = list_privileges_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "list_privileges failed: unknown result")

  def grant_privileges(self, privileges):
    """
    Parameters:
     - privileges
    """
    self.send_grant_privileges(privileges)
    return self.recv_grant_privileges()

  def send_grant_privileges(self, privileges):
    self._oprot.writeMessageBegin('grant_privileges', TMessageType.CALL, self._seqid)
    args = grant_privileges_args()
    args.privileges = privileges
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_grant_privileges(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = grant_privileges_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_privileges failed: unknown result")

  def revoke_privileges(self, privileges):
    """
    Parameters:
     - privileges
    """
    self.send_revoke_privileges(privileges)
    return self.recv_revoke_privileges()

  def send_revoke_privileges(self, privileges):
    self._oprot.writeMessageBegin('revoke_privileges', TMessageType.CALL, self._seqid)
    args = revoke_privileges_args()
    args.privileges = privileges
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revoke_privileges(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revoke_privileges_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "revoke_privileges failed: unknown result")

  def grant_revoke_privileges(self, request):
    """
    Parameters:
     - request
    """
    self.send_grant_revoke_privileges(request)
    return self.recv_grant_revoke_privileges()

  def send_grant_revoke_privileges(self, request):
    self._oprot.writeMessageBegin('grant_revoke_privileges', TMessageType.CALL, self._seqid)
    args = grant_revoke_privileges_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_grant_revoke_privileges(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = grant_revoke_privileges_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_revoke_privileges failed: unknown result")

  def set_ugi(self, user_name, group_names):
    """
    Parameters:
     - user_name
     - group_names
    """
    self.send_set_ugi(user_name, group_names)
    return self.recv_set_ugi()

  def send_set_ugi(self, user_name, group_names):
    self._oprot.writeMessageBegin('set_ugi', TMessageType.CALL, self._seqid)
    args = set_ugi_args()
    args.user_name = user_name
    args.group_names = group_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_ugi(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = set_ugi_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "set_ugi failed: unknown result")

  def get_delegation_token(self, token_owner, renewer_kerberos_principal_name):
    """
    Parameters:
     - token_owner
     - renewer_kerberos_principal_name
    """
    self.send_get_delegation_token(token_owner, renewer_kerberos_principal_name)
    return self.recv_get_delegation_token()

  def send_get_delegation_token(self, token_owner, renewer_kerberos_principal_name):
    self._oprot.writeMessageBegin('get_delegation_token', TMessageType.CALL, self._seqid)
    args = get_delegation_token_args()
    args.token_owner = token_owner
    args.renewer_kerberos_principal_name = renewer_kerberos_principal_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_delegation_token(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_delegation_token_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_delegation_token failed: unknown result")

  def renew_delegation_token(self, token_str_form):
    """
    Parameters:
     - token_str_form
    """
    self.send_renew_delegation_token(token_str_form)
    return self.recv_renew_delegation_token()

  def send_renew_delegation_token(self, token_str_form):
    self._oprot.writeMessageBegin('renew_delegation_token', TMessageType.CALL, self._seqid)
    args = renew_delegation_token_args()
    args.token_str_form = token_str_form
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_renew_delegation_token(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = renew_delegation_token_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "renew_delegation_token failed: unknown result")

  def cancel_delegation_token(self, token_str_form):
    """
    Parameters:
     - token_str_form
    """
    self.send_cancel_delegation_token(token_str_form)
    self.recv_cancel_delegation_token()

  def send_cancel_delegation_token(self, token_str_form):
    self._oprot.writeMessageBegin('cancel_delegation_token', TMessageType.CALL, self._seqid)
    args = cancel_delegation_token_args()
    args.token_str_form = token_str_form
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cancel_delegation_token(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = cancel_delegation_token_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    return

  def add_token(self, token_identifier, delegation_token):
    """
    Parameters:
     - token_identifier
     - delegation_token
    """
    self.send_add_token(token_identifier, delegation_token)
    return self.recv_add_token()

  def send_add_token(self, token_identifier, delegation_token):
    self._oprot.writeMessageBegin('add_token', TMessageType.CALL, self._seqid)
    args = add_token_args()
    args.token_identifier = token_identifier
    args.delegation_token = delegation_token
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_token(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_token_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_token failed: unknown result")

  def remove_token(self, token_identifier):
    """
    Parameters:
     - token_identifier
    """
    self.send_remove_token(token_identifier)
    return self.recv_remove_token()

  def send_remove_token(self, token_identifier):
    self._oprot.writeMessageBegin('remove_token', TMessageType.CALL, self._seqid)
    args = remove_token_args()
    args.token_identifier = token_identifier
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_remove_token(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = remove_token_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "remove_token failed: unknown result")

  def get_token(self, token_identifier):
    """
    Parameters:
     - token_identifier
    """
    self.send_get_token(token_identifier)
    return self.recv_get_token()

  def send_get_token(self, token_identifier):
    self._oprot.writeMessageBegin('get_token', TMessageType.CALL, self._seqid)
    args = get_token_args()
    args.token_identifier = token_identifier
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_token(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_token_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_token failed: unknown result")

  def get_all_token_identifiers(self):
    self.send_get_all_token_identifiers()
    return self.recv_get_all_token_identifiers()

  def send_get_all_token_identifiers(self):
    self._oprot.writeMessageBegin('get_all_token_identifiers', TMessageType.CALL, self._seqid)
    args = get_all_token_identifiers_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_token_identifiers(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_token_identifiers_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_token_identifiers failed: unknown result")

  def add_master_key(self, key):
    """
    Parameters:
     - key
    """
    self.send_add_master_key(key)
    return self.recv_add_master_key()

  def send_add_master_key(self, key):
    self._oprot.writeMessageBegin('add_master_key', TMessageType.CALL, self._seqid)
    args = add_master_key_args()
    args.key = key
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_master_key(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_master_key_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_master_key failed: unknown result")

  def update_master_key(self, seq_number, key):
    """
    Parameters:
     - seq_number
     - key
    """
    self.send_update_master_key(seq_number, key)
    self.recv_update_master_key()

  def send_update_master_key(self, seq_number, key):
    self._oprot.writeMessageBegin('update_master_key', TMessageType.CALL, self._seqid)
    args = update_master_key_args()
    args.seq_number = seq_number
    args.key = key
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_master_key(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = update_master_key_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def remove_master_key(self, key_seq):
    """
    Parameters:
     - key_seq
    """
    self.send_remove_master_key(key_seq)
    return self.recv_remove_master_key()

  def send_remove_master_key(self, key_seq):
    self._oprot.writeMessageBegin('remove_master_key', TMessageType.CALL, self._seqid)
    args = remove_master_key_args()
    args.key_seq = key_seq
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_remove_master_key(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = remove_master_key_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "remove_master_key failed: unknown result")

  def get_master_keys(self):
    self.send_get_master_keys()
    return self.recv_get_master_keys()

  def send_get_master_keys(self):
    self._oprot.writeMessageBegin('get_master_keys', TMessageType.CALL, self._seqid)
    args = get_master_keys_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_master_keys(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_master_keys_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_master_keys failed: unknown result")

  def get_open_txns(self):
    self.send_get_open_txns()
    return self.recv_get_open_txns()

  def send_get_open_txns(self):
    self._oprot.writeMessageBegin('get_open_txns', TMessageType.CALL, self._seqid)
    args = get_open_txns_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_open_txns(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_open_txns_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_open_txns failed: unknown result")

  def get_open_txns_info(self):
    self.send_get_open_txns_info()
    return self.recv_get_open_txns_info()

  def send_get_open_txns_info(self):
    self._oprot.writeMessageBegin('get_open_txns_info', TMessageType.CALL, self._seqid)
    args = get_open_txns_info_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_open_txns_info(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_open_txns_info_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_open_txns_info failed: unknown result")

  def open_txns(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_open_txns(rqst)
    return self.recv_open_txns()

  def send_open_txns(self, rqst):
    self._oprot.writeMessageBegin('open_txns', TMessageType.CALL, self._seqid)
    args = open_txns_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_open_txns(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = open_txns_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "open_txns failed: unknown result")

  def abort_txn(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_abort_txn(rqst)
    self.recv_abort_txn()

  def send_abort_txn(self, rqst):
    self._oprot.writeMessageBegin('abort_txn', TMessageType.CALL, self._seqid)
    args = abort_txn_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_abort_txn(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = abort_txn_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    return

  def abort_txns(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_abort_txns(rqst)
    self.recv_abort_txns()

  def send_abort_txns(self, rqst):
    self._oprot.writeMessageBegin('abort_txns', TMessageType.CALL, self._seqid)
    args = abort_txns_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_abort_txns(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = abort_txns_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    return

  def commit_txn(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_commit_txn(rqst)
    self.recv_commit_txn()

  def send_commit_txn(self, rqst):
    self._oprot.writeMessageBegin('commit_txn', TMessageType.CALL, self._seqid)
    args = commit_txn_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_commit_txn(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = commit_txn_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def lock(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_lock(rqst)
    return self.recv_lock()

  def send_lock(self, rqst):
    self._oprot.writeMessageBegin('lock', TMessageType.CALL, self._seqid)
    args = lock_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_lock(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = lock_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "lock failed: unknown result")

  def check_lock(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_check_lock(rqst)
    return self.recv_check_lock()

  def send_check_lock(self, rqst):
    self._oprot.writeMessageBegin('check_lock', TMessageType.CALL, self._seqid)
    args = check_lock_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_check_lock(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = check_lock_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "check_lock failed: unknown result")

  def unlock(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_unlock(rqst)
    self.recv_unlock()

  def send_unlock(self, rqst):
    self._oprot.writeMessageBegin('unlock', TMessageType.CALL, self._seqid)
    args = unlock_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_unlock(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = unlock_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def show_locks(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_show_locks(rqst)
    return self.recv_show_locks()

  def send_show_locks(self, rqst):
    self._oprot.writeMessageBegin('show_locks', TMessageType.CALL, self._seqid)
    args = show_locks_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_show_locks(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = show_locks_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "show_locks failed: unknown result")

  def heartbeat(self, ids):
    """
    Parameters:
     - ids
    """
    self.send_heartbeat(ids)
    self.recv_heartbeat()

  def send_heartbeat(self, ids):
    self._oprot.writeMessageBegin('heartbeat', TMessageType.CALL, self._seqid)
    args = heartbeat_args()
    args.ids = ids
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_heartbeat(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = heartbeat_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    return

  def heartbeat_txn_range(self, txns):
    """
    Parameters:
     - txns
    """
    self.send_heartbeat_txn_range(txns)
    return self.recv_heartbeat_txn_range()

  def send_heartbeat_txn_range(self, txns):
    self._oprot.writeMessageBegin('heartbeat_txn_range', TMessageType.CALL, self._seqid)
    args = heartbeat_txn_range_args()
    args.txns = txns
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_heartbeat_txn_range(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = heartbeat_txn_range_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "heartbeat_txn_range failed: unknown result")

  def compact(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_compact(rqst)
    self.recv_compact()

  def send_compact(self, rqst):
    self._oprot.writeMessageBegin('compact', TMessageType.CALL, self._seqid)
    args = compact_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_compact(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = compact_result()
    result.read(iprot)
    iprot.readMessageEnd()
    return

  def compact2(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_compact2(rqst)
    return self.recv_compact2()

  def send_compact2(self, rqst):
    self._oprot.writeMessageBegin('compact2', TMessageType.CALL, self._seqid)
    args = compact2_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_compact2(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = compact2_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "compact2 failed: unknown result")

  def show_compact(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_show_compact(rqst)
    return self.recv_show_compact()

  def send_show_compact(self, rqst):
    self._oprot.writeMessageBegin('show_compact', TMessageType.CALL, self._seqid)
    args = show_compact_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_show_compact(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = show_compact_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "show_compact failed: unknown result")

  def add_dynamic_partitions(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_add_dynamic_partitions(rqst)
    self.recv_add_dynamic_partitions()

  def send_add_dynamic_partitions(self, rqst):
    self._oprot.writeMessageBegin('add_dynamic_partitions', TMessageType.CALL, self._seqid)
    args = add_dynamic_partitions_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_dynamic_partitions(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_dynamic_partitions_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def get_next_notification(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_get_next_notification(rqst)
    return self.recv_get_next_notification()

  def send_get_next_notification(self, rqst):
    self._oprot.writeMessageBegin('get_next_notification', TMessageType.CALL, self._seqid)
    args = get_next_notification_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_next_notification(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_next_notification_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_next_notification failed: unknown result")

  def get_current_notificationEventId(self):
    self.send_get_current_notificationEventId()
    return self.recv_get_current_notificationEventId()

  def send_get_current_notificationEventId(self):
    self._oprot.writeMessageBegin('get_current_notificationEventId', TMessageType.CALL, self._seqid)
    args = get_current_notificationEventId_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_current_notificationEventId(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_current_notificationEventId_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_current_notificationEventId failed: unknown result")

  def get_notification_events_count(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_get_notification_events_count(rqst)
    return self.recv_get_notification_events_count()

  def send_get_notification_events_count(self, rqst):
    self._oprot.writeMessageBegin('get_notification_events_count', TMessageType.CALL, self._seqid)
    args = get_notification_events_count_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_notification_events_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_notification_events_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_notification_events_count failed: unknown result")

  def fire_listener_event(self, rqst):
    """
    Parameters:
     - rqst
    """
    self.send_fire_listener_event(rqst)
    return self.recv_fire_listener_event()

  def send_fire_listener_event(self, rqst):
    self._oprot.writeMessageBegin('fire_listener_event', TMessageType.CALL, self._seqid)
    args = fire_listener_event_args()
    args.rqst = rqst
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_fire_listener_event(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = fire_listener_event_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "fire_listener_event failed: unknown result")

  def flushCache(self):
    self.send_flushCache()
    self.recv_flushCache()

  def send_flushCache(self):
    self._oprot.writeMessageBegin('flushCache', TMessageType.CALL, self._seqid)
    args = flushCache_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_flushCache(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = flushCache_result()
    result.read(iprot)
    iprot.readMessageEnd()
    return

  def cm_recycle(self, request):
    """
    Parameters:
     - request
    """
    self.send_cm_recycle(request)
    return self.recv_cm_recycle()

  def send_cm_recycle(self, request):
    self._oprot.writeMessageBegin('cm_recycle', TMessageType.CALL, self._seqid)
    args = cm_recycle_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cm_recycle(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = cm_recycle_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "cm_recycle failed: unknown result")

  def get_file_metadata_by_expr(self, req):
    """
    Parameters:
     - req
    """
    self.send_get_file_metadata_by_expr(req)
    return self.recv_get_file_metadata_by_expr()

  def send_get_file_metadata_by_expr(self, req):
    self._oprot.writeMessageBegin('get_file_metadata_by_expr', TMessageType.CALL, self._seqid)
    args = get_file_metadata_by_expr_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_file_metadata_by_expr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_file_metadata_by_expr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_file_metadata_by_expr failed: unknown result")

  def get_file_metadata(self, req):
    """
    Parameters:
     - req
    """
    self.send_get_file_metadata(req)
    return self.recv_get_file_metadata()

  def send_get_file_metadata(self, req):
    self._oprot.writeMessageBegin('get_file_metadata', TMessageType.CALL, self._seqid)
    args = get_file_metadata_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_file_metadata(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_file_metadata_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_file_metadata failed: unknown result")

  def put_file_metadata(self, req):
    """
    Parameters:
     - req
    """
    self.send_put_file_metadata(req)
    return self.recv_put_file_metadata()

  def send_put_file_metadata(self, req):
    self._oprot.writeMessageBegin('put_file_metadata', TMessageType.CALL, self._seqid)
    args = put_file_metadata_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_put_file_metadata(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = put_file_metadata_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "put_file_metadata failed: unknown result")

  def clear_file_metadata(self, req):
    """
    Parameters:
     - req
    """
    self.send_clear_file_metadata(req)
    return self.recv_clear_file_metadata()

  def send_clear_file_metadata(self, req):
    self._oprot.writeMessageBegin('clear_file_metadata', TMessageType.CALL, self._seqid)
    args = clear_file_metadata_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clear_file_metadata(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = clear_file_metadata_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "clear_file_metadata failed: unknown result")

  def cache_file_metadata(self, req):
    """
    Parameters:
     - req
    """
    self.send_cache_file_metadata(req)
    return self.recv_cache_file_metadata()

  def send_cache_file_metadata(self, req):
    self._oprot.writeMessageBegin('cache_file_metadata', TMessageType.CALL, self._seqid)
    args = cache_file_metadata_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cache_file_metadata(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = cache_file_metadata_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "cache_file_metadata failed: unknown result")

  def get_metastore_db_uuid(self):
    self.send_get_metastore_db_uuid()
    return self.recv_get_metastore_db_uuid()

  def send_get_metastore_db_uuid(self):
    self._oprot.writeMessageBegin('get_metastore_db_uuid', TMessageType.CALL, self._seqid)
    args = get_metastore_db_uuid_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_metastore_db_uuid(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_metastore_db_uuid_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_metastore_db_uuid failed: unknown result")

  def create_resource_plan(self, request):
    """
    Parameters:
     - request
    """
    self.send_create_resource_plan(request)
    return self.recv_create_resource_plan()

  def send_create_resource_plan(self, request):
    self._oprot.writeMessageBegin('create_resource_plan', TMessageType.CALL, self._seqid)
    args = create_resource_plan_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_resource_plan(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_resource_plan_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_resource_plan failed: unknown result")

  def get_resource_plan(self, request):
    """
    Parameters:
     - request
    """
    self.send_get_resource_plan(request)
    return self.recv_get_resource_plan()

  def send_get_resource_plan(self, request):
    self._oprot.writeMessageBegin('get_resource_plan', TMessageType.CALL, self._seqid)
    args = get_resource_plan_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_resource_plan(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_resource_plan_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_resource_plan failed: unknown result")

  def get_active_resource_plan(self, request):
    """
    Parameters:
     - request
    """
    self.send_get_active_resource_plan(request)
    return self.recv_get_active_resource_plan()

  def send_get_active_resource_plan(self, request):
    self._oprot.writeMessageBegin('get_active_resource_plan', TMessageType.CALL, self._seqid)
    args = get_active_resource_plan_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_active_resource_plan(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_active_resource_plan_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_active_resource_plan failed: unknown result")

  def get_all_resource_plans(self, request):
    """
    Parameters:
     - request
    """
    self.send_get_all_resource_plans(request)
    return self.recv_get_all_resource_plans()

  def send_get_all_resource_plans(self, request):
    self._oprot.writeMessageBegin('get_all_resource_plans', TMessageType.CALL, self._seqid)
    args = get_all_resource_plans_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_resource_plans(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_resource_plans_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_resource_plans failed: unknown result")

  def alter_resource_plan(self, request):
    """
    Parameters:
     - request
    """
    self.send_alter_resource_plan(request)
    return self.recv_alter_resource_plan()

  def send_alter_resource_plan(self, request):
    self._oprot.writeMessageBegin('alter_resource_plan', TMessageType.CALL, self._seqid)
    args = alter_resource_plan_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_resource_plan(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_resource_plan_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "alter_resource_plan failed: unknown result")

  def validate_resource_plan(self, request):
    """
    Parameters:
     - request
    """
    self.send_validate_resource_plan(request)
    return self.recv_validate_resource_plan()

  def send_validate_resource_plan(self, request):
    self._oprot.writeMessageBegin('validate_resource_plan', TMessageType.CALL, self._seqid)
    args = validate_resource_plan_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_validate_resource_plan(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = validate_resource_plan_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "validate_resource_plan failed: unknown result")

  def drop_resource_plan(self, request):
    """
    Parameters:
     - request
    """
    self.send_drop_resource_plan(request)
    return self.recv_drop_resource_plan()

  def send_drop_resource_plan(self, request):
    self._oprot.writeMessageBegin('drop_resource_plan', TMessageType.CALL, self._seqid)
    args = drop_resource_plan_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_resource_plan(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_resource_plan_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_resource_plan failed: unknown result")

  def create_wm_trigger(self, request):
    """
    Parameters:
     - request
    """
    self.send_create_wm_trigger(request)
    return self.recv_create_wm_trigger()

  def send_create_wm_trigger(self, request):
    self._oprot.writeMessageBegin('create_wm_trigger', TMessageType.CALL, self._seqid)
    args = create_wm_trigger_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_wm_trigger(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_wm_trigger_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_wm_trigger failed: unknown result")

  def alter_wm_trigger(self, request):
    """
    Parameters:
     - request
    """
    self.send_alter_wm_trigger(request)
    return self.recv_alter_wm_trigger()

  def send_alter_wm_trigger(self, request):
    self._oprot.writeMessageBegin('alter_wm_trigger', TMessageType.CALL, self._seqid)
    args = alter_wm_trigger_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_wm_trigger(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_wm_trigger_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "alter_wm_trigger failed: unknown result")

  def drop_wm_trigger(self, request):
    """
    Parameters:
     - request
    """
    self.send_drop_wm_trigger(request)
    return self.recv_drop_wm_trigger()

  def send_drop_wm_trigger(self, request):
    self._oprot.writeMessageBegin('drop_wm_trigger', TMessageType.CALL, self._seqid)
    args = drop_wm_trigger_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_wm_trigger(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_wm_trigger_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_wm_trigger failed: unknown result")

  def get_triggers_for_resourceplan(self, request):
    """
    Parameters:
     - request
    """
    self.send_get_triggers_for_resourceplan(request)
    return self.recv_get_triggers_for_resourceplan()

  def send_get_triggers_for_resourceplan(self, request):
    self._oprot.writeMessageBegin('get_triggers_for_resourceplan', TMessageType.CALL, self._seqid)
    args = get_triggers_for_resourceplan_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_triggers_for_resourceplan(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_triggers_for_resourceplan_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_triggers_for_resourceplan failed: unknown result")

  def create_wm_pool(self, request):
    """
    Parameters:
     - request
    """
    self.send_create_wm_pool(request)
    return self.recv_create_wm_pool()

  def send_create_wm_pool(self, request):
    self._oprot.writeMessageBegin('create_wm_pool', TMessageType.CALL, self._seqid)
    args = create_wm_pool_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_wm_pool(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_wm_pool_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_wm_pool failed: unknown result")

  def alter_wm_pool(self, request):
    """
    Parameters:
     - request
    """
    self.send_alter_wm_pool(request)
    return self.recv_alter_wm_pool()

  def send_alter_wm_pool(self, request):
    self._oprot.writeMessageBegin('alter_wm_pool', TMessageType.CALL, self._seqid)
    args = alter_wm_pool_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_wm_pool(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = alter_wm_pool_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "alter_wm_pool failed: unknown result")

  def drop_wm_pool(self, request):
    """
    Parameters:
     - request
    """
    self.send_drop_wm_pool(request)
    return self.recv_drop_wm_pool()

  def send_drop_wm_pool(self, request):
    self._oprot.writeMessageBegin('drop_wm_pool', TMessageType.CALL, self._seqid)
    args = drop_wm_pool_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_wm_pool(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_wm_pool_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_wm_pool failed: unknown result")

  def create_or_update_wm_mapping(self, request):
    """
    Parameters:
     - request
    """
    self.send_create_or_update_wm_mapping(request)
    return self.recv_create_or_update_wm_mapping()

  def send_create_or_update_wm_mapping(self, request):
    self._oprot.writeMessageBegin('create_or_update_wm_mapping', TMessageType.CALL, self._seqid)
    args = create_or_update_wm_mapping_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_or_update_wm_mapping(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_or_update_wm_mapping_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_or_update_wm_mapping failed: unknown result")

  def drop_wm_mapping(self, request):
    """
    Parameters:
     - request
    """
    self.send_drop_wm_mapping(request)
    return self.recv_drop_wm_mapping()

  def send_drop_wm_mapping(self, request):
    self._oprot.writeMessageBegin('drop_wm_mapping', TMessageType.CALL, self._seqid)
    args = drop_wm_mapping_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_wm_mapping(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drop_wm_mapping_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_wm_mapping failed: unknown result")

  def create_or_drop_wm_trigger_to_pool_mapping(self, request):
    """
    Parameters:
     - request
    """
    self.send_create_or_drop_wm_trigger_to_pool_mapping(request)
    return self.recv_create_or_drop_wm_trigger_to_pool_mapping()

  def send_create_or_drop_wm_trigger_to_pool_mapping(self, request):
    self._oprot.writeMessageBegin('create_or_drop_wm_trigger_to_pool_mapping', TMessageType.CALL, self._seqid)
    args = create_or_drop_wm_trigger_to_pool_mapping_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_or_drop_wm_trigger_to_pool_mapping(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_or_drop_wm_trigger_to_pool_mapping_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_or_drop_wm_trigger_to_pool_mapping failed: unknown result")


class Processor(fb303.FacebookService.Processor, Iface, TProcessor):
  def __init__(self, handler):
    fb303.FacebookService.Processor.__init__(self, handler)
    self._processMap["getMetaConf"] = Processor.process_getMetaConf
    self._processMap["setMetaConf"] = Processor.process_setMetaConf
    self._processMap["create_database"] = Processor.process_create_database
    self._processMap["get_database"] = Processor.process_get_database
    self._processMap["drop_database"] = Processor.process_drop_database
    self._processMap["get_databases"] = Processor.process_get_databases
    self._processMap["get_all_databases"] = Processor.process_get_all_databases
    self._processMap["alter_database"] = Processor.process_alter_database
    self._processMap["get_type"] = Processor.process_get_type
    self._processMap["create_type"] = Processor.process_create_type
    self._processMap["drop_type"] = Processor.process_drop_type
    self._processMap["get_type_all"] = Processor.process_get_type_all
    self._processMap["get_fields"] = Processor.process_get_fields
    self._processMap["get_fields_with_environment_context"] = Processor.process_get_fields_with_environment_context
    self._processMap["get_schema"] = Processor.process_get_schema
    self._processMap["get_schema_with_environment_context"] = Processor.process_get_schema_with_environment_context
    self._processMap["create_table"] = Processor.process_create_table
    self._processMap["create_table_with_environment_context"] = Processor.process_create_table_with_environment_context
    self._processMap["create_table_with_constraints"] = Processor.process_create_table_with_constraints
    self._processMap["drop_constraint"] = Processor.process_drop_constraint
    self._processMap["add_primary_key"] = Processor.process_add_primary_key
    self._processMap["add_foreign_key"] = Processor.process_add_foreign_key
    self._processMap["add_unique_constraint"] = Processor.process_add_unique_constraint
    self._processMap["add_not_null_constraint"] = Processor.process_add_not_null_constraint
    self._processMap["drop_table"] = Processor.process_drop_table
    self._processMap["drop_table_with_environment_context"] = Processor.process_drop_table_with_environment_context
    self._processMap["truncate_table"] = Processor.process_truncate_table
    self._processMap["get_tables"] = Processor.process_get_tables
    self._processMap["get_tables_by_type"] = Processor.process_get_tables_by_type
    self._processMap["get_materialized_views_for_rewriting"] = Processor.process_get_materialized_views_for_rewriting
    self._processMap["get_table_meta"] = Processor.process_get_table_meta
    self._processMap["get_all_tables"] = Processor.process_get_all_tables
    self._processMap["get_table"] = Processor.process_get_table
    self._processMap["get_table_objects_by_name"] = Processor.process_get_table_objects_by_name
    self._processMap["get_table_req"] = Processor.process_get_table_req
    self._processMap["get_table_objects_by_name_req"] = Processor.process_get_table_objects_by_name_req
    self._processMap["get_materialization_invalidation_info"] = Processor.process_get_materialization_invalidation_info
    self._processMap["get_table_names_by_filter"] = Processor.process_get_table_names_by_filter
    self._processMap["alter_table"] = Processor.process_alter_table
    self._processMap["alter_table_with_environment_context"] = Processor.process_alter_table_with_environment_context
    self._processMap["alter_table_with_cascade"] = Processor.process_alter_table_with_cascade
    self._processMap["add_partition"] = Processor.process_add_partition
    self._processMap["add_partition_with_environment_context"] = Processor.process_add_partition_with_environment_context
    self._processMap["add_partitions"] = Processor.process_add_partitions
    self._processMap["add_partitions_pspec"] = Processor.process_add_partitions_pspec
    self._processMap["append_partition"] = Processor.process_append_partition
    self._processMap["add_partitions_req"] = Processor.process_add_partitions_req
    self._processMap["append_partition_with_environment_context"] = Processor.process_append_partition_with_environment_context
    self._processMap["append_partition_by_name"] = Processor.process_append_partition_by_name
    self._processMap["append_partition_by_name_with_environment_context"] = Processor.process_append_partition_by_name_with_environment_context
    self._processMap["drop_partition"] = Processor.process_drop_partition
    self._processMap["drop_partition_with_environment_context"] = Processor.process_drop_partition_with_environment_context
    self._processMap["drop_partition_by_name"] = Processor.process_drop_partition_by_name
    self._processMap["drop_partition_by_name_with_environment_context"] = Processor.process_drop_partition_by_name_with_environment_context
    self._processMap["drop_partitions_req"] = Processor.process_drop_partitions_req
    self._processMap["get_partition"] = Processor.process_get_partition
    self._processMap["exchange_partition"] = Processor.process_exchange_partition
    self._processMap["exchange_partitions"] = Processor.process_exchange_partitions
    self._processMap["get_partition_with_auth"] = Processor.process_get_partition_with_auth
    self._processMap["get_partition_by_name"] = Processor.process_get_partition_by_name
    self._processMap["get_partitions"] = Processor.process_get_partitions
    self._processMap["get_partitions_with_auth"] = Processor.process_get_partitions_with_auth
    self._processMap["get_partitions_pspec"] = Processor.process_get_partitions_pspec
    self._processMap["get_partition_names"] = Processor.process_get_partition_names
    self._processMap["get_partition_values"] = Processor.process_get_partition_values
    self._processMap["get_partitions_ps"] = Processor.process_get_partitions_ps
    self._processMap["get_partitions_ps_with_auth"] = Processor.process_get_partitions_ps_with_auth
    self._processMap["get_partition_names_ps"] = Processor.process_get_partition_names_ps
    self._processMap["get_partitions_by_filter"] = Processor.process_get_partitions_by_filter
    self._processMap["get_part_specs_by_filter"] = Processor.process_get_part_specs_by_filter
    self._processMap["get_partitions_by_expr"] = Processor.process_get_partitions_by_expr
    self._processMap["get_num_partitions_by_filter"] = Processor.process_get_num_partitions_by_filter
    self._processMap["get_partitions_by_names"] = Processor.process_get_partitions_by_names
    self._processMap["alter_partition"] = Processor.process_alter_partition
    self._processMap["alter_partitions"] = Processor.process_alter_partitions
    self._processMap["alter_partitions_with_environment_context"] = Processor.process_alter_partitions_with_environment_context
    self._processMap["alter_partition_with_environment_context"] = Processor.process_alter_partition_with_environment_context
    self._processMap["rename_partition"] = Processor.process_rename_partition
    self._processMap["partition_name_has_valid_characters"] = Processor.process_partition_name_has_valid_characters
    self._processMap["get_config_value"] = Processor.process_get_config_value
    self._processMap["partition_name_to_vals"] = Processor.process_partition_name_to_vals
    self._processMap["partition_name_to_spec"] = Processor.process_partition_name_to_spec
    self._processMap["markPartitionForEvent"] = Processor.process_markPartitionForEvent
    self._processMap["isPartitionMarkedForEvent"] = Processor.process_isPartitionMarkedForEvent
    self._processMap["add_index"] = Processor.process_add_index
    self._processMap["alter_index"] = Processor.process_alter_index
    self._processMap["drop_index_by_name"] = Processor.process_drop_index_by_name
    self._processMap["get_index_by_name"] = Processor.process_get_index_by_name
    self._processMap["get_indexes"] = Processor.process_get_indexes
    self._processMap["get_index_names"] = Processor.process_get_index_names
    self._processMap["get_primary_keys"] = Processor.process_get_primary_keys
    self._processMap["get_foreign_keys"] = Processor.process_get_foreign_keys
    self._processMap["get_unique_constraints"] = Processor.process_get_unique_constraints
    self._processMap["get_not_null_constraints"] = Processor.process_get_not_null_constraints
    self._processMap["update_table_column_statistics"] = Processor.process_update_table_column_statistics
    self._processMap["update_partition_column_statistics"] = Processor.process_update_partition_column_statistics
    self._processMap["get_table_column_statistics"] = Processor.process_get_table_column_statistics
    self._processMap["get_partition_column_statistics"] = Processor.process_get_partition_column_statistics
    self._processMap["get_table_statistics_req"] = Processor.process_get_table_statistics_req
    self._processMap["get_partitions_statistics_req"] = Processor.process_get_partitions_statistics_req
    self._processMap["get_aggr_stats_for"] = Processor.process_get_aggr_stats_for
    self._processMap["set_aggr_stats_for"] = Processor.process_set_aggr_stats_for
    self._processMap["delete_partition_column_statistics"] = Processor.process_delete_partition_column_statistics
    self._processMap["delete_table_column_statistics"] = Processor.process_delete_table_column_statistics
    self._processMap["create_function"] = Processor.process_create_function
    self._processMap["drop_function"] = Processor.process_drop_function
    self._processMap["alter_function"] = Processor.process_alter_function
    self._processMap["get_functions"] = Processor.process_get_functions
    self._processMap["get_function"] = Processor.process_get_function
    self._processMap["get_all_functions"] = Processor.process_get_all_functions
    self._processMap["create_role"] = Processor.process_create_role
    self._processMap["drop_role"] = Processor.process_drop_role
    self._processMap["get_role_names"] = Processor.process_get_role_names
    self._processMap["grant_role"] = Processor.process_grant_role
    self._processMap["revoke_role"] = Processor.process_revoke_role
    self._processMap["list_roles"] = Processor.process_list_roles
    self._processMap["grant_revoke_role"] = Processor.process_grant_revoke_role
    self._processMap["get_principals_in_role"] = Processor.process_get_principals_in_role
    self._processMap["get_role_grants_for_principal"] = Processor.process_get_role_grants_for_principal
    self._processMap["get_privilege_set"] = Processor.process_get_privilege_set
    self._processMap["list_privileges"] = Processor.process_list_privileges
    self._processMap["grant_privileges"] = Processor.process_grant_privileges
    self._processMap["revoke_privileges"] = Processor.process_revoke_privileges
    self._processMap["grant_revoke_privileges"] = Processor.process_grant_revoke_privileges
    self._processMap["set_ugi"] = Processor.process_set_ugi
    self._processMap["get_delegation_token"] = Processor.process_get_delegation_token
    self._processMap["renew_delegation_token"] = Processor.process_renew_delegation_token
    self._processMap["cancel_delegation_token"] = Processor.process_cancel_delegation_token
    self._processMap["add_token"] = Processor.process_add_token
    self._processMap["remove_token"] = Processor.process_remove_token
    self._processMap["get_token"] = Processor.process_get_token
    self._processMap["get_all_token_identifiers"] = Processor.process_get_all_token_identifiers
    self._processMap["add_master_key"] = Processor.process_add_master_key
    self._processMap["update_master_key"] = Processor.process_update_master_key
    self._processMap["remove_master_key"] = Processor.process_remove_master_key
    self._processMap["get_master_keys"] = Processor.process_get_master_keys
    self._processMap["get_open_txns"] = Processor.process_get_open_txns
    self._processMap["get_open_txns_info"] = Processor.process_get_open_txns_info
    self._processMap["open_txns"] = Processor.process_open_txns
    self._processMap["abort_txn"] = Processor.process_abort_txn
    self._processMap["abort_txns"] = Processor.process_abort_txns
    self._processMap["commit_txn"] = Processor.process_commit_txn
    self._processMap["lock"] = Processor.process_lock
    self._processMap["check_lock"] = Processor.process_check_lock
    self._processMap["unlock"] = Processor.process_unlock
    self._processMap["show_locks"] = Processor.process_show_locks
    self._processMap["heartbeat"] = Processor.process_heartbeat
    self._processMap["heartbeat_txn_range"] = Processor.process_heartbeat_txn_range
    self._processMap["compact"] = Processor.process_compact
    self._processMap["compact2"] = Processor.process_compact2
    self._processMap["show_compact"] = Processor.process_show_compact
    self._processMap["add_dynamic_partitions"] = Processor.process_add_dynamic_partitions
    self._processMap["get_next_notification"] = Processor.process_get_next_notification
    self._processMap["get_current_notificationEventId"] = Processor.process_get_current_notificationEventId
    self._processMap["get_notification_events_count"] = Processor.process_get_notification_events_count
    self._processMap["fire_listener_event"] = Processor.process_fire_listener_event
    self._processMap["flushCache"] = Processor.process_flushCache
    self._processMap["cm_recycle"] = Processor.process_cm_recycle
    self._processMap["get_file_metadata_by_expr"] = Processor.process_get_file_metadata_by_expr
    self._processMap["get_file_metadata"] = Processor.process_get_file_metadata
    self._processMap["put_file_metadata"] = Processor.process_put_file_metadata
    self._processMap["clear_file_metadata"] = Processor.process_clear_file_metadata
    self._processMap["cache_file_metadata"] = Processor.process_cache_file_metadata
    self._processMap["get_metastore_db_uuid"] = Processor.process_get_metastore_db_uuid
    self._processMap["create_resource_plan"] = Processor.process_create_resource_plan
    self._processMap["get_resource_plan"] = Processor.process_get_resource_plan
    self._processMap["get_active_resource_plan"] = Processor.process_get_active_resource_plan
    self._processMap["get_all_resource_plans"] = Processor.process_get_all_resource_plans
    self._processMap["alter_resource_plan"] = Processor.process_alter_resource_plan
    self._processMap["validate_resource_plan"] = Processor.process_validate_resource_plan
    self._processMap["drop_resource_plan"] = Processor.process_drop_resource_plan
    self._processMap["create_wm_trigger"] = Processor.process_create_wm_trigger
    self._processMap["alter_wm_trigger"] = Processor.process_alter_wm_trigger
    self._processMap["drop_wm_trigger"] = Processor.process_drop_wm_trigger
    self._processMap["get_triggers_for_resourceplan"] = Processor.process_get_triggers_for_resourceplan
    self._processMap["create_wm_pool"] = Processor.process_create_wm_pool
    self._processMap["alter_wm_pool"] = Processor.process_alter_wm_pool
    self._processMap["drop_wm_pool"] = Processor.process_drop_wm_pool
    self._processMap["create_or_update_wm_mapping"] = Processor.process_create_or_update_wm_mapping
    self._processMap["drop_wm_mapping"] = Processor.process_drop_wm_mapping
    self._processMap["create_or_drop_wm_trigger_to_pool_mapping"] = Processor.process_create_or_drop_wm_trigger_to_pool_mapping

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_getMetaConf(self, seqid, iprot, oprot):
    args = getMetaConf_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getMetaConf_result()
    try:
      result.success = self._handler.getMetaConf(args.key)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getMetaConf", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setMetaConf(self, seqid, iprot, oprot):
    args = setMetaConf_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setMetaConf_result()
    try:
      self._handler.setMetaConf(args.key, args.value)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("setMetaConf", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_database(self, seqid, iprot, oprot):
    args = create_database_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_database_result()
    try:
      self._handler.create_database(args.database)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except AlreadyExistsException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("create_database", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_database(self, seqid, iprot, oprot):
    args = get_database_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_database_result()
    try:
      result.success = self._handler.get_database(args.name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_database", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_database(self, seqid, iprot, oprot):
    args = drop_database_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_database_result()
    try:
      self._handler.drop_database(args.name, args.deleteData, args.cascade)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidOperationException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_database", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_databases(self, seqid, iprot, oprot):
    args = get_databases_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_databases_result()
    try:
      result.success = self._handler.get_databases(args.pattern)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_databases", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_databases(self, seqid, iprot, oprot):
    args = get_all_databases_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_databases_result()
    try:
      result.success = self._handler.get_all_databases()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_all_databases", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_database(self, seqid, iprot, oprot):
    args = alter_database_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_database_result()
    try:
      self._handler.alter_database(args.dbname, args.db)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_database", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_type(self, seqid, iprot, oprot):
    args = get_type_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_type_result()
    try:
      result.success = self._handler.get_type(args.name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_type", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_type(self, seqid, iprot, oprot):
    args = create_type_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_type_result()
    try:
      result.success = self._handler.create_type(args.type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except AlreadyExistsException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("create_type", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_type(self, seqid, iprot, oprot):
    args = drop_type_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_type_result()
    try:
      result.success = self._handler.drop_type(args.type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_type", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_type_all(self, seqid, iprot, oprot):
    args = get_type_all_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_type_all_result()
    try:
      result.success = self._handler.get_type_all(args.name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_type_all", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_fields(self, seqid, iprot, oprot):
    args = get_fields_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_fields_result()
    try:
      result.success = self._handler.get_fields(args.db_name, args.table_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except UnknownTableException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except UnknownDBException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_fields", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_fields_with_environment_context(self, seqid, iprot, oprot):
    args = get_fields_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_fields_with_environment_context_result()
    try:
      result.success = self._handler.get_fields_with_environment_context(args.db_name, args.table_name, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except UnknownTableException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except UnknownDBException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_fields_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_schema(self, seqid, iprot, oprot):
    args = get_schema_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_schema_result()
    try:
      result.success = self._handler.get_schema(args.db_name, args.table_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except UnknownTableException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except UnknownDBException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_schema", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_schema_with_environment_context(self, seqid, iprot, oprot):
    args = get_schema_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_schema_with_environment_context_result()
    try:
      result.success = self._handler.get_schema_with_environment_context(args.db_name, args.table_name, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except UnknownTableException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except UnknownDBException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_schema_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_table(self, seqid, iprot, oprot):
    args = create_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_table_result()
    try:
      self._handler.create_table(args.tbl)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except AlreadyExistsException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except NoSuchObjectException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("create_table", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_table_with_environment_context(self, seqid, iprot, oprot):
    args = create_table_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_table_with_environment_context_result()
    try:
      self._handler.create_table_with_environment_context(args.tbl, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except AlreadyExistsException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except NoSuchObjectException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("create_table_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_table_with_constraints(self, seqid, iprot, oprot):
    args = create_table_with_constraints_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_table_with_constraints_result()
    try:
      self._handler.create_table_with_constraints(args.tbl, args.primaryKeys, args.foreignKeys, args.uniqueConstraints, args.notNullConstraints)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except AlreadyExistsException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except NoSuchObjectException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("create_table_with_constraints", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_constraint(self, seqid, iprot, oprot):
    args = drop_constraint_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_constraint_result()
    try:
      self._handler.drop_constraint(args.req)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_constraint", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_primary_key(self, seqid, iprot, oprot):
    args = add_primary_key_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_primary_key_result()
    try:
      self._handler.add_primary_key(args.req)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("add_primary_key", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_foreign_key(self, seqid, iprot, oprot):
    args = add_foreign_key_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_foreign_key_result()
    try:
      self._handler.add_foreign_key(args.req)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("add_foreign_key", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_unique_constraint(self, seqid, iprot, oprot):
    args = add_unique_constraint_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_unique_constraint_result()
    try:
      self._handler.add_unique_constraint(args.req)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("add_unique_constraint", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_not_null_constraint(self, seqid, iprot, oprot):
    args = add_not_null_constraint_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_not_null_constraint_result()
    try:
      self._handler.add_not_null_constraint(args.req)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("add_not_null_constraint", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_table(self, seqid, iprot, oprot):
    args = drop_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_table_result()
    try:
      self._handler.drop_table(args.dbname, args.name, args.deleteData)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_table", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_table_with_environment_context(self, seqid, iprot, oprot):
    args = drop_table_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_table_with_environment_context_result()
    try:
      self._handler.drop_table_with_environment_context(args.dbname, args.name, args.deleteData, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_table_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_truncate_table(self, seqid, iprot, oprot):
    args = truncate_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = truncate_table_result()
    try:
      self._handler.truncate_table(args.dbName, args.tableName, args.partNames)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("truncate_table", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_tables(self, seqid, iprot, oprot):
    args = get_tables_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_tables_result()
    try:
      result.success = self._handler.get_tables(args.db_name, args.pattern)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_tables", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_tables_by_type(self, seqid, iprot, oprot):
    args = get_tables_by_type_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_tables_by_type_result()
    try:
      result.success = self._handler.get_tables_by_type(args.db_name, args.pattern, args.tableType)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_tables_by_type", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_materialized_views_for_rewriting(self, seqid, iprot, oprot):
    args = get_materialized_views_for_rewriting_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_materialized_views_for_rewriting_result()
    try:
      result.success = self._handler.get_materialized_views_for_rewriting(args.db_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_materialized_views_for_rewriting", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_meta(self, seqid, iprot, oprot):
    args = get_table_meta_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_meta_result()
    try:
      result.success = self._handler.get_table_meta(args.db_patterns, args.tbl_patterns, args.tbl_types)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_table_meta", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_tables(self, seqid, iprot, oprot):
    args = get_all_tables_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_tables_result()
    try:
      result.success = self._handler.get_all_tables(args.db_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_all_tables", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table(self, seqid, iprot, oprot):
    args = get_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_result()
    try:
      result.success = self._handler.get_table(args.dbname, args.tbl_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_table", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_objects_by_name(self, seqid, iprot, oprot):
    args = get_table_objects_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_objects_by_name_result()
    try:
      result.success = self._handler.get_table_objects_by_name(args.dbname, args.tbl_names)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_table_objects_by_name", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_req(self, seqid, iprot, oprot):
    args = get_table_req_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_req_result()
    try:
      result.success = self._handler.get_table_req(args.req)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_table_req", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_objects_by_name_req(self, seqid, iprot, oprot):
    args = get_table_objects_by_name_req_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_objects_by_name_req_result()
    try:
      result.success = self._handler.get_table_objects_by_name_req(args.req)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidOperationException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except UnknownDBException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_table_objects_by_name_req", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_materialization_invalidation_info(self, seqid, iprot, oprot):
    args = get_materialization_invalidation_info_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_materialization_invalidation_info_result()
    try:
      result.success = self._handler.get_materialization_invalidation_info(args.dbname, args.tbl_names)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidOperationException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except UnknownDBException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_materialization_invalidation_info", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_names_by_filter(self, seqid, iprot, oprot):
    args = get_table_names_by_filter_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_names_by_filter_result()
    try:
      result.success = self._handler.get_table_names_by_filter(args.dbname, args.filter, args.max_tables)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidOperationException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except UnknownDBException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_table_names_by_filter", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_table(self, seqid, iprot, oprot):
    args = alter_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_table_result()
    try:
      self._handler.alter_table(args.dbname, args.tbl_name, args.new_tbl)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidOperationException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_table", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_table_with_environment_context(self, seqid, iprot, oprot):
    args = alter_table_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_table_with_environment_context_result()
    try:
      self._handler.alter_table_with_environment_context(args.dbname, args.tbl_name, args.new_tbl, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidOperationException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_table_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_table_with_cascade(self, seqid, iprot, oprot):
    args = alter_table_with_cascade_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_table_with_cascade_result()
    try:
      self._handler.alter_table_with_cascade(args.dbname, args.tbl_name, args.new_tbl, args.cascade)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidOperationException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_table_with_cascade", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_partition(self, seqid, iprot, oprot):
    args = add_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_partition_result()
    try:
      result.success = self._handler.add_partition(args.new_part)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except AlreadyExistsException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("add_partition", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_partition_with_environment_context(self, seqid, iprot, oprot):
    args = add_partition_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_partition_with_environment_context_result()
    try:
      result.success = self._handler.add_partition_with_environment_context(args.new_part, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except AlreadyExistsException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("add_partition_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_partitions(self, seqid, iprot, oprot):
    args = add_partitions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_partitions_result()
    try:
      result.success = self._handler.add_partitions(args.new_parts)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except AlreadyExistsException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("add_partitions", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_partitions_pspec(self, seqid, iprot, oprot):
    args = add_partitions_pspec_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_partitions_pspec_result()
    try:
      result.success = self._handler.add_partitions_pspec(args.new_parts)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except AlreadyExistsException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("add_partitions_pspec", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_append_partition(self, seqid, iprot, oprot):
    args = append_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = append_partition_result()
    try:
      result.success = self._handler.append_partition(args.db_name, args.tbl_name, args.part_vals)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except AlreadyExistsException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("append_partition", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_partitions_req(self, seqid, iprot, oprot):
    args = add_partitions_req_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_partitions_req_result()
    try:
      result.success = self._handler.add_partitions_req(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except AlreadyExistsException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("add_partitions_req", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_append_partition_with_environment_context(self, seqid, iprot, oprot):
    args = append_partition_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = append_partition_with_environment_context_result()
    try:
      result.success = self._handler.append_partition_with_environment_context(args.db_name, args.tbl_name, args.part_vals, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except AlreadyExistsException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("append_partition_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_append_partition_by_name(self, seqid, iprot, oprot):
    args = append_partition_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = append_partition_by_name_result()
    try:
      result.success = self._handler.append_partition_by_name(args.db_name, args.tbl_name, args.part_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except AlreadyExistsException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("append_partition_by_name", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_append_partition_by_name_with_environment_context(self, seqid, iprot, oprot):
    args = append_partition_by_name_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = append_partition_by_name_with_environment_context_result()
    try:
      result.success = self._handler.append_partition_by_name_with_environment_context(args.db_name, args.tbl_name, args.part_name, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except AlreadyExistsException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("append_partition_by_name_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_partition(self, seqid, iprot, oprot):
    args = drop_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_partition_result()
    try:
      result.success = self._handler.drop_partition(args.db_name, args.tbl_name, args.part_vals, args.deleteData)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_partition", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_partition_with_environment_context(self, seqid, iprot, oprot):
    args = drop_partition_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_partition_with_environment_context_result()
    try:
      result.success = self._handler.drop_partition_with_environment_context(args.db_name, args.tbl_name, args.part_vals, args.deleteData, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_partition_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_partition_by_name(self, seqid, iprot, oprot):
    args = drop_partition_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_partition_by_name_result()
    try:
      result.success = self._handler.drop_partition_by_name(args.db_name, args.tbl_name, args.part_name, args.deleteData)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_partition_by_name", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_partition_by_name_with_environment_context(self, seqid, iprot, oprot):
    args = drop_partition_by_name_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_partition_by_name_with_environment_context_result()
    try:
      result.success = self._handler.drop_partition_by_name_with_environment_context(args.db_name, args.tbl_name, args.part_name, args.deleteData, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_partition_by_name_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_partitions_req(self, seqid, iprot, oprot):
    args = drop_partitions_req_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_partitions_req_result()
    try:
      result.success = self._handler.drop_partitions_req(args.req)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_partitions_req", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition(self, seqid, iprot, oprot):
    args = get_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_result()
    try:
      result.success = self._handler.get_partition(args.db_name, args.tbl_name, args.part_vals)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partition", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_exchange_partition(self, seqid, iprot, oprot):
    args = exchange_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = exchange_partition_result()
    try:
      result.success = self._handler.exchange_partition(args.partitionSpecs, args.source_db, args.source_table_name, args.dest_db, args.dest_table_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except InvalidObjectException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except InvalidInputException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("exchange_partition", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_exchange_partitions(self, seqid, iprot, oprot):
    args = exchange_partitions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = exchange_partitions_result()
    try:
      result.success = self._handler.exchange_partitions(args.partitionSpecs, args.source_db, args.source_table_name, args.dest_db, args.dest_table_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except InvalidObjectException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except InvalidInputException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("exchange_partitions", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_with_auth(self, seqid, iprot, oprot):
    args = get_partition_with_auth_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_with_auth_result()
    try:
      result.success = self._handler.get_partition_with_auth(args.db_name, args.tbl_name, args.part_vals, args.user_name, args.group_names)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partition_with_auth", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_by_name(self, seqid, iprot, oprot):
    args = get_partition_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_by_name_result()
    try:
      result.success = self._handler.get_partition_by_name(args.db_name, args.tbl_name, args.part_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partition_by_name", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions(self, seqid, iprot, oprot):
    args = get_partitions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_result()
    try:
      result.success = self._handler.get_partitions(args.db_name, args.tbl_name, args.max_parts)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partitions", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_with_auth(self, seqid, iprot, oprot):
    args = get_partitions_with_auth_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_with_auth_result()
    try:
      result.success = self._handler.get_partitions_with_auth(args.db_name, args.tbl_name, args.max_parts, args.user_name, args.group_names)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partitions_with_auth", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_pspec(self, seqid, iprot, oprot):
    args = get_partitions_pspec_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_pspec_result()
    try:
      result.success = self._handler.get_partitions_pspec(args.db_name, args.tbl_name, args.max_parts)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partitions_pspec", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_names(self, seqid, iprot, oprot):
    args = get_partition_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_names_result()
    try:
      result.success = self._handler.get_partition_names(args.db_name, args.tbl_name, args.max_parts)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partition_names", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_values(self, seqid, iprot, oprot):
    args = get_partition_values_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_values_result()
    try:
      result.success = self._handler.get_partition_values(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partition_values", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_ps(self, seqid, iprot, oprot):
    args = get_partitions_ps_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_ps_result()
    try:
      result.success = self._handler.get_partitions_ps(args.db_name, args.tbl_name, args.part_vals, args.max_parts)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partitions_ps", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_ps_with_auth(self, seqid, iprot, oprot):
    args = get_partitions_ps_with_auth_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_ps_with_auth_result()
    try:
      result.success = self._handler.get_partitions_ps_with_auth(args.db_name, args.tbl_name, args.part_vals, args.max_parts, args.user_name, args.group_names)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partitions_ps_with_auth", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_names_ps(self, seqid, iprot, oprot):
    args = get_partition_names_ps_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_names_ps_result()
    try:
      result.success = self._handler.get_partition_names_ps(args.db_name, args.tbl_name, args.part_vals, args.max_parts)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partition_names_ps", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_by_filter(self, seqid, iprot, oprot):
    args = get_partitions_by_filter_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_by_filter_result()
    try:
      result.success = self._handler.get_partitions_by_filter(args.db_name, args.tbl_name, args.filter, args.max_parts)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partitions_by_filter", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_part_specs_by_filter(self, seqid, iprot, oprot):
    args = get_part_specs_by_filter_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_part_specs_by_filter_result()
    try:
      result.success = self._handler.get_part_specs_by_filter(args.db_name, args.tbl_name, args.filter, args.max_parts)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_part_specs_by_filter", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_by_expr(self, seqid, iprot, oprot):
    args = get_partitions_by_expr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_by_expr_result()
    try:
      result.success = self._handler.get_partitions_by_expr(args.req)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partitions_by_expr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_num_partitions_by_filter(self, seqid, iprot, oprot):
    args = get_num_partitions_by_filter_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_num_partitions_by_filter_result()
    try:
      result.success = self._handler.get_num_partitions_by_filter(args.db_name, args.tbl_name, args.filter)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_num_partitions_by_filter", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_by_names(self, seqid, iprot, oprot):
    args = get_partitions_by_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_by_names_result()
    try:
      result.success = self._handler.get_partitions_by_names(args.db_name, args.tbl_name, args.names)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partitions_by_names", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_partition(self, seqid, iprot, oprot):
    args = alter_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_partition_result()
    try:
      self._handler.alter_partition(args.db_name, args.tbl_name, args.new_part)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidOperationException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_partition", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_partitions(self, seqid, iprot, oprot):
    args = alter_partitions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_partitions_result()
    try:
      self._handler.alter_partitions(args.db_name, args.tbl_name, args.new_parts)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidOperationException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_partitions", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_partitions_with_environment_context(self, seqid, iprot, oprot):
    args = alter_partitions_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_partitions_with_environment_context_result()
    try:
      self._handler.alter_partitions_with_environment_context(args.db_name, args.tbl_name, args.new_parts, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidOperationException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_partitions_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_partition_with_environment_context(self, seqid, iprot, oprot):
    args = alter_partition_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_partition_with_environment_context_result()
    try:
      self._handler.alter_partition_with_environment_context(args.db_name, args.tbl_name, args.new_part, args.environment_context)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidOperationException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_partition_with_environment_context", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_rename_partition(self, seqid, iprot, oprot):
    args = rename_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = rename_partition_result()
    try:
      self._handler.rename_partition(args.db_name, args.tbl_name, args.part_vals, args.new_part)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidOperationException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("rename_partition", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_partition_name_has_valid_characters(self, seqid, iprot, oprot):
    args = partition_name_has_valid_characters_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = partition_name_has_valid_characters_result()
    try:
      result.success = self._handler.partition_name_has_valid_characters(args.part_vals, args.throw_exception)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("partition_name_has_valid_characters", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_config_value(self, seqid, iprot, oprot):
    args = get_config_value_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_config_value_result()
    try:
      result.success = self._handler.get_config_value(args.name, args.defaultValue)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except ConfigValSecurityException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_config_value", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_partition_name_to_vals(self, seqid, iprot, oprot):
    args = partition_name_to_vals_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = partition_name_to_vals_result()
    try:
      result.success = self._handler.partition_name_to_vals(args.part_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("partition_name_to_vals", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_partition_name_to_spec(self, seqid, iprot, oprot):
    args = partition_name_to_spec_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = partition_name_to_spec_result()
    try:
      result.success = self._handler.partition_name_to_spec(args.part_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("partition_name_to_spec", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_markPartitionForEvent(self, seqid, iprot, oprot):
    args = markPartitionForEvent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = markPartitionForEvent_result()
    try:
      self._handler.markPartitionForEvent(args.db_name, args.tbl_name, args.part_vals, args.eventType)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except UnknownDBException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except UnknownTableException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except UnknownPartitionException as o5:
      msg_type = TMessageType.REPLY
      result.o5 = o5
    except InvalidPartitionException as o6:
      msg_type = TMessageType.REPLY
      result.o6 = o6
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("markPartitionForEvent", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_isPartitionMarkedForEvent(self, seqid, iprot, oprot):
    args = isPartitionMarkedForEvent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = isPartitionMarkedForEvent_result()
    try:
      result.success = self._handler.isPartitionMarkedForEvent(args.db_name, args.tbl_name, args.part_vals, args.eventType)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except UnknownDBException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except UnknownTableException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except UnknownPartitionException as o5:
      msg_type = TMessageType.REPLY
      result.o5 = o5
    except InvalidPartitionException as o6:
      msg_type = TMessageType.REPLY
      result.o6 = o6
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("isPartitionMarkedForEvent", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_index(self, seqid, iprot, oprot):
    args = add_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_index_result()
    try:
      result.success = self._handler.add_index(args.new_index, args.index_table)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except AlreadyExistsException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("add_index", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_index(self, seqid, iprot, oprot):
    args = alter_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_index_result()
    try:
      self._handler.alter_index(args.dbname, args.base_tbl_name, args.idx_name, args.new_idx)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidOperationException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_index", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_index_by_name(self, seqid, iprot, oprot):
    args = drop_index_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_index_by_name_result()
    try:
      result.success = self._handler.drop_index_by_name(args.db_name, args.tbl_name, args.index_name, args.deleteData)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_index_by_name", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_index_by_name(self, seqid, iprot, oprot):
    args = get_index_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_index_by_name_result()
    try:
      result.success = self._handler.get_index_by_name(args.db_name, args.tbl_name, args.index_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_index_by_name", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_indexes(self, seqid, iprot, oprot):
    args = get_indexes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_indexes_result()
    try:
      result.success = self._handler.get_indexes(args.db_name, args.tbl_name, args.max_indexes)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_indexes", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_index_names(self, seqid, iprot, oprot):
    args = get_index_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_index_names_result()
    try:
      result.success = self._handler.get_index_names(args.db_name, args.tbl_name, args.max_indexes)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_index_names", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_primary_keys(self, seqid, iprot, oprot):
    args = get_primary_keys_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_primary_keys_result()
    try:
      result.success = self._handler.get_primary_keys(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_primary_keys", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_foreign_keys(self, seqid, iprot, oprot):
    args = get_foreign_keys_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_foreign_keys_result()
    try:
      result.success = self._handler.get_foreign_keys(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_foreign_keys", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_unique_constraints(self, seqid, iprot, oprot):
    args = get_unique_constraints_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_unique_constraints_result()
    try:
      result.success = self._handler.get_unique_constraints(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_unique_constraints", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_not_null_constraints(self, seqid, iprot, oprot):
    args = get_not_null_constraints_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_not_null_constraints_result()
    try:
      result.success = self._handler.get_not_null_constraints(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_not_null_constraints", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_table_column_statistics(self, seqid, iprot, oprot):
    args = update_table_column_statistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_table_column_statistics_result()
    try:
      result.success = self._handler.update_table_column_statistics(args.stats_obj)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except InvalidInputException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("update_table_column_statistics", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_partition_column_statistics(self, seqid, iprot, oprot):
    args = update_partition_column_statistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_partition_column_statistics_result()
    try:
      result.success = self._handler.update_partition_column_statistics(args.stats_obj)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except InvalidInputException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("update_partition_column_statistics", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_column_statistics(self, seqid, iprot, oprot):
    args = get_table_column_statistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_column_statistics_result()
    try:
      result.success = self._handler.get_table_column_statistics(args.db_name, args.tbl_name, args.col_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except InvalidInputException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except InvalidObjectException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_table_column_statistics", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_column_statistics(self, seqid, iprot, oprot):
    args = get_partition_column_statistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_column_statistics_result()
    try:
      result.success = self._handler.get_partition_column_statistics(args.db_name, args.tbl_name, args.part_name, args.col_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except InvalidInputException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except InvalidObjectException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partition_column_statistics", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_statistics_req(self, seqid, iprot, oprot):
    args = get_table_statistics_req_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_statistics_req_result()
    try:
      result.success = self._handler.get_table_statistics_req(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_table_statistics_req", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_statistics_req(self, seqid, iprot, oprot):
    args = get_partitions_statistics_req_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_statistics_req_result()
    try:
      result.success = self._handler.get_partitions_statistics_req(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_partitions_statistics_req", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_aggr_stats_for(self, seqid, iprot, oprot):
    args = get_aggr_stats_for_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_aggr_stats_for_result()
    try:
      result.success = self._handler.get_aggr_stats_for(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_aggr_stats_for", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_aggr_stats_for(self, seqid, iprot, oprot):
    args = set_aggr_stats_for_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_aggr_stats_for_result()
    try:
      result.success = self._handler.set_aggr_stats_for(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except InvalidInputException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("set_aggr_stats_for", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_delete_partition_column_statistics(self, seqid, iprot, oprot):
    args = delete_partition_column_statistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = delete_partition_column_statistics_result()
    try:
      result.success = self._handler.delete_partition_column_statistics(args.db_name, args.tbl_name, args.part_name, args.col_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except InvalidObjectException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except InvalidInputException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("delete_partition_column_statistics", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_delete_table_column_statistics(self, seqid, iprot, oprot):
    args = delete_table_column_statistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = delete_table_column_statistics_result()
    try:
      result.success = self._handler.delete_table_column_statistics(args.db_name, args.tbl_name, args.col_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except InvalidObjectException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except InvalidInputException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("delete_table_column_statistics", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_function(self, seqid, iprot, oprot):
    args = create_function_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_function_result()
    try:
      self._handler.create_function(args.func)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except AlreadyExistsException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except NoSuchObjectException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("create_function", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_function(self, seqid, iprot, oprot):
    args = drop_function_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_function_result()
    try:
      self._handler.drop_function(args.dbName, args.funcName)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_function", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_function(self, seqid, iprot, oprot):
    args = alter_function_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_function_result()
    try:
      self._handler.alter_function(args.dbName, args.funcName, args.newFunc)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidOperationException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_function", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_functions(self, seqid, iprot, oprot):
    args = get_functions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_functions_result()
    try:
      result.success = self._handler.get_functions(args.dbName, args.pattern)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_functions", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_function(self, seqid, iprot, oprot):
    args = get_function_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_function_result()
    try:
      result.success = self._handler.get_function(args.dbName, args.funcName)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_function", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_functions(self, seqid, iprot, oprot):
    args = get_all_functions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_functions_result()
    try:
      result.success = self._handler.get_all_functions()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_all_functions", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_role(self, seqid, iprot, oprot):
    args = create_role_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_role_result()
    try:
      result.success = self._handler.create_role(args.role)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("create_role", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_role(self, seqid, iprot, oprot):
    args = drop_role_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_role_result()
    try:
      result.success = self._handler.drop_role(args.role_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_role", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_role_names(self, seqid, iprot, oprot):
    args = get_role_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_role_names_result()
    try:
      result.success = self._handler.get_role_names()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_role_names", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_grant_role(self, seqid, iprot, oprot):
    args = grant_role_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = grant_role_result()
    try:
      result.success = self._handler.grant_role(args.role_name, args.principal_name, args.principal_type, args.grantor, args.grantorType, args.grant_option)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("grant_role", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revoke_role(self, seqid, iprot, oprot):
    args = revoke_role_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revoke_role_result()
    try:
      result.success = self._handler.revoke_role(args.role_name, args.principal_name, args.principal_type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revoke_role", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_list_roles(self, seqid, iprot, oprot):
    args = list_roles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = list_roles_result()
    try:
      result.success = self._handler.list_roles(args.principal_name, args.principal_type)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("list_roles", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_grant_revoke_role(self, seqid, iprot, oprot):
    args = grant_revoke_role_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = grant_revoke_role_result()
    try:
      result.success = self._handler.grant_revoke_role(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("grant_revoke_role", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_principals_in_role(self, seqid, iprot, oprot):
    args = get_principals_in_role_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_principals_in_role_result()
    try:
      result.success = self._handler.get_principals_in_role(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_principals_in_role", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_role_grants_for_principal(self, seqid, iprot, oprot):
    args = get_role_grants_for_principal_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_role_grants_for_principal_result()
    try:
      result.success = self._handler.get_role_grants_for_principal(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_role_grants_for_principal", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_privilege_set(self, seqid, iprot, oprot):
    args = get_privilege_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_privilege_set_result()
    try:
      result.success = self._handler.get_privilege_set(args.hiveObject, args.user_name, args.group_names)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_privilege_set", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_list_privileges(self, seqid, iprot, oprot):
    args = list_privileges_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = list_privileges_result()
    try:
      result.success = self._handler.list_privileges(args.principal_name, args.principal_type, args.hiveObject)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("list_privileges", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_grant_privileges(self, seqid, iprot, oprot):
    args = grant_privileges_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = grant_privileges_result()
    try:
      result.success = self._handler.grant_privileges(args.privileges)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("grant_privileges", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revoke_privileges(self, seqid, iprot, oprot):
    args = revoke_privileges_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revoke_privileges_result()
    try:
      result.success = self._handler.revoke_privileges(args.privileges)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revoke_privileges", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_grant_revoke_privileges(self, seqid, iprot, oprot):
    args = grant_revoke_privileges_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = grant_revoke_privileges_result()
    try:
      result.success = self._handler.grant_revoke_privileges(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("grant_revoke_privileges", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_ugi(self, seqid, iprot, oprot):
    args = set_ugi_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_ugi_result()
    try:
      result.success = self._handler.set_ugi(args.user_name, args.group_names)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("set_ugi", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_delegation_token(self, seqid, iprot, oprot):
    args = get_delegation_token_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_delegation_token_result()
    try:
      result.success = self._handler.get_delegation_token(args.token_owner, args.renewer_kerberos_principal_name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_delegation_token", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_renew_delegation_token(self, seqid, iprot, oprot):
    args = renew_delegation_token_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = renew_delegation_token_result()
    try:
      result.success = self._handler.renew_delegation_token(args.token_str_form)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("renew_delegation_token", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cancel_delegation_token(self, seqid, iprot, oprot):
    args = cancel_delegation_token_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cancel_delegation_token_result()
    try:
      self._handler.cancel_delegation_token(args.token_str_form)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("cancel_delegation_token", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_token(self, seqid, iprot, oprot):
    args = add_token_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_token_result()
    try:
      result.success = self._handler.add_token(args.token_identifier, args.delegation_token)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("add_token", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_remove_token(self, seqid, iprot, oprot):
    args = remove_token_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = remove_token_result()
    try:
      result.success = self._handler.remove_token(args.token_identifier)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("remove_token", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_token(self, seqid, iprot, oprot):
    args = get_token_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_token_result()
    try:
      result.success = self._handler.get_token(args.token_identifier)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_token", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_token_identifiers(self, seqid, iprot, oprot):
    args = get_all_token_identifiers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_token_identifiers_result()
    try:
      result.success = self._handler.get_all_token_identifiers()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_all_token_identifiers", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_master_key(self, seqid, iprot, oprot):
    args = add_master_key_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_master_key_result()
    try:
      result.success = self._handler.add_master_key(args.key)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("add_master_key", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_master_key(self, seqid, iprot, oprot):
    args = update_master_key_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_master_key_result()
    try:
      self._handler.update_master_key(args.seq_number, args.key)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("update_master_key", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_remove_master_key(self, seqid, iprot, oprot):
    args = remove_master_key_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = remove_master_key_result()
    try:
      result.success = self._handler.remove_master_key(args.key_seq)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("remove_master_key", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_master_keys(self, seqid, iprot, oprot):
    args = get_master_keys_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_master_keys_result()
    try:
      result.success = self._handler.get_master_keys()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_master_keys", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_open_txns(self, seqid, iprot, oprot):
    args = get_open_txns_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_open_txns_result()
    try:
      result.success = self._handler.get_open_txns()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_open_txns", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_open_txns_info(self, seqid, iprot, oprot):
    args = get_open_txns_info_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_open_txns_info_result()
    try:
      result.success = self._handler.get_open_txns_info()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_open_txns_info", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_open_txns(self, seqid, iprot, oprot):
    args = open_txns_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = open_txns_result()
    try:
      result.success = self._handler.open_txns(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("open_txns", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_abort_txn(self, seqid, iprot, oprot):
    args = abort_txn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = abort_txn_result()
    try:
      self._handler.abort_txn(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchTxnException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("abort_txn", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_abort_txns(self, seqid, iprot, oprot):
    args = abort_txns_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = abort_txns_result()
    try:
      self._handler.abort_txns(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchTxnException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("abort_txns", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_commit_txn(self, seqid, iprot, oprot):
    args = commit_txn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = commit_txn_result()
    try:
      self._handler.commit_txn(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchTxnException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except TxnAbortedException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("commit_txn", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_lock(self, seqid, iprot, oprot):
    args = lock_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = lock_result()
    try:
      result.success = self._handler.lock(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchTxnException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except TxnAbortedException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("lock", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_check_lock(self, seqid, iprot, oprot):
    args = check_lock_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = check_lock_result()
    try:
      result.success = self._handler.check_lock(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchTxnException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except TxnAbortedException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except NoSuchLockException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("check_lock", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_unlock(self, seqid, iprot, oprot):
    args = unlock_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = unlock_result()
    try:
      self._handler.unlock(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchLockException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except TxnOpenException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("unlock", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_show_locks(self, seqid, iprot, oprot):
    args = show_locks_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = show_locks_result()
    try:
      result.success = self._handler.show_locks(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("show_locks", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_heartbeat(self, seqid, iprot, oprot):
    args = heartbeat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = heartbeat_result()
    try:
      self._handler.heartbeat(args.ids)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchLockException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchTxnException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except TxnAbortedException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("heartbeat", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_heartbeat_txn_range(self, seqid, iprot, oprot):
    args = heartbeat_txn_range_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = heartbeat_txn_range_result()
    try:
      result.success = self._handler.heartbeat_txn_range(args.txns)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("heartbeat_txn_range", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_compact(self, seqid, iprot, oprot):
    args = compact_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = compact_result()
    try:
      self._handler.compact(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("compact", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_compact2(self, seqid, iprot, oprot):
    args = compact2_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = compact2_result()
    try:
      result.success = self._handler.compact2(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("compact2", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_show_compact(self, seqid, iprot, oprot):
    args = show_compact_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = show_compact_result()
    try:
      result.success = self._handler.show_compact(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("show_compact", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_dynamic_partitions(self, seqid, iprot, oprot):
    args = add_dynamic_partitions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_dynamic_partitions_result()
    try:
      self._handler.add_dynamic_partitions(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchTxnException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except TxnAbortedException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("add_dynamic_partitions", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_next_notification(self, seqid, iprot, oprot):
    args = get_next_notification_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_next_notification_result()
    try:
      result.success = self._handler.get_next_notification(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_next_notification", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_current_notificationEventId(self, seqid, iprot, oprot):
    args = get_current_notificationEventId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_current_notificationEventId_result()
    try:
      result.success = self._handler.get_current_notificationEventId()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_current_notificationEventId", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_notification_events_count(self, seqid, iprot, oprot):
    args = get_notification_events_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_notification_events_count_result()
    try:
      result.success = self._handler.get_notification_events_count(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_notification_events_count", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_fire_listener_event(self, seqid, iprot, oprot):
    args = fire_listener_event_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = fire_listener_event_result()
    try:
      result.success = self._handler.fire_listener_event(args.rqst)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("fire_listener_event", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_flushCache(self, seqid, iprot, oprot):
    args = flushCache_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = flushCache_result()
    try:
      self._handler.flushCache()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("flushCache", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cm_recycle(self, seqid, iprot, oprot):
    args = cm_recycle_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cm_recycle_result()
    try:
      result.success = self._handler.cm_recycle(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("cm_recycle", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_file_metadata_by_expr(self, seqid, iprot, oprot):
    args = get_file_metadata_by_expr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_file_metadata_by_expr_result()
    try:
      result.success = self._handler.get_file_metadata_by_expr(args.req)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_file_metadata_by_expr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_file_metadata(self, seqid, iprot, oprot):
    args = get_file_metadata_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_file_metadata_result()
    try:
      result.success = self._handler.get_file_metadata(args.req)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_file_metadata", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_put_file_metadata(self, seqid, iprot, oprot):
    args = put_file_metadata_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = put_file_metadata_result()
    try:
      result.success = self._handler.put_file_metadata(args.req)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("put_file_metadata", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clear_file_metadata(self, seqid, iprot, oprot):
    args = clear_file_metadata_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clear_file_metadata_result()
    try:
      result.success = self._handler.clear_file_metadata(args.req)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("clear_file_metadata", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cache_file_metadata(self, seqid, iprot, oprot):
    args = cache_file_metadata_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cache_file_metadata_result()
    try:
      result.success = self._handler.cache_file_metadata(args.req)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("cache_file_metadata", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_metastore_db_uuid(self, seqid, iprot, oprot):
    args = get_metastore_db_uuid_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_metastore_db_uuid_result()
    try:
      result.success = self._handler.get_metastore_db_uuid()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_metastore_db_uuid", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_resource_plan(self, seqid, iprot, oprot):
    args = create_resource_plan_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_resource_plan_result()
    try:
      result.success = self._handler.create_resource_plan(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except AlreadyExistsException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("create_resource_plan", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_resource_plan(self, seqid, iprot, oprot):
    args = get_resource_plan_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_resource_plan_result()
    try:
      result.success = self._handler.get_resource_plan(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_resource_plan", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_active_resource_plan(self, seqid, iprot, oprot):
    args = get_active_resource_plan_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_active_resource_plan_result()
    try:
      result.success = self._handler.get_active_resource_plan(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_active_resource_plan", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_resource_plans(self, seqid, iprot, oprot):
    args = get_all_resource_plans_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_resource_plans_result()
    try:
      result.success = self._handler.get_all_resource_plans(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except MetaException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_all_resource_plans", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_resource_plan(self, seqid, iprot, oprot):
    args = alter_resource_plan_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_resource_plan_result()
    try:
      result.success = self._handler.alter_resource_plan(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidOperationException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_resource_plan", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_validate_resource_plan(self, seqid, iprot, oprot):
    args = validate_resource_plan_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = validate_resource_plan_result()
    try:
      result.success = self._handler.validate_resource_plan(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("validate_resource_plan", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_resource_plan(self, seqid, iprot, oprot):
    args = drop_resource_plan_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_resource_plan_result()
    try:
      result.success = self._handler.drop_resource_plan(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidOperationException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_resource_plan", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_wm_trigger(self, seqid, iprot, oprot):
    args = create_wm_trigger_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_wm_trigger_result()
    try:
      result.success = self._handler.create_wm_trigger(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except AlreadyExistsException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except InvalidObjectException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except MetaException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("create_wm_trigger", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_wm_trigger(self, seqid, iprot, oprot):
    args = alter_wm_trigger_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_wm_trigger_result()
    try:
      result.success = self._handler.alter_wm_trigger(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_wm_trigger", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_wm_trigger(self, seqid, iprot, oprot):
    args = drop_wm_trigger_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_wm_trigger_result()
    try:
      result.success = self._handler.drop_wm_trigger(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidOperationException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_wm_trigger", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_triggers_for_resourceplan(self, seqid, iprot, oprot):
    args = get_triggers_for_resourceplan_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_triggers_for_resourceplan_result()
    try:
      result.success = self._handler.get_triggers_for_resourceplan(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except MetaException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("get_triggers_for_resourceplan", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_wm_pool(self, seqid, iprot, oprot):
    args = create_wm_pool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_wm_pool_result()
    try:
      result.success = self._handler.create_wm_pool(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except AlreadyExistsException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except InvalidObjectException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except MetaException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("create_wm_pool", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_wm_pool(self, seqid, iprot, oprot):
    args = alter_wm_pool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_wm_pool_result()
    try:
      result.success = self._handler.alter_wm_pool(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except AlreadyExistsException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except InvalidObjectException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except MetaException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("alter_wm_pool", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_wm_pool(self, seqid, iprot, oprot):
    args = drop_wm_pool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_wm_pool_result()
    try:
      result.success = self._handler.drop_wm_pool(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidOperationException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_wm_pool", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_or_update_wm_mapping(self, seqid, iprot, oprot):
    args = create_or_update_wm_mapping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_or_update_wm_mapping_result()
    try:
      result.success = self._handler.create_or_update_wm_mapping(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except AlreadyExistsException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except InvalidObjectException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except MetaException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("create_or_update_wm_mapping", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_wm_mapping(self, seqid, iprot, oprot):
    args = drop_wm_mapping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_wm_mapping_result()
    try:
      result.success = self._handler.drop_wm_mapping(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except NoSuchObjectException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except InvalidOperationException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except MetaException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("drop_wm_mapping", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_or_drop_wm_trigger_to_pool_mapping(self, seqid, iprot, oprot):
    args = create_or_drop_wm_trigger_to_pool_mapping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_or_drop_wm_trigger_to_pool_mapping_result()
    try:
      result.success = self._handler.create_or_drop_wm_trigger_to_pool_mapping(args.request)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except AlreadyExistsException as o1:
      msg_type = TMessageType.REPLY
      result.o1 = o1
    except NoSuchObjectException as o2:
      msg_type = TMessageType.REPLY
      result.o2 = o2
    except InvalidObjectException as o3:
      msg_type = TMessageType.REPLY
      result.o3 = o3
    except MetaException as o4:
      msg_type = TMessageType.REPLY
      result.o4 = o4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("create_or_drop_wm_trigger_to_pool_mapping", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class getMetaConf_args:
  """
  Attributes:
   - key
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
  )

  def __init__(self, key=None,):
    self.key = key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMetaConf_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMetaConf_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMetaConf_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setMetaConf_args:
  """
  Attributes:
   - key
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'value', None, None, ), # 2
  )

  def __init__(self, key=None, value=None,):
    self.key = key
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setMetaConf_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setMetaConf_result:
  """
  Attributes:
   - o1
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, o1=None,):
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setMetaConf_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_database_args:
  """
  Attributes:
   - database
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'database', (Database, Database.thrift_spec), None, ), # 1
  )

  def __init__(self, database=None,):
    self.database = database

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.database = Database()
          self.database.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_database_args')
    if self.database is not None:
      oprot.writeFieldBegin('database', TType.STRUCT, 1)
      self.database.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.database)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_database_result:
  """
  Attributes:
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, o1=None, o2=None, o3=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_database_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_database_args:
  """
  Attributes:
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
  )

  def __init__(self, name=None,):
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_database_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_database_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Database, Database.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Database()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_database_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_database_args:
  """
  Attributes:
   - name
   - deleteData
   - cascade
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.BOOL, 'deleteData', None, None, ), # 2
    (3, TType.BOOL, 'cascade', None, None, ), # 3
  )

  def __init__(self, name=None, deleteData=None, cascade=None,):
    self.name = name
    self.deleteData = deleteData
    self.cascade = cascade

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.cascade = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_database_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 2)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    if self.cascade is not None:
      oprot.writeFieldBegin('cascade', TType.BOOL, 3)
      oprot.writeBool(self.cascade)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.deleteData)
    value = (value * 31) ^ hash(self.cascade)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_database_result:
  """
  Attributes:
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, o1=None, o2=None, o3=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidOperationException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_database_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_databases_args:
  """
  Attributes:
   - pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pattern', None, None, ), # 1
  )

  def __init__(self, pattern=None,):
    self.pattern = pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pattern = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_databases_args')
    if self.pattern is not None:
      oprot.writeFieldBegin('pattern', TType.STRING, 1)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pattern)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_databases_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype723, _size720) = iprot.readListBegin()
          for _i724 in xrange(_size720):
            _elem725 = iprot.readString()
            self.success.append(_elem725)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_databases_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter726 in self.success:
        oprot.writeString(iter726)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_databases_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_databases_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_databases_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype730, _size727) = iprot.readListBegin()
          for _i731 in xrange(_size727):
            _elem732 = iprot.readString()
            self.success.append(_elem732)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_databases_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter733 in self.success:
        oprot.writeString(iter733)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_database_args:
  """
  Attributes:
   - dbname
   - db
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRUCT, 'db', (Database, Database.thrift_spec), None, ), # 2
  )

  def __init__(self, dbname=None, db=None,):
    self.dbname = dbname
    self.db = db

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.db = Database()
          self.db.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_database_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRUCT, 2)
      self.db.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.db)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_database_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_database_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_type_args:
  """
  Attributes:
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
  )

  def __init__(self, name=None,):
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_type_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_type_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Type, Type.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Type()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_type_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_type_args:
  """
  Attributes:
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'type', (Type, Type.thrift_spec), None, ), # 1
  )

  def __init__(self, type=None,):
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.type = Type()
          self.type.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_type_args')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRUCT, 1)
      self.type.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_type_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_type_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_type_args:
  """
  Attributes:
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'type', None, None, ), # 1
  )

  def __init__(self, type=None,):
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.type = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_type_args')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 1)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_type_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_type_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_type_all_args:
  """
  Attributes:
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
  )

  def __init__(self, name=None,):
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_type_all_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_type_all_result:
  """
  Attributes:
   - success
   - o2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(Type, Type.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o2=None,):
    self.success = success
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype735, _vtype736, _size734 ) = iprot.readMapBegin()
          for _i738 in xrange(_size734):
            _key739 = iprot.readString()
            _val740 = Type()
            _val740.read(iprot)
            self.success[_key739] = _val740
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_type_all_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter741,viter742 in self.success.items():
        oprot.writeString(kiter741)
        viter742.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 1)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_fields_args:
  """
  Attributes:
   - db_name
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
  )

  def __init__(self, db_name=None, table_name=None,):
    self.db_name = db_name
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_fields_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.table_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_fields_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype746, _size743) = iprot.readListBegin()
          for _i747 in xrange(_size743):
            _elem748 = FieldSchema()
            _elem748.read(iprot)
            self.success.append(_elem748)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = UnknownTableException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_fields_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter749 in self.success:
        iter749.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_fields_with_environment_context_args:
  """
  Attributes:
   - db_name
   - table_name
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 3
  )

  def __init__(self, db_name=None, table_name=None, environment_context=None,):
    self.db_name = db_name
    self.table_name = table_name
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_fields_with_environment_context_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 3)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_fields_with_environment_context_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype753, _size750) = iprot.readListBegin()
          for _i754 in xrange(_size750):
            _elem755 = FieldSchema()
            _elem755.read(iprot)
            self.success.append(_elem755)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = UnknownTableException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_fields_with_environment_context_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter756 in self.success:
        iter756.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_schema_args:
  """
  Attributes:
   - db_name
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
  )

  def __init__(self, db_name=None, table_name=None,):
    self.db_name = db_name
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_schema_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.table_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_schema_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype760, _size757) = iprot.readListBegin()
          for _i761 in xrange(_size757):
            _elem762 = FieldSchema()
            _elem762.read(iprot)
            self.success.append(_elem762)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = UnknownTableException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_schema_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter763 in self.success:
        iter763.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_schema_with_environment_context_args:
  """
  Attributes:
   - db_name
   - table_name
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 3
  )

  def __init__(self, db_name=None, table_name=None, environment_context=None,):
    self.db_name = db_name
    self.table_name = table_name
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_schema_with_environment_context_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 3)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_schema_with_environment_context_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype767, _size764) = iprot.readListBegin()
          for _i768 in xrange(_size764):
            _elem769 = FieldSchema()
            _elem769.read(iprot)
            self.success.append(_elem769)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = UnknownTableException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_schema_with_environment_context_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter770 in self.success:
        iter770.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_args:
  """
  Attributes:
   - tbl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tbl', (Table, Table.thrift_spec), None, ), # 1
  )

  def __init__(self, tbl=None,):
    self.tbl = tbl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tbl = Table()
          self.tbl.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_args')
    if self.tbl is not None:
      oprot.writeFieldBegin('tbl', TType.STRUCT, 1)
      self.tbl.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tbl)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_result:
  """
  Attributes:
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 4
  )

  def __init__(self, o1=None, o2=None, o3=None, o4=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = NoSuchObjectException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_with_environment_context_args:
  """
  Attributes:
   - tbl
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tbl', (Table, Table.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 2
  )

  def __init__(self, tbl=None, environment_context=None,):
    self.tbl = tbl
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tbl = Table()
          self.tbl.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_with_environment_context_args')
    if self.tbl is not None:
      oprot.writeFieldBegin('tbl', TType.STRUCT, 1)
      self.tbl.write(oprot)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 2)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tbl)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_with_environment_context_result:
  """
  Attributes:
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 4
  )

  def __init__(self, o1=None, o2=None, o3=None, o4=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = NoSuchObjectException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_with_environment_context_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_with_constraints_args:
  """
  Attributes:
   - tbl
   - primaryKeys
   - foreignKeys
   - uniqueConstraints
   - notNullConstraints
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tbl', (Table, Table.thrift_spec), None, ), # 1
    (2, TType.LIST, 'primaryKeys', (TType.STRUCT,(SQLPrimaryKey, SQLPrimaryKey.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'foreignKeys', (TType.STRUCT,(SQLForeignKey, SQLForeignKey.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'uniqueConstraints', (TType.STRUCT,(SQLUniqueConstraint, SQLUniqueConstraint.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'notNullConstraints', (TType.STRUCT,(SQLNotNullConstraint, SQLNotNullConstraint.thrift_spec)), None, ), # 5
  )

  def __init__(self, tbl=None, primaryKeys=None, foreignKeys=None, uniqueConstraints=None, notNullConstraints=None,):
    self.tbl = tbl
    self.primaryKeys = primaryKeys
    self.foreignKeys = foreignKeys
    self.uniqueConstraints = uniqueConstraints
    self.notNullConstraints = notNullConstraints

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tbl = Table()
          self.tbl.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.primaryKeys = []
          (_etype774, _size771) = iprot.readListBegin()
          for _i775 in xrange(_size771):
            _elem776 = SQLPrimaryKey()
            _elem776.read(iprot)
            self.primaryKeys.append(_elem776)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.foreignKeys = []
          (_etype780, _size777) = iprot.readListBegin()
          for _i781 in xrange(_size777):
            _elem782 = SQLForeignKey()
            _elem782.read(iprot)
            self.foreignKeys.append(_elem782)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.uniqueConstraints = []
          (_etype786, _size783) = iprot.readListBegin()
          for _i787 in xrange(_size783):
            _elem788 = SQLUniqueConstraint()
            _elem788.read(iprot)
            self.uniqueConstraints.append(_elem788)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.notNullConstraints = []
          (_etype792, _size789) = iprot.readListBegin()
          for _i793 in xrange(_size789):
            _elem794 = SQLNotNullConstraint()
            _elem794.read(iprot)
            self.notNullConstraints.append(_elem794)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_with_constraints_args')
    if self.tbl is not None:
      oprot.writeFieldBegin('tbl', TType.STRUCT, 1)
      self.tbl.write(oprot)
      oprot.writeFieldEnd()
    if self.primaryKeys is not None:
      oprot.writeFieldBegin('primaryKeys', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.primaryKeys))
      for iter795 in self.primaryKeys:
        iter795.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.foreignKeys is not None:
      oprot.writeFieldBegin('foreignKeys', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.foreignKeys))
      for iter796 in self.foreignKeys:
        iter796.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.uniqueConstraints is not None:
      oprot.writeFieldBegin('uniqueConstraints', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.uniqueConstraints))
      for iter797 in self.uniqueConstraints:
        iter797.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.notNullConstraints is not None:
      oprot.writeFieldBegin('notNullConstraints', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.notNullConstraints))
      for iter798 in self.notNullConstraints:
        iter798.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tbl)
    value = (value * 31) ^ hash(self.primaryKeys)
    value = (value * 31) ^ hash(self.foreignKeys)
    value = (value * 31) ^ hash(self.uniqueConstraints)
    value = (value * 31) ^ hash(self.notNullConstraints)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_with_constraints_result:
  """
  Attributes:
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 4
  )

  def __init__(self, o1=None, o2=None, o3=None, o4=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = NoSuchObjectException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_with_constraints_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_constraint_args:
  """
  Attributes:
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'req', (DropConstraintRequest, DropConstraintRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, req=None,):
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = DropConstraintRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_constraint_args')
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.req)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_constraint_result:
  """
  Attributes:
   - o1
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o3=None,):
    self.o1 = o1
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_constraint_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 2)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_primary_key_args:
  """
  Attributes:
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'req', (AddPrimaryKeyRequest, AddPrimaryKeyRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, req=None,):
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = AddPrimaryKeyRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_primary_key_args')
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.req)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_primary_key_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_primary_key_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_foreign_key_args:
  """
  Attributes:
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'req', (AddForeignKeyRequest, AddForeignKeyRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, req=None,):
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = AddForeignKeyRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_foreign_key_args')
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.req)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_foreign_key_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_foreign_key_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_unique_constraint_args:
  """
  Attributes:
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'req', (AddUniqueConstraintRequest, AddUniqueConstraintRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, req=None,):
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = AddUniqueConstraintRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_unique_constraint_args')
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.req)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_unique_constraint_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_unique_constraint_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_not_null_constraint_args:
  """
  Attributes:
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'req', (AddNotNullConstraintRequest, AddNotNullConstraintRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, req=None,):
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = AddNotNullConstraintRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_not_null_constraint_args')
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.req)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_not_null_constraint_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_not_null_constraint_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_table_args:
  """
  Attributes:
   - dbname
   - name
   - deleteData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.BOOL, 'deleteData', None, None, ), # 3
  )

  def __init__(self, dbname=None, name=None, deleteData=None,):
    self.dbname = dbname
    self.name = name
    self.deleteData = deleteData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_table_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 3)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.deleteData)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_table_result:
  """
  Attributes:
   - o1
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o3=None,):
    self.o1 = o1
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_table_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 2)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_table_with_environment_context_args:
  """
  Attributes:
   - dbname
   - name
   - deleteData
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.BOOL, 'deleteData', None, None, ), # 3
    (4, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 4
  )

  def __init__(self, dbname=None, name=None, deleteData=None, environment_context=None,):
    self.dbname = dbname
    self.name = name
    self.deleteData = deleteData
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_table_with_environment_context_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 3)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.deleteData)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_table_with_environment_context_result:
  """
  Attributes:
   - o1
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o3=None,):
    self.o1 = o1
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_table_with_environment_context_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 2)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class truncate_table_args:
  """
  Attributes:
   - dbName
   - tableName
   - partNames
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.LIST, 'partNames', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, dbName=None, tableName=None, partNames=None,):
    self.dbName = dbName
    self.tableName = tableName
    self.partNames = partNames

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.partNames = []
          (_etype802, _size799) = iprot.readListBegin()
          for _i803 in xrange(_size799):
            _elem804 = iprot.readString()
            self.partNames.append(_elem804)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('truncate_table_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.partNames is not None:
      oprot.writeFieldBegin('partNames', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.partNames))
      for iter805 in self.partNames:
        oprot.writeString(iter805)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.partNames)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class truncate_table_result:
  """
  Attributes:
   - o1
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, o1=None,):
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('truncate_table_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_tables_args:
  """
  Attributes:
   - db_name
   - pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'pattern', None, None, ), # 2
  )

  def __init__(self, db_name=None, pattern=None,):
    self.db_name = db_name
    self.pattern = pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pattern = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_tables_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.pattern is not None:
      oprot.writeFieldBegin('pattern', TType.STRING, 2)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.pattern)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_tables_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype809, _size806) = iprot.readListBegin()
          for _i810 in xrange(_size806):
            _elem811 = iprot.readString()
            self.success.append(_elem811)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_tables_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter812 in self.success:
        oprot.writeString(iter812)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_tables_by_type_args:
  """
  Attributes:
   - db_name
   - pattern
   - tableType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'pattern', None, None, ), # 2
    (3, TType.STRING, 'tableType', None, None, ), # 3
  )

  def __init__(self, db_name=None, pattern=None, tableType=None,):
    self.db_name = db_name
    self.pattern = pattern
    self.tableType = tableType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pattern = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tableType = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_tables_by_type_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.pattern is not None:
      oprot.writeFieldBegin('pattern', TType.STRING, 2)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    if self.tableType is not None:
      oprot.writeFieldBegin('tableType', TType.STRING, 3)
      oprot.writeString(self.tableType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.pattern)
    value = (value * 31) ^ hash(self.tableType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_tables_by_type_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype816, _size813) = iprot.readListBegin()
          for _i817 in xrange(_size813):
            _elem818 = iprot.readString()
            self.success.append(_elem818)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_tables_by_type_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter819 in self.success:
        oprot.writeString(iter819)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_materialized_views_for_rewriting_args:
  """
  Attributes:
   - db_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
  )

  def __init__(self, db_name=None,):
    self.db_name = db_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_materialized_views_for_rewriting_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_materialized_views_for_rewriting_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype823, _size820) = iprot.readListBegin()
          for _i824 in xrange(_size820):
            _elem825 = iprot.readString()
            self.success.append(_elem825)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_materialized_views_for_rewriting_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter826 in self.success:
        oprot.writeString(iter826)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_meta_args:
  """
  Attributes:
   - db_patterns
   - tbl_patterns
   - tbl_types
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_patterns', None, None, ), # 1
    (2, TType.STRING, 'tbl_patterns', None, None, ), # 2
    (3, TType.LIST, 'tbl_types', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, db_patterns=None, tbl_patterns=None, tbl_types=None,):
    self.db_patterns = db_patterns
    self.tbl_patterns = tbl_patterns
    self.tbl_types = tbl_types

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_patterns = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_patterns = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.tbl_types = []
          (_etype830, _size827) = iprot.readListBegin()
          for _i831 in xrange(_size827):
            _elem832 = iprot.readString()
            self.tbl_types.append(_elem832)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_meta_args')
    if self.db_patterns is not None:
      oprot.writeFieldBegin('db_patterns', TType.STRING, 1)
      oprot.writeString(self.db_patterns)
      oprot.writeFieldEnd()
    if self.tbl_patterns is not None:
      oprot.writeFieldBegin('tbl_patterns', TType.STRING, 2)
      oprot.writeString(self.tbl_patterns)
      oprot.writeFieldEnd()
    if self.tbl_types is not None:
      oprot.writeFieldBegin('tbl_types', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.tbl_types))
      for iter833 in self.tbl_types:
        oprot.writeString(iter833)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_patterns)
    value = (value * 31) ^ hash(self.tbl_patterns)
    value = (value * 31) ^ hash(self.tbl_types)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_meta_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TableMeta, TableMeta.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype837, _size834) = iprot.readListBegin()
          for _i838 in xrange(_size834):
            _elem839 = TableMeta()
            _elem839.read(iprot)
            self.success.append(_elem839)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_meta_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter840 in self.success:
        iter840.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_tables_args:
  """
  Attributes:
   - db_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
  )

  def __init__(self, db_name=None,):
    self.db_name = db_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_tables_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_tables_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype844, _size841) = iprot.readListBegin()
          for _i845 in xrange(_size841):
            _elem846 = iprot.readString()
            self.success.append(_elem846)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_tables_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter847 in self.success:
        oprot.writeString(iter847)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_args:
  """
  Attributes:
   - dbname
   - tbl_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
  )

  def __init__(self, dbname=None, tbl_name=None,):
    self.dbname = dbname
    self.tbl_name = tbl_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tbl_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Table, Table.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Table()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_objects_by_name_args:
  """
  Attributes:
   - dbname
   - tbl_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.LIST, 'tbl_names', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, dbname=None, tbl_names=None,):
    self.dbname = dbname
    self.tbl_names = tbl_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tbl_names = []
          (_etype851, _size848) = iprot.readListBegin()
          for _i852 in xrange(_size848):
            _elem853 = iprot.readString()
            self.tbl_names.append(_elem853)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_objects_by_name_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_names is not None:
      oprot.writeFieldBegin('tbl_names', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.tbl_names))
      for iter854 in self.tbl_names:
        oprot.writeString(iter854)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tbl_names)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_objects_by_name_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Table, Table.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype858, _size855) = iprot.readListBegin()
          for _i859 in xrange(_size855):
            _elem860 = Table()
            _elem860.read(iprot)
            self.success.append(_elem860)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_objects_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter861 in self.success:
        iter861.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_req_args:
  """
  Attributes:
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'req', (GetTableRequest, GetTableRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, req=None,):
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = GetTableRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_req_args')
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.req)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_req_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetTableResult, GetTableResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetTableResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_req_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_objects_by_name_req_args:
  """
  Attributes:
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'req', (GetTablesRequest, GetTablesRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, req=None,):
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = GetTablesRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_objects_by_name_req_args')
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.req)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_objects_by_name_req_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetTablesResult, GetTablesResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetTablesResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidOperationException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_objects_by_name_req_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_materialization_invalidation_info_args:
  """
  Attributes:
   - dbname
   - tbl_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.LIST, 'tbl_names', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, dbname=None, tbl_names=None,):
    self.dbname = dbname
    self.tbl_names = tbl_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tbl_names = []
          (_etype865, _size862) = iprot.readListBegin()
          for _i866 in xrange(_size862):
            _elem867 = iprot.readString()
            self.tbl_names.append(_elem867)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_materialization_invalidation_info_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_names is not None:
      oprot.writeFieldBegin('tbl_names', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.tbl_names))
      for iter868 in self.tbl_names:
        oprot.writeString(iter868)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tbl_names)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_materialization_invalidation_info_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(Materialization, Materialization.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype870, _vtype871, _size869 ) = iprot.readMapBegin()
          for _i873 in xrange(_size869):
            _key874 = iprot.readString()
            _val875 = Materialization()
            _val875.read(iprot)
            self.success[_key874] = _val875
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidOperationException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_materialization_invalidation_info_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter876,viter877 in self.success.items():
        oprot.writeString(kiter876)
        viter877.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_names_by_filter_args:
  """
  Attributes:
   - dbname
   - filter
   - max_tables
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'filter', None, None, ), # 2
    (3, TType.I16, 'max_tables', None, -1, ), # 3
  )

  def __init__(self, dbname=None, filter=None, max_tables=thrift_spec[3][4],):
    self.dbname = dbname
    self.filter = filter
    self.max_tables = max_tables

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_tables = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_names_by_filter_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRING, 2)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.max_tables is not None:
      oprot.writeFieldBegin('max_tables', TType.I16, 3)
      oprot.writeI16(self.max_tables)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.filter)
    value = (value * 31) ^ hash(self.max_tables)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_names_by_filter_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype881, _size878) = iprot.readListBegin()
          for _i882 in xrange(_size878):
            _elem883 = iprot.readString()
            self.success.append(_elem883)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidOperationException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_names_by_filter_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter884 in self.success:
        oprot.writeString(iter884)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_args:
  """
  Attributes:
   - dbname
   - tbl_name
   - new_tbl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRUCT, 'new_tbl', (Table, Table.thrift_spec), None, ), # 3
  )

  def __init__(self, dbname=None, tbl_name=None, new_tbl=None,):
    self.dbname = dbname
    self.tbl_name = tbl_name
    self.new_tbl = new_tbl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_tbl = Table()
          self.new_tbl.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_tbl is not None:
      oprot.writeFieldBegin('new_tbl', TType.STRUCT, 3)
      self.new_tbl.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.new_tbl)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_with_environment_context_args:
  """
  Attributes:
   - dbname
   - tbl_name
   - new_tbl
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRUCT, 'new_tbl', (Table, Table.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 4
  )

  def __init__(self, dbname=None, tbl_name=None, new_tbl=None, environment_context=None,):
    self.dbname = dbname
    self.tbl_name = tbl_name
    self.new_tbl = new_tbl
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_tbl = Table()
          self.new_tbl.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_with_environment_context_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_tbl is not None:
      oprot.writeFieldBegin('new_tbl', TType.STRUCT, 3)
      self.new_tbl.write(oprot)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.new_tbl)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_with_environment_context_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_with_environment_context_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_with_cascade_args:
  """
  Attributes:
   - dbname
   - tbl_name
   - new_tbl
   - cascade
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRUCT, 'new_tbl', (Table, Table.thrift_spec), None, ), # 3
    (4, TType.BOOL, 'cascade', None, None, ), # 4
  )

  def __init__(self, dbname=None, tbl_name=None, new_tbl=None, cascade=None,):
    self.dbname = dbname
    self.tbl_name = tbl_name
    self.new_tbl = new_tbl
    self.cascade = cascade

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_tbl = Table()
          self.new_tbl.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.cascade = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_with_cascade_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_tbl is not None:
      oprot.writeFieldBegin('new_tbl', TType.STRUCT, 3)
      self.new_tbl.write(oprot)
      oprot.writeFieldEnd()
    if self.cascade is not None:
      oprot.writeFieldBegin('cascade', TType.BOOL, 4)
      oprot.writeBool(self.cascade)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.new_tbl)
    value = (value * 31) ^ hash(self.cascade)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_with_cascade_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_with_cascade_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_args:
  """
  Attributes:
   - new_part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ), # 1
  )

  def __init__(self, new_part=None,):
    self.new_part = new_part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.new_part = Partition()
          self.new_part.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_args')
    if self.new_part is not None:
      oprot.writeFieldBegin('new_part', TType.STRUCT, 1)
      self.new_part.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.new_part)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_with_environment_context_args:
  """
  Attributes:
   - new_part
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 2
  )

  def __init__(self, new_part=None, environment_context=None,):
    self.new_part = new_part
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.new_part = Partition()
          self.new_part.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_with_environment_context_args')
    if self.new_part is not None:
      oprot.writeFieldBegin('new_part', TType.STRUCT, 1)
      self.new_part.write(oprot)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 2)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.new_part)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_with_environment_context_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_with_environment_context_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partitions_args:
  """
  Attributes:
   - new_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'new_parts', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 1
  )

  def __init__(self, new_parts=None,):
    self.new_parts = new_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.new_parts = []
          (_etype888, _size885) = iprot.readListBegin()
          for _i889 in xrange(_size885):
            _elem890 = Partition()
            _elem890.read(iprot)
            self.new_parts.append(_elem890)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partitions_args')
    if self.new_parts is not None:
      oprot.writeFieldBegin('new_parts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.new_parts))
      for iter891 in self.new_parts:
        iter891.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.new_parts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partitions_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partitions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partitions_pspec_args:
  """
  Attributes:
   - new_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'new_parts', (TType.STRUCT,(PartitionSpec, PartitionSpec.thrift_spec)), None, ), # 1
  )

  def __init__(self, new_parts=None,):
    self.new_parts = new_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.new_parts = []
          (_etype895, _size892) = iprot.readListBegin()
          for _i896 in xrange(_size892):
            _elem897 = PartitionSpec()
            _elem897.read(iprot)
            self.new_parts.append(_elem897)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partitions_pspec_args')
    if self.new_parts is not None:
      oprot.writeFieldBegin('new_parts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.new_parts))
      for iter898 in self.new_parts:
        iter898.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.new_parts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partitions_pspec_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partitions_pspec_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype902, _size899) = iprot.readListBegin()
          for _i903 in xrange(_size899):
            _elem904 = iprot.readString()
            self.part_vals.append(_elem904)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter905 in self.part_vals:
        oprot.writeString(iter905)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partitions_req_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (AddPartitionsRequest, AddPartitionsRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = AddPartitionsRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partitions_req_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partitions_req_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AddPartitionsResult, AddPartitionsResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AddPartitionsResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partitions_req_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_with_environment_context_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, environment_context=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype909, _size906) = iprot.readListBegin()
          for _i910 in xrange(_size906):
            _elem911 = iprot.readString()
            self.part_vals.append(_elem911)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_with_environment_context_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter912 in self.part_vals:
        oprot.writeString(iter912)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_with_environment_context_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_with_environment_context_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_by_name_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_by_name_with_environment_context_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
    (4, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None, environment_context=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_by_name_with_environment_context_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_name)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_by_name_with_environment_context_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_by_name_with_environment_context_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - deleteData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, deleteData=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.deleteData = deleteData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype916, _size913) = iprot.readListBegin()
          for _i917 in xrange(_size913):
            _elem918 = iprot.readString()
            self.part_vals.append(_elem918)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter919 in self.part_vals:
        oprot.writeString(iter919)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.deleteData)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_with_environment_context_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - deleteData
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
    (5, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 5
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, deleteData=None, environment_context=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.deleteData = deleteData
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype923, _size920) = iprot.readListBegin()
          for _i924 in xrange(_size920):
            _elem925 = iprot.readString()
            self.part_vals.append(_elem925)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_with_environment_context_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter926 in self.part_vals:
        oprot.writeString(iter926)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 5)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.deleteData)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_with_environment_context_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_with_environment_context_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
   - deleteData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None, deleteData=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name
    self.deleteData = deleteData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_by_name_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_name)
    value = (value * 31) ^ hash(self.deleteData)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_by_name_with_environment_context_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
   - deleteData
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
    (5, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 5
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None, deleteData=None, environment_context=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name
    self.deleteData = deleteData
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_by_name_with_environment_context_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 5)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_name)
    value = (value * 31) ^ hash(self.deleteData)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_by_name_with_environment_context_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_by_name_with_environment_context_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partitions_req_args:
  """
  Attributes:
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'req', (DropPartitionsRequest, DropPartitionsRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, req=None,):
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = DropPartitionsRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partitions_req_args')
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.req)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partitions_req_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (DropPartitionsResult, DropPartitionsResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = DropPartitionsResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partitions_req_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype930, _size927) = iprot.readListBegin()
          for _i931 in xrange(_size927):
            _elem932 = iprot.readString()
            self.part_vals.append(_elem932)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter933 in self.part_vals:
        oprot.writeString(iter933)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class exchange_partition_args:
  """
  Attributes:
   - partitionSpecs
   - source_db
   - source_table_name
   - dest_db
   - dest_table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'partitionSpecs', (TType.STRING,None,TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'source_db', None, None, ), # 2
    (3, TType.STRING, 'source_table_name', None, None, ), # 3
    (4, TType.STRING, 'dest_db', None, None, ), # 4
    (5, TType.STRING, 'dest_table_name', None, None, ), # 5
  )

  def __init__(self, partitionSpecs=None, source_db=None, source_table_name=None, dest_db=None, dest_table_name=None,):
    self.partitionSpecs = partitionSpecs
    self.source_db = source_db
    self.source_table_name = source_table_name
    self.dest_db = dest_db
    self.dest_table_name = dest_table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.partitionSpecs = {}
          (_ktype935, _vtype936, _size934 ) = iprot.readMapBegin()
          for _i938 in xrange(_size934):
            _key939 = iprot.readString()
            _val940 = iprot.readString()
            self.partitionSpecs[_key939] = _val940
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.source_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.source_table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.dest_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.dest_table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('exchange_partition_args')
    if self.partitionSpecs is not None:
      oprot.writeFieldBegin('partitionSpecs', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.partitionSpecs))
      for kiter941,viter942 in self.partitionSpecs.items():
        oprot.writeString(kiter941)
        oprot.writeString(viter942)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.source_db is not None:
      oprot.writeFieldBegin('source_db', TType.STRING, 2)
      oprot.writeString(self.source_db)
      oprot.writeFieldEnd()
    if self.source_table_name is not None:
      oprot.writeFieldBegin('source_table_name', TType.STRING, 3)
      oprot.writeString(self.source_table_name)
      oprot.writeFieldEnd()
    if self.dest_db is not None:
      oprot.writeFieldBegin('dest_db', TType.STRING, 4)
      oprot.writeString(self.dest_db)
      oprot.writeFieldEnd()
    if self.dest_table_name is not None:
      oprot.writeFieldBegin('dest_table_name', TType.STRING, 5)
      oprot.writeString(self.dest_table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitionSpecs)
    value = (value * 31) ^ hash(self.source_db)
    value = (value * 31) ^ hash(self.source_table_name)
    value = (value * 31) ^ hash(self.dest_db)
    value = (value * 31) ^ hash(self.dest_table_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class exchange_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = InvalidObjectException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidInputException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('exchange_partition_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class exchange_partitions_args:
  """
  Attributes:
   - partitionSpecs
   - source_db
   - source_table_name
   - dest_db
   - dest_table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'partitionSpecs', (TType.STRING,None,TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'source_db', None, None, ), # 2
    (3, TType.STRING, 'source_table_name', None, None, ), # 3
    (4, TType.STRING, 'dest_db', None, None, ), # 4
    (5, TType.STRING, 'dest_table_name', None, None, ), # 5
  )

  def __init__(self, partitionSpecs=None, source_db=None, source_table_name=None, dest_db=None, dest_table_name=None,):
    self.partitionSpecs = partitionSpecs
    self.source_db = source_db
    self.source_table_name = source_table_name
    self.dest_db = dest_db
    self.dest_table_name = dest_table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.partitionSpecs = {}
          (_ktype944, _vtype945, _size943 ) = iprot.readMapBegin()
          for _i947 in xrange(_size943):
            _key948 = iprot.readString()
            _val949 = iprot.readString()
            self.partitionSpecs[_key948] = _val949
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.source_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.source_table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.dest_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.dest_table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('exchange_partitions_args')
    if self.partitionSpecs is not None:
      oprot.writeFieldBegin('partitionSpecs', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.partitionSpecs))
      for kiter950,viter951 in self.partitionSpecs.items():
        oprot.writeString(kiter950)
        oprot.writeString(viter951)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.source_db is not None:
      oprot.writeFieldBegin('source_db', TType.STRING, 2)
      oprot.writeString(self.source_db)
      oprot.writeFieldEnd()
    if self.source_table_name is not None:
      oprot.writeFieldBegin('source_table_name', TType.STRING, 3)
      oprot.writeString(self.source_table_name)
      oprot.writeFieldEnd()
    if self.dest_db is not None:
      oprot.writeFieldBegin('dest_db', TType.STRING, 4)
      oprot.writeString(self.dest_db)
      oprot.writeFieldEnd()
    if self.dest_table_name is not None:
      oprot.writeFieldBegin('dest_table_name', TType.STRING, 5)
      oprot.writeString(self.dest_table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitionSpecs)
    value = (value * 31) ^ hash(self.source_db)
    value = (value * 31) ^ hash(self.source_table_name)
    value = (value * 31) ^ hash(self.dest_db)
    value = (value * 31) ^ hash(self.dest_table_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class exchange_partitions_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype955, _size952) = iprot.readListBegin()
          for _i956 in xrange(_size952):
            _elem957 = Partition()
            _elem957.read(iprot)
            self.success.append(_elem957)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = InvalidObjectException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidInputException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('exchange_partitions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter958 in self.success:
        iter958.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_with_auth_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - user_name
   - group_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.STRING, 'user_name', None, None, ), # 4
    (5, TType.LIST, 'group_names', (TType.STRING,None), None, ), # 5
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, user_name=None, group_names=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.user_name = user_name
    self.group_names = group_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype962, _size959) = iprot.readListBegin()
          for _i963 in xrange(_size959):
            _elem964 = iprot.readString()
            self.part_vals.append(_elem964)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.user_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.group_names = []
          (_etype968, _size965) = iprot.readListBegin()
          for _i969 in xrange(_size965):
            _elem970 = iprot.readString()
            self.group_names.append(_elem970)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_with_auth_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter971 in self.part_vals:
        oprot.writeString(iter971)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 4)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.group_names))
      for iter972 in self.group_names:
        oprot.writeString(iter972)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.user_name)
    value = (value * 31) ^ hash(self.group_names)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_with_auth_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_with_auth_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_by_name_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_parts', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_parts=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 3)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.max_parts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype976, _size973) = iprot.readListBegin()
          for _i977 in xrange(_size973):
            _elem978 = Partition()
            _elem978.read(iprot)
            self.success.append(_elem978)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter979 in self.success:
        iter979.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_with_auth_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_parts
   - user_name
   - group_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_parts', None, -1, ), # 3
    (4, TType.STRING, 'user_name', None, None, ), # 4
    (5, TType.LIST, 'group_names', (TType.STRING,None), None, ), # 5
  )

  def __init__(self, db_name=None, tbl_name=None, max_parts=thrift_spec[3][4], user_name=None, group_names=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_parts = max_parts
    self.user_name = user_name
    self.group_names = group_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.user_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.group_names = []
          (_etype983, _size980) = iprot.readListBegin()
          for _i984 in xrange(_size980):
            _elem985 = iprot.readString()
            self.group_names.append(_elem985)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_with_auth_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 3)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 4)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.group_names))
      for iter986 in self.group_names:
        oprot.writeString(iter986)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.max_parts)
    value = (value * 31) ^ hash(self.user_name)
    value = (value * 31) ^ hash(self.group_names)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_with_auth_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype990, _size987) = iprot.readListBegin()
          for _i991 in xrange(_size987):
            _elem992 = Partition()
            _elem992.read(iprot)
            self.success.append(_elem992)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_with_auth_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter993 in self.success:
        iter993.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_pspec_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I32, 'max_parts', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_parts=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.max_parts = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_pspec_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I32, 3)
      oprot.writeI32(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.max_parts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_pspec_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(PartitionSpec, PartitionSpec.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype997, _size994) = iprot.readListBegin()
          for _i998 in xrange(_size994):
            _elem999 = PartitionSpec()
            _elem999.read(iprot)
            self.success.append(_elem999)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_pspec_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter1000 in self.success:
        iter1000.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_names_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_parts', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_parts=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_names_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 3)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.max_parts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_names_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1004, _size1001) = iprot.readListBegin()
          for _i1005 in xrange(_size1001):
            _elem1006 = iprot.readString()
            self.success.append(_elem1006)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_names_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter1007 in self.success:
        oprot.writeString(iter1007)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_values_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (PartitionValuesRequest, PartitionValuesRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = PartitionValuesRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_values_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_values_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PartitionValuesResponse, PartitionValuesResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PartitionValuesResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_values_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_ps_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.I16, 'max_parts', None, -1, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, max_parts=thrift_spec[4][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype1011, _size1008) = iprot.readListBegin()
          for _i1012 in xrange(_size1008):
            _elem1013 = iprot.readString()
            self.part_vals.append(_elem1013)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_ps_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter1014 in self.part_vals:
        oprot.writeString(iter1014)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 4)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.max_parts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_ps_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1018, _size1015) = iprot.readListBegin()
          for _i1019 in xrange(_size1015):
            _elem1020 = Partition()
            _elem1020.read(iprot)
            self.success.append(_elem1020)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_ps_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter1021 in self.success:
        iter1021.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_ps_with_auth_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - max_parts
   - user_name
   - group_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.I16, 'max_parts', None, -1, ), # 4
    (5, TType.STRING, 'user_name', None, None, ), # 5
    (6, TType.LIST, 'group_names', (TType.STRING,None), None, ), # 6
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, max_parts=thrift_spec[4][4], user_name=None, group_names=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.max_parts = max_parts
    self.user_name = user_name
    self.group_names = group_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype1025, _size1022) = iprot.readListBegin()
          for _i1026 in xrange(_size1022):
            _elem1027 = iprot.readString()
            self.part_vals.append(_elem1027)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.user_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.group_names = []
          (_etype1031, _size1028) = iprot.readListBegin()
          for _i1032 in xrange(_size1028):
            _elem1033 = iprot.readString()
            self.group_names.append(_elem1033)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_ps_with_auth_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter1034 in self.part_vals:
        oprot.writeString(iter1034)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 4)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 5)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.LIST, 6)
      oprot.writeListBegin(TType.STRING, len(self.group_names))
      for iter1035 in self.group_names:
        oprot.writeString(iter1035)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.max_parts)
    value = (value * 31) ^ hash(self.user_name)
    value = (value * 31) ^ hash(self.group_names)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_ps_with_auth_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1039, _size1036) = iprot.readListBegin()
          for _i1040 in xrange(_size1036):
            _elem1041 = Partition()
            _elem1041.read(iprot)
            self.success.append(_elem1041)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_ps_with_auth_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter1042 in self.success:
        iter1042.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_names_ps_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.I16, 'max_parts', None, -1, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, max_parts=thrift_spec[4][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype1046, _size1043) = iprot.readListBegin()
          for _i1047 in xrange(_size1043):
            _elem1048 = iprot.readString()
            self.part_vals.append(_elem1048)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_names_ps_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter1049 in self.part_vals:
        oprot.writeString(iter1049)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 4)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.max_parts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_names_ps_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1053, _size1050) = iprot.readListBegin()
          for _i1054 in xrange(_size1050):
            _elem1055 = iprot.readString()
            self.success.append(_elem1055)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_names_ps_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter1056 in self.success:
        oprot.writeString(iter1056)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_by_filter_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - filter
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'filter', None, None, ), # 3
    (4, TType.I16, 'max_parts', None, -1, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, filter=None, max_parts=thrift_spec[4][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.filter = filter
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_by_filter_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRING, 3)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 4)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.filter)
    value = (value * 31) ^ hash(self.max_parts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_by_filter_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1060, _size1057) = iprot.readListBegin()
          for _i1061 in xrange(_size1057):
            _elem1062 = Partition()
            _elem1062.read(iprot)
            self.success.append(_elem1062)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_by_filter_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter1063 in self.success:
        iter1063.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_part_specs_by_filter_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - filter
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'filter', None, None, ), # 3
    (4, TType.I32, 'max_parts', None, -1, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, filter=None, max_parts=thrift_spec[4][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.filter = filter
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.max_parts = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_part_specs_by_filter_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRING, 3)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I32, 4)
      oprot.writeI32(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.filter)
    value = (value * 31) ^ hash(self.max_parts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_part_specs_by_filter_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(PartitionSpec, PartitionSpec.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1067, _size1064) = iprot.readListBegin()
          for _i1068 in xrange(_size1064):
            _elem1069 = PartitionSpec()
            _elem1069.read(iprot)
            self.success.append(_elem1069)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_part_specs_by_filter_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter1070 in self.success:
        iter1070.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_by_expr_args:
  """
  Attributes:
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'req', (PartitionsByExprRequest, PartitionsByExprRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, req=None,):
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = PartitionsByExprRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_by_expr_args')
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.req)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_by_expr_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PartitionsByExprResult, PartitionsByExprResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PartitionsByExprResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_by_expr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_num_partitions_by_filter_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - filter
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'filter', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, filter=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.filter = filter

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_num_partitions_by_filter_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRING, 3)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.filter)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_num_partitions_by_filter_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_num_partitions_by_filter_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_by_names_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'names', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, names=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.names = names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.names = []
          (_etype1074, _size1071) = iprot.readListBegin()
          for _i1075 in xrange(_size1071):
            _elem1076 = iprot.readString()
            self.names.append(_elem1076)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_by_names_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.names is not None:
      oprot.writeFieldBegin('names', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.names))
      for iter1077 in self.names:
        oprot.writeString(iter1077)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.names)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_by_names_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1081, _size1078) = iprot.readListBegin()
          for _i1082 in xrange(_size1078):
            _elem1083 = Partition()
            _elem1083.read(iprot)
            self.success.append(_elem1083)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_by_names_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter1084 in self.success:
        iter1084.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - new_part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, new_part=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.new_part = new_part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_part = Partition()
          self.new_part.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partition_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_part is not None:
      oprot.writeFieldBegin('new_part', TType.STRUCT, 3)
      self.new_part.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.new_part)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partition_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partition_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partitions_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - new_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'new_parts', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, new_parts=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.new_parts = new_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.new_parts = []
          (_etype1088, _size1085) = iprot.readListBegin()
          for _i1089 in xrange(_size1085):
            _elem1090 = Partition()
            _elem1090.read(iprot)
            self.new_parts.append(_elem1090)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partitions_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_parts is not None:
      oprot.writeFieldBegin('new_parts', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.new_parts))
      for iter1091 in self.new_parts:
        iter1091.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.new_parts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partitions_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partitions_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partitions_with_environment_context_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - new_parts
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'new_parts', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 3
    (4, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, new_parts=None, environment_context=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.new_parts = new_parts
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.new_parts = []
          (_etype1095, _size1092) = iprot.readListBegin()
          for _i1096 in xrange(_size1092):
            _elem1097 = Partition()
            _elem1097.read(iprot)
            self.new_parts.append(_elem1097)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partitions_with_environment_context_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_parts is not None:
      oprot.writeFieldBegin('new_parts', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.new_parts))
      for iter1098 in self.new_parts:
        iter1098.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.new_parts)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partitions_with_environment_context_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partitions_with_environment_context_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partition_with_environment_context_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - new_part
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, new_part=None, environment_context=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.new_part = new_part
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_part = Partition()
          self.new_part.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partition_with_environment_context_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_part is not None:
      oprot.writeFieldBegin('new_part', TType.STRUCT, 3)
      self.new_part.write(oprot)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.new_part)
    value = (value * 31) ^ hash(self.environment_context)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partition_with_environment_context_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partition_with_environment_context_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rename_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - new_part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, new_part=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.new_part = new_part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype1102, _size1099) = iprot.readListBegin()
          for _i1103 in xrange(_size1099):
            _elem1104 = iprot.readString()
            self.part_vals.append(_elem1104)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.new_part = Partition()
          self.new_part.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rename_partition_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter1105 in self.part_vals:
        oprot.writeString(iter1105)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.new_part is not None:
      oprot.writeFieldBegin('new_part', TType.STRUCT, 4)
      self.new_part.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.new_part)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rename_partition_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rename_partition_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_has_valid_characters_args:
  """
  Attributes:
   - part_vals
   - throw_exception
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 1
    (2, TType.BOOL, 'throw_exception', None, None, ), # 2
  )

  def __init__(self, part_vals=None, throw_exception=None,):
    self.part_vals = part_vals
    self.throw_exception = throw_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype1109, _size1106) = iprot.readListBegin()
          for _i1110 in xrange(_size1106):
            _elem1111 = iprot.readString()
            self.part_vals.append(_elem1111)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.throw_exception = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_has_valid_characters_args')
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter1112 in self.part_vals:
        oprot.writeString(iter1112)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.throw_exception is not None:
      oprot.writeFieldBegin('throw_exception', TType.BOOL, 2)
      oprot.writeBool(self.throw_exception)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.throw_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_has_valid_characters_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_has_valid_characters_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_config_value_args:
  """
  Attributes:
   - name
   - defaultValue
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'defaultValue', None, None, ), # 2
  )

  def __init__(self, name=None, defaultValue=None,):
    self.name = name
    self.defaultValue = defaultValue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.defaultValue = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_config_value_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.defaultValue is not None:
      oprot.writeFieldBegin('defaultValue', TType.STRING, 2)
      oprot.writeString(self.defaultValue)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.defaultValue)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_config_value_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (ConfigValSecurityException, ConfigValSecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = ConfigValSecurityException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_config_value_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_to_vals_args:
  """
  Attributes:
   - part_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'part_name', None, None, ), # 1
  )

  def __init__(self, part_name=None,):
    self.part_name = part_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.part_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_to_vals_args')
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 1)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.part_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_to_vals_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1116, _size1113) = iprot.readListBegin()
          for _i1117 in xrange(_size1113):
            _elem1118 = iprot.readString()
            self.success.append(_elem1118)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_to_vals_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter1119 in self.success:
        oprot.writeString(iter1119)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_to_spec_args:
  """
  Attributes:
   - part_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'part_name', None, None, ), # 1
  )

  def __init__(self, part_name=None,):
    self.part_name = part_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.part_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_to_spec_args')
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 1)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.part_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_to_spec_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1121, _vtype1122, _size1120 ) = iprot.readMapBegin()
          for _i1124 in xrange(_size1120):
            _key1125 = iprot.readString()
            _val1126 = iprot.readString()
            self.success[_key1125] = _val1126
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_to_spec_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter1127,viter1128 in self.success.items():
        oprot.writeString(kiter1127)
        oprot.writeString(viter1128)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class markPartitionForEvent_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - eventType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.MAP, 'part_vals', (TType.STRING,None,TType.STRING,None), None, ), # 3
    (4, TType.I32, 'eventType', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, eventType=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.eventType = eventType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.part_vals = {}
          (_ktype1130, _vtype1131, _size1129 ) = iprot.readMapBegin()
          for _i1133 in xrange(_size1129):
            _key1134 = iprot.readString()
            _val1135 = iprot.readString()
            self.part_vals[_key1134] = _val1135
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.eventType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('markPartitionForEvent_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.part_vals))
      for kiter1136,viter1137 in self.part_vals.items():
        oprot.writeString(kiter1136)
        oprot.writeString(viter1137)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.eventType is not None:
      oprot.writeFieldBegin('eventType', TType.I32, 4)
      oprot.writeI32(self.eventType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.eventType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class markPartitionForEvent_result:
  """
  Attributes:
   - o1
   - o2
   - o3
   - o4
   - o5
   - o6
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'o5', (UnknownPartitionException, UnknownPartitionException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'o6', (InvalidPartitionException, InvalidPartitionException.thrift_spec), None, ), # 6
  )

  def __init__(self, o1=None, o2=None, o3=None, o4=None, o5=None, o6=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4
    self.o5 = o5
    self.o6 = o6

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = UnknownTableException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.o5 = UnknownPartitionException()
          self.o5.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.o6 = InvalidPartitionException()
          self.o6.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('markPartitionForEvent_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    if self.o5 is not None:
      oprot.writeFieldBegin('o5', TType.STRUCT, 5)
      self.o5.write(oprot)
      oprot.writeFieldEnd()
    if self.o6 is not None:
      oprot.writeFieldBegin('o6', TType.STRUCT, 6)
      self.o6.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    value = (value * 31) ^ hash(self.o5)
    value = (value * 31) ^ hash(self.o6)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isPartitionMarkedForEvent_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - eventType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.MAP, 'part_vals', (TType.STRING,None,TType.STRING,None), None, ), # 3
    (4, TType.I32, 'eventType', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, eventType=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.eventType = eventType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.part_vals = {}
          (_ktype1139, _vtype1140, _size1138 ) = iprot.readMapBegin()
          for _i1142 in xrange(_size1138):
            _key1143 = iprot.readString()
            _val1144 = iprot.readString()
            self.part_vals[_key1143] = _val1144
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.eventType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isPartitionMarkedForEvent_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.part_vals))
      for kiter1145,viter1146 in self.part_vals.items():
        oprot.writeString(kiter1145)
        oprot.writeString(viter1146)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.eventType is not None:
      oprot.writeFieldBegin('eventType', TType.I32, 4)
      oprot.writeI32(self.eventType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_vals)
    value = (value * 31) ^ hash(self.eventType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isPartitionMarkedForEvent_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
   - o5
   - o6
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'o5', (UnknownPartitionException, UnknownPartitionException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'o6', (InvalidPartitionException, InvalidPartitionException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None, o5=None, o6=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4
    self.o5 = o5
    self.o6 = o6

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = UnknownTableException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.o5 = UnknownPartitionException()
          self.o5.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.o6 = InvalidPartitionException()
          self.o6.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isPartitionMarkedForEvent_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    if self.o5 is not None:
      oprot.writeFieldBegin('o5', TType.STRUCT, 5)
      self.o5.write(oprot)
      oprot.writeFieldEnd()
    if self.o6 is not None:
      oprot.writeFieldBegin('o6', TType.STRUCT, 6)
      self.o6.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    value = (value * 31) ^ hash(self.o5)
    value = (value * 31) ^ hash(self.o6)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_index_args:
  """
  Attributes:
   - new_index
   - index_table
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'new_index', (Index, Index.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'index_table', (Table, Table.thrift_spec), None, ), # 2
  )

  def __init__(self, new_index=None, index_table=None,):
    self.new_index = new_index
    self.index_table = index_table

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.new_index = Index()
          self.new_index.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.index_table = Table()
          self.index_table.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_index_args')
    if self.new_index is not None:
      oprot.writeFieldBegin('new_index', TType.STRUCT, 1)
      self.new_index.write(oprot)
      oprot.writeFieldEnd()
    if self.index_table is not None:
      oprot.writeFieldBegin('index_table', TType.STRUCT, 2)
      self.index_table.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.new_index)
    value = (value * 31) ^ hash(self.index_table)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_index_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Index, Index.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Index()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_index_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_index_args:
  """
  Attributes:
   - dbname
   - base_tbl_name
   - idx_name
   - new_idx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'base_tbl_name', None, None, ), # 2
    (3, TType.STRING, 'idx_name', None, None, ), # 3
    (4, TType.STRUCT, 'new_idx', (Index, Index.thrift_spec), None, ), # 4
  )

  def __init__(self, dbname=None, base_tbl_name=None, idx_name=None, new_idx=None,):
    self.dbname = dbname
    self.base_tbl_name = base_tbl_name
    self.idx_name = idx_name
    self.new_idx = new_idx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.base_tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.idx_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.new_idx = Index()
          self.new_idx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_index_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.base_tbl_name is not None:
      oprot.writeFieldBegin('base_tbl_name', TType.STRING, 2)
      oprot.writeString(self.base_tbl_name)
      oprot.writeFieldEnd()
    if self.idx_name is not None:
      oprot.writeFieldBegin('idx_name', TType.STRING, 3)
      oprot.writeString(self.idx_name)
      oprot.writeFieldEnd()
    if self.new_idx is not None:
      oprot.writeFieldBegin('new_idx', TType.STRUCT, 4)
      self.new_idx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.base_tbl_name)
    value = (value * 31) ^ hash(self.idx_name)
    value = (value * 31) ^ hash(self.new_idx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_index_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_index_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_index_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - index_name
   - deleteData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'index_name', None, None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, index_name=None, deleteData=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.index_name = index_name
    self.deleteData = deleteData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_index_by_name_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.index_name is not None:
      oprot.writeFieldBegin('index_name', TType.STRING, 3)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.index_name)
    value = (value * 31) ^ hash(self.deleteData)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_index_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_index_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_index_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - index_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'index_name', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, index_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.index_name = index_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_index_by_name_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.index_name is not None:
      oprot.writeFieldBegin('index_name', TType.STRING, 3)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.index_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_index_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Index, Index.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Index()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_index_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_indexes_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_indexes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_indexes', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_indexes=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_indexes = max_indexes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_indexes = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_indexes_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_indexes is not None:
      oprot.writeFieldBegin('max_indexes', TType.I16, 3)
      oprot.writeI16(self.max_indexes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.max_indexes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_indexes_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Index, Index.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1150, _size1147) = iprot.readListBegin()
          for _i1151 in xrange(_size1147):
            _elem1152 = Index()
            _elem1152.read(iprot)
            self.success.append(_elem1152)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_indexes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter1153 in self.success:
        iter1153.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_index_names_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_indexes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_indexes', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_indexes=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_indexes = max_indexes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_indexes = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_index_names_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_indexes is not None:
      oprot.writeFieldBegin('max_indexes', TType.I16, 3)
      oprot.writeI16(self.max_indexes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.max_indexes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_index_names_result:
  """
  Attributes:
   - success
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o2=None,):
    self.success = success
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1157, _size1154) = iprot.readListBegin()
          for _i1158 in xrange(_size1154):
            _elem1159 = iprot.readString()
            self.success.append(_elem1159)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_index_names_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter1160 in self.success:
        oprot.writeString(iter1160)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 1)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_primary_keys_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (PrimaryKeysRequest, PrimaryKeysRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = PrimaryKeysRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_primary_keys_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_primary_keys_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PrimaryKeysResponse, PrimaryKeysResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PrimaryKeysResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_primary_keys_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_foreign_keys_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (ForeignKeysRequest, ForeignKeysRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = ForeignKeysRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_foreign_keys_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_foreign_keys_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ForeignKeysResponse, ForeignKeysResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ForeignKeysResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_foreign_keys_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_unique_constraints_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (UniqueConstraintsRequest, UniqueConstraintsRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = UniqueConstraintsRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_unique_constraints_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_unique_constraints_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (UniqueConstraintsResponse, UniqueConstraintsResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = UniqueConstraintsResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_unique_constraints_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_not_null_constraints_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (NotNullConstraintsRequest, NotNullConstraintsRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = NotNullConstraintsRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_not_null_constraints_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_not_null_constraints_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (NotNullConstraintsResponse, NotNullConstraintsResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = NotNullConstraintsResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_not_null_constraints_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_table_column_statistics_args:
  """
  Attributes:
   - stats_obj
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'stats_obj', (ColumnStatistics, ColumnStatistics.thrift_spec), None, ), # 1
  )

  def __init__(self, stats_obj=None,):
    self.stats_obj = stats_obj

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.stats_obj = ColumnStatistics()
          self.stats_obj.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_table_column_statistics_args')
    if self.stats_obj is not None:
      oprot.writeFieldBegin('stats_obj', TType.STRUCT, 1)
      self.stats_obj.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.stats_obj)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_table_column_statistics_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidInputException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_table_column_statistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_partition_column_statistics_args:
  """
  Attributes:
   - stats_obj
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'stats_obj', (ColumnStatistics, ColumnStatistics.thrift_spec), None, ), # 1
  )

  def __init__(self, stats_obj=None,):
    self.stats_obj = stats_obj

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.stats_obj = ColumnStatistics()
          self.stats_obj.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_partition_column_statistics_args')
    if self.stats_obj is not None:
      oprot.writeFieldBegin('stats_obj', TType.STRUCT, 1)
      self.stats_obj.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.stats_obj)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_partition_column_statistics_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidInputException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_partition_column_statistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_column_statistics_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - col_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'col_name', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, col_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.col_name = col_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.col_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_column_statistics_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.col_name is not None:
      oprot.writeFieldBegin('col_name', TType.STRING, 3)
      oprot.writeString(self.col_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.col_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_column_statistics_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ColumnStatistics, ColumnStatistics.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ColumnStatistics()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = InvalidInputException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidObjectException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_column_statistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_column_statistics_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
   - col_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
    (4, TType.STRING, 'col_name', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None, col_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name
    self.col_name = col_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.col_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_column_statistics_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    if self.col_name is not None:
      oprot.writeFieldBegin('col_name', TType.STRING, 4)
      oprot.writeString(self.col_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_name)
    value = (value * 31) ^ hash(self.col_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_column_statistics_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ColumnStatistics, ColumnStatistics.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ColumnStatistics()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = InvalidInputException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidObjectException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_column_statistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_statistics_req_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (TableStatsRequest, TableStatsRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = TableStatsRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_statistics_req_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_statistics_req_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TableStatsResult, TableStatsResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TableStatsResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_statistics_req_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_statistics_req_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (PartitionsStatsRequest, PartitionsStatsRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = PartitionsStatsRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_statistics_req_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_statistics_req_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PartitionsStatsResult, PartitionsStatsResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PartitionsStatsResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_statistics_req_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_aggr_stats_for_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (PartitionsStatsRequest, PartitionsStatsRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = PartitionsStatsRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_aggr_stats_for_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_aggr_stats_for_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AggrStats, AggrStats.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AggrStats()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_aggr_stats_for_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_aggr_stats_for_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (SetPartitionsStatsRequest, SetPartitionsStatsRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = SetPartitionsStatsRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_aggr_stats_for_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_aggr_stats_for_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidInputException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_aggr_stats_for_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_partition_column_statistics_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
   - col_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
    (4, TType.STRING, 'col_name', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None, col_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name
    self.col_name = col_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.col_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_partition_column_statistics_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    if self.col_name is not None:
      oprot.writeFieldBegin('col_name', TType.STRING, 4)
      oprot.writeString(self.col_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.part_name)
    value = (value * 31) ^ hash(self.col_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_partition_column_statistics_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = InvalidObjectException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidInputException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_partition_column_statistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_table_column_statistics_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - col_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'col_name', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, col_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.col_name = col_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.col_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_table_column_statistics_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.col_name is not None:
      oprot.writeFieldBegin('col_name', TType.STRING, 3)
      oprot.writeString(self.col_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.col_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_table_column_statistics_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = InvalidObjectException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidInputException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_table_column_statistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_function_args:
  """
  Attributes:
   - func
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'func', (Function, Function.thrift_spec), None, ), # 1
  )

  def __init__(self, func=None,):
    self.func = func

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.func = Function()
          self.func.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_function_args')
    if self.func is not None:
      oprot.writeFieldBegin('func', TType.STRUCT, 1)
      self.func.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.func)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_function_result:
  """
  Attributes:
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 4
  )

  def __init__(self, o1=None, o2=None, o3=None, o4=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = NoSuchObjectException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_function_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_function_args:
  """
  Attributes:
   - dbName
   - funcName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'funcName', None, None, ), # 2
  )

  def __init__(self, dbName=None, funcName=None,):
    self.dbName = dbName
    self.funcName = funcName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.funcName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_function_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.funcName is not None:
      oprot.writeFieldBegin('funcName', TType.STRING, 2)
      oprot.writeString(self.funcName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.funcName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_function_result:
  """
  Attributes:
   - o1
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o3=None,):
    self.o1 = o1
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_function_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 2)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_function_args:
  """
  Attributes:
   - dbName
   - funcName
   - newFunc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'funcName', None, None, ), # 2
    (3, TType.STRUCT, 'newFunc', (Function, Function.thrift_spec), None, ), # 3
  )

  def __init__(self, dbName=None, funcName=None, newFunc=None,):
    self.dbName = dbName
    self.funcName = funcName
    self.newFunc = newFunc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.funcName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.newFunc = Function()
          self.newFunc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_function_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.funcName is not None:
      oprot.writeFieldBegin('funcName', TType.STRING, 2)
      oprot.writeString(self.funcName)
      oprot.writeFieldEnd()
    if self.newFunc is not None:
      oprot.writeFieldBegin('newFunc', TType.STRUCT, 3)
      self.newFunc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.funcName)
    value = (value * 31) ^ hash(self.newFunc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_function_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_function_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_functions_args:
  """
  Attributes:
   - dbName
   - pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'pattern', None, None, ), # 2
  )

  def __init__(self, dbName=None, pattern=None,):
    self.dbName = dbName
    self.pattern = pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pattern = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_functions_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.pattern is not None:
      oprot.writeFieldBegin('pattern', TType.STRING, 2)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.pattern)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_functions_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1164, _size1161) = iprot.readListBegin()
          for _i1165 in xrange(_size1161):
            _elem1166 = iprot.readString()
            self.success.append(_elem1166)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_functions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter1167 in self.success:
        oprot.writeString(iter1167)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_function_args:
  """
  Attributes:
   - dbName
   - funcName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'funcName', None, None, ), # 2
  )

  def __init__(self, dbName=None, funcName=None,):
    self.dbName = dbName
    self.funcName = funcName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.funcName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_function_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.funcName is not None:
      oprot.writeFieldBegin('funcName', TType.STRING, 2)
      oprot.writeString(self.funcName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.funcName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_function_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Function, Function.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Function()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_function_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_functions_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_functions_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_functions_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetAllFunctionsResponse, GetAllFunctionsResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetAllFunctionsResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_functions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_role_args:
  """
  Attributes:
   - role
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'role', (Role, Role.thrift_spec), None, ), # 1
  )

  def __init__(self, role=None,):
    self.role = role

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.role = Role()
          self.role.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_role_args')
    if self.role is not None:
      oprot.writeFieldBegin('role', TType.STRUCT, 1)
      self.role.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.role)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_role_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_role_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_role_args:
  """
  Attributes:
   - role_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role_name', None, None, ), # 1
  )

  def __init__(self, role_name=None,):
    self.role_name = role_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_role_args')
    if self.role_name is not None:
      oprot.writeFieldBegin('role_name', TType.STRING, 1)
      oprot.writeString(self.role_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.role_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_role_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_role_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_role_names_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_role_names_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_role_names_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1171, _size1168) = iprot.readListBegin()
          for _i1172 in xrange(_size1168):
            _elem1173 = iprot.readString()
            self.success.append(_elem1173)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_role_names_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter1174 in self.success:
        oprot.writeString(iter1174)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_role_args:
  """
  Attributes:
   - role_name
   - principal_name
   - principal_type
   - grantor
   - grantorType
   - grant_option
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role_name', None, None, ), # 1
    (2, TType.STRING, 'principal_name', None, None, ), # 2
    (3, TType.I32, 'principal_type', None, None, ), # 3
    (4, TType.STRING, 'grantor', None, None, ), # 4
    (5, TType.I32, 'grantorType', None, None, ), # 5
    (6, TType.BOOL, 'grant_option', None, None, ), # 6
  )

  def __init__(self, role_name=None, principal_name=None, principal_type=None, grantor=None, grantorType=None, grant_option=None,):
    self.role_name = role_name
    self.principal_name = principal_name
    self.principal_type = principal_type
    self.grantor = grantor
    self.grantorType = grantorType
    self.grant_option = grant_option

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.principal_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.principal_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.grantor = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.grantorType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.grant_option = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_role_args')
    if self.role_name is not None:
      oprot.writeFieldBegin('role_name', TType.STRING, 1)
      oprot.writeString(self.role_name)
      oprot.writeFieldEnd()
    if self.principal_name is not None:
      oprot.writeFieldBegin('principal_name', TType.STRING, 2)
      oprot.writeString(self.principal_name)
      oprot.writeFieldEnd()
    if self.principal_type is not None:
      oprot.writeFieldBegin('principal_type', TType.I32, 3)
      oprot.writeI32(self.principal_type)
      oprot.writeFieldEnd()
    if self.grantor is not None:
      oprot.writeFieldBegin('grantor', TType.STRING, 4)
      oprot.writeString(self.grantor)
      oprot.writeFieldEnd()
    if self.grantorType is not None:
      oprot.writeFieldBegin('grantorType', TType.I32, 5)
      oprot.writeI32(self.grantorType)
      oprot.writeFieldEnd()
    if self.grant_option is not None:
      oprot.writeFieldBegin('grant_option', TType.BOOL, 6)
      oprot.writeBool(self.grant_option)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.role_name)
    value = (value * 31) ^ hash(self.principal_name)
    value = (value * 31) ^ hash(self.principal_type)
    value = (value * 31) ^ hash(self.grantor)
    value = (value * 31) ^ hash(self.grantorType)
    value = (value * 31) ^ hash(self.grant_option)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_role_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_role_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revoke_role_args:
  """
  Attributes:
   - role_name
   - principal_name
   - principal_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role_name', None, None, ), # 1
    (2, TType.STRING, 'principal_name', None, None, ), # 2
    (3, TType.I32, 'principal_type', None, None, ), # 3
  )

  def __init__(self, role_name=None, principal_name=None, principal_type=None,):
    self.role_name = role_name
    self.principal_name = principal_name
    self.principal_type = principal_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.principal_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.principal_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revoke_role_args')
    if self.role_name is not None:
      oprot.writeFieldBegin('role_name', TType.STRING, 1)
      oprot.writeString(self.role_name)
      oprot.writeFieldEnd()
    if self.principal_name is not None:
      oprot.writeFieldBegin('principal_name', TType.STRING, 2)
      oprot.writeString(self.principal_name)
      oprot.writeFieldEnd()
    if self.principal_type is not None:
      oprot.writeFieldBegin('principal_type', TType.I32, 3)
      oprot.writeI32(self.principal_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.role_name)
    value = (value * 31) ^ hash(self.principal_name)
    value = (value * 31) ^ hash(self.principal_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revoke_role_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revoke_role_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_roles_args:
  """
  Attributes:
   - principal_name
   - principal_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'principal_name', None, None, ), # 1
    (2, TType.I32, 'principal_type', None, None, ), # 2
  )

  def __init__(self, principal_name=None, principal_type=None,):
    self.principal_name = principal_name
    self.principal_type = principal_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.principal_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.principal_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_roles_args')
    if self.principal_name is not None:
      oprot.writeFieldBegin('principal_name', TType.STRING, 1)
      oprot.writeString(self.principal_name)
      oprot.writeFieldEnd()
    if self.principal_type is not None:
      oprot.writeFieldBegin('principal_type', TType.I32, 2)
      oprot.writeI32(self.principal_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.principal_name)
    value = (value * 31) ^ hash(self.principal_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_roles_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Role, Role.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1178, _size1175) = iprot.readListBegin()
          for _i1179 in xrange(_size1175):
            _elem1180 = Role()
            _elem1180.read(iprot)
            self.success.append(_elem1180)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_roles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter1181 in self.success:
        iter1181.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_revoke_role_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (GrantRevokeRoleRequest, GrantRevokeRoleRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = GrantRevokeRoleRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_revoke_role_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_revoke_role_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GrantRevokeRoleResponse, GrantRevokeRoleResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GrantRevokeRoleResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_revoke_role_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_principals_in_role_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (GetPrincipalsInRoleRequest, GetPrincipalsInRoleRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = GetPrincipalsInRoleRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_principals_in_role_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_principals_in_role_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetPrincipalsInRoleResponse, GetPrincipalsInRoleResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetPrincipalsInRoleResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_principals_in_role_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_role_grants_for_principal_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (GetRoleGrantsForPrincipalRequest, GetRoleGrantsForPrincipalRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = GetRoleGrantsForPrincipalRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_role_grants_for_principal_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_role_grants_for_principal_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetRoleGrantsForPrincipalResponse, GetRoleGrantsForPrincipalResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetRoleGrantsForPrincipalResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_role_grants_for_principal_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_privilege_set_args:
  """
  Attributes:
   - hiveObject
   - user_name
   - group_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'hiveObject', (HiveObjectRef, HiveObjectRef.thrift_spec), None, ), # 1
    (2, TType.STRING, 'user_name', None, None, ), # 2
    (3, TType.LIST, 'group_names', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, hiveObject=None, user_name=None, group_names=None,):
    self.hiveObject = hiveObject
    self.user_name = user_name
    self.group_names = group_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.hiveObject = HiveObjectRef()
          self.hiveObject.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.group_names = []
          (_etype1185, _size1182) = iprot.readListBegin()
          for _i1186 in xrange(_size1182):
            _elem1187 = iprot.readString()
            self.group_names.append(_elem1187)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_privilege_set_args')
    if self.hiveObject is not None:
      oprot.writeFieldBegin('hiveObject', TType.STRUCT, 1)
      self.hiveObject.write(oprot)
      oprot.writeFieldEnd()
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 2)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.group_names))
      for iter1188 in self.group_names:
        oprot.writeString(iter1188)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hiveObject)
    value = (value * 31) ^ hash(self.user_name)
    value = (value * 31) ^ hash(self.group_names)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_privilege_set_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PrincipalPrivilegeSet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_privilege_set_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_privileges_args:
  """
  Attributes:
   - principal_name
   - principal_type
   - hiveObject
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'principal_name', None, None, ), # 1
    (2, TType.I32, 'principal_type', None, None, ), # 2
    (3, TType.STRUCT, 'hiveObject', (HiveObjectRef, HiveObjectRef.thrift_spec), None, ), # 3
  )

  def __init__(self, principal_name=None, principal_type=None, hiveObject=None,):
    self.principal_name = principal_name
    self.principal_type = principal_type
    self.hiveObject = hiveObject

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.principal_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.principal_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.hiveObject = HiveObjectRef()
          self.hiveObject.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_privileges_args')
    if self.principal_name is not None:
      oprot.writeFieldBegin('principal_name', TType.STRING, 1)
      oprot.writeString(self.principal_name)
      oprot.writeFieldEnd()
    if self.principal_type is not None:
      oprot.writeFieldBegin('principal_type', TType.I32, 2)
      oprot.writeI32(self.principal_type)
      oprot.writeFieldEnd()
    if self.hiveObject is not None:
      oprot.writeFieldBegin('hiveObject', TType.STRUCT, 3)
      self.hiveObject.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.principal_name)
    value = (value * 31) ^ hash(self.principal_type)
    value = (value * 31) ^ hash(self.hiveObject)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_privileges_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(HiveObjectPrivilege, HiveObjectPrivilege.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1192, _size1189) = iprot.readListBegin()
          for _i1193 in xrange(_size1189):
            _elem1194 = HiveObjectPrivilege()
            _elem1194.read(iprot)
            self.success.append(_elem1194)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_privileges_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter1195 in self.success:
        iter1195.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_privileges_args:
  """
  Attributes:
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'privileges', (PrivilegeBag, PrivilegeBag.thrift_spec), None, ), # 1
  )

  def __init__(self, privileges=None,):
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.privileges = PrivilegeBag()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_privileges_args')
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 1)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.privileges)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_privileges_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_privileges_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revoke_privileges_args:
  """
  Attributes:
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'privileges', (PrivilegeBag, PrivilegeBag.thrift_spec), None, ), # 1
  )

  def __init__(self, privileges=None,):
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.privileges = PrivilegeBag()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revoke_privileges_args')
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 1)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.privileges)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revoke_privileges_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revoke_privileges_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_revoke_privileges_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (GrantRevokePrivilegeRequest, GrantRevokePrivilegeRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = GrantRevokePrivilegeRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_revoke_privileges_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_revoke_privileges_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GrantRevokePrivilegeResponse, GrantRevokePrivilegeResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GrantRevokePrivilegeResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_revoke_privileges_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_ugi_args:
  """
  Attributes:
   - user_name
   - group_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'user_name', None, None, ), # 1
    (2, TType.LIST, 'group_names', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, user_name=None, group_names=None,):
    self.user_name = user_name
    self.group_names = group_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.group_names = []
          (_etype1199, _size1196) = iprot.readListBegin()
          for _i1200 in xrange(_size1196):
            _elem1201 = iprot.readString()
            self.group_names.append(_elem1201)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_ugi_args')
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 1)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.group_names))
      for iter1202 in self.group_names:
        oprot.writeString(iter1202)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.user_name)
    value = (value * 31) ^ hash(self.group_names)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_ugi_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1206, _size1203) = iprot.readListBegin()
          for _i1207 in xrange(_size1203):
            _elem1208 = iprot.readString()
            self.success.append(_elem1208)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_ugi_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter1209 in self.success:
        oprot.writeString(iter1209)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_delegation_token_args:
  """
  Attributes:
   - token_owner
   - renewer_kerberos_principal_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token_owner', None, None, ), # 1
    (2, TType.STRING, 'renewer_kerberos_principal_name', None, None, ), # 2
  )

  def __init__(self, token_owner=None, renewer_kerberos_principal_name=None,):
    self.token_owner = token_owner
    self.renewer_kerberos_principal_name = renewer_kerberos_principal_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token_owner = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.renewer_kerberos_principal_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_delegation_token_args')
    if self.token_owner is not None:
      oprot.writeFieldBegin('token_owner', TType.STRING, 1)
      oprot.writeString(self.token_owner)
      oprot.writeFieldEnd()
    if self.renewer_kerberos_principal_name is not None:
      oprot.writeFieldBegin('renewer_kerberos_principal_name', TType.STRING, 2)
      oprot.writeString(self.renewer_kerberos_principal_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token_owner)
    value = (value * 31) ^ hash(self.renewer_kerberos_principal_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_delegation_token_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_delegation_token_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class renew_delegation_token_args:
  """
  Attributes:
   - token_str_form
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token_str_form', None, None, ), # 1
  )

  def __init__(self, token_str_form=None,):
    self.token_str_form = token_str_form

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token_str_form = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('renew_delegation_token_args')
    if self.token_str_form is not None:
      oprot.writeFieldBegin('token_str_form', TType.STRING, 1)
      oprot.writeString(self.token_str_form)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token_str_form)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class renew_delegation_token_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('renew_delegation_token_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cancel_delegation_token_args:
  """
  Attributes:
   - token_str_form
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token_str_form', None, None, ), # 1
  )

  def __init__(self, token_str_form=None,):
    self.token_str_form = token_str_form

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token_str_form = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cancel_delegation_token_args')
    if self.token_str_form is not None:
      oprot.writeFieldBegin('token_str_form', TType.STRING, 1)
      oprot.writeString(self.token_str_form)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token_str_form)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cancel_delegation_token_result:
  """
  Attributes:
   - o1
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, o1=None,):
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cancel_delegation_token_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_token_args:
  """
  Attributes:
   - token_identifier
   - delegation_token
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token_identifier', None, None, ), # 1
    (2, TType.STRING, 'delegation_token', None, None, ), # 2
  )

  def __init__(self, token_identifier=None, delegation_token=None,):
    self.token_identifier = token_identifier
    self.delegation_token = delegation_token

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token_identifier = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.delegation_token = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_token_args')
    if self.token_identifier is not None:
      oprot.writeFieldBegin('token_identifier', TType.STRING, 1)
      oprot.writeString(self.token_identifier)
      oprot.writeFieldEnd()
    if self.delegation_token is not None:
      oprot.writeFieldBegin('delegation_token', TType.STRING, 2)
      oprot.writeString(self.delegation_token)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token_identifier)
    value = (value * 31) ^ hash(self.delegation_token)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_token_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_token_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class remove_token_args:
  """
  Attributes:
   - token_identifier
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token_identifier', None, None, ), # 1
  )

  def __init__(self, token_identifier=None,):
    self.token_identifier = token_identifier

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token_identifier = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('remove_token_args')
    if self.token_identifier is not None:
      oprot.writeFieldBegin('token_identifier', TType.STRING, 1)
      oprot.writeString(self.token_identifier)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token_identifier)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class remove_token_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('remove_token_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_token_args:
  """
  Attributes:
   - token_identifier
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token_identifier', None, None, ), # 1
  )

  def __init__(self, token_identifier=None,):
    self.token_identifier = token_identifier

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token_identifier = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_token_args')
    if self.token_identifier is not None:
      oprot.writeFieldBegin('token_identifier', TType.STRING, 1)
      oprot.writeString(self.token_identifier)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token_identifier)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_token_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_token_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_token_identifiers_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_token_identifiers_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_token_identifiers_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1213, _size1210) = iprot.readListBegin()
          for _i1214 in xrange(_size1210):
            _elem1215 = iprot.readString()
            self.success.append(_elem1215)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_token_identifiers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter1216 in self.success:
        oprot.writeString(iter1216)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_master_key_args:
  """
  Attributes:
   - key
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
  )

  def __init__(self, key=None,):
    self.key = key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_master_key_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_master_key_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_master_key_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_master_key_args:
  """
  Attributes:
   - seq_number
   - key
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'seq_number', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
  )

  def __init__(self, seq_number=None, key=None,):
    self.seq_number = seq_number
    self.key = key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.seq_number = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_master_key_args')
    if self.seq_number is not None:
      oprot.writeFieldBegin('seq_number', TType.I32, 1)
      oprot.writeI32(self.seq_number)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.seq_number)
    value = (value * 31) ^ hash(self.key)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_master_key_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_master_key_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class remove_master_key_args:
  """
  Attributes:
   - key_seq
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'key_seq', None, None, ), # 1
  )

  def __init__(self, key_seq=None,):
    self.key_seq = key_seq

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.key_seq = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('remove_master_key_args')
    if self.key_seq is not None:
      oprot.writeFieldBegin('key_seq', TType.I32, 1)
      oprot.writeI32(self.key_seq)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key_seq)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class remove_master_key_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('remove_master_key_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_master_keys_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_master_keys_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_master_keys_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1220, _size1217) = iprot.readListBegin()
          for _i1221 in xrange(_size1217):
            _elem1222 = iprot.readString()
            self.success.append(_elem1222)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_master_keys_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter1223 in self.success:
        oprot.writeString(iter1223)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_open_txns_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_open_txns_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_open_txns_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetOpenTxnsResponse, GetOpenTxnsResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetOpenTxnsResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_open_txns_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_open_txns_info_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_open_txns_info_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_open_txns_info_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetOpenTxnsInfoResponse, GetOpenTxnsInfoResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetOpenTxnsInfoResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_open_txns_info_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class open_txns_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (OpenTxnRequest, OpenTxnRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = OpenTxnRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('open_txns_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class open_txns_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (OpenTxnsResponse, OpenTxnsResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = OpenTxnsResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('open_txns_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class abort_txn_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (AbortTxnRequest, AbortTxnRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = AbortTxnRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('abort_txn_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class abort_txn_result:
  """
  Attributes:
   - o1
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchTxnException, NoSuchTxnException.thrift_spec), None, ), # 1
  )

  def __init__(self, o1=None,):
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchTxnException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('abort_txn_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class abort_txns_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (AbortTxnsRequest, AbortTxnsRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = AbortTxnsRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('abort_txns_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class abort_txns_result:
  """
  Attributes:
   - o1
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchTxnException, NoSuchTxnException.thrift_spec), None, ), # 1
  )

  def __init__(self, o1=None,):
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchTxnException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('abort_txns_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class commit_txn_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (CommitTxnRequest, CommitTxnRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = CommitTxnRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('commit_txn_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class commit_txn_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchTxnException, NoSuchTxnException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (TxnAbortedException, TxnAbortedException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchTxnException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = TxnAbortedException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('commit_txn_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class lock_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (LockRequest, LockRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = LockRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('lock_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class lock_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (LockResponse, LockResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchTxnException, NoSuchTxnException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (TxnAbortedException, TxnAbortedException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = LockResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchTxnException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = TxnAbortedException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('lock_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class check_lock_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (CheckLockRequest, CheckLockRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = CheckLockRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('check_lock_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class check_lock_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (LockResponse, LockResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchTxnException, NoSuchTxnException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (TxnAbortedException, TxnAbortedException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (NoSuchLockException, NoSuchLockException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = LockResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchTxnException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = TxnAbortedException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = NoSuchLockException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('check_lock_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unlock_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (UnlockRequest, UnlockRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = UnlockRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unlock_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unlock_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchLockException, NoSuchLockException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (TxnOpenException, TxnOpenException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchLockException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = TxnOpenException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unlock_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class show_locks_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (ShowLocksRequest, ShowLocksRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = ShowLocksRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('show_locks_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class show_locks_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ShowLocksResponse, ShowLocksResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ShowLocksResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('show_locks_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class heartbeat_args:
  """
  Attributes:
   - ids
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ids', (HeartbeatRequest, HeartbeatRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, ids=None,):
    self.ids = ids

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ids = HeartbeatRequest()
          self.ids.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('heartbeat_args')
    if self.ids is not None:
      oprot.writeFieldBegin('ids', TType.STRUCT, 1)
      self.ids.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ids)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class heartbeat_result:
  """
  Attributes:
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchLockException, NoSuchLockException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchTxnException, NoSuchTxnException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (TxnAbortedException, TxnAbortedException.thrift_spec), None, ), # 3
  )

  def __init__(self, o1=None, o2=None, o3=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchLockException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchTxnException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = TxnAbortedException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('heartbeat_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class heartbeat_txn_range_args:
  """
  Attributes:
   - txns
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'txns', (HeartbeatTxnRangeRequest, HeartbeatTxnRangeRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, txns=None,):
    self.txns = txns

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.txns = HeartbeatTxnRangeRequest()
          self.txns.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('heartbeat_txn_range_args')
    if self.txns is not None:
      oprot.writeFieldBegin('txns', TType.STRUCT, 1)
      self.txns.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txns)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class heartbeat_txn_range_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (HeartbeatTxnRangeResponse, HeartbeatTxnRangeResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = HeartbeatTxnRangeResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('heartbeat_txn_range_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class compact_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (CompactionRequest, CompactionRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = CompactionRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('compact_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class compact_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('compact_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class compact2_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (CompactionRequest, CompactionRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = CompactionRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('compact2_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class compact2_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (CompactionResponse, CompactionResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = CompactionResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('compact2_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class show_compact_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (ShowCompactRequest, ShowCompactRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = ShowCompactRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('show_compact_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class show_compact_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ShowCompactResponse, ShowCompactResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ShowCompactResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('show_compact_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_dynamic_partitions_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (AddDynamicPartitions, AddDynamicPartitions.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = AddDynamicPartitions()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_dynamic_partitions_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_dynamic_partitions_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchTxnException, NoSuchTxnException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (TxnAbortedException, TxnAbortedException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchTxnException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = TxnAbortedException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_dynamic_partitions_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_next_notification_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (NotificationEventRequest, NotificationEventRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = NotificationEventRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_next_notification_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_next_notification_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (NotificationEventResponse, NotificationEventResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = NotificationEventResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_next_notification_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_current_notificationEventId_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_current_notificationEventId_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_current_notificationEventId_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (CurrentNotificationEventId, CurrentNotificationEventId.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = CurrentNotificationEventId()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_current_notificationEventId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_notification_events_count_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (NotificationEventsCountRequest, NotificationEventsCountRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = NotificationEventsCountRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_notification_events_count_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_notification_events_count_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (NotificationEventsCountResponse, NotificationEventsCountResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = NotificationEventsCountResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_notification_events_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class fire_listener_event_args:
  """
  Attributes:
   - rqst
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rqst', (FireEventRequest, FireEventRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, rqst=None,):
    self.rqst = rqst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rqst = FireEventRequest()
          self.rqst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('fire_listener_event_args')
    if self.rqst is not None:
      oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
      self.rqst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rqst)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class fire_listener_event_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (FireEventResponse, FireEventResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = FireEventResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('fire_listener_event_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class flushCache_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('flushCache_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class flushCache_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('flushCache_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cm_recycle_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (CmRecycleRequest, CmRecycleRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = CmRecycleRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cm_recycle_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cm_recycle_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (CmRecycleResponse, CmRecycleResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = CmRecycleResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cm_recycle_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_file_metadata_by_expr_args:
  """
  Attributes:
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'req', (GetFileMetadataByExprRequest, GetFileMetadataByExprRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, req=None,):
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = GetFileMetadataByExprRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_file_metadata_by_expr_args')
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.req)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_file_metadata_by_expr_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetFileMetadataByExprResult, GetFileMetadataByExprResult.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetFileMetadataByExprResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_file_metadata_by_expr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_file_metadata_args:
  """
  Attributes:
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'req', (GetFileMetadataRequest, GetFileMetadataRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, req=None,):
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = GetFileMetadataRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_file_metadata_args')
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.req)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_file_metadata_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GetFileMetadataResult, GetFileMetadataResult.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GetFileMetadataResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_file_metadata_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class put_file_metadata_args:
  """
  Attributes:
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'req', (PutFileMetadataRequest, PutFileMetadataRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, req=None,):
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = PutFileMetadataRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('put_file_metadata_args')
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.req)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class put_file_metadata_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PutFileMetadataResult, PutFileMetadataResult.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PutFileMetadataResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('put_file_metadata_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clear_file_metadata_args:
  """
  Attributes:
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'req', (ClearFileMetadataRequest, ClearFileMetadataRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, req=None,):
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = ClearFileMetadataRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clear_file_metadata_args')
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.req)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clear_file_metadata_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ClearFileMetadataResult, ClearFileMetadataResult.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ClearFileMetadataResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clear_file_metadata_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cache_file_metadata_args:
  """
  Attributes:
   - req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'req', (CacheFileMetadataRequest, CacheFileMetadataRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, req=None,):
    self.req = req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = CacheFileMetadataRequest()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cache_file_metadata_args')
    if self.req is not None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.req)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cache_file_metadata_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (CacheFileMetadataResult, CacheFileMetadataResult.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = CacheFileMetadataResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cache_file_metadata_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_metastore_db_uuid_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_metastore_db_uuid_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_metastore_db_uuid_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_metastore_db_uuid_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_resource_plan_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (WMCreateResourcePlanRequest, WMCreateResourcePlanRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = WMCreateResourcePlanRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_resource_plan_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_resource_plan_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (WMCreateResourcePlanResponse, WMCreateResourcePlanResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = WMCreateResourcePlanResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_resource_plan_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_resource_plan_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (WMGetResourcePlanRequest, WMGetResourcePlanRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = WMGetResourcePlanRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_resource_plan_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_resource_plan_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (WMGetResourcePlanResponse, WMGetResourcePlanResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = WMGetResourcePlanResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_resource_plan_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_active_resource_plan_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (WMGetActiveResourcePlanRequest, WMGetActiveResourcePlanRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = WMGetActiveResourcePlanRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_active_resource_plan_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_active_resource_plan_result:
  """
  Attributes:
   - success
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (WMGetActiveResourcePlanResponse, WMGetActiveResourcePlanResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o2=None,):
    self.success = success
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = WMGetActiveResourcePlanResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_active_resource_plan_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 1)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_resource_plans_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (WMGetAllResourcePlanRequest, WMGetAllResourcePlanRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = WMGetAllResourcePlanRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_resource_plans_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_resource_plans_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (WMGetAllResourcePlanResponse, WMGetAllResourcePlanResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = WMGetAllResourcePlanResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_resource_plans_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_resource_plan_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (WMAlterResourcePlanRequest, WMAlterResourcePlanRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = WMAlterResourcePlanRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_resource_plan_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_resource_plan_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (WMAlterResourcePlanResponse, WMAlterResourcePlanResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = WMAlterResourcePlanResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidOperationException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_resource_plan_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class validate_resource_plan_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (WMValidateResourcePlanRequest, WMValidateResourcePlanRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = WMValidateResourcePlanRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('validate_resource_plan_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class validate_resource_plan_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (WMValidateResourcePlanResponse, WMValidateResourcePlanResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = WMValidateResourcePlanResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('validate_resource_plan_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_resource_plan_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (WMDropResourcePlanRequest, WMDropResourcePlanRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = WMDropResourcePlanRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_resource_plan_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_resource_plan_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (WMDropResourcePlanResponse, WMDropResourcePlanResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = WMDropResourcePlanResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidOperationException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_resource_plan_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_wm_trigger_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (WMCreateTriggerRequest, WMCreateTriggerRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = WMCreateTriggerRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_wm_trigger_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_wm_trigger_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (WMCreateTriggerResponse, WMCreateTriggerResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (MetaException, MetaException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = WMCreateTriggerResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = InvalidObjectException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = MetaException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_wm_trigger_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_wm_trigger_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (WMAlterTriggerRequest, WMAlterTriggerRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = WMAlterTriggerRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_wm_trigger_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_wm_trigger_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (WMAlterTriggerResponse, WMAlterTriggerResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = WMAlterTriggerResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_wm_trigger_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_wm_trigger_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (WMDropTriggerRequest, WMDropTriggerRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = WMDropTriggerRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_wm_trigger_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_wm_trigger_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (WMDropTriggerResponse, WMDropTriggerResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = WMDropTriggerResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidOperationException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_wm_trigger_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_triggers_for_resourceplan_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (WMGetTriggersForResourePlanRequest, WMGetTriggersForResourePlanRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = WMGetTriggersForResourePlanRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_triggers_for_resourceplan_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_triggers_for_resourceplan_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (WMGetTriggersForResourePlanResponse, WMGetTriggersForResourePlanResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = WMGetTriggersForResourePlanResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_triggers_for_resourceplan_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_wm_pool_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (WMCreatePoolRequest, WMCreatePoolRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = WMCreatePoolRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_wm_pool_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_wm_pool_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (WMCreatePoolResponse, WMCreatePoolResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (MetaException, MetaException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = WMCreatePoolResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = InvalidObjectException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = MetaException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_wm_pool_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_wm_pool_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (WMAlterPoolRequest, WMAlterPoolRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = WMAlterPoolRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_wm_pool_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_wm_pool_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (WMAlterPoolResponse, WMAlterPoolResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (MetaException, MetaException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = WMAlterPoolResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = InvalidObjectException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = MetaException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_wm_pool_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_wm_pool_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (WMDropPoolRequest, WMDropPoolRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = WMDropPoolRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_wm_pool_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_wm_pool_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (WMDropPoolResponse, WMDropPoolResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = WMDropPoolResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidOperationException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_wm_pool_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_or_update_wm_mapping_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (WMCreateOrUpdateMappingRequest, WMCreateOrUpdateMappingRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = WMCreateOrUpdateMappingRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_or_update_wm_mapping_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_or_update_wm_mapping_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (WMCreateOrUpdateMappingResponse, WMCreateOrUpdateMappingResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (MetaException, MetaException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = WMCreateOrUpdateMappingResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = InvalidObjectException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = MetaException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_or_update_wm_mapping_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_wm_mapping_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (WMDropMappingRequest, WMDropMappingRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = WMDropMappingRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_wm_mapping_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_wm_mapping_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (WMDropMappingResponse, WMDropMappingResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = WMDropMappingResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidOperationException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_wm_mapping_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_or_drop_wm_trigger_to_pool_mapping_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (WMCreateOrDropTriggerToPoolMappingRequest, WMCreateOrDropTriggerToPoolMappingRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = WMCreateOrDropTriggerToPoolMappingRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_or_drop_wm_trigger_to_pool_mapping_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_or_drop_wm_trigger_to_pool_mapping_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (WMCreateOrDropTriggerToPoolMappingResponse, WMCreateOrDropTriggerToPoolMappingResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (MetaException, MetaException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = WMCreateOrDropTriggerToPoolMappingResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = InvalidObjectException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = MetaException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_or_drop_wm_trigger_to_pool_mapping_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.o1)
    value = (value * 31) ^ hash(self.o2)
    value = (value * 31) ^ hash(self.o3)
    value = (value * 31) ^ hash(self.o4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
