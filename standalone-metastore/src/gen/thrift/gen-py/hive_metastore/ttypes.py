#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import fb303.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class HiveObjectType:
  GLOBAL = 1
  DATABASE = 2
  TABLE = 3
  PARTITION = 4
  COLUMN = 5

  _VALUES_TO_NAMES = {
    1: "GLOBAL",
    2: "DATABASE",
    3: "TABLE",
    4: "PARTITION",
    5: "COLUMN",
  }

  _NAMES_TO_VALUES = {
    "GLOBAL": 1,
    "DATABASE": 2,
    "TABLE": 3,
    "PARTITION": 4,
    "COLUMN": 5,
  }

class PrincipalType:
  USER = 1
  ROLE = 2
  GROUP = 3

  _VALUES_TO_NAMES = {
    1: "USER",
    2: "ROLE",
    3: "GROUP",
  }

  _NAMES_TO_VALUES = {
    "USER": 1,
    "ROLE": 2,
    "GROUP": 3,
  }

class PartitionEventType:
  LOAD_DONE = 1

  _VALUES_TO_NAMES = {
    1: "LOAD_DONE",
  }

  _NAMES_TO_VALUES = {
    "LOAD_DONE": 1,
  }

class TxnState:
  COMMITTED = 1
  ABORTED = 2
  OPEN = 3

  _VALUES_TO_NAMES = {
    1: "COMMITTED",
    2: "ABORTED",
    3: "OPEN",
  }

  _NAMES_TO_VALUES = {
    "COMMITTED": 1,
    "ABORTED": 2,
    "OPEN": 3,
  }

class LockLevel:
  DB = 1
  TABLE = 2
  PARTITION = 3

  _VALUES_TO_NAMES = {
    1: "DB",
    2: "TABLE",
    3: "PARTITION",
  }

  _NAMES_TO_VALUES = {
    "DB": 1,
    "TABLE": 2,
    "PARTITION": 3,
  }

class LockState:
  ACQUIRED = 1
  WAITING = 2
  ABORT = 3
  NOT_ACQUIRED = 4

  _VALUES_TO_NAMES = {
    1: "ACQUIRED",
    2: "WAITING",
    3: "ABORT",
    4: "NOT_ACQUIRED",
  }

  _NAMES_TO_VALUES = {
    "ACQUIRED": 1,
    "WAITING": 2,
    "ABORT": 3,
    "NOT_ACQUIRED": 4,
  }

class LockType:
  SHARED_READ = 1
  SHARED_WRITE = 2
  EXCLUSIVE = 3

  _VALUES_TO_NAMES = {
    1: "SHARED_READ",
    2: "SHARED_WRITE",
    3: "EXCLUSIVE",
  }

  _NAMES_TO_VALUES = {
    "SHARED_READ": 1,
    "SHARED_WRITE": 2,
    "EXCLUSIVE": 3,
  }

class CompactionType:
  MINOR = 1
  MAJOR = 2

  _VALUES_TO_NAMES = {
    1: "MINOR",
    2: "MAJOR",
  }

  _NAMES_TO_VALUES = {
    "MINOR": 1,
    "MAJOR": 2,
  }

class GrantRevokeType:
  GRANT = 1
  REVOKE = 2

  _VALUES_TO_NAMES = {
    1: "GRANT",
    2: "REVOKE",
  }

  _NAMES_TO_VALUES = {
    "GRANT": 1,
    "REVOKE": 2,
  }

class DataOperationType:
  SELECT = 1
  INSERT = 2
  UPDATE = 3
  DELETE = 4
  UNSET = 5
  NO_TXN = 6

  _VALUES_TO_NAMES = {
    1: "SELECT",
    2: "INSERT",
    3: "UPDATE",
    4: "DELETE",
    5: "UNSET",
    6: "NO_TXN",
  }

  _NAMES_TO_VALUES = {
    "SELECT": 1,
    "INSERT": 2,
    "UPDATE": 3,
    "DELETE": 4,
    "UNSET": 5,
    "NO_TXN": 6,
  }

class EventRequestType:
  INSERT = 1
  UPDATE = 2
  DELETE = 3

  _VALUES_TO_NAMES = {
    1: "INSERT",
    2: "UPDATE",
    3: "DELETE",
  }

  _NAMES_TO_VALUES = {
    "INSERT": 1,
    "UPDATE": 2,
    "DELETE": 3,
  }

class FunctionType:
  JAVA = 1

  _VALUES_TO_NAMES = {
    1: "JAVA",
  }

  _NAMES_TO_VALUES = {
    "JAVA": 1,
  }

class ResourceType:
  JAR = 1
  FILE = 2
  ARCHIVE = 3

  _VALUES_TO_NAMES = {
    1: "JAR",
    2: "FILE",
    3: "ARCHIVE",
  }

  _NAMES_TO_VALUES = {
    "JAR": 1,
    "FILE": 2,
    "ARCHIVE": 3,
  }

class FileMetadataExprType:
  ORC_SARG = 1

  _VALUES_TO_NAMES = {
    1: "ORC_SARG",
  }

  _NAMES_TO_VALUES = {
    "ORC_SARG": 1,
  }

class ClientCapability:
  TEST_CAPABILITY = 1
  INSERT_ONLY_TABLES = 2

  _VALUES_TO_NAMES = {
    1: "TEST_CAPABILITY",
    2: "INSERT_ONLY_TABLES",
  }

  _NAMES_TO_VALUES = {
    "TEST_CAPABILITY": 1,
    "INSERT_ONLY_TABLES": 2,
  }

class WMResourcePlanStatus:
  ACTIVE = 1
  ENABLED = 2
  DISABLED = 3

  _VALUES_TO_NAMES = {
    1: "ACTIVE",
    2: "ENABLED",
    3: "DISABLED",
  }

  _NAMES_TO_VALUES = {
    "ACTIVE": 1,
    "ENABLED": 2,
    "DISABLED": 3,
  }

class WMPoolSchedulingPolicy:
  FAIR = 1
  FIFO = 2

  _VALUES_TO_NAMES = {
    1: "FAIR",
    2: "FIFO",
  }

  _NAMES_TO_VALUES = {
    "FAIR": 1,
    "FIFO": 2,
  }


class Version:
  """
  Attributes:
   - version
   - comments
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'version', None, None, ), # 1
    (2, TType.STRING, 'comments', None, None, ), # 2
  )

  def __init__(self, version=None, comments=None,):
    self.version = version
    self.comments = comments

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.version = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.comments = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Version')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.STRING, 1)
      oprot.writeString(self.version)
      oprot.writeFieldEnd()
    if self.comments is not None:
      oprot.writeFieldBegin('comments', TType.STRING, 2)
      oprot.writeString(self.comments)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.comments)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FieldSchema:
  """
  Attributes:
   - name
   - type
   - comment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'type', None, None, ), # 2
    (3, TType.STRING, 'comment', None, None, ), # 3
  )

  def __init__(self, name=None, type=None, comment=None,):
    self.name = name
    self.type = type
    self.comment = comment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.type = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.comment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FieldSchema')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 2)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 3)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.comment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SQLPrimaryKey:
  """
  Attributes:
   - table_db
   - table_name
   - column_name
   - key_seq
   - pk_name
   - enable_cstr
   - validate_cstr
   - rely_cstr
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table_db', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.STRING, 'column_name', None, None, ), # 3
    (4, TType.I32, 'key_seq', None, None, ), # 4
    (5, TType.STRING, 'pk_name', None, None, ), # 5
    (6, TType.BOOL, 'enable_cstr', None, None, ), # 6
    (7, TType.BOOL, 'validate_cstr', None, None, ), # 7
    (8, TType.BOOL, 'rely_cstr', None, None, ), # 8
  )

  def __init__(self, table_db=None, table_name=None, column_name=None, key_seq=None, pk_name=None, enable_cstr=None, validate_cstr=None, rely_cstr=None,):
    self.table_db = table_db
    self.table_name = table_name
    self.column_name = column_name
    self.key_seq = key_seq
    self.pk_name = pk_name
    self.enable_cstr = enable_cstr
    self.validate_cstr = validate_cstr
    self.rely_cstr = rely_cstr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.column_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.key_seq = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.pk_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.enable_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.validate_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.rely_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SQLPrimaryKey')
    if self.table_db is not None:
      oprot.writeFieldBegin('table_db', TType.STRING, 1)
      oprot.writeString(self.table_db)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.column_name is not None:
      oprot.writeFieldBegin('column_name', TType.STRING, 3)
      oprot.writeString(self.column_name)
      oprot.writeFieldEnd()
    if self.key_seq is not None:
      oprot.writeFieldBegin('key_seq', TType.I32, 4)
      oprot.writeI32(self.key_seq)
      oprot.writeFieldEnd()
    if self.pk_name is not None:
      oprot.writeFieldBegin('pk_name', TType.STRING, 5)
      oprot.writeString(self.pk_name)
      oprot.writeFieldEnd()
    if self.enable_cstr is not None:
      oprot.writeFieldBegin('enable_cstr', TType.BOOL, 6)
      oprot.writeBool(self.enable_cstr)
      oprot.writeFieldEnd()
    if self.validate_cstr is not None:
      oprot.writeFieldBegin('validate_cstr', TType.BOOL, 7)
      oprot.writeBool(self.validate_cstr)
      oprot.writeFieldEnd()
    if self.rely_cstr is not None:
      oprot.writeFieldBegin('rely_cstr', TType.BOOL, 8)
      oprot.writeBool(self.rely_cstr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.table_db)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.column_name)
    value = (value * 31) ^ hash(self.key_seq)
    value = (value * 31) ^ hash(self.pk_name)
    value = (value * 31) ^ hash(self.enable_cstr)
    value = (value * 31) ^ hash(self.validate_cstr)
    value = (value * 31) ^ hash(self.rely_cstr)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SQLForeignKey:
  """
  Attributes:
   - pktable_db
   - pktable_name
   - pkcolumn_name
   - fktable_db
   - fktable_name
   - fkcolumn_name
   - key_seq
   - update_rule
   - delete_rule
   - fk_name
   - pk_name
   - enable_cstr
   - validate_cstr
   - rely_cstr
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pktable_db', None, None, ), # 1
    (2, TType.STRING, 'pktable_name', None, None, ), # 2
    (3, TType.STRING, 'pkcolumn_name', None, None, ), # 3
    (4, TType.STRING, 'fktable_db', None, None, ), # 4
    (5, TType.STRING, 'fktable_name', None, None, ), # 5
    (6, TType.STRING, 'fkcolumn_name', None, None, ), # 6
    (7, TType.I32, 'key_seq', None, None, ), # 7
    (8, TType.I32, 'update_rule', None, None, ), # 8
    (9, TType.I32, 'delete_rule', None, None, ), # 9
    (10, TType.STRING, 'fk_name', None, None, ), # 10
    (11, TType.STRING, 'pk_name', None, None, ), # 11
    (12, TType.BOOL, 'enable_cstr', None, None, ), # 12
    (13, TType.BOOL, 'validate_cstr', None, None, ), # 13
    (14, TType.BOOL, 'rely_cstr', None, None, ), # 14
  )

  def __init__(self, pktable_db=None, pktable_name=None, pkcolumn_name=None, fktable_db=None, fktable_name=None, fkcolumn_name=None, key_seq=None, update_rule=None, delete_rule=None, fk_name=None, pk_name=None, enable_cstr=None, validate_cstr=None, rely_cstr=None,):
    self.pktable_db = pktable_db
    self.pktable_name = pktable_name
    self.pkcolumn_name = pkcolumn_name
    self.fktable_db = fktable_db
    self.fktable_name = fktable_name
    self.fkcolumn_name = fkcolumn_name
    self.key_seq = key_seq
    self.update_rule = update_rule
    self.delete_rule = delete_rule
    self.fk_name = fk_name
    self.pk_name = pk_name
    self.enable_cstr = enable_cstr
    self.validate_cstr = validate_cstr
    self.rely_cstr = rely_cstr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pktable_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pktable_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.pkcolumn_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.fktable_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.fktable_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.fkcolumn_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.key_seq = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.update_rule = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.delete_rule = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.fk_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.pk_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.enable_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BOOL:
          self.validate_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.BOOL:
          self.rely_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SQLForeignKey')
    if self.pktable_db is not None:
      oprot.writeFieldBegin('pktable_db', TType.STRING, 1)
      oprot.writeString(self.pktable_db)
      oprot.writeFieldEnd()
    if self.pktable_name is not None:
      oprot.writeFieldBegin('pktable_name', TType.STRING, 2)
      oprot.writeString(self.pktable_name)
      oprot.writeFieldEnd()
    if self.pkcolumn_name is not None:
      oprot.writeFieldBegin('pkcolumn_name', TType.STRING, 3)
      oprot.writeString(self.pkcolumn_name)
      oprot.writeFieldEnd()
    if self.fktable_db is not None:
      oprot.writeFieldBegin('fktable_db', TType.STRING, 4)
      oprot.writeString(self.fktable_db)
      oprot.writeFieldEnd()
    if self.fktable_name is not None:
      oprot.writeFieldBegin('fktable_name', TType.STRING, 5)
      oprot.writeString(self.fktable_name)
      oprot.writeFieldEnd()
    if self.fkcolumn_name is not None:
      oprot.writeFieldBegin('fkcolumn_name', TType.STRING, 6)
      oprot.writeString(self.fkcolumn_name)
      oprot.writeFieldEnd()
    if self.key_seq is not None:
      oprot.writeFieldBegin('key_seq', TType.I32, 7)
      oprot.writeI32(self.key_seq)
      oprot.writeFieldEnd()
    if self.update_rule is not None:
      oprot.writeFieldBegin('update_rule', TType.I32, 8)
      oprot.writeI32(self.update_rule)
      oprot.writeFieldEnd()
    if self.delete_rule is not None:
      oprot.writeFieldBegin('delete_rule', TType.I32, 9)
      oprot.writeI32(self.delete_rule)
      oprot.writeFieldEnd()
    if self.fk_name is not None:
      oprot.writeFieldBegin('fk_name', TType.STRING, 10)
      oprot.writeString(self.fk_name)
      oprot.writeFieldEnd()
    if self.pk_name is not None:
      oprot.writeFieldBegin('pk_name', TType.STRING, 11)
      oprot.writeString(self.pk_name)
      oprot.writeFieldEnd()
    if self.enable_cstr is not None:
      oprot.writeFieldBegin('enable_cstr', TType.BOOL, 12)
      oprot.writeBool(self.enable_cstr)
      oprot.writeFieldEnd()
    if self.validate_cstr is not None:
      oprot.writeFieldBegin('validate_cstr', TType.BOOL, 13)
      oprot.writeBool(self.validate_cstr)
      oprot.writeFieldEnd()
    if self.rely_cstr is not None:
      oprot.writeFieldBegin('rely_cstr', TType.BOOL, 14)
      oprot.writeBool(self.rely_cstr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pktable_db)
    value = (value * 31) ^ hash(self.pktable_name)
    value = (value * 31) ^ hash(self.pkcolumn_name)
    value = (value * 31) ^ hash(self.fktable_db)
    value = (value * 31) ^ hash(self.fktable_name)
    value = (value * 31) ^ hash(self.fkcolumn_name)
    value = (value * 31) ^ hash(self.key_seq)
    value = (value * 31) ^ hash(self.update_rule)
    value = (value * 31) ^ hash(self.delete_rule)
    value = (value * 31) ^ hash(self.fk_name)
    value = (value * 31) ^ hash(self.pk_name)
    value = (value * 31) ^ hash(self.enable_cstr)
    value = (value * 31) ^ hash(self.validate_cstr)
    value = (value * 31) ^ hash(self.rely_cstr)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SQLUniqueConstraint:
  """
  Attributes:
   - table_db
   - table_name
   - column_name
   - key_seq
   - uk_name
   - enable_cstr
   - validate_cstr
   - rely_cstr
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table_db', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.STRING, 'column_name', None, None, ), # 3
    (4, TType.I32, 'key_seq', None, None, ), # 4
    (5, TType.STRING, 'uk_name', None, None, ), # 5
    (6, TType.BOOL, 'enable_cstr', None, None, ), # 6
    (7, TType.BOOL, 'validate_cstr', None, None, ), # 7
    (8, TType.BOOL, 'rely_cstr', None, None, ), # 8
  )

  def __init__(self, table_db=None, table_name=None, column_name=None, key_seq=None, uk_name=None, enable_cstr=None, validate_cstr=None, rely_cstr=None,):
    self.table_db = table_db
    self.table_name = table_name
    self.column_name = column_name
    self.key_seq = key_seq
    self.uk_name = uk_name
    self.enable_cstr = enable_cstr
    self.validate_cstr = validate_cstr
    self.rely_cstr = rely_cstr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.column_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.key_seq = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.uk_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.enable_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.validate_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.rely_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SQLUniqueConstraint')
    if self.table_db is not None:
      oprot.writeFieldBegin('table_db', TType.STRING, 1)
      oprot.writeString(self.table_db)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.column_name is not None:
      oprot.writeFieldBegin('column_name', TType.STRING, 3)
      oprot.writeString(self.column_name)
      oprot.writeFieldEnd()
    if self.key_seq is not None:
      oprot.writeFieldBegin('key_seq', TType.I32, 4)
      oprot.writeI32(self.key_seq)
      oprot.writeFieldEnd()
    if self.uk_name is not None:
      oprot.writeFieldBegin('uk_name', TType.STRING, 5)
      oprot.writeString(self.uk_name)
      oprot.writeFieldEnd()
    if self.enable_cstr is not None:
      oprot.writeFieldBegin('enable_cstr', TType.BOOL, 6)
      oprot.writeBool(self.enable_cstr)
      oprot.writeFieldEnd()
    if self.validate_cstr is not None:
      oprot.writeFieldBegin('validate_cstr', TType.BOOL, 7)
      oprot.writeBool(self.validate_cstr)
      oprot.writeFieldEnd()
    if self.rely_cstr is not None:
      oprot.writeFieldBegin('rely_cstr', TType.BOOL, 8)
      oprot.writeBool(self.rely_cstr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.table_db)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.column_name)
    value = (value * 31) ^ hash(self.key_seq)
    value = (value * 31) ^ hash(self.uk_name)
    value = (value * 31) ^ hash(self.enable_cstr)
    value = (value * 31) ^ hash(self.validate_cstr)
    value = (value * 31) ^ hash(self.rely_cstr)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SQLNotNullConstraint:
  """
  Attributes:
   - table_db
   - table_name
   - column_name
   - nn_name
   - enable_cstr
   - validate_cstr
   - rely_cstr
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table_db', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.STRING, 'column_name', None, None, ), # 3
    (4, TType.STRING, 'nn_name', None, None, ), # 4
    (5, TType.BOOL, 'enable_cstr', None, None, ), # 5
    (6, TType.BOOL, 'validate_cstr', None, None, ), # 6
    (7, TType.BOOL, 'rely_cstr', None, None, ), # 7
  )

  def __init__(self, table_db=None, table_name=None, column_name=None, nn_name=None, enable_cstr=None, validate_cstr=None, rely_cstr=None,):
    self.table_db = table_db
    self.table_name = table_name
    self.column_name = column_name
    self.nn_name = nn_name
    self.enable_cstr = enable_cstr
    self.validate_cstr = validate_cstr
    self.rely_cstr = rely_cstr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table_db = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.column_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.nn_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.enable_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.validate_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.rely_cstr = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SQLNotNullConstraint')
    if self.table_db is not None:
      oprot.writeFieldBegin('table_db', TType.STRING, 1)
      oprot.writeString(self.table_db)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.column_name is not None:
      oprot.writeFieldBegin('column_name', TType.STRING, 3)
      oprot.writeString(self.column_name)
      oprot.writeFieldEnd()
    if self.nn_name is not None:
      oprot.writeFieldBegin('nn_name', TType.STRING, 4)
      oprot.writeString(self.nn_name)
      oprot.writeFieldEnd()
    if self.enable_cstr is not None:
      oprot.writeFieldBegin('enable_cstr', TType.BOOL, 5)
      oprot.writeBool(self.enable_cstr)
      oprot.writeFieldEnd()
    if self.validate_cstr is not None:
      oprot.writeFieldBegin('validate_cstr', TType.BOOL, 6)
      oprot.writeBool(self.validate_cstr)
      oprot.writeFieldEnd()
    if self.rely_cstr is not None:
      oprot.writeFieldBegin('rely_cstr', TType.BOOL, 7)
      oprot.writeBool(self.rely_cstr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.table_db)
    value = (value * 31) ^ hash(self.table_name)
    value = (value * 31) ^ hash(self.column_name)
    value = (value * 31) ^ hash(self.nn_name)
    value = (value * 31) ^ hash(self.enable_cstr)
    value = (value * 31) ^ hash(self.validate_cstr)
    value = (value * 31) ^ hash(self.rely_cstr)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Type:
  """
  Attributes:
   - name
   - type1
   - type2
   - fields
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'type1', None, None, ), # 2
    (3, TType.STRING, 'type2', None, None, ), # 3
    (4, TType.LIST, 'fields', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 4
  )

  def __init__(self, name=None, type1=None, type2=None, fields=None,):
    self.name = name
    self.type1 = type1
    self.type2 = type2
    self.fields = fields

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.type1 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.type2 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.fields = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = FieldSchema()
            _elem5.read(iprot)
            self.fields.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Type')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.type1 is not None:
      oprot.writeFieldBegin('type1', TType.STRING, 2)
      oprot.writeString(self.type1)
      oprot.writeFieldEnd()
    if self.type2 is not None:
      oprot.writeFieldBegin('type2', TType.STRING, 3)
      oprot.writeString(self.type2)
      oprot.writeFieldEnd()
    if self.fields is not None:
      oprot.writeFieldBegin('fields', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.fields))
      for iter6 in self.fields:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.type1)
    value = (value * 31) ^ hash(self.type2)
    value = (value * 31) ^ hash(self.fields)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HiveObjectRef:
  """
  Attributes:
   - objectType
   - dbName
   - objectName
   - partValues
   - columnName
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'objectType', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'objectName', None, None, ), # 3
    (4, TType.LIST, 'partValues', (TType.STRING,None), None, ), # 4
    (5, TType.STRING, 'columnName', None, None, ), # 5
  )

  def __init__(self, objectType=None, dbName=None, objectName=None, partValues=None, columnName=None,):
    self.objectType = objectType
    self.dbName = dbName
    self.objectName = objectName
    self.partValues = partValues
    self.columnName = columnName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.objectType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.objectName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.partValues = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString()
            self.partValues.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.columnName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HiveObjectRef')
    if self.objectType is not None:
      oprot.writeFieldBegin('objectType', TType.I32, 1)
      oprot.writeI32(self.objectType)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.objectName is not None:
      oprot.writeFieldBegin('objectName', TType.STRING, 3)
      oprot.writeString(self.objectName)
      oprot.writeFieldEnd()
    if self.partValues is not None:
      oprot.writeFieldBegin('partValues', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.partValues))
      for iter13 in self.partValues:
        oprot.writeString(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.columnName is not None:
      oprot.writeFieldBegin('columnName', TType.STRING, 5)
      oprot.writeString(self.columnName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.objectType)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.objectName)
    value = (value * 31) ^ hash(self.partValues)
    value = (value * 31) ^ hash(self.columnName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrivilegeGrantInfo:
  """
  Attributes:
   - privilege
   - createTime
   - grantor
   - grantorType
   - grantOption
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'privilege', None, None, ), # 1
    (2, TType.I32, 'createTime', None, None, ), # 2
    (3, TType.STRING, 'grantor', None, None, ), # 3
    (4, TType.I32, 'grantorType', None, None, ), # 4
    (5, TType.BOOL, 'grantOption', None, None, ), # 5
  )

  def __init__(self, privilege=None, createTime=None, grantor=None, grantorType=None, grantOption=None,):
    self.privilege = privilege
    self.createTime = createTime
    self.grantor = grantor
    self.grantorType = grantorType
    self.grantOption = grantOption

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.privilege = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.createTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.grantor = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.grantorType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.grantOption = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrivilegeGrantInfo')
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.STRING, 1)
      oprot.writeString(self.privilege)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 2)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.grantor is not None:
      oprot.writeFieldBegin('grantor', TType.STRING, 3)
      oprot.writeString(self.grantor)
      oprot.writeFieldEnd()
    if self.grantorType is not None:
      oprot.writeFieldBegin('grantorType', TType.I32, 4)
      oprot.writeI32(self.grantorType)
      oprot.writeFieldEnd()
    if self.grantOption is not None:
      oprot.writeFieldBegin('grantOption', TType.BOOL, 5)
      oprot.writeBool(self.grantOption)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.privilege)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.grantor)
    value = (value * 31) ^ hash(self.grantorType)
    value = (value * 31) ^ hash(self.grantOption)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HiveObjectPrivilege:
  """
  Attributes:
   - hiveObject
   - principalName
   - principalType
   - grantInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'hiveObject', (HiveObjectRef, HiveObjectRef.thrift_spec), None, ), # 1
    (2, TType.STRING, 'principalName', None, None, ), # 2
    (3, TType.I32, 'principalType', None, None, ), # 3
    (4, TType.STRUCT, 'grantInfo', (PrivilegeGrantInfo, PrivilegeGrantInfo.thrift_spec), None, ), # 4
  )

  def __init__(self, hiveObject=None, principalName=None, principalType=None, grantInfo=None,):
    self.hiveObject = hiveObject
    self.principalName = principalName
    self.principalType = principalType
    self.grantInfo = grantInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.hiveObject = HiveObjectRef()
          self.hiveObject.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.principalName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.principalType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.grantInfo = PrivilegeGrantInfo()
          self.grantInfo.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HiveObjectPrivilege')
    if self.hiveObject is not None:
      oprot.writeFieldBegin('hiveObject', TType.STRUCT, 1)
      self.hiveObject.write(oprot)
      oprot.writeFieldEnd()
    if self.principalName is not None:
      oprot.writeFieldBegin('principalName', TType.STRING, 2)
      oprot.writeString(self.principalName)
      oprot.writeFieldEnd()
    if self.principalType is not None:
      oprot.writeFieldBegin('principalType', TType.I32, 3)
      oprot.writeI32(self.principalType)
      oprot.writeFieldEnd()
    if self.grantInfo is not None:
      oprot.writeFieldBegin('grantInfo', TType.STRUCT, 4)
      self.grantInfo.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hiveObject)
    value = (value * 31) ^ hash(self.principalName)
    value = (value * 31) ^ hash(self.principalType)
    value = (value * 31) ^ hash(self.grantInfo)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrivilegeBag:
  """
  Attributes:
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'privileges', (TType.STRUCT,(HiveObjectPrivilege, HiveObjectPrivilege.thrift_spec)), None, ), # 1
  )

  def __init__(self, privileges=None,):
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.privileges = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = HiveObjectPrivilege()
            _elem19.read(iprot)
            self.privileges.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrivilegeBag')
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.privileges))
      for iter20 in self.privileges:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.privileges)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrincipalPrivilegeSet:
  """
  Attributes:
   - userPrivileges
   - groupPrivileges
   - rolePrivileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'userPrivileges', (TType.STRING,None,TType.LIST,(TType.STRUCT,(PrivilegeGrantInfo, PrivilegeGrantInfo.thrift_spec))), None, ), # 1
    (2, TType.MAP, 'groupPrivileges', (TType.STRING,None,TType.LIST,(TType.STRUCT,(PrivilegeGrantInfo, PrivilegeGrantInfo.thrift_spec))), None, ), # 2
    (3, TType.MAP, 'rolePrivileges', (TType.STRING,None,TType.LIST,(TType.STRUCT,(PrivilegeGrantInfo, PrivilegeGrantInfo.thrift_spec))), None, ), # 3
  )

  def __init__(self, userPrivileges=None, groupPrivileges=None, rolePrivileges=None,):
    self.userPrivileges = userPrivileges
    self.groupPrivileges = groupPrivileges
    self.rolePrivileges = rolePrivileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.userPrivileges = {}
          (_ktype22, _vtype23, _size21 ) = iprot.readMapBegin()
          for _i25 in xrange(_size21):
            _key26 = iprot.readString()
            _val27 = []
            (_etype31, _size28) = iprot.readListBegin()
            for _i32 in xrange(_size28):
              _elem33 = PrivilegeGrantInfo()
              _elem33.read(iprot)
              _val27.append(_elem33)
            iprot.readListEnd()
            self.userPrivileges[_key26] = _val27
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.groupPrivileges = {}
          (_ktype35, _vtype36, _size34 ) = iprot.readMapBegin()
          for _i38 in xrange(_size34):
            _key39 = iprot.readString()
            _val40 = []
            (_etype44, _size41) = iprot.readListBegin()
            for _i45 in xrange(_size41):
              _elem46 = PrivilegeGrantInfo()
              _elem46.read(iprot)
              _val40.append(_elem46)
            iprot.readListEnd()
            self.groupPrivileges[_key39] = _val40
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.rolePrivileges = {}
          (_ktype48, _vtype49, _size47 ) = iprot.readMapBegin()
          for _i51 in xrange(_size47):
            _key52 = iprot.readString()
            _val53 = []
            (_etype57, _size54) = iprot.readListBegin()
            for _i58 in xrange(_size54):
              _elem59 = PrivilegeGrantInfo()
              _elem59.read(iprot)
              _val53.append(_elem59)
            iprot.readListEnd()
            self.rolePrivileges[_key52] = _val53
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrincipalPrivilegeSet')
    if self.userPrivileges is not None:
      oprot.writeFieldBegin('userPrivileges', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.userPrivileges))
      for kiter60,viter61 in self.userPrivileges.items():
        oprot.writeString(kiter60)
        oprot.writeListBegin(TType.STRUCT, len(viter61))
        for iter62 in viter61:
          iter62.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.groupPrivileges is not None:
      oprot.writeFieldBegin('groupPrivileges', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.groupPrivileges))
      for kiter63,viter64 in self.groupPrivileges.items():
        oprot.writeString(kiter63)
        oprot.writeListBegin(TType.STRUCT, len(viter64))
        for iter65 in viter64:
          iter65.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.rolePrivileges is not None:
      oprot.writeFieldBegin('rolePrivileges', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.rolePrivileges))
      for kiter66,viter67 in self.rolePrivileges.items():
        oprot.writeString(kiter66)
        oprot.writeListBegin(TType.STRUCT, len(viter67))
        for iter68 in viter67:
          iter68.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.userPrivileges)
    value = (value * 31) ^ hash(self.groupPrivileges)
    value = (value * 31) ^ hash(self.rolePrivileges)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GrantRevokePrivilegeRequest:
  """
  Attributes:
   - requestType
   - privileges
   - revokeGrantOption
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'requestType', None, None, ), # 1
    (2, TType.STRUCT, 'privileges', (PrivilegeBag, PrivilegeBag.thrift_spec), None, ), # 2
    (3, TType.BOOL, 'revokeGrantOption', None, None, ), # 3
  )

  def __init__(self, requestType=None, privileges=None, revokeGrantOption=None,):
    self.requestType = requestType
    self.privileges = privileges
    self.revokeGrantOption = revokeGrantOption

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.requestType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.privileges = PrivilegeBag()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.revokeGrantOption = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GrantRevokePrivilegeRequest')
    if self.requestType is not None:
      oprot.writeFieldBegin('requestType', TType.I32, 1)
      oprot.writeI32(self.requestType)
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 2)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    if self.revokeGrantOption is not None:
      oprot.writeFieldBegin('revokeGrantOption', TType.BOOL, 3)
      oprot.writeBool(self.revokeGrantOption)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.requestType)
    value = (value * 31) ^ hash(self.privileges)
    value = (value * 31) ^ hash(self.revokeGrantOption)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GrantRevokePrivilegeResponse:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'success', None, None, ), # 1
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GrantRevokePrivilegeResponse')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 1)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Role:
  """
  Attributes:
   - roleName
   - createTime
   - ownerName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'roleName', None, None, ), # 1
    (2, TType.I32, 'createTime', None, None, ), # 2
    (3, TType.STRING, 'ownerName', None, None, ), # 3
  )

  def __init__(self, roleName=None, createTime=None, ownerName=None,):
    self.roleName = roleName
    self.createTime = createTime
    self.ownerName = ownerName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.roleName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.createTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.ownerName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Role')
    if self.roleName is not None:
      oprot.writeFieldBegin('roleName', TType.STRING, 1)
      oprot.writeString(self.roleName)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 2)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.ownerName is not None:
      oprot.writeFieldBegin('ownerName', TType.STRING, 3)
      oprot.writeString(self.ownerName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.roleName)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.ownerName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RolePrincipalGrant:
  """
  Attributes:
   - roleName
   - principalName
   - principalType
   - grantOption
   - grantTime
   - grantorName
   - grantorPrincipalType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'roleName', None, None, ), # 1
    (2, TType.STRING, 'principalName', None, None, ), # 2
    (3, TType.I32, 'principalType', None, None, ), # 3
    (4, TType.BOOL, 'grantOption', None, None, ), # 4
    (5, TType.I32, 'grantTime', None, None, ), # 5
    (6, TType.STRING, 'grantorName', None, None, ), # 6
    (7, TType.I32, 'grantorPrincipalType', None, None, ), # 7
  )

  def __init__(self, roleName=None, principalName=None, principalType=None, grantOption=None, grantTime=None, grantorName=None, grantorPrincipalType=None,):
    self.roleName = roleName
    self.principalName = principalName
    self.principalType = principalType
    self.grantOption = grantOption
    self.grantTime = grantTime
    self.grantorName = grantorName
    self.grantorPrincipalType = grantorPrincipalType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.roleName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.principalName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.principalType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.grantOption = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.grantTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.grantorName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.grantorPrincipalType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RolePrincipalGrant')
    if self.roleName is not None:
      oprot.writeFieldBegin('roleName', TType.STRING, 1)
      oprot.writeString(self.roleName)
      oprot.writeFieldEnd()
    if self.principalName is not None:
      oprot.writeFieldBegin('principalName', TType.STRING, 2)
      oprot.writeString(self.principalName)
      oprot.writeFieldEnd()
    if self.principalType is not None:
      oprot.writeFieldBegin('principalType', TType.I32, 3)
      oprot.writeI32(self.principalType)
      oprot.writeFieldEnd()
    if self.grantOption is not None:
      oprot.writeFieldBegin('grantOption', TType.BOOL, 4)
      oprot.writeBool(self.grantOption)
      oprot.writeFieldEnd()
    if self.grantTime is not None:
      oprot.writeFieldBegin('grantTime', TType.I32, 5)
      oprot.writeI32(self.grantTime)
      oprot.writeFieldEnd()
    if self.grantorName is not None:
      oprot.writeFieldBegin('grantorName', TType.STRING, 6)
      oprot.writeString(self.grantorName)
      oprot.writeFieldEnd()
    if self.grantorPrincipalType is not None:
      oprot.writeFieldBegin('grantorPrincipalType', TType.I32, 7)
      oprot.writeI32(self.grantorPrincipalType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.roleName)
    value = (value * 31) ^ hash(self.principalName)
    value = (value * 31) ^ hash(self.principalType)
    value = (value * 31) ^ hash(self.grantOption)
    value = (value * 31) ^ hash(self.grantTime)
    value = (value * 31) ^ hash(self.grantorName)
    value = (value * 31) ^ hash(self.grantorPrincipalType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetRoleGrantsForPrincipalRequest:
  """
  Attributes:
   - principal_name
   - principal_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'principal_name', None, None, ), # 1
    (2, TType.I32, 'principal_type', None, None, ), # 2
  )

  def __init__(self, principal_name=None, principal_type=None,):
    self.principal_name = principal_name
    self.principal_type = principal_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.principal_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.principal_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetRoleGrantsForPrincipalRequest')
    if self.principal_name is not None:
      oprot.writeFieldBegin('principal_name', TType.STRING, 1)
      oprot.writeString(self.principal_name)
      oprot.writeFieldEnd()
    if self.principal_type is not None:
      oprot.writeFieldBegin('principal_type', TType.I32, 2)
      oprot.writeI32(self.principal_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.principal_name is None:
      raise TProtocol.TProtocolException(message='Required field principal_name is unset!')
    if self.principal_type is None:
      raise TProtocol.TProtocolException(message='Required field principal_type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.principal_name)
    value = (value * 31) ^ hash(self.principal_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetRoleGrantsForPrincipalResponse:
  """
  Attributes:
   - principalGrants
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'principalGrants', (TType.STRUCT,(RolePrincipalGrant, RolePrincipalGrant.thrift_spec)), None, ), # 1
  )

  def __init__(self, principalGrants=None,):
    self.principalGrants = principalGrants

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.principalGrants = []
          (_etype72, _size69) = iprot.readListBegin()
          for _i73 in xrange(_size69):
            _elem74 = RolePrincipalGrant()
            _elem74.read(iprot)
            self.principalGrants.append(_elem74)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetRoleGrantsForPrincipalResponse')
    if self.principalGrants is not None:
      oprot.writeFieldBegin('principalGrants', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.principalGrants))
      for iter75 in self.principalGrants:
        iter75.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.principalGrants is None:
      raise TProtocol.TProtocolException(message='Required field principalGrants is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.principalGrants)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetPrincipalsInRoleRequest:
  """
  Attributes:
   - roleName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'roleName', None, None, ), # 1
  )

  def __init__(self, roleName=None,):
    self.roleName = roleName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.roleName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetPrincipalsInRoleRequest')
    if self.roleName is not None:
      oprot.writeFieldBegin('roleName', TType.STRING, 1)
      oprot.writeString(self.roleName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.roleName is None:
      raise TProtocol.TProtocolException(message='Required field roleName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.roleName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetPrincipalsInRoleResponse:
  """
  Attributes:
   - principalGrants
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'principalGrants', (TType.STRUCT,(RolePrincipalGrant, RolePrincipalGrant.thrift_spec)), None, ), # 1
  )

  def __init__(self, principalGrants=None,):
    self.principalGrants = principalGrants

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.principalGrants = []
          (_etype79, _size76) = iprot.readListBegin()
          for _i80 in xrange(_size76):
            _elem81 = RolePrincipalGrant()
            _elem81.read(iprot)
            self.principalGrants.append(_elem81)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetPrincipalsInRoleResponse')
    if self.principalGrants is not None:
      oprot.writeFieldBegin('principalGrants', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.principalGrants))
      for iter82 in self.principalGrants:
        iter82.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.principalGrants is None:
      raise TProtocol.TProtocolException(message='Required field principalGrants is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.principalGrants)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GrantRevokeRoleRequest:
  """
  Attributes:
   - requestType
   - roleName
   - principalName
   - principalType
   - grantor
   - grantorType
   - grantOption
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'requestType', None, None, ), # 1
    (2, TType.STRING, 'roleName', None, None, ), # 2
    (3, TType.STRING, 'principalName', None, None, ), # 3
    (4, TType.I32, 'principalType', None, None, ), # 4
    (5, TType.STRING, 'grantor', None, None, ), # 5
    (6, TType.I32, 'grantorType', None, None, ), # 6
    (7, TType.BOOL, 'grantOption', None, None, ), # 7
  )

  def __init__(self, requestType=None, roleName=None, principalName=None, principalType=None, grantor=None, grantorType=None, grantOption=None,):
    self.requestType = requestType
    self.roleName = roleName
    self.principalName = principalName
    self.principalType = principalType
    self.grantor = grantor
    self.grantorType = grantorType
    self.grantOption = grantOption

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.requestType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.roleName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.principalName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.principalType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.grantor = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.grantorType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.grantOption = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GrantRevokeRoleRequest')
    if self.requestType is not None:
      oprot.writeFieldBegin('requestType', TType.I32, 1)
      oprot.writeI32(self.requestType)
      oprot.writeFieldEnd()
    if self.roleName is not None:
      oprot.writeFieldBegin('roleName', TType.STRING, 2)
      oprot.writeString(self.roleName)
      oprot.writeFieldEnd()
    if self.principalName is not None:
      oprot.writeFieldBegin('principalName', TType.STRING, 3)
      oprot.writeString(self.principalName)
      oprot.writeFieldEnd()
    if self.principalType is not None:
      oprot.writeFieldBegin('principalType', TType.I32, 4)
      oprot.writeI32(self.principalType)
      oprot.writeFieldEnd()
    if self.grantor is not None:
      oprot.writeFieldBegin('grantor', TType.STRING, 5)
      oprot.writeString(self.grantor)
      oprot.writeFieldEnd()
    if self.grantorType is not None:
      oprot.writeFieldBegin('grantorType', TType.I32, 6)
      oprot.writeI32(self.grantorType)
      oprot.writeFieldEnd()
    if self.grantOption is not None:
      oprot.writeFieldBegin('grantOption', TType.BOOL, 7)
      oprot.writeBool(self.grantOption)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.requestType)
    value = (value * 31) ^ hash(self.roleName)
    value = (value * 31) ^ hash(self.principalName)
    value = (value * 31) ^ hash(self.principalType)
    value = (value * 31) ^ hash(self.grantor)
    value = (value * 31) ^ hash(self.grantorType)
    value = (value * 31) ^ hash(self.grantOption)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GrantRevokeRoleResponse:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'success', None, None, ), # 1
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GrantRevokeRoleResponse')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 1)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Database:
  """
  Attributes:
   - name
   - description
   - locationUri
   - parameters
   - privileges
   - ownerName
   - ownerType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'description', None, None, ), # 2
    (3, TType.STRING, 'locationUri', None, None, ), # 3
    (4, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 4
    (5, TType.STRUCT, 'privileges', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 5
    (6, TType.STRING, 'ownerName', None, None, ), # 6
    (7, TType.I32, 'ownerType', None, None, ), # 7
  )

  def __init__(self, name=None, description=None, locationUri=None, parameters=None, privileges=None, ownerName=None, ownerType=None,):
    self.name = name
    self.description = description
    self.locationUri = locationUri
    self.parameters = parameters
    self.privileges = privileges
    self.ownerName = ownerName
    self.ownerType = ownerType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.description = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.locationUri = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype84, _vtype85, _size83 ) = iprot.readMapBegin()
          for _i87 in xrange(_size83):
            _key88 = iprot.readString()
            _val89 = iprot.readString()
            self.parameters[_key88] = _val89
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.privileges = PrincipalPrivilegeSet()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.ownerName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.ownerType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Database')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 2)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    if self.locationUri is not None:
      oprot.writeFieldBegin('locationUri', TType.STRING, 3)
      oprot.writeString(self.locationUri)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter90,viter91 in self.parameters.items():
        oprot.writeString(kiter90)
        oprot.writeString(viter91)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 5)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    if self.ownerName is not None:
      oprot.writeFieldBegin('ownerName', TType.STRING, 6)
      oprot.writeString(self.ownerName)
      oprot.writeFieldEnd()
    if self.ownerType is not None:
      oprot.writeFieldBegin('ownerType', TType.I32, 7)
      oprot.writeI32(self.ownerType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.description)
    value = (value * 31) ^ hash(self.locationUri)
    value = (value * 31) ^ hash(self.parameters)
    value = (value * 31) ^ hash(self.privileges)
    value = (value * 31) ^ hash(self.ownerName)
    value = (value * 31) ^ hash(self.ownerType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SerDeInfo:
  """
  Attributes:
   - name
   - serializationLib
   - parameters
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'serializationLib', None, None, ), # 2
    (3, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 3
  )

  def __init__(self, name=None, serializationLib=None, parameters=None,):
    self.name = name
    self.serializationLib = serializationLib
    self.parameters = parameters

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.serializationLib = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype93, _vtype94, _size92 ) = iprot.readMapBegin()
          for _i96 in xrange(_size92):
            _key97 = iprot.readString()
            _val98 = iprot.readString()
            self.parameters[_key97] = _val98
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SerDeInfo')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.serializationLib is not None:
      oprot.writeFieldBegin('serializationLib', TType.STRING, 2)
      oprot.writeString(self.serializationLib)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter99,viter100 in self.parameters.items():
        oprot.writeString(kiter99)
        oprot.writeString(viter100)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.serializationLib)
    value = (value * 31) ^ hash(self.parameters)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Order:
  """
  Attributes:
   - col
   - order
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'col', None, None, ), # 1
    (2, TType.I32, 'order', None, None, ), # 2
  )

  def __init__(self, col=None, order=None,):
    self.col = col
    self.order = order

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.col = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.order = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Order')
    if self.col is not None:
      oprot.writeFieldBegin('col', TType.STRING, 1)
      oprot.writeString(self.col)
      oprot.writeFieldEnd()
    if self.order is not None:
      oprot.writeFieldBegin('order', TType.I32, 2)
      oprot.writeI32(self.order)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.col)
    value = (value * 31) ^ hash(self.order)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SkewedInfo:
  """
  Attributes:
   - skewedColNames
   - skewedColValues
   - skewedColValueLocationMaps
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'skewedColNames', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'skewedColValues', (TType.LIST,(TType.STRING,None)), None, ), # 2
    (3, TType.MAP, 'skewedColValueLocationMaps', (TType.LIST,(TType.STRING,None),TType.STRING,None), None, ), # 3
  )

  def __init__(self, skewedColNames=None, skewedColValues=None, skewedColValueLocationMaps=None,):
    self.skewedColNames = skewedColNames
    self.skewedColValues = skewedColValues
    self.skewedColValueLocationMaps = skewedColValueLocationMaps

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.skewedColNames = []
          (_etype104, _size101) = iprot.readListBegin()
          for _i105 in xrange(_size101):
            _elem106 = iprot.readString()
            self.skewedColNames.append(_elem106)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.skewedColValues = []
          (_etype110, _size107) = iprot.readListBegin()
          for _i111 in xrange(_size107):
            _elem112 = []
            (_etype116, _size113) = iprot.readListBegin()
            for _i117 in xrange(_size113):
              _elem118 = iprot.readString()
              _elem112.append(_elem118)
            iprot.readListEnd()
            self.skewedColValues.append(_elem112)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.skewedColValueLocationMaps = {}
          (_ktype120, _vtype121, _size119 ) = iprot.readMapBegin()
          for _i123 in xrange(_size119):
            _key124 = []
            (_etype129, _size126) = iprot.readListBegin()
            for _i130 in xrange(_size126):
              _elem131 = iprot.readString()
              _key124.append(_elem131)
            iprot.readListEnd()
            _val125 = iprot.readString()
            self.skewedColValueLocationMaps[_key124] = _val125
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SkewedInfo')
    if self.skewedColNames is not None:
      oprot.writeFieldBegin('skewedColNames', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.skewedColNames))
      for iter132 in self.skewedColNames:
        oprot.writeString(iter132)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.skewedColValues is not None:
      oprot.writeFieldBegin('skewedColValues', TType.LIST, 2)
      oprot.writeListBegin(TType.LIST, len(self.skewedColValues))
      for iter133 in self.skewedColValues:
        oprot.writeListBegin(TType.STRING, len(iter133))
        for iter134 in iter133:
          oprot.writeString(iter134)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.skewedColValueLocationMaps is not None:
      oprot.writeFieldBegin('skewedColValueLocationMaps', TType.MAP, 3)
      oprot.writeMapBegin(TType.LIST, TType.STRING, len(self.skewedColValueLocationMaps))
      for kiter135,viter136 in self.skewedColValueLocationMaps.items():
        oprot.writeListBegin(TType.STRING, len(kiter135))
        for iter137 in kiter135:
          oprot.writeString(iter137)
        oprot.writeListEnd()
        oprot.writeString(viter136)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.skewedColNames)
    value = (value * 31) ^ hash(self.skewedColValues)
    value = (value * 31) ^ hash(self.skewedColValueLocationMaps)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StorageDescriptor:
  """
  Attributes:
   - cols
   - location
   - inputFormat
   - outputFormat
   - compressed
   - numBuckets
   - serdeInfo
   - bucketCols
   - sortCols
   - parameters
   - skewedInfo
   - storedAsSubDirectories
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'cols', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'location', None, None, ), # 2
    (3, TType.STRING, 'inputFormat', None, None, ), # 3
    (4, TType.STRING, 'outputFormat', None, None, ), # 4
    (5, TType.BOOL, 'compressed', None, None, ), # 5
    (6, TType.I32, 'numBuckets', None, None, ), # 6
    (7, TType.STRUCT, 'serdeInfo', (SerDeInfo, SerDeInfo.thrift_spec), None, ), # 7
    (8, TType.LIST, 'bucketCols', (TType.STRING,None), None, ), # 8
    (9, TType.LIST, 'sortCols', (TType.STRUCT,(Order, Order.thrift_spec)), None, ), # 9
    (10, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 10
    (11, TType.STRUCT, 'skewedInfo', (SkewedInfo, SkewedInfo.thrift_spec), None, ), # 11
    (12, TType.BOOL, 'storedAsSubDirectories', None, None, ), # 12
  )

  def __init__(self, cols=None, location=None, inputFormat=None, outputFormat=None, compressed=None, numBuckets=None, serdeInfo=None, bucketCols=None, sortCols=None, parameters=None, skewedInfo=None, storedAsSubDirectories=None,):
    self.cols = cols
    self.location = location
    self.inputFormat = inputFormat
    self.outputFormat = outputFormat
    self.compressed = compressed
    self.numBuckets = numBuckets
    self.serdeInfo = serdeInfo
    self.bucketCols = bucketCols
    self.sortCols = sortCols
    self.parameters = parameters
    self.skewedInfo = skewedInfo
    self.storedAsSubDirectories = storedAsSubDirectories

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.cols = []
          (_etype141, _size138) = iprot.readListBegin()
          for _i142 in xrange(_size138):
            _elem143 = FieldSchema()
            _elem143.read(iprot)
            self.cols.append(_elem143)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.location = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.inputFormat = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.outputFormat = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.compressed = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.numBuckets = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.serdeInfo = SerDeInfo()
          self.serdeInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.bucketCols = []
          (_etype147, _size144) = iprot.readListBegin()
          for _i148 in xrange(_size144):
            _elem149 = iprot.readString()
            self.bucketCols.append(_elem149)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.sortCols = []
          (_etype153, _size150) = iprot.readListBegin()
          for _i154 in xrange(_size150):
            _elem155 = Order()
            _elem155.read(iprot)
            self.sortCols.append(_elem155)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype157, _vtype158, _size156 ) = iprot.readMapBegin()
          for _i160 in xrange(_size156):
            _key161 = iprot.readString()
            _val162 = iprot.readString()
            self.parameters[_key161] = _val162
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.skewedInfo = SkewedInfo()
          self.skewedInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.storedAsSubDirectories = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StorageDescriptor')
    if self.cols is not None:
      oprot.writeFieldBegin('cols', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.cols))
      for iter163 in self.cols:
        iter163.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 2)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.inputFormat is not None:
      oprot.writeFieldBegin('inputFormat', TType.STRING, 3)
      oprot.writeString(self.inputFormat)
      oprot.writeFieldEnd()
    if self.outputFormat is not None:
      oprot.writeFieldBegin('outputFormat', TType.STRING, 4)
      oprot.writeString(self.outputFormat)
      oprot.writeFieldEnd()
    if self.compressed is not None:
      oprot.writeFieldBegin('compressed', TType.BOOL, 5)
      oprot.writeBool(self.compressed)
      oprot.writeFieldEnd()
    if self.numBuckets is not None:
      oprot.writeFieldBegin('numBuckets', TType.I32, 6)
      oprot.writeI32(self.numBuckets)
      oprot.writeFieldEnd()
    if self.serdeInfo is not None:
      oprot.writeFieldBegin('serdeInfo', TType.STRUCT, 7)
      self.serdeInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.bucketCols is not None:
      oprot.writeFieldBegin('bucketCols', TType.LIST, 8)
      oprot.writeListBegin(TType.STRING, len(self.bucketCols))
      for iter164 in self.bucketCols:
        oprot.writeString(iter164)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sortCols is not None:
      oprot.writeFieldBegin('sortCols', TType.LIST, 9)
      oprot.writeListBegin(TType.STRUCT, len(self.sortCols))
      for iter165 in self.sortCols:
        iter165.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 10)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter166,viter167 in self.parameters.items():
        oprot.writeString(kiter166)
        oprot.writeString(viter167)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.skewedInfo is not None:
      oprot.writeFieldBegin('skewedInfo', TType.STRUCT, 11)
      self.skewedInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.storedAsSubDirectories is not None:
      oprot.writeFieldBegin('storedAsSubDirectories', TType.BOOL, 12)
      oprot.writeBool(self.storedAsSubDirectories)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cols)
    value = (value * 31) ^ hash(self.location)
    value = (value * 31) ^ hash(self.inputFormat)
    value = (value * 31) ^ hash(self.outputFormat)
    value = (value * 31) ^ hash(self.compressed)
    value = (value * 31) ^ hash(self.numBuckets)
    value = (value * 31) ^ hash(self.serdeInfo)
    value = (value * 31) ^ hash(self.bucketCols)
    value = (value * 31) ^ hash(self.sortCols)
    value = (value * 31) ^ hash(self.parameters)
    value = (value * 31) ^ hash(self.skewedInfo)
    value = (value * 31) ^ hash(self.storedAsSubDirectories)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Table:
  """
  Attributes:
   - tableName
   - dbName
   - owner
   - createTime
   - lastAccessTime
   - retention
   - sd
   - partitionKeys
   - parameters
   - viewOriginalText
   - viewExpandedText
   - tableType
   - privileges
   - temporary
   - rewriteEnabled
   - creationMetadata
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'owner', None, None, ), # 3
    (4, TType.I32, 'createTime', None, None, ), # 4
    (5, TType.I32, 'lastAccessTime', None, None, ), # 5
    (6, TType.I32, 'retention', None, None, ), # 6
    (7, TType.STRUCT, 'sd', (StorageDescriptor, StorageDescriptor.thrift_spec), None, ), # 7
    (8, TType.LIST, 'partitionKeys', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 8
    (9, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 9
    (10, TType.STRING, 'viewOriginalText', None, None, ), # 10
    (11, TType.STRING, 'viewExpandedText', None, None, ), # 11
    (12, TType.STRING, 'tableType', None, None, ), # 12
    (13, TType.STRUCT, 'privileges', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 13
    (14, TType.BOOL, 'temporary', None, False, ), # 14
    (15, TType.BOOL, 'rewriteEnabled', None, None, ), # 15
    (16, TType.STRUCT, 'creationMetadata', (CreationMetadata, CreationMetadata.thrift_spec), None, ), # 16
  )

  def __init__(self, tableName=None, dbName=None, owner=None, createTime=None, lastAccessTime=None, retention=None, sd=None, partitionKeys=None, parameters=None, viewOriginalText=None, viewExpandedText=None, tableType=None, privileges=None, temporary=thrift_spec[14][4], rewriteEnabled=None, creationMetadata=None,):
    self.tableName = tableName
    self.dbName = dbName
    self.owner = owner
    self.createTime = createTime
    self.lastAccessTime = lastAccessTime
    self.retention = retention
    self.sd = sd
    self.partitionKeys = partitionKeys
    self.parameters = parameters
    self.viewOriginalText = viewOriginalText
    self.viewExpandedText = viewExpandedText
    self.tableType = tableType
    self.privileges = privileges
    self.temporary = temporary
    self.rewriteEnabled = rewriteEnabled
    self.creationMetadata = creationMetadata

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.owner = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.createTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.lastAccessTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.retention = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.sd = StorageDescriptor()
          self.sd.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.partitionKeys = []
          (_etype171, _size168) = iprot.readListBegin()
          for _i172 in xrange(_size168):
            _elem173 = FieldSchema()
            _elem173.read(iprot)
            self.partitionKeys.append(_elem173)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype175, _vtype176, _size174 ) = iprot.readMapBegin()
          for _i178 in xrange(_size174):
            _key179 = iprot.readString()
            _val180 = iprot.readString()
            self.parameters[_key179] = _val180
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.viewOriginalText = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.viewExpandedText = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.tableType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.privileges = PrincipalPrivilegeSet()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.BOOL:
          self.temporary = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.BOOL:
          self.rewriteEnabled = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRUCT:
          self.creationMetadata = CreationMetadata()
          self.creationMetadata.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Table')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.owner is not None:
      oprot.writeFieldBegin('owner', TType.STRING, 3)
      oprot.writeString(self.owner)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 4)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime is not None:
      oprot.writeFieldBegin('lastAccessTime', TType.I32, 5)
      oprot.writeI32(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.retention is not None:
      oprot.writeFieldBegin('retention', TType.I32, 6)
      oprot.writeI32(self.retention)
      oprot.writeFieldEnd()
    if self.sd is not None:
      oprot.writeFieldBegin('sd', TType.STRUCT, 7)
      self.sd.write(oprot)
      oprot.writeFieldEnd()
    if self.partitionKeys is not None:
      oprot.writeFieldBegin('partitionKeys', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.partitionKeys))
      for iter181 in self.partitionKeys:
        iter181.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter182,viter183 in self.parameters.items():
        oprot.writeString(kiter182)
        oprot.writeString(viter183)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.viewOriginalText is not None:
      oprot.writeFieldBegin('viewOriginalText', TType.STRING, 10)
      oprot.writeString(self.viewOriginalText)
      oprot.writeFieldEnd()
    if self.viewExpandedText is not None:
      oprot.writeFieldBegin('viewExpandedText', TType.STRING, 11)
      oprot.writeString(self.viewExpandedText)
      oprot.writeFieldEnd()
    if self.tableType is not None:
      oprot.writeFieldBegin('tableType', TType.STRING, 12)
      oprot.writeString(self.tableType)
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 13)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    if self.temporary is not None:
      oprot.writeFieldBegin('temporary', TType.BOOL, 14)
      oprot.writeBool(self.temporary)
      oprot.writeFieldEnd()
    if self.rewriteEnabled is not None:
      oprot.writeFieldBegin('rewriteEnabled', TType.BOOL, 15)
      oprot.writeBool(self.rewriteEnabled)
      oprot.writeFieldEnd()
    if self.creationMetadata is not None:
      oprot.writeFieldBegin('creationMetadata', TType.STRUCT, 16)
      self.creationMetadata.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.owner)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.lastAccessTime)
    value = (value * 31) ^ hash(self.retention)
    value = (value * 31) ^ hash(self.sd)
    value = (value * 31) ^ hash(self.partitionKeys)
    value = (value * 31) ^ hash(self.parameters)
    value = (value * 31) ^ hash(self.viewOriginalText)
    value = (value * 31) ^ hash(self.viewExpandedText)
    value = (value * 31) ^ hash(self.tableType)
    value = (value * 31) ^ hash(self.privileges)
    value = (value * 31) ^ hash(self.temporary)
    value = (value * 31) ^ hash(self.rewriteEnabled)
    value = (value * 31) ^ hash(self.creationMetadata)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Partition:
  """
  Attributes:
   - values
   - dbName
   - tableName
   - createTime
   - lastAccessTime
   - sd
   - parameters
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'values', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'tableName', None, None, ), # 3
    (4, TType.I32, 'createTime', None, None, ), # 4
    (5, TType.I32, 'lastAccessTime', None, None, ), # 5
    (6, TType.STRUCT, 'sd', (StorageDescriptor, StorageDescriptor.thrift_spec), None, ), # 6
    (7, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 7
    (8, TType.STRUCT, 'privileges', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 8
  )

  def __init__(self, values=None, dbName=None, tableName=None, createTime=None, lastAccessTime=None, sd=None, parameters=None, privileges=None,):
    self.values = values
    self.dbName = dbName
    self.tableName = tableName
    self.createTime = createTime
    self.lastAccessTime = lastAccessTime
    self.sd = sd
    self.parameters = parameters
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.values = []
          (_etype187, _size184) = iprot.readListBegin()
          for _i188 in xrange(_size184):
            _elem189 = iprot.readString()
            self.values.append(_elem189)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.createTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.lastAccessTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.sd = StorageDescriptor()
          self.sd.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype191, _vtype192, _size190 ) = iprot.readMapBegin()
          for _i194 in xrange(_size190):
            _key195 = iprot.readString()
            _val196 = iprot.readString()
            self.parameters[_key195] = _val196
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.privileges = PrincipalPrivilegeSet()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Partition')
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.values))
      for iter197 in self.values:
        oprot.writeString(iter197)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 3)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 4)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime is not None:
      oprot.writeFieldBegin('lastAccessTime', TType.I32, 5)
      oprot.writeI32(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.sd is not None:
      oprot.writeFieldBegin('sd', TType.STRUCT, 6)
      self.sd.write(oprot)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter198,viter199 in self.parameters.items():
        oprot.writeString(kiter198)
        oprot.writeString(viter199)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 8)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.lastAccessTime)
    value = (value * 31) ^ hash(self.sd)
    value = (value * 31) ^ hash(self.parameters)
    value = (value * 31) ^ hash(self.privileges)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionWithoutSD:
  """
  Attributes:
   - values
   - createTime
   - lastAccessTime
   - relativePath
   - parameters
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'values', (TType.STRING,None), None, ), # 1
    (2, TType.I32, 'createTime', None, None, ), # 2
    (3, TType.I32, 'lastAccessTime', None, None, ), # 3
    (4, TType.STRING, 'relativePath', None, None, ), # 4
    (5, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 5
    (6, TType.STRUCT, 'privileges', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 6
  )

  def __init__(self, values=None, createTime=None, lastAccessTime=None, relativePath=None, parameters=None, privileges=None,):
    self.values = values
    self.createTime = createTime
    self.lastAccessTime = lastAccessTime
    self.relativePath = relativePath
    self.parameters = parameters
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.values = []
          (_etype203, _size200) = iprot.readListBegin()
          for _i204 in xrange(_size200):
            _elem205 = iprot.readString()
            self.values.append(_elem205)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.createTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.lastAccessTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.relativePath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype207, _vtype208, _size206 ) = iprot.readMapBegin()
          for _i210 in xrange(_size206):
            _key211 = iprot.readString()
            _val212 = iprot.readString()
            self.parameters[_key211] = _val212
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.privileges = PrincipalPrivilegeSet()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionWithoutSD')
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.values))
      for iter213 in self.values:
        oprot.writeString(iter213)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 2)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime is not None:
      oprot.writeFieldBegin('lastAccessTime', TType.I32, 3)
      oprot.writeI32(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.relativePath is not None:
      oprot.writeFieldBegin('relativePath', TType.STRING, 4)
      oprot.writeString(self.relativePath)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter214,viter215 in self.parameters.items():
        oprot.writeString(kiter214)
        oprot.writeString(viter215)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 6)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.lastAccessTime)
    value = (value * 31) ^ hash(self.relativePath)
    value = (value * 31) ^ hash(self.parameters)
    value = (value * 31) ^ hash(self.privileges)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionSpecWithSharedSD:
  """
  Attributes:
   - partitions
   - sd
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partitions', (TType.STRUCT,(PartitionWithoutSD, PartitionWithoutSD.thrift_spec)), None, ), # 1
    (2, TType.STRUCT, 'sd', (StorageDescriptor, StorageDescriptor.thrift_spec), None, ), # 2
  )

  def __init__(self, partitions=None, sd=None,):
    self.partitions = partitions
    self.sd = sd

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partitions = []
          (_etype219, _size216) = iprot.readListBegin()
          for _i220 in xrange(_size216):
            _elem221 = PartitionWithoutSD()
            _elem221.read(iprot)
            self.partitions.append(_elem221)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.sd = StorageDescriptor()
          self.sd.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionSpecWithSharedSD')
    if self.partitions is not None:
      oprot.writeFieldBegin('partitions', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partitions))
      for iter222 in self.partitions:
        iter222.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sd is not None:
      oprot.writeFieldBegin('sd', TType.STRUCT, 2)
      self.sd.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitions)
    value = (value * 31) ^ hash(self.sd)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionListComposingSpec:
  """
  Attributes:
   - partitions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partitions', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 1
  )

  def __init__(self, partitions=None,):
    self.partitions = partitions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partitions = []
          (_etype226, _size223) = iprot.readListBegin()
          for _i227 in xrange(_size223):
            _elem228 = Partition()
            _elem228.read(iprot)
            self.partitions.append(_elem228)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionListComposingSpec')
    if self.partitions is not None:
      oprot.writeFieldBegin('partitions', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partitions))
      for iter229 in self.partitions:
        iter229.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionSpec:
  """
  Attributes:
   - dbName
   - tableName
   - rootPath
   - sharedSDPartitionSpec
   - partitionList
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'rootPath', None, None, ), # 3
    (4, TType.STRUCT, 'sharedSDPartitionSpec', (PartitionSpecWithSharedSD, PartitionSpecWithSharedSD.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'partitionList', (PartitionListComposingSpec, PartitionListComposingSpec.thrift_spec), None, ), # 5
  )

  def __init__(self, dbName=None, tableName=None, rootPath=None, sharedSDPartitionSpec=None, partitionList=None,):
    self.dbName = dbName
    self.tableName = tableName
    self.rootPath = rootPath
    self.sharedSDPartitionSpec = sharedSDPartitionSpec
    self.partitionList = partitionList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.rootPath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.sharedSDPartitionSpec = PartitionSpecWithSharedSD()
          self.sharedSDPartitionSpec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.partitionList = PartitionListComposingSpec()
          self.partitionList.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionSpec')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.rootPath is not None:
      oprot.writeFieldBegin('rootPath', TType.STRING, 3)
      oprot.writeString(self.rootPath)
      oprot.writeFieldEnd()
    if self.sharedSDPartitionSpec is not None:
      oprot.writeFieldBegin('sharedSDPartitionSpec', TType.STRUCT, 4)
      self.sharedSDPartitionSpec.write(oprot)
      oprot.writeFieldEnd()
    if self.partitionList is not None:
      oprot.writeFieldBegin('partitionList', TType.STRUCT, 5)
      self.partitionList.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.rootPath)
    value = (value * 31) ^ hash(self.sharedSDPartitionSpec)
    value = (value * 31) ^ hash(self.partitionList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Index:
  """
  Attributes:
   - indexName
   - indexHandlerClass
   - dbName
   - origTableName
   - createTime
   - lastAccessTime
   - indexTableName
   - sd
   - parameters
   - deferredRebuild
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'indexName', None, None, ), # 1
    (2, TType.STRING, 'indexHandlerClass', None, None, ), # 2
    (3, TType.STRING, 'dbName', None, None, ), # 3
    (4, TType.STRING, 'origTableName', None, None, ), # 4
    (5, TType.I32, 'createTime', None, None, ), # 5
    (6, TType.I32, 'lastAccessTime', None, None, ), # 6
    (7, TType.STRING, 'indexTableName', None, None, ), # 7
    (8, TType.STRUCT, 'sd', (StorageDescriptor, StorageDescriptor.thrift_spec), None, ), # 8
    (9, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 9
    (10, TType.BOOL, 'deferredRebuild', None, None, ), # 10
  )

  def __init__(self, indexName=None, indexHandlerClass=None, dbName=None, origTableName=None, createTime=None, lastAccessTime=None, indexTableName=None, sd=None, parameters=None, deferredRebuild=None,):
    self.indexName = indexName
    self.indexHandlerClass = indexHandlerClass
    self.dbName = dbName
    self.origTableName = origTableName
    self.createTime = createTime
    self.lastAccessTime = lastAccessTime
    self.indexTableName = indexTableName
    self.sd = sd
    self.parameters = parameters
    self.deferredRebuild = deferredRebuild

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.indexName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.indexHandlerClass = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.origTableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.createTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.lastAccessTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.indexTableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.sd = StorageDescriptor()
          self.sd.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype231, _vtype232, _size230 ) = iprot.readMapBegin()
          for _i234 in xrange(_size230):
            _key235 = iprot.readString()
            _val236 = iprot.readString()
            self.parameters[_key235] = _val236
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.deferredRebuild = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Index')
    if self.indexName is not None:
      oprot.writeFieldBegin('indexName', TType.STRING, 1)
      oprot.writeString(self.indexName)
      oprot.writeFieldEnd()
    if self.indexHandlerClass is not None:
      oprot.writeFieldBegin('indexHandlerClass', TType.STRING, 2)
      oprot.writeString(self.indexHandlerClass)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 3)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.origTableName is not None:
      oprot.writeFieldBegin('origTableName', TType.STRING, 4)
      oprot.writeString(self.origTableName)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 5)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime is not None:
      oprot.writeFieldBegin('lastAccessTime', TType.I32, 6)
      oprot.writeI32(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.indexTableName is not None:
      oprot.writeFieldBegin('indexTableName', TType.STRING, 7)
      oprot.writeString(self.indexTableName)
      oprot.writeFieldEnd()
    if self.sd is not None:
      oprot.writeFieldBegin('sd', TType.STRUCT, 8)
      self.sd.write(oprot)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter237,viter238 in self.parameters.items():
        oprot.writeString(kiter237)
        oprot.writeString(viter238)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.deferredRebuild is not None:
      oprot.writeFieldBegin('deferredRebuild', TType.BOOL, 10)
      oprot.writeBool(self.deferredRebuild)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.indexName)
    value = (value * 31) ^ hash(self.indexHandlerClass)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.origTableName)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.lastAccessTime)
    value = (value * 31) ^ hash(self.indexTableName)
    value = (value * 31) ^ hash(self.sd)
    value = (value * 31) ^ hash(self.parameters)
    value = (value * 31) ^ hash(self.deferredRebuild)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BooleanColumnStatsData:
  """
  Attributes:
   - numTrues
   - numFalses
   - numNulls
   - bitVectors
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'numTrues', None, None, ), # 1
    (2, TType.I64, 'numFalses', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.STRING, 'bitVectors', None, None, ), # 4
  )

  def __init__(self, numTrues=None, numFalses=None, numNulls=None, bitVectors=None,):
    self.numTrues = numTrues
    self.numFalses = numFalses
    self.numNulls = numNulls
    self.bitVectors = bitVectors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.numTrues = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.numFalses = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.bitVectors = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BooleanColumnStatsData')
    if self.numTrues is not None:
      oprot.writeFieldBegin('numTrues', TType.I64, 1)
      oprot.writeI64(self.numTrues)
      oprot.writeFieldEnd()
    if self.numFalses is not None:
      oprot.writeFieldBegin('numFalses', TType.I64, 2)
      oprot.writeI64(self.numFalses)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.bitVectors is not None:
      oprot.writeFieldBegin('bitVectors', TType.STRING, 4)
      oprot.writeString(self.bitVectors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.numTrues is None:
      raise TProtocol.TProtocolException(message='Required field numTrues is unset!')
    if self.numFalses is None:
      raise TProtocol.TProtocolException(message='Required field numFalses is unset!')
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.numTrues)
    value = (value * 31) ^ hash(self.numFalses)
    value = (value * 31) ^ hash(self.numNulls)
    value = (value * 31) ^ hash(self.bitVectors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DoubleColumnStatsData:
  """
  Attributes:
   - lowValue
   - highValue
   - numNulls
   - numDVs
   - bitVectors
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'lowValue', None, None, ), # 1
    (2, TType.DOUBLE, 'highValue', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.I64, 'numDVs', None, None, ), # 4
    (5, TType.STRING, 'bitVectors', None, None, ), # 5
  )

  def __init__(self, lowValue=None, highValue=None, numNulls=None, numDVs=None, bitVectors=None,):
    self.lowValue = lowValue
    self.highValue = highValue
    self.numNulls = numNulls
    self.numDVs = numDVs
    self.bitVectors = bitVectors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.lowValue = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.highValue = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.numDVs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.bitVectors = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DoubleColumnStatsData')
    if self.lowValue is not None:
      oprot.writeFieldBegin('lowValue', TType.DOUBLE, 1)
      oprot.writeDouble(self.lowValue)
      oprot.writeFieldEnd()
    if self.highValue is not None:
      oprot.writeFieldBegin('highValue', TType.DOUBLE, 2)
      oprot.writeDouble(self.highValue)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.numDVs is not None:
      oprot.writeFieldBegin('numDVs', TType.I64, 4)
      oprot.writeI64(self.numDVs)
      oprot.writeFieldEnd()
    if self.bitVectors is not None:
      oprot.writeFieldBegin('bitVectors', TType.STRING, 5)
      oprot.writeString(self.bitVectors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    if self.numDVs is None:
      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lowValue)
    value = (value * 31) ^ hash(self.highValue)
    value = (value * 31) ^ hash(self.numNulls)
    value = (value * 31) ^ hash(self.numDVs)
    value = (value * 31) ^ hash(self.bitVectors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LongColumnStatsData:
  """
  Attributes:
   - lowValue
   - highValue
   - numNulls
   - numDVs
   - bitVectors
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lowValue', None, None, ), # 1
    (2, TType.I64, 'highValue', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.I64, 'numDVs', None, None, ), # 4
    (5, TType.STRING, 'bitVectors', None, None, ), # 5
  )

  def __init__(self, lowValue=None, highValue=None, numNulls=None, numDVs=None, bitVectors=None,):
    self.lowValue = lowValue
    self.highValue = highValue
    self.numNulls = numNulls
    self.numDVs = numDVs
    self.bitVectors = bitVectors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lowValue = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.highValue = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.numDVs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.bitVectors = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LongColumnStatsData')
    if self.lowValue is not None:
      oprot.writeFieldBegin('lowValue', TType.I64, 1)
      oprot.writeI64(self.lowValue)
      oprot.writeFieldEnd()
    if self.highValue is not None:
      oprot.writeFieldBegin('highValue', TType.I64, 2)
      oprot.writeI64(self.highValue)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.numDVs is not None:
      oprot.writeFieldBegin('numDVs', TType.I64, 4)
      oprot.writeI64(self.numDVs)
      oprot.writeFieldEnd()
    if self.bitVectors is not None:
      oprot.writeFieldBegin('bitVectors', TType.STRING, 5)
      oprot.writeString(self.bitVectors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    if self.numDVs is None:
      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lowValue)
    value = (value * 31) ^ hash(self.highValue)
    value = (value * 31) ^ hash(self.numNulls)
    value = (value * 31) ^ hash(self.numDVs)
    value = (value * 31) ^ hash(self.bitVectors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StringColumnStatsData:
  """
  Attributes:
   - maxColLen
   - avgColLen
   - numNulls
   - numDVs
   - bitVectors
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'maxColLen', None, None, ), # 1
    (2, TType.DOUBLE, 'avgColLen', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.I64, 'numDVs', None, None, ), # 4
    (5, TType.STRING, 'bitVectors', None, None, ), # 5
  )

  def __init__(self, maxColLen=None, avgColLen=None, numNulls=None, numDVs=None, bitVectors=None,):
    self.maxColLen = maxColLen
    self.avgColLen = avgColLen
    self.numNulls = numNulls
    self.numDVs = numDVs
    self.bitVectors = bitVectors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.maxColLen = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.avgColLen = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.numDVs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.bitVectors = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StringColumnStatsData')
    if self.maxColLen is not None:
      oprot.writeFieldBegin('maxColLen', TType.I64, 1)
      oprot.writeI64(self.maxColLen)
      oprot.writeFieldEnd()
    if self.avgColLen is not None:
      oprot.writeFieldBegin('avgColLen', TType.DOUBLE, 2)
      oprot.writeDouble(self.avgColLen)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.numDVs is not None:
      oprot.writeFieldBegin('numDVs', TType.I64, 4)
      oprot.writeI64(self.numDVs)
      oprot.writeFieldEnd()
    if self.bitVectors is not None:
      oprot.writeFieldBegin('bitVectors', TType.STRING, 5)
      oprot.writeString(self.bitVectors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.maxColLen is None:
      raise TProtocol.TProtocolException(message='Required field maxColLen is unset!')
    if self.avgColLen is None:
      raise TProtocol.TProtocolException(message='Required field avgColLen is unset!')
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    if self.numDVs is None:
      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.maxColLen)
    value = (value * 31) ^ hash(self.avgColLen)
    value = (value * 31) ^ hash(self.numNulls)
    value = (value * 31) ^ hash(self.numDVs)
    value = (value * 31) ^ hash(self.bitVectors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BinaryColumnStatsData:
  """
  Attributes:
   - maxColLen
   - avgColLen
   - numNulls
   - bitVectors
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'maxColLen', None, None, ), # 1
    (2, TType.DOUBLE, 'avgColLen', None, None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.STRING, 'bitVectors', None, None, ), # 4
  )

  def __init__(self, maxColLen=None, avgColLen=None, numNulls=None, bitVectors=None,):
    self.maxColLen = maxColLen
    self.avgColLen = avgColLen
    self.numNulls = numNulls
    self.bitVectors = bitVectors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.maxColLen = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.avgColLen = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.bitVectors = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BinaryColumnStatsData')
    if self.maxColLen is not None:
      oprot.writeFieldBegin('maxColLen', TType.I64, 1)
      oprot.writeI64(self.maxColLen)
      oprot.writeFieldEnd()
    if self.avgColLen is not None:
      oprot.writeFieldBegin('avgColLen', TType.DOUBLE, 2)
      oprot.writeDouble(self.avgColLen)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.bitVectors is not None:
      oprot.writeFieldBegin('bitVectors', TType.STRING, 4)
      oprot.writeString(self.bitVectors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.maxColLen is None:
      raise TProtocol.TProtocolException(message='Required field maxColLen is unset!')
    if self.avgColLen is None:
      raise TProtocol.TProtocolException(message='Required field avgColLen is unset!')
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.maxColLen)
    value = (value * 31) ^ hash(self.avgColLen)
    value = (value * 31) ^ hash(self.numNulls)
    value = (value * 31) ^ hash(self.bitVectors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Decimal:
  """
  Attributes:
   - unscaled
   - scale
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'unscaled', None, None, ), # 1
    None, # 2
    (3, TType.I16, 'scale', None, None, ), # 3
  )

  def __init__(self, unscaled=None, scale=None,):
    self.unscaled = unscaled
    self.scale = scale

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.unscaled = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.scale = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Decimal')
    if self.unscaled is not None:
      oprot.writeFieldBegin('unscaled', TType.STRING, 1)
      oprot.writeString(self.unscaled)
      oprot.writeFieldEnd()
    if self.scale is not None:
      oprot.writeFieldBegin('scale', TType.I16, 3)
      oprot.writeI16(self.scale)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.unscaled is None:
      raise TProtocol.TProtocolException(message='Required field unscaled is unset!')
    if self.scale is None:
      raise TProtocol.TProtocolException(message='Required field scale is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.unscaled)
    value = (value * 31) ^ hash(self.scale)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DecimalColumnStatsData:
  """
  Attributes:
   - lowValue
   - highValue
   - numNulls
   - numDVs
   - bitVectors
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'lowValue', (Decimal, Decimal.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'highValue', (Decimal, Decimal.thrift_spec), None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.I64, 'numDVs', None, None, ), # 4
    (5, TType.STRING, 'bitVectors', None, None, ), # 5
  )

  def __init__(self, lowValue=None, highValue=None, numNulls=None, numDVs=None, bitVectors=None,):
    self.lowValue = lowValue
    self.highValue = highValue
    self.numNulls = numNulls
    self.numDVs = numDVs
    self.bitVectors = bitVectors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.lowValue = Decimal()
          self.lowValue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.highValue = Decimal()
          self.highValue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.numDVs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.bitVectors = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DecimalColumnStatsData')
    if self.lowValue is not None:
      oprot.writeFieldBegin('lowValue', TType.STRUCT, 1)
      self.lowValue.write(oprot)
      oprot.writeFieldEnd()
    if self.highValue is not None:
      oprot.writeFieldBegin('highValue', TType.STRUCT, 2)
      self.highValue.write(oprot)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.numDVs is not None:
      oprot.writeFieldBegin('numDVs', TType.I64, 4)
      oprot.writeI64(self.numDVs)
      oprot.writeFieldEnd()
    if self.bitVectors is not None:
      oprot.writeFieldBegin('bitVectors', TType.STRING, 5)
      oprot.writeString(self.bitVectors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    if self.numDVs is None:
      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lowValue)
    value = (value * 31) ^ hash(self.highValue)
    value = (value * 31) ^ hash(self.numNulls)
    value = (value * 31) ^ hash(self.numDVs)
    value = (value * 31) ^ hash(self.bitVectors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Date:
  """
  Attributes:
   - daysSinceEpoch
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'daysSinceEpoch', None, None, ), # 1
  )

  def __init__(self, daysSinceEpoch=None,):
    self.daysSinceEpoch = daysSinceEpoch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.daysSinceEpoch = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Date')
    if self.daysSinceEpoch is not None:
      oprot.writeFieldBegin('daysSinceEpoch', TType.I64, 1)
      oprot.writeI64(self.daysSinceEpoch)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.daysSinceEpoch is None:
      raise TProtocol.TProtocolException(message='Required field daysSinceEpoch is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.daysSinceEpoch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DateColumnStatsData:
  """
  Attributes:
   - lowValue
   - highValue
   - numNulls
   - numDVs
   - bitVectors
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'lowValue', (Date, Date.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'highValue', (Date, Date.thrift_spec), None, ), # 2
    (3, TType.I64, 'numNulls', None, None, ), # 3
    (4, TType.I64, 'numDVs', None, None, ), # 4
    (5, TType.STRING, 'bitVectors', None, None, ), # 5
  )

  def __init__(self, lowValue=None, highValue=None, numNulls=None, numDVs=None, bitVectors=None,):
    self.lowValue = lowValue
    self.highValue = highValue
    self.numNulls = numNulls
    self.numDVs = numDVs
    self.bitVectors = bitVectors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.lowValue = Date()
          self.lowValue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.highValue = Date()
          self.highValue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.numNulls = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.numDVs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.bitVectors = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DateColumnStatsData')
    if self.lowValue is not None:
      oprot.writeFieldBegin('lowValue', TType.STRUCT, 1)
      self.lowValue.write(oprot)
      oprot.writeFieldEnd()
    if self.highValue is not None:
      oprot.writeFieldBegin('highValue', TType.STRUCT, 2)
      self.highValue.write(oprot)
      oprot.writeFieldEnd()
    if self.numNulls is not None:
      oprot.writeFieldBegin('numNulls', TType.I64, 3)
      oprot.writeI64(self.numNulls)
      oprot.writeFieldEnd()
    if self.numDVs is not None:
      oprot.writeFieldBegin('numDVs', TType.I64, 4)
      oprot.writeI64(self.numDVs)
      oprot.writeFieldEnd()
    if self.bitVectors is not None:
      oprot.writeFieldBegin('bitVectors', TType.STRING, 5)
      oprot.writeString(self.bitVectors)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.numNulls is None:
      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
    if self.numDVs is None:
      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lowValue)
    value = (value * 31) ^ hash(self.highValue)
    value = (value * 31) ^ hash(self.numNulls)
    value = (value * 31) ^ hash(self.numDVs)
    value = (value * 31) ^ hash(self.bitVectors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnStatisticsData:
  """
  Attributes:
   - booleanStats
   - longStats
   - doubleStats
   - stringStats
   - binaryStats
   - decimalStats
   - dateStats
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'booleanStats', (BooleanColumnStatsData, BooleanColumnStatsData.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'longStats', (LongColumnStatsData, LongColumnStatsData.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'doubleStats', (DoubleColumnStatsData, DoubleColumnStatsData.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'stringStats', (StringColumnStatsData, StringColumnStatsData.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'binaryStats', (BinaryColumnStatsData, BinaryColumnStatsData.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'decimalStats', (DecimalColumnStatsData, DecimalColumnStatsData.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'dateStats', (DateColumnStatsData, DateColumnStatsData.thrift_spec), None, ), # 7
  )

  def __init__(self, booleanStats=None, longStats=None, doubleStats=None, stringStats=None, binaryStats=None, decimalStats=None, dateStats=None,):
    self.booleanStats = booleanStats
    self.longStats = longStats
    self.doubleStats = doubleStats
    self.stringStats = stringStats
    self.binaryStats = binaryStats
    self.decimalStats = decimalStats
    self.dateStats = dateStats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.booleanStats = BooleanColumnStatsData()
          self.booleanStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.longStats = LongColumnStatsData()
          self.longStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.doubleStats = DoubleColumnStatsData()
          self.doubleStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.stringStats = StringColumnStatsData()
          self.stringStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.binaryStats = BinaryColumnStatsData()
          self.binaryStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.decimalStats = DecimalColumnStatsData()
          self.decimalStats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.dateStats = DateColumnStatsData()
          self.dateStats.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ColumnStatisticsData')
    if self.booleanStats is not None:
      oprot.writeFieldBegin('booleanStats', TType.STRUCT, 1)
      self.booleanStats.write(oprot)
      oprot.writeFieldEnd()
    if self.longStats is not None:
      oprot.writeFieldBegin('longStats', TType.STRUCT, 2)
      self.longStats.write(oprot)
      oprot.writeFieldEnd()
    if self.doubleStats is not None:
      oprot.writeFieldBegin('doubleStats', TType.STRUCT, 3)
      self.doubleStats.write(oprot)
      oprot.writeFieldEnd()
    if self.stringStats is not None:
      oprot.writeFieldBegin('stringStats', TType.STRUCT, 4)
      self.stringStats.write(oprot)
      oprot.writeFieldEnd()
    if self.binaryStats is not None:
      oprot.writeFieldBegin('binaryStats', TType.STRUCT, 5)
      self.binaryStats.write(oprot)
      oprot.writeFieldEnd()
    if self.decimalStats is not None:
      oprot.writeFieldBegin('decimalStats', TType.STRUCT, 6)
      self.decimalStats.write(oprot)
      oprot.writeFieldEnd()
    if self.dateStats is not None:
      oprot.writeFieldBegin('dateStats', TType.STRUCT, 7)
      self.dateStats.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.booleanStats)
    value = (value * 31) ^ hash(self.longStats)
    value = (value * 31) ^ hash(self.doubleStats)
    value = (value * 31) ^ hash(self.stringStats)
    value = (value * 31) ^ hash(self.binaryStats)
    value = (value * 31) ^ hash(self.decimalStats)
    value = (value * 31) ^ hash(self.dateStats)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnStatisticsObj:
  """
  Attributes:
   - colName
   - colType
   - statsData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'colName', None, None, ), # 1
    (2, TType.STRING, 'colType', None, None, ), # 2
    (3, TType.STRUCT, 'statsData', (ColumnStatisticsData, ColumnStatisticsData.thrift_spec), None, ), # 3
  )

  def __init__(self, colName=None, colType=None, statsData=None,):
    self.colName = colName
    self.colType = colType
    self.statsData = statsData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.colName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.colType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.statsData = ColumnStatisticsData()
          self.statsData.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ColumnStatisticsObj')
    if self.colName is not None:
      oprot.writeFieldBegin('colName', TType.STRING, 1)
      oprot.writeString(self.colName)
      oprot.writeFieldEnd()
    if self.colType is not None:
      oprot.writeFieldBegin('colType', TType.STRING, 2)
      oprot.writeString(self.colType)
      oprot.writeFieldEnd()
    if self.statsData is not None:
      oprot.writeFieldBegin('statsData', TType.STRUCT, 3)
      self.statsData.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.colName is None:
      raise TProtocol.TProtocolException(message='Required field colName is unset!')
    if self.colType is None:
      raise TProtocol.TProtocolException(message='Required field colType is unset!')
    if self.statsData is None:
      raise TProtocol.TProtocolException(message='Required field statsData is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.colName)
    value = (value * 31) ^ hash(self.colType)
    value = (value * 31) ^ hash(self.statsData)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnStatisticsDesc:
  """
  Attributes:
   - isTblLevel
   - dbName
   - tableName
   - partName
   - lastAnalyzed
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'isTblLevel', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'tableName', None, None, ), # 3
    (4, TType.STRING, 'partName', None, None, ), # 4
    (5, TType.I64, 'lastAnalyzed', None, None, ), # 5
  )

  def __init__(self, isTblLevel=None, dbName=None, tableName=None, partName=None, lastAnalyzed=None,):
    self.isTblLevel = isTblLevel
    self.dbName = dbName
    self.tableName = tableName
    self.partName = partName
    self.lastAnalyzed = lastAnalyzed

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.isTblLevel = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.partName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.lastAnalyzed = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ColumnStatisticsDesc')
    if self.isTblLevel is not None:
      oprot.writeFieldBegin('isTblLevel', TType.BOOL, 1)
      oprot.writeBool(self.isTblLevel)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 3)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.partName is not None:
      oprot.writeFieldBegin('partName', TType.STRING, 4)
      oprot.writeString(self.partName)
      oprot.writeFieldEnd()
    if self.lastAnalyzed is not None:
      oprot.writeFieldBegin('lastAnalyzed', TType.I64, 5)
      oprot.writeI64(self.lastAnalyzed)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.isTblLevel is None:
      raise TProtocol.TProtocolException(message='Required field isTblLevel is unset!')
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tableName is None:
      raise TProtocol.TProtocolException(message='Required field tableName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.isTblLevel)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.partName)
    value = (value * 31) ^ hash(self.lastAnalyzed)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnStatistics:
  """
  Attributes:
   - statsDesc
   - statsObj
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'statsDesc', (ColumnStatisticsDesc, ColumnStatisticsDesc.thrift_spec), None, ), # 1
    (2, TType.LIST, 'statsObj', (TType.STRUCT,(ColumnStatisticsObj, ColumnStatisticsObj.thrift_spec)), None, ), # 2
  )

  def __init__(self, statsDesc=None, statsObj=None,):
    self.statsDesc = statsDesc
    self.statsObj = statsObj

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.statsDesc = ColumnStatisticsDesc()
          self.statsDesc.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.statsObj = []
          (_etype242, _size239) = iprot.readListBegin()
          for _i243 in xrange(_size239):
            _elem244 = ColumnStatisticsObj()
            _elem244.read(iprot)
            self.statsObj.append(_elem244)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ColumnStatistics')
    if self.statsDesc is not None:
      oprot.writeFieldBegin('statsDesc', TType.STRUCT, 1)
      self.statsDesc.write(oprot)
      oprot.writeFieldEnd()
    if self.statsObj is not None:
      oprot.writeFieldBegin('statsObj', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.statsObj))
      for iter245 in self.statsObj:
        iter245.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.statsDesc is None:
      raise TProtocol.TProtocolException(message='Required field statsDesc is unset!')
    if self.statsObj is None:
      raise TProtocol.TProtocolException(message='Required field statsObj is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.statsDesc)
    value = (value * 31) ^ hash(self.statsObj)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AggrStats:
  """
  Attributes:
   - colStats
   - partsFound
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'colStats', (TType.STRUCT,(ColumnStatisticsObj, ColumnStatisticsObj.thrift_spec)), None, ), # 1
    (2, TType.I64, 'partsFound', None, None, ), # 2
  )

  def __init__(self, colStats=None, partsFound=None,):
    self.colStats = colStats
    self.partsFound = partsFound

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.colStats = []
          (_etype249, _size246) = iprot.readListBegin()
          for _i250 in xrange(_size246):
            _elem251 = ColumnStatisticsObj()
            _elem251.read(iprot)
            self.colStats.append(_elem251)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.partsFound = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AggrStats')
    if self.colStats is not None:
      oprot.writeFieldBegin('colStats', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.colStats))
      for iter252 in self.colStats:
        iter252.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.partsFound is not None:
      oprot.writeFieldBegin('partsFound', TType.I64, 2)
      oprot.writeI64(self.partsFound)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.colStats is None:
      raise TProtocol.TProtocolException(message='Required field colStats is unset!')
    if self.partsFound is None:
      raise TProtocol.TProtocolException(message='Required field partsFound is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.colStats)
    value = (value * 31) ^ hash(self.partsFound)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetPartitionsStatsRequest:
  """
  Attributes:
   - colStats
   - needMerge
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'colStats', (TType.STRUCT,(ColumnStatistics, ColumnStatistics.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'needMerge', None, None, ), # 2
  )

  def __init__(self, colStats=None, needMerge=None,):
    self.colStats = colStats
    self.needMerge = needMerge

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.colStats = []
          (_etype256, _size253) = iprot.readListBegin()
          for _i257 in xrange(_size253):
            _elem258 = ColumnStatistics()
            _elem258.read(iprot)
            self.colStats.append(_elem258)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.needMerge = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetPartitionsStatsRequest')
    if self.colStats is not None:
      oprot.writeFieldBegin('colStats', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.colStats))
      for iter259 in self.colStats:
        iter259.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.needMerge is not None:
      oprot.writeFieldBegin('needMerge', TType.BOOL, 2)
      oprot.writeBool(self.needMerge)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.colStats is None:
      raise TProtocol.TProtocolException(message='Required field colStats is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.colStats)
    value = (value * 31) ^ hash(self.needMerge)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Schema:
  """
  Attributes:
   - fieldSchemas
   - properties
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fieldSchemas', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 1
    (2, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 2
  )

  def __init__(self, fieldSchemas=None, properties=None,):
    self.fieldSchemas = fieldSchemas
    self.properties = properties

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fieldSchemas = []
          (_etype263, _size260) = iprot.readListBegin()
          for _i264 in xrange(_size260):
            _elem265 = FieldSchema()
            _elem265.read(iprot)
            self.fieldSchemas.append(_elem265)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.properties = {}
          (_ktype267, _vtype268, _size266 ) = iprot.readMapBegin()
          for _i270 in xrange(_size266):
            _key271 = iprot.readString()
            _val272 = iprot.readString()
            self.properties[_key271] = _val272
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Schema')
    if self.fieldSchemas is not None:
      oprot.writeFieldBegin('fieldSchemas', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.fieldSchemas))
      for iter273 in self.fieldSchemas:
        iter273.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.properties is not None:
      oprot.writeFieldBegin('properties', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
      for kiter274,viter275 in self.properties.items():
        oprot.writeString(kiter274)
        oprot.writeString(viter275)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fieldSchemas)
    value = (value * 31) ^ hash(self.properties)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EnvironmentContext:
  """
  Attributes:
   - properties
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 1
  )

  def __init__(self, properties=None,):
    self.properties = properties

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.properties = {}
          (_ktype277, _vtype278, _size276 ) = iprot.readMapBegin()
          for _i280 in xrange(_size276):
            _key281 = iprot.readString()
            _val282 = iprot.readString()
            self.properties[_key281] = _val282
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EnvironmentContext')
    if self.properties is not None:
      oprot.writeFieldBegin('properties', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
      for kiter283,viter284 in self.properties.items():
        oprot.writeString(kiter283)
        oprot.writeString(viter284)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.properties)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrimaryKeysRequest:
  """
  Attributes:
   - db_name
   - tbl_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
  )

  def __init__(self, db_name=None, tbl_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrimaryKeysRequest')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db_name is None:
      raise TProtocol.TProtocolException(message='Required field db_name is unset!')
    if self.tbl_name is None:
      raise TProtocol.TProtocolException(message='Required field tbl_name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PrimaryKeysResponse:
  """
  Attributes:
   - primaryKeys
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'primaryKeys', (TType.STRUCT,(SQLPrimaryKey, SQLPrimaryKey.thrift_spec)), None, ), # 1
  )

  def __init__(self, primaryKeys=None,):
    self.primaryKeys = primaryKeys

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.primaryKeys = []
          (_etype288, _size285) = iprot.readListBegin()
          for _i289 in xrange(_size285):
            _elem290 = SQLPrimaryKey()
            _elem290.read(iprot)
            self.primaryKeys.append(_elem290)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PrimaryKeysResponse')
    if self.primaryKeys is not None:
      oprot.writeFieldBegin('primaryKeys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.primaryKeys))
      for iter291 in self.primaryKeys:
        iter291.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.primaryKeys is None:
      raise TProtocol.TProtocolException(message='Required field primaryKeys is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.primaryKeys)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ForeignKeysRequest:
  """
  Attributes:
   - parent_db_name
   - parent_tbl_name
   - foreign_db_name
   - foreign_tbl_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'parent_db_name', None, None, ), # 1
    (2, TType.STRING, 'parent_tbl_name', None, None, ), # 2
    (3, TType.STRING, 'foreign_db_name', None, None, ), # 3
    (4, TType.STRING, 'foreign_tbl_name', None, None, ), # 4
  )

  def __init__(self, parent_db_name=None, parent_tbl_name=None, foreign_db_name=None, foreign_tbl_name=None,):
    self.parent_db_name = parent_db_name
    self.parent_tbl_name = parent_tbl_name
    self.foreign_db_name = foreign_db_name
    self.foreign_tbl_name = foreign_tbl_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.parent_db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.parent_tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.foreign_db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.foreign_tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ForeignKeysRequest')
    if self.parent_db_name is not None:
      oprot.writeFieldBegin('parent_db_name', TType.STRING, 1)
      oprot.writeString(self.parent_db_name)
      oprot.writeFieldEnd()
    if self.parent_tbl_name is not None:
      oprot.writeFieldBegin('parent_tbl_name', TType.STRING, 2)
      oprot.writeString(self.parent_tbl_name)
      oprot.writeFieldEnd()
    if self.foreign_db_name is not None:
      oprot.writeFieldBegin('foreign_db_name', TType.STRING, 3)
      oprot.writeString(self.foreign_db_name)
      oprot.writeFieldEnd()
    if self.foreign_tbl_name is not None:
      oprot.writeFieldBegin('foreign_tbl_name', TType.STRING, 4)
      oprot.writeString(self.foreign_tbl_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.parent_db_name)
    value = (value * 31) ^ hash(self.parent_tbl_name)
    value = (value * 31) ^ hash(self.foreign_db_name)
    value = (value * 31) ^ hash(self.foreign_tbl_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ForeignKeysResponse:
  """
  Attributes:
   - foreignKeys
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'foreignKeys', (TType.STRUCT,(SQLForeignKey, SQLForeignKey.thrift_spec)), None, ), # 1
  )

  def __init__(self, foreignKeys=None,):
    self.foreignKeys = foreignKeys

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.foreignKeys = []
          (_etype295, _size292) = iprot.readListBegin()
          for _i296 in xrange(_size292):
            _elem297 = SQLForeignKey()
            _elem297.read(iprot)
            self.foreignKeys.append(_elem297)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ForeignKeysResponse')
    if self.foreignKeys is not None:
      oprot.writeFieldBegin('foreignKeys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.foreignKeys))
      for iter298 in self.foreignKeys:
        iter298.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.foreignKeys is None:
      raise TProtocol.TProtocolException(message='Required field foreignKeys is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.foreignKeys)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UniqueConstraintsRequest:
  """
  Attributes:
   - db_name
   - tbl_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
  )

  def __init__(self, db_name=None, tbl_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UniqueConstraintsRequest')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db_name is None:
      raise TProtocol.TProtocolException(message='Required field db_name is unset!')
    if self.tbl_name is None:
      raise TProtocol.TProtocolException(message='Required field tbl_name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UniqueConstraintsResponse:
  """
  Attributes:
   - uniqueConstraints
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'uniqueConstraints', (TType.STRUCT,(SQLUniqueConstraint, SQLUniqueConstraint.thrift_spec)), None, ), # 1
  )

  def __init__(self, uniqueConstraints=None,):
    self.uniqueConstraints = uniqueConstraints

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.uniqueConstraints = []
          (_etype302, _size299) = iprot.readListBegin()
          for _i303 in xrange(_size299):
            _elem304 = SQLUniqueConstraint()
            _elem304.read(iprot)
            self.uniqueConstraints.append(_elem304)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UniqueConstraintsResponse')
    if self.uniqueConstraints is not None:
      oprot.writeFieldBegin('uniqueConstraints', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.uniqueConstraints))
      for iter305 in self.uniqueConstraints:
        iter305.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uniqueConstraints is None:
      raise TProtocol.TProtocolException(message='Required field uniqueConstraints is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.uniqueConstraints)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotNullConstraintsRequest:
  """
  Attributes:
   - db_name
   - tbl_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
  )

  def __init__(self, db_name=None, tbl_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotNullConstraintsRequest')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db_name is None:
      raise TProtocol.TProtocolException(message='Required field db_name is unset!')
    if self.tbl_name is None:
      raise TProtocol.TProtocolException(message='Required field tbl_name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.db_name)
    value = (value * 31) ^ hash(self.tbl_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotNullConstraintsResponse:
  """
  Attributes:
   - notNullConstraints
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'notNullConstraints', (TType.STRUCT,(SQLNotNullConstraint, SQLNotNullConstraint.thrift_spec)), None, ), # 1
  )

  def __init__(self, notNullConstraints=None,):
    self.notNullConstraints = notNullConstraints

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.notNullConstraints = []
          (_etype309, _size306) = iprot.readListBegin()
          for _i310 in xrange(_size306):
            _elem311 = SQLNotNullConstraint()
            _elem311.read(iprot)
            self.notNullConstraints.append(_elem311)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotNullConstraintsResponse')
    if self.notNullConstraints is not None:
      oprot.writeFieldBegin('notNullConstraints', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.notNullConstraints))
      for iter312 in self.notNullConstraints:
        iter312.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.notNullConstraints is None:
      raise TProtocol.TProtocolException(message='Required field notNullConstraints is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.notNullConstraints)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DropConstraintRequest:
  """
  Attributes:
   - dbname
   - tablename
   - constraintname
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tablename', None, None, ), # 2
    (3, TType.STRING, 'constraintname', None, None, ), # 3
  )

  def __init__(self, dbname=None, tablename=None, constraintname=None,):
    self.dbname = dbname
    self.tablename = tablename
    self.constraintname = constraintname

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.constraintname = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DropConstraintRequest')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 2)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.constraintname is not None:
      oprot.writeFieldBegin('constraintname', TType.STRING, 3)
      oprot.writeString(self.constraintname)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbname is None:
      raise TProtocol.TProtocolException(message='Required field dbname is unset!')
    if self.tablename is None:
      raise TProtocol.TProtocolException(message='Required field tablename is unset!')
    if self.constraintname is None:
      raise TProtocol.TProtocolException(message='Required field constraintname is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.constraintname)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddPrimaryKeyRequest:
  """
  Attributes:
   - primaryKeyCols
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'primaryKeyCols', (TType.STRUCT,(SQLPrimaryKey, SQLPrimaryKey.thrift_spec)), None, ), # 1
  )

  def __init__(self, primaryKeyCols=None,):
    self.primaryKeyCols = primaryKeyCols

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.primaryKeyCols = []
          (_etype316, _size313) = iprot.readListBegin()
          for _i317 in xrange(_size313):
            _elem318 = SQLPrimaryKey()
            _elem318.read(iprot)
            self.primaryKeyCols.append(_elem318)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddPrimaryKeyRequest')
    if self.primaryKeyCols is not None:
      oprot.writeFieldBegin('primaryKeyCols', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.primaryKeyCols))
      for iter319 in self.primaryKeyCols:
        iter319.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.primaryKeyCols is None:
      raise TProtocol.TProtocolException(message='Required field primaryKeyCols is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.primaryKeyCols)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddForeignKeyRequest:
  """
  Attributes:
   - foreignKeyCols
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'foreignKeyCols', (TType.STRUCT,(SQLForeignKey, SQLForeignKey.thrift_spec)), None, ), # 1
  )

  def __init__(self, foreignKeyCols=None,):
    self.foreignKeyCols = foreignKeyCols

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.foreignKeyCols = []
          (_etype323, _size320) = iprot.readListBegin()
          for _i324 in xrange(_size320):
            _elem325 = SQLForeignKey()
            _elem325.read(iprot)
            self.foreignKeyCols.append(_elem325)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddForeignKeyRequest')
    if self.foreignKeyCols is not None:
      oprot.writeFieldBegin('foreignKeyCols', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.foreignKeyCols))
      for iter326 in self.foreignKeyCols:
        iter326.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.foreignKeyCols is None:
      raise TProtocol.TProtocolException(message='Required field foreignKeyCols is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.foreignKeyCols)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddUniqueConstraintRequest:
  """
  Attributes:
   - uniqueConstraintCols
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'uniqueConstraintCols', (TType.STRUCT,(SQLUniqueConstraint, SQLUniqueConstraint.thrift_spec)), None, ), # 1
  )

  def __init__(self, uniqueConstraintCols=None,):
    self.uniqueConstraintCols = uniqueConstraintCols

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.uniqueConstraintCols = []
          (_etype330, _size327) = iprot.readListBegin()
          for _i331 in xrange(_size327):
            _elem332 = SQLUniqueConstraint()
            _elem332.read(iprot)
            self.uniqueConstraintCols.append(_elem332)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddUniqueConstraintRequest')
    if self.uniqueConstraintCols is not None:
      oprot.writeFieldBegin('uniqueConstraintCols', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.uniqueConstraintCols))
      for iter333 in self.uniqueConstraintCols:
        iter333.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uniqueConstraintCols is None:
      raise TProtocol.TProtocolException(message='Required field uniqueConstraintCols is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.uniqueConstraintCols)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddNotNullConstraintRequest:
  """
  Attributes:
   - notNullConstraintCols
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'notNullConstraintCols', (TType.STRUCT,(SQLNotNullConstraint, SQLNotNullConstraint.thrift_spec)), None, ), # 1
  )

  def __init__(self, notNullConstraintCols=None,):
    self.notNullConstraintCols = notNullConstraintCols

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.notNullConstraintCols = []
          (_etype337, _size334) = iprot.readListBegin()
          for _i338 in xrange(_size334):
            _elem339 = SQLNotNullConstraint()
            _elem339.read(iprot)
            self.notNullConstraintCols.append(_elem339)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddNotNullConstraintRequest')
    if self.notNullConstraintCols is not None:
      oprot.writeFieldBegin('notNullConstraintCols', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.notNullConstraintCols))
      for iter340 in self.notNullConstraintCols:
        iter340.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.notNullConstraintCols is None:
      raise TProtocol.TProtocolException(message='Required field notNullConstraintCols is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.notNullConstraintCols)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionsByExprResult:
  """
  Attributes:
   - partitions
   - hasUnknownPartitions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partitions', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'hasUnknownPartitions', None, None, ), # 2
  )

  def __init__(self, partitions=None, hasUnknownPartitions=None,):
    self.partitions = partitions
    self.hasUnknownPartitions = hasUnknownPartitions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partitions = []
          (_etype344, _size341) = iprot.readListBegin()
          for _i345 in xrange(_size341):
            _elem346 = Partition()
            _elem346.read(iprot)
            self.partitions.append(_elem346)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.hasUnknownPartitions = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionsByExprResult')
    if self.partitions is not None:
      oprot.writeFieldBegin('partitions', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partitions))
      for iter347 in self.partitions:
        iter347.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.hasUnknownPartitions is not None:
      oprot.writeFieldBegin('hasUnknownPartitions', TType.BOOL, 2)
      oprot.writeBool(self.hasUnknownPartitions)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.partitions is None:
      raise TProtocol.TProtocolException(message='Required field partitions is unset!')
    if self.hasUnknownPartitions is None:
      raise TProtocol.TProtocolException(message='Required field hasUnknownPartitions is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitions)
    value = (value * 31) ^ hash(self.hasUnknownPartitions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionsByExprRequest:
  """
  Attributes:
   - dbName
   - tblName
   - expr
   - defaultPartitionName
   - maxParts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.STRING, 'expr', None, None, ), # 3
    (4, TType.STRING, 'defaultPartitionName', None, None, ), # 4
    (5, TType.I16, 'maxParts', None, -1, ), # 5
  )

  def __init__(self, dbName=None, tblName=None, expr=None, defaultPartitionName=None, maxParts=thrift_spec[5][4],):
    self.dbName = dbName
    self.tblName = tblName
    self.expr = expr
    self.defaultPartitionName = defaultPartitionName
    self.maxParts = maxParts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.expr = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.defaultPartitionName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.maxParts = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionsByExprRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.expr is not None:
      oprot.writeFieldBegin('expr', TType.STRING, 3)
      oprot.writeString(self.expr)
      oprot.writeFieldEnd()
    if self.defaultPartitionName is not None:
      oprot.writeFieldBegin('defaultPartitionName', TType.STRING, 4)
      oprot.writeString(self.defaultPartitionName)
      oprot.writeFieldEnd()
    if self.maxParts is not None:
      oprot.writeFieldBegin('maxParts', TType.I16, 5)
      oprot.writeI16(self.maxParts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    if self.expr is None:
      raise TProtocol.TProtocolException(message='Required field expr is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.expr)
    value = (value * 31) ^ hash(self.defaultPartitionName)
    value = (value * 31) ^ hash(self.maxParts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableStatsResult:
  """
  Attributes:
   - tableStats
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tableStats', (TType.STRUCT,(ColumnStatisticsObj, ColumnStatisticsObj.thrift_spec)), None, ), # 1
  )

  def __init__(self, tableStats=None,):
    self.tableStats = tableStats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tableStats = []
          (_etype351, _size348) = iprot.readListBegin()
          for _i352 in xrange(_size348):
            _elem353 = ColumnStatisticsObj()
            _elem353.read(iprot)
            self.tableStats.append(_elem353)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableStatsResult')
    if self.tableStats is not None:
      oprot.writeFieldBegin('tableStats', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.tableStats))
      for iter354 in self.tableStats:
        iter354.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tableStats is None:
      raise TProtocol.TProtocolException(message='Required field tableStats is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableStats)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionsStatsResult:
  """
  Attributes:
   - partStats
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'partStats', (TType.STRING,None,TType.LIST,(TType.STRUCT,(ColumnStatisticsObj, ColumnStatisticsObj.thrift_spec))), None, ), # 1
  )

  def __init__(self, partStats=None,):
    self.partStats = partStats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.partStats = {}
          (_ktype356, _vtype357, _size355 ) = iprot.readMapBegin()
          for _i359 in xrange(_size355):
            _key360 = iprot.readString()
            _val361 = []
            (_etype365, _size362) = iprot.readListBegin()
            for _i366 in xrange(_size362):
              _elem367 = ColumnStatisticsObj()
              _elem367.read(iprot)
              _val361.append(_elem367)
            iprot.readListEnd()
            self.partStats[_key360] = _val361
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionsStatsResult')
    if self.partStats is not None:
      oprot.writeFieldBegin('partStats', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.partStats))
      for kiter368,viter369 in self.partStats.items():
        oprot.writeString(kiter368)
        oprot.writeListBegin(TType.STRUCT, len(viter369))
        for iter370 in viter369:
          iter370.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.partStats is None:
      raise TProtocol.TProtocolException(message='Required field partStats is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partStats)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableStatsRequest:
  """
  Attributes:
   - dbName
   - tblName
   - colNames
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.LIST, 'colNames', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, dbName=None, tblName=None, colNames=None,):
    self.dbName = dbName
    self.tblName = tblName
    self.colNames = colNames

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.colNames = []
          (_etype374, _size371) = iprot.readListBegin()
          for _i375 in xrange(_size371):
            _elem376 = iprot.readString()
            self.colNames.append(_elem376)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableStatsRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.colNames is not None:
      oprot.writeFieldBegin('colNames', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.colNames))
      for iter377 in self.colNames:
        oprot.writeString(iter377)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    if self.colNames is None:
      raise TProtocol.TProtocolException(message='Required field colNames is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.colNames)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionsStatsRequest:
  """
  Attributes:
   - dbName
   - tblName
   - colNames
   - partNames
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.LIST, 'colNames', (TType.STRING,None), None, ), # 3
    (4, TType.LIST, 'partNames', (TType.STRING,None), None, ), # 4
  )

  def __init__(self, dbName=None, tblName=None, colNames=None, partNames=None,):
    self.dbName = dbName
    self.tblName = tblName
    self.colNames = colNames
    self.partNames = partNames

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.colNames = []
          (_etype381, _size378) = iprot.readListBegin()
          for _i382 in xrange(_size378):
            _elem383 = iprot.readString()
            self.colNames.append(_elem383)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.partNames = []
          (_etype387, _size384) = iprot.readListBegin()
          for _i388 in xrange(_size384):
            _elem389 = iprot.readString()
            self.partNames.append(_elem389)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionsStatsRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.colNames is not None:
      oprot.writeFieldBegin('colNames', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.colNames))
      for iter390 in self.colNames:
        oprot.writeString(iter390)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.partNames is not None:
      oprot.writeFieldBegin('partNames', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.partNames))
      for iter391 in self.partNames:
        oprot.writeString(iter391)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    if self.colNames is None:
      raise TProtocol.TProtocolException(message='Required field colNames is unset!')
    if self.partNames is None:
      raise TProtocol.TProtocolException(message='Required field partNames is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.colNames)
    value = (value * 31) ^ hash(self.partNames)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddPartitionsResult:
  """
  Attributes:
   - partitions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partitions', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 1
  )

  def __init__(self, partitions=None,):
    self.partitions = partitions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partitions = []
          (_etype395, _size392) = iprot.readListBegin()
          for _i396 in xrange(_size392):
            _elem397 = Partition()
            _elem397.read(iprot)
            self.partitions.append(_elem397)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddPartitionsResult')
    if self.partitions is not None:
      oprot.writeFieldBegin('partitions', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partitions))
      for iter398 in self.partitions:
        iter398.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddPartitionsRequest:
  """
  Attributes:
   - dbName
   - tblName
   - parts
   - ifNotExists
   - needResult
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.LIST, 'parts', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 3
    (4, TType.BOOL, 'ifNotExists', None, None, ), # 4
    (5, TType.BOOL, 'needResult', None, True, ), # 5
  )

  def __init__(self, dbName=None, tblName=None, parts=None, ifNotExists=None, needResult=thrift_spec[5][4],):
    self.dbName = dbName
    self.tblName = tblName
    self.parts = parts
    self.ifNotExists = ifNotExists
    self.needResult = needResult

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.parts = []
          (_etype402, _size399) = iprot.readListBegin()
          for _i403 in xrange(_size399):
            _elem404 = Partition()
            _elem404.read(iprot)
            self.parts.append(_elem404)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.ifNotExists = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.needResult = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddPartitionsRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.parts is not None:
      oprot.writeFieldBegin('parts', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.parts))
      for iter405 in self.parts:
        iter405.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ifNotExists is not None:
      oprot.writeFieldBegin('ifNotExists', TType.BOOL, 4)
      oprot.writeBool(self.ifNotExists)
      oprot.writeFieldEnd()
    if self.needResult is not None:
      oprot.writeFieldBegin('needResult', TType.BOOL, 5)
      oprot.writeBool(self.needResult)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    if self.parts is None:
      raise TProtocol.TProtocolException(message='Required field parts is unset!')
    if self.ifNotExists is None:
      raise TProtocol.TProtocolException(message='Required field ifNotExists is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.parts)
    value = (value * 31) ^ hash(self.ifNotExists)
    value = (value * 31) ^ hash(self.needResult)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DropPartitionsResult:
  """
  Attributes:
   - partitions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partitions', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 1
  )

  def __init__(self, partitions=None,):
    self.partitions = partitions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partitions = []
          (_etype409, _size406) = iprot.readListBegin()
          for _i410 in xrange(_size406):
            _elem411 = Partition()
            _elem411.read(iprot)
            self.partitions.append(_elem411)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DropPartitionsResult')
    if self.partitions is not None:
      oprot.writeFieldBegin('partitions', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partitions))
      for iter412 in self.partitions:
        iter412.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DropPartitionsExpr:
  """
  Attributes:
   - expr
   - partArchiveLevel
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'expr', None, None, ), # 1
    (2, TType.I32, 'partArchiveLevel', None, None, ), # 2
  )

  def __init__(self, expr=None, partArchiveLevel=None,):
    self.expr = expr
    self.partArchiveLevel = partArchiveLevel

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.expr = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.partArchiveLevel = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DropPartitionsExpr')
    if self.expr is not None:
      oprot.writeFieldBegin('expr', TType.STRING, 1)
      oprot.writeString(self.expr)
      oprot.writeFieldEnd()
    if self.partArchiveLevel is not None:
      oprot.writeFieldBegin('partArchiveLevel', TType.I32, 2)
      oprot.writeI32(self.partArchiveLevel)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.expr is None:
      raise TProtocol.TProtocolException(message='Required field expr is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.expr)
    value = (value * 31) ^ hash(self.partArchiveLevel)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestPartsSpec:
  """
  Attributes:
   - names
   - exprs
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'names', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'exprs', (TType.STRUCT,(DropPartitionsExpr, DropPartitionsExpr.thrift_spec)), None, ), # 2
  )

  def __init__(self, names=None, exprs=None,):
    self.names = names
    self.exprs = exprs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.names = []
          (_etype416, _size413) = iprot.readListBegin()
          for _i417 in xrange(_size413):
            _elem418 = iprot.readString()
            self.names.append(_elem418)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.exprs = []
          (_etype422, _size419) = iprot.readListBegin()
          for _i423 in xrange(_size419):
            _elem424 = DropPartitionsExpr()
            _elem424.read(iprot)
            self.exprs.append(_elem424)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestPartsSpec')
    if self.names is not None:
      oprot.writeFieldBegin('names', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.names))
      for iter425 in self.names:
        oprot.writeString(iter425)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.exprs is not None:
      oprot.writeFieldBegin('exprs', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.exprs))
      for iter426 in self.exprs:
        iter426.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.names)
    value = (value * 31) ^ hash(self.exprs)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DropPartitionsRequest:
  """
  Attributes:
   - dbName
   - tblName
   - parts
   - deleteData
   - ifExists
   - ignoreProtection
   - environmentContext
   - needResult
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.STRUCT, 'parts', (RequestPartsSpec, RequestPartsSpec.thrift_spec), None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
    (5, TType.BOOL, 'ifExists', None, True, ), # 5
    (6, TType.BOOL, 'ignoreProtection', None, None, ), # 6
    (7, TType.STRUCT, 'environmentContext', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 7
    (8, TType.BOOL, 'needResult', None, True, ), # 8
  )

  def __init__(self, dbName=None, tblName=None, parts=None, deleteData=None, ifExists=thrift_spec[5][4], ignoreProtection=None, environmentContext=None, needResult=thrift_spec[8][4],):
    self.dbName = dbName
    self.tblName = tblName
    self.parts = parts
    self.deleteData = deleteData
    self.ifExists = ifExists
    self.ignoreProtection = ignoreProtection
    self.environmentContext = environmentContext
    self.needResult = needResult

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.parts = RequestPartsSpec()
          self.parts.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.ifExists = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.ignoreProtection = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.environmentContext = EnvironmentContext()
          self.environmentContext.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.needResult = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DropPartitionsRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.parts is not None:
      oprot.writeFieldBegin('parts', TType.STRUCT, 3)
      self.parts.write(oprot)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    if self.ifExists is not None:
      oprot.writeFieldBegin('ifExists', TType.BOOL, 5)
      oprot.writeBool(self.ifExists)
      oprot.writeFieldEnd()
    if self.ignoreProtection is not None:
      oprot.writeFieldBegin('ignoreProtection', TType.BOOL, 6)
      oprot.writeBool(self.ignoreProtection)
      oprot.writeFieldEnd()
    if self.environmentContext is not None:
      oprot.writeFieldBegin('environmentContext', TType.STRUCT, 7)
      self.environmentContext.write(oprot)
      oprot.writeFieldEnd()
    if self.needResult is not None:
      oprot.writeFieldBegin('needResult', TType.BOOL, 8)
      oprot.writeBool(self.needResult)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    if self.parts is None:
      raise TProtocol.TProtocolException(message='Required field parts is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.parts)
    value = (value * 31) ^ hash(self.deleteData)
    value = (value * 31) ^ hash(self.ifExists)
    value = (value * 31) ^ hash(self.ignoreProtection)
    value = (value * 31) ^ hash(self.environmentContext)
    value = (value * 31) ^ hash(self.needResult)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionValuesRequest:
  """
  Attributes:
   - dbName
   - tblName
   - partitionKeys
   - applyDistinct
   - filter
   - partitionOrder
   - ascending
   - maxParts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.LIST, 'partitionKeys', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 3
    (4, TType.BOOL, 'applyDistinct', None, True, ), # 4
    (5, TType.STRING, 'filter', None, None, ), # 5
    (6, TType.LIST, 'partitionOrder', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 6
    (7, TType.BOOL, 'ascending', None, True, ), # 7
    (8, TType.I64, 'maxParts', None, -1, ), # 8
  )

  def __init__(self, dbName=None, tblName=None, partitionKeys=None, applyDistinct=thrift_spec[4][4], filter=None, partitionOrder=None, ascending=thrift_spec[7][4], maxParts=thrift_spec[8][4],):
    self.dbName = dbName
    self.tblName = tblName
    self.partitionKeys = partitionKeys
    self.applyDistinct = applyDistinct
    self.filter = filter
    self.partitionOrder = partitionOrder
    self.ascending = ascending
    self.maxParts = maxParts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.partitionKeys = []
          (_etype430, _size427) = iprot.readListBegin()
          for _i431 in xrange(_size427):
            _elem432 = FieldSchema()
            _elem432.read(iprot)
            self.partitionKeys.append(_elem432)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.applyDistinct = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.partitionOrder = []
          (_etype436, _size433) = iprot.readListBegin()
          for _i437 in xrange(_size433):
            _elem438 = FieldSchema()
            _elem438.read(iprot)
            self.partitionOrder.append(_elem438)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.ascending = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.maxParts = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionValuesRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.partitionKeys is not None:
      oprot.writeFieldBegin('partitionKeys', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.partitionKeys))
      for iter439 in self.partitionKeys:
        iter439.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.applyDistinct is not None:
      oprot.writeFieldBegin('applyDistinct', TType.BOOL, 4)
      oprot.writeBool(self.applyDistinct)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRING, 5)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.partitionOrder is not None:
      oprot.writeFieldBegin('partitionOrder', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.partitionOrder))
      for iter440 in self.partitionOrder:
        iter440.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ascending is not None:
      oprot.writeFieldBegin('ascending', TType.BOOL, 7)
      oprot.writeBool(self.ascending)
      oprot.writeFieldEnd()
    if self.maxParts is not None:
      oprot.writeFieldBegin('maxParts', TType.I64, 8)
      oprot.writeI64(self.maxParts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    if self.partitionKeys is None:
      raise TProtocol.TProtocolException(message='Required field partitionKeys is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.partitionKeys)
    value = (value * 31) ^ hash(self.applyDistinct)
    value = (value * 31) ^ hash(self.filter)
    value = (value * 31) ^ hash(self.partitionOrder)
    value = (value * 31) ^ hash(self.ascending)
    value = (value * 31) ^ hash(self.maxParts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionValuesRow:
  """
  Attributes:
   - row
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'row', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, row=None,):
    self.row = row

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.row = []
          (_etype444, _size441) = iprot.readListBegin()
          for _i445 in xrange(_size441):
            _elem446 = iprot.readString()
            self.row.append(_elem446)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionValuesRow')
    if self.row is not None:
      oprot.writeFieldBegin('row', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.row))
      for iter447 in self.row:
        oprot.writeString(iter447)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.row is None:
      raise TProtocol.TProtocolException(message='Required field row is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.row)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionValuesResponse:
  """
  Attributes:
   - partitionValues
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partitionValues', (TType.STRUCT,(PartitionValuesRow, PartitionValuesRow.thrift_spec)), None, ), # 1
  )

  def __init__(self, partitionValues=None,):
    self.partitionValues = partitionValues

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partitionValues = []
          (_etype451, _size448) = iprot.readListBegin()
          for _i452 in xrange(_size448):
            _elem453 = PartitionValuesRow()
            _elem453.read(iprot)
            self.partitionValues.append(_elem453)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionValuesResponse')
    if self.partitionValues is not None:
      oprot.writeFieldBegin('partitionValues', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partitionValues))
      for iter454 in self.partitionValues:
        iter454.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.partitionValues is None:
      raise TProtocol.TProtocolException(message='Required field partitionValues is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitionValues)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResourceUri:
  """
  Attributes:
   - resourceType
   - uri
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'resourceType', None, None, ), # 1
    (2, TType.STRING, 'uri', None, None, ), # 2
  )

  def __init__(self, resourceType=None, uri=None,):
    self.resourceType = resourceType
    self.uri = uri

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.resourceType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.uri = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResourceUri')
    if self.resourceType is not None:
      oprot.writeFieldBegin('resourceType', TType.I32, 1)
      oprot.writeI32(self.resourceType)
      oprot.writeFieldEnd()
    if self.uri is not None:
      oprot.writeFieldBegin('uri', TType.STRING, 2)
      oprot.writeString(self.uri)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourceType)
    value = (value * 31) ^ hash(self.uri)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Function:
  """
  Attributes:
   - functionName
   - dbName
   - className
   - ownerName
   - ownerType
   - createTime
   - functionType
   - resourceUris
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'functionName', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'className', None, None, ), # 3
    (4, TType.STRING, 'ownerName', None, None, ), # 4
    (5, TType.I32, 'ownerType', None, None, ), # 5
    (6, TType.I32, 'createTime', None, None, ), # 6
    (7, TType.I32, 'functionType', None, None, ), # 7
    (8, TType.LIST, 'resourceUris', (TType.STRUCT,(ResourceUri, ResourceUri.thrift_spec)), None, ), # 8
  )

  def __init__(self, functionName=None, dbName=None, className=None, ownerName=None, ownerType=None, createTime=None, functionType=None, resourceUris=None,):
    self.functionName = functionName
    self.dbName = dbName
    self.className = className
    self.ownerName = ownerName
    self.ownerType = ownerType
    self.createTime = createTime
    self.functionType = functionType
    self.resourceUris = resourceUris

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.functionName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.className = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.ownerName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.ownerType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.createTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.functionType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.resourceUris = []
          (_etype458, _size455) = iprot.readListBegin()
          for _i459 in xrange(_size455):
            _elem460 = ResourceUri()
            _elem460.read(iprot)
            self.resourceUris.append(_elem460)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Function')
    if self.functionName is not None:
      oprot.writeFieldBegin('functionName', TType.STRING, 1)
      oprot.writeString(self.functionName)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.className is not None:
      oprot.writeFieldBegin('className', TType.STRING, 3)
      oprot.writeString(self.className)
      oprot.writeFieldEnd()
    if self.ownerName is not None:
      oprot.writeFieldBegin('ownerName', TType.STRING, 4)
      oprot.writeString(self.ownerName)
      oprot.writeFieldEnd()
    if self.ownerType is not None:
      oprot.writeFieldBegin('ownerType', TType.I32, 5)
      oprot.writeI32(self.ownerType)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I32, 6)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.functionType is not None:
      oprot.writeFieldBegin('functionType', TType.I32, 7)
      oprot.writeI32(self.functionType)
      oprot.writeFieldEnd()
    if self.resourceUris is not None:
      oprot.writeFieldBegin('resourceUris', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.resourceUris))
      for iter461 in self.resourceUris:
        iter461.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.functionName)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.className)
    value = (value * 31) ^ hash(self.ownerName)
    value = (value * 31) ^ hash(self.ownerType)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.functionType)
    value = (value * 31) ^ hash(self.resourceUris)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TxnInfo:
  """
  Attributes:
   - id
   - state
   - user
   - hostname
   - agentInfo
   - heartbeatCount
   - metaInfo
   - startedTime
   - lastHeartbeatTime
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.I32, 'state', None, None, ), # 2
    (3, TType.STRING, 'user', None, None, ), # 3
    (4, TType.STRING, 'hostname', None, None, ), # 4
    (5, TType.STRING, 'agentInfo', None, "Unknown", ), # 5
    (6, TType.I32, 'heartbeatCount', None, 0, ), # 6
    (7, TType.STRING, 'metaInfo', None, None, ), # 7
    (8, TType.I64, 'startedTime', None, None, ), # 8
    (9, TType.I64, 'lastHeartbeatTime', None, None, ), # 9
  )

  def __init__(self, id=None, state=None, user=None, hostname=None, agentInfo=thrift_spec[5][4], heartbeatCount=thrift_spec[6][4], metaInfo=None, startedTime=None, lastHeartbeatTime=None,):
    self.id = id
    self.state = state
    self.user = user
    self.hostname = hostname
    self.agentInfo = agentInfo
    self.heartbeatCount = heartbeatCount
    self.metaInfo = metaInfo
    self.startedTime = startedTime
    self.lastHeartbeatTime = lastHeartbeatTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.state = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.hostname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.agentInfo = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.heartbeatCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.metaInfo = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.startedTime = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.lastHeartbeatTime = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TxnInfo')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 2)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 3)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.hostname is not None:
      oprot.writeFieldBegin('hostname', TType.STRING, 4)
      oprot.writeString(self.hostname)
      oprot.writeFieldEnd()
    if self.agentInfo is not None:
      oprot.writeFieldBegin('agentInfo', TType.STRING, 5)
      oprot.writeString(self.agentInfo)
      oprot.writeFieldEnd()
    if self.heartbeatCount is not None:
      oprot.writeFieldBegin('heartbeatCount', TType.I32, 6)
      oprot.writeI32(self.heartbeatCount)
      oprot.writeFieldEnd()
    if self.metaInfo is not None:
      oprot.writeFieldBegin('metaInfo', TType.STRING, 7)
      oprot.writeString(self.metaInfo)
      oprot.writeFieldEnd()
    if self.startedTime is not None:
      oprot.writeFieldBegin('startedTime', TType.I64, 8)
      oprot.writeI64(self.startedTime)
      oprot.writeFieldEnd()
    if self.lastHeartbeatTime is not None:
      oprot.writeFieldBegin('lastHeartbeatTime', TType.I64, 9)
      oprot.writeI64(self.lastHeartbeatTime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    if self.state is None:
      raise TProtocol.TProtocolException(message='Required field state is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    if self.hostname is None:
      raise TProtocol.TProtocolException(message='Required field hostname is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.state)
    value = (value * 31) ^ hash(self.user)
    value = (value * 31) ^ hash(self.hostname)
    value = (value * 31) ^ hash(self.agentInfo)
    value = (value * 31) ^ hash(self.heartbeatCount)
    value = (value * 31) ^ hash(self.metaInfo)
    value = (value * 31) ^ hash(self.startedTime)
    value = (value * 31) ^ hash(self.lastHeartbeatTime)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetOpenTxnsInfoResponse:
  """
  Attributes:
   - txn_high_water_mark
   - open_txns
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'txn_high_water_mark', None, None, ), # 1
    (2, TType.LIST, 'open_txns', (TType.STRUCT,(TxnInfo, TxnInfo.thrift_spec)), None, ), # 2
  )

  def __init__(self, txn_high_water_mark=None, open_txns=None,):
    self.txn_high_water_mark = txn_high_water_mark
    self.open_txns = open_txns

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.txn_high_water_mark = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.open_txns = []
          (_etype465, _size462) = iprot.readListBegin()
          for _i466 in xrange(_size462):
            _elem467 = TxnInfo()
            _elem467.read(iprot)
            self.open_txns.append(_elem467)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetOpenTxnsInfoResponse')
    if self.txn_high_water_mark is not None:
      oprot.writeFieldBegin('txn_high_water_mark', TType.I64, 1)
      oprot.writeI64(self.txn_high_water_mark)
      oprot.writeFieldEnd()
    if self.open_txns is not None:
      oprot.writeFieldBegin('open_txns', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.open_txns))
      for iter468 in self.open_txns:
        iter468.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txn_high_water_mark is None:
      raise TProtocol.TProtocolException(message='Required field txn_high_water_mark is unset!')
    if self.open_txns is None:
      raise TProtocol.TProtocolException(message='Required field open_txns is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txn_high_water_mark)
    value = (value * 31) ^ hash(self.open_txns)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetOpenTxnsResponse:
  """
  Attributes:
   - txn_high_water_mark
   - open_txns
   - min_open_txn
   - abortedBits
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'txn_high_water_mark', None, None, ), # 1
    (2, TType.LIST, 'open_txns', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'min_open_txn', None, None, ), # 3
    (4, TType.STRING, 'abortedBits', None, None, ), # 4
  )

  def __init__(self, txn_high_water_mark=None, open_txns=None, min_open_txn=None, abortedBits=None,):
    self.txn_high_water_mark = txn_high_water_mark
    self.open_txns = open_txns
    self.min_open_txn = min_open_txn
    self.abortedBits = abortedBits

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.txn_high_water_mark = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.open_txns = []
          (_etype472, _size469) = iprot.readListBegin()
          for _i473 in xrange(_size469):
            _elem474 = iprot.readI64()
            self.open_txns.append(_elem474)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.min_open_txn = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.abortedBits = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetOpenTxnsResponse')
    if self.txn_high_water_mark is not None:
      oprot.writeFieldBegin('txn_high_water_mark', TType.I64, 1)
      oprot.writeI64(self.txn_high_water_mark)
      oprot.writeFieldEnd()
    if self.open_txns is not None:
      oprot.writeFieldBegin('open_txns', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.open_txns))
      for iter475 in self.open_txns:
        oprot.writeI64(iter475)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.min_open_txn is not None:
      oprot.writeFieldBegin('min_open_txn', TType.I64, 3)
      oprot.writeI64(self.min_open_txn)
      oprot.writeFieldEnd()
    if self.abortedBits is not None:
      oprot.writeFieldBegin('abortedBits', TType.STRING, 4)
      oprot.writeString(self.abortedBits)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txn_high_water_mark is None:
      raise TProtocol.TProtocolException(message='Required field txn_high_water_mark is unset!')
    if self.open_txns is None:
      raise TProtocol.TProtocolException(message='Required field open_txns is unset!')
    if self.abortedBits is None:
      raise TProtocol.TProtocolException(message='Required field abortedBits is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txn_high_water_mark)
    value = (value * 31) ^ hash(self.open_txns)
    value = (value * 31) ^ hash(self.min_open_txn)
    value = (value * 31) ^ hash(self.abortedBits)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class OpenTxnRequest:
  """
  Attributes:
   - num_txns
   - user
   - hostname
   - agentInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'num_txns', None, None, ), # 1
    (2, TType.STRING, 'user', None, None, ), # 2
    (3, TType.STRING, 'hostname', None, None, ), # 3
    (4, TType.STRING, 'agentInfo', None, "Unknown", ), # 4
  )

  def __init__(self, num_txns=None, user=None, hostname=None, agentInfo=thrift_spec[4][4],):
    self.num_txns = num_txns
    self.user = user
    self.hostname = hostname
    self.agentInfo = agentInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.num_txns = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.hostname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.agentInfo = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('OpenTxnRequest')
    if self.num_txns is not None:
      oprot.writeFieldBegin('num_txns', TType.I32, 1)
      oprot.writeI32(self.num_txns)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 2)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.hostname is not None:
      oprot.writeFieldBegin('hostname', TType.STRING, 3)
      oprot.writeString(self.hostname)
      oprot.writeFieldEnd()
    if self.agentInfo is not None:
      oprot.writeFieldBegin('agentInfo', TType.STRING, 4)
      oprot.writeString(self.agentInfo)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.num_txns is None:
      raise TProtocol.TProtocolException(message='Required field num_txns is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    if self.hostname is None:
      raise TProtocol.TProtocolException(message='Required field hostname is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.num_txns)
    value = (value * 31) ^ hash(self.user)
    value = (value * 31) ^ hash(self.hostname)
    value = (value * 31) ^ hash(self.agentInfo)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class OpenTxnsResponse:
  """
  Attributes:
   - txn_ids
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'txn_ids', (TType.I64,None), None, ), # 1
  )

  def __init__(self, txn_ids=None,):
    self.txn_ids = txn_ids

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.txn_ids = []
          (_etype479, _size476) = iprot.readListBegin()
          for _i480 in xrange(_size476):
            _elem481 = iprot.readI64()
            self.txn_ids.append(_elem481)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('OpenTxnsResponse')
    if self.txn_ids is not None:
      oprot.writeFieldBegin('txn_ids', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.txn_ids))
      for iter482 in self.txn_ids:
        oprot.writeI64(iter482)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txn_ids is None:
      raise TProtocol.TProtocolException(message='Required field txn_ids is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txn_ids)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AbortTxnRequest:
  """
  Attributes:
   - txnid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'txnid', None, None, ), # 1
  )

  def __init__(self, txnid=None,):
    self.txnid = txnid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AbortTxnRequest')
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 1)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txnid is None:
      raise TProtocol.TProtocolException(message='Required field txnid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txnid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AbortTxnsRequest:
  """
  Attributes:
   - txn_ids
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'txn_ids', (TType.I64,None), None, ), # 1
  )

  def __init__(self, txn_ids=None,):
    self.txn_ids = txn_ids

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.txn_ids = []
          (_etype486, _size483) = iprot.readListBegin()
          for _i487 in xrange(_size483):
            _elem488 = iprot.readI64()
            self.txn_ids.append(_elem488)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AbortTxnsRequest')
    if self.txn_ids is not None:
      oprot.writeFieldBegin('txn_ids', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.txn_ids))
      for iter489 in self.txn_ids:
        oprot.writeI64(iter489)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txn_ids is None:
      raise TProtocol.TProtocolException(message='Required field txn_ids is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txn_ids)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CommitTxnRequest:
  """
  Attributes:
   - txnid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'txnid', None, None, ), # 1
  )

  def __init__(self, txnid=None,):
    self.txnid = txnid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CommitTxnRequest')
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 1)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txnid is None:
      raise TProtocol.TProtocolException(message='Required field txnid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txnid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LockComponent:
  """
  Attributes:
   - type
   - level
   - dbname
   - tablename
   - partitionname
   - operationType
   - isAcid
   - isDynamicPartitionWrite
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.I32, 'level', None, None, ), # 2
    (3, TType.STRING, 'dbname', None, None, ), # 3
    (4, TType.STRING, 'tablename', None, None, ), # 4
    (5, TType.STRING, 'partitionname', None, None, ), # 5
    (6, TType.I32, 'operationType', None,     5, ), # 6
    (7, TType.BOOL, 'isAcid', None, False, ), # 7
    (8, TType.BOOL, 'isDynamicPartitionWrite', None, False, ), # 8
  )

  def __init__(self, type=None, level=None, dbname=None, tablename=None, partitionname=None, operationType=thrift_spec[6][4], isAcid=thrift_spec[7][4], isDynamicPartitionWrite=thrift_spec[8][4],):
    self.type = type
    self.level = level
    self.dbname = dbname
    self.tablename = tablename
    self.partitionname = partitionname
    self.operationType = operationType
    self.isAcid = isAcid
    self.isDynamicPartitionWrite = isDynamicPartitionWrite

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.level = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.partitionname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.operationType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.isAcid = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.isDynamicPartitionWrite = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LockComponent')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.level is not None:
      oprot.writeFieldBegin('level', TType.I32, 2)
      oprot.writeI32(self.level)
      oprot.writeFieldEnd()
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 3)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 4)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.partitionname is not None:
      oprot.writeFieldBegin('partitionname', TType.STRING, 5)
      oprot.writeString(self.partitionname)
      oprot.writeFieldEnd()
    if self.operationType is not None:
      oprot.writeFieldBegin('operationType', TType.I32, 6)
      oprot.writeI32(self.operationType)
      oprot.writeFieldEnd()
    if self.isAcid is not None:
      oprot.writeFieldBegin('isAcid', TType.BOOL, 7)
      oprot.writeBool(self.isAcid)
      oprot.writeFieldEnd()
    if self.isDynamicPartitionWrite is not None:
      oprot.writeFieldBegin('isDynamicPartitionWrite', TType.BOOL, 8)
      oprot.writeBool(self.isDynamicPartitionWrite)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    if self.level is None:
      raise TProtocol.TProtocolException(message='Required field level is unset!')
    if self.dbname is None:
      raise TProtocol.TProtocolException(message='Required field dbname is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.level)
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.partitionname)
    value = (value * 31) ^ hash(self.operationType)
    value = (value * 31) ^ hash(self.isAcid)
    value = (value * 31) ^ hash(self.isDynamicPartitionWrite)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LockRequest:
  """
  Attributes:
   - component
   - txnid
   - user
   - hostname
   - agentInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'component', (TType.STRUCT,(LockComponent, LockComponent.thrift_spec)), None, ), # 1
    (2, TType.I64, 'txnid', None, None, ), # 2
    (3, TType.STRING, 'user', None, None, ), # 3
    (4, TType.STRING, 'hostname', None, None, ), # 4
    (5, TType.STRING, 'agentInfo', None, "Unknown", ), # 5
  )

  def __init__(self, component=None, txnid=None, user=None, hostname=None, agentInfo=thrift_spec[5][4],):
    self.component = component
    self.txnid = txnid
    self.user = user
    self.hostname = hostname
    self.agentInfo = agentInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.component = []
          (_etype493, _size490) = iprot.readListBegin()
          for _i494 in xrange(_size490):
            _elem495 = LockComponent()
            _elem495.read(iprot)
            self.component.append(_elem495)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.hostname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.agentInfo = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LockRequest')
    if self.component is not None:
      oprot.writeFieldBegin('component', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.component))
      for iter496 in self.component:
        iter496.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 2)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 3)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.hostname is not None:
      oprot.writeFieldBegin('hostname', TType.STRING, 4)
      oprot.writeString(self.hostname)
      oprot.writeFieldEnd()
    if self.agentInfo is not None:
      oprot.writeFieldBegin('agentInfo', TType.STRING, 5)
      oprot.writeString(self.agentInfo)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.component is None:
      raise TProtocol.TProtocolException(message='Required field component is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    if self.hostname is None:
      raise TProtocol.TProtocolException(message='Required field hostname is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.component)
    value = (value * 31) ^ hash(self.txnid)
    value = (value * 31) ^ hash(self.user)
    value = (value * 31) ^ hash(self.hostname)
    value = (value * 31) ^ hash(self.agentInfo)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LockResponse:
  """
  Attributes:
   - lockid
   - state
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lockid', None, None, ), # 1
    (2, TType.I32, 'state', None, None, ), # 2
  )

  def __init__(self, lockid=None, state=None,):
    self.lockid = lockid
    self.state = state

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lockid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.state = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LockResponse')
    if self.lockid is not None:
      oprot.writeFieldBegin('lockid', TType.I64, 1)
      oprot.writeI64(self.lockid)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 2)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lockid is None:
      raise TProtocol.TProtocolException(message='Required field lockid is unset!')
    if self.state is None:
      raise TProtocol.TProtocolException(message='Required field state is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lockid)
    value = (value * 31) ^ hash(self.state)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CheckLockRequest:
  """
  Attributes:
   - lockid
   - txnid
   - elapsed_ms
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lockid', None, None, ), # 1
    (2, TType.I64, 'txnid', None, None, ), # 2
    (3, TType.I64, 'elapsed_ms', None, None, ), # 3
  )

  def __init__(self, lockid=None, txnid=None, elapsed_ms=None,):
    self.lockid = lockid
    self.txnid = txnid
    self.elapsed_ms = elapsed_ms

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lockid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.elapsed_ms = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CheckLockRequest')
    if self.lockid is not None:
      oprot.writeFieldBegin('lockid', TType.I64, 1)
      oprot.writeI64(self.lockid)
      oprot.writeFieldEnd()
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 2)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    if self.elapsed_ms is not None:
      oprot.writeFieldBegin('elapsed_ms', TType.I64, 3)
      oprot.writeI64(self.elapsed_ms)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lockid is None:
      raise TProtocol.TProtocolException(message='Required field lockid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lockid)
    value = (value * 31) ^ hash(self.txnid)
    value = (value * 31) ^ hash(self.elapsed_ms)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnlockRequest:
  """
  Attributes:
   - lockid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lockid', None, None, ), # 1
  )

  def __init__(self, lockid=None,):
    self.lockid = lockid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lockid = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnlockRequest')
    if self.lockid is not None:
      oprot.writeFieldBegin('lockid', TType.I64, 1)
      oprot.writeI64(self.lockid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lockid is None:
      raise TProtocol.TProtocolException(message='Required field lockid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lockid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShowLocksRequest:
  """
  Attributes:
   - dbname
   - tablename
   - partname
   - isExtended
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tablename', None, None, ), # 2
    (3, TType.STRING, 'partname', None, None, ), # 3
    (4, TType.BOOL, 'isExtended', None, False, ), # 4
  )

  def __init__(self, dbname=None, tablename=None, partname=None, isExtended=thrift_spec[4][4],):
    self.dbname = dbname
    self.tablename = tablename
    self.partname = partname
    self.isExtended = isExtended

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.partname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.isExtended = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShowLocksRequest')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 2)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.partname is not None:
      oprot.writeFieldBegin('partname', TType.STRING, 3)
      oprot.writeString(self.partname)
      oprot.writeFieldEnd()
    if self.isExtended is not None:
      oprot.writeFieldBegin('isExtended', TType.BOOL, 4)
      oprot.writeBool(self.isExtended)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.partname)
    value = (value * 31) ^ hash(self.isExtended)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShowLocksResponseElement:
  """
  Attributes:
   - lockid
   - dbname
   - tablename
   - partname
   - state
   - type
   - txnid
   - lastheartbeat
   - acquiredat
   - user
   - hostname
   - heartbeatCount
   - agentInfo
   - blockedByExtId
   - blockedByIntId
   - lockIdInternal
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lockid', None, None, ), # 1
    (2, TType.STRING, 'dbname', None, None, ), # 2
    (3, TType.STRING, 'tablename', None, None, ), # 3
    (4, TType.STRING, 'partname', None, None, ), # 4
    (5, TType.I32, 'state', None, None, ), # 5
    (6, TType.I32, 'type', None, None, ), # 6
    (7, TType.I64, 'txnid', None, None, ), # 7
    (8, TType.I64, 'lastheartbeat', None, None, ), # 8
    (9, TType.I64, 'acquiredat', None, None, ), # 9
    (10, TType.STRING, 'user', None, None, ), # 10
    (11, TType.STRING, 'hostname', None, None, ), # 11
    (12, TType.I32, 'heartbeatCount', None, 0, ), # 12
    (13, TType.STRING, 'agentInfo', None, None, ), # 13
    (14, TType.I64, 'blockedByExtId', None, None, ), # 14
    (15, TType.I64, 'blockedByIntId', None, None, ), # 15
    (16, TType.I64, 'lockIdInternal', None, None, ), # 16
  )

  def __init__(self, lockid=None, dbname=None, tablename=None, partname=None, state=None, type=None, txnid=None, lastheartbeat=None, acquiredat=None, user=None, hostname=None, heartbeatCount=thrift_spec[12][4], agentInfo=None, blockedByExtId=None, blockedByIntId=None, lockIdInternal=None,):
    self.lockid = lockid
    self.dbname = dbname
    self.tablename = tablename
    self.partname = partname
    self.state = state
    self.type = type
    self.txnid = txnid
    self.lastheartbeat = lastheartbeat
    self.acquiredat = acquiredat
    self.user = user
    self.hostname = hostname
    self.heartbeatCount = heartbeatCount
    self.agentInfo = agentInfo
    self.blockedByExtId = blockedByExtId
    self.blockedByIntId = blockedByIntId
    self.lockIdInternal = lockIdInternal

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lockid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.partname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.state = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.lastheartbeat = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.acquiredat = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.hostname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.heartbeatCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.agentInfo = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I64:
          self.blockedByExtId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I64:
          self.blockedByIntId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.I64:
          self.lockIdInternal = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShowLocksResponseElement')
    if self.lockid is not None:
      oprot.writeFieldBegin('lockid', TType.I64, 1)
      oprot.writeI64(self.lockid)
      oprot.writeFieldEnd()
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 2)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 3)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.partname is not None:
      oprot.writeFieldBegin('partname', TType.STRING, 4)
      oprot.writeString(self.partname)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 5)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 6)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 7)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    if self.lastheartbeat is not None:
      oprot.writeFieldBegin('lastheartbeat', TType.I64, 8)
      oprot.writeI64(self.lastheartbeat)
      oprot.writeFieldEnd()
    if self.acquiredat is not None:
      oprot.writeFieldBegin('acquiredat', TType.I64, 9)
      oprot.writeI64(self.acquiredat)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 10)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.hostname is not None:
      oprot.writeFieldBegin('hostname', TType.STRING, 11)
      oprot.writeString(self.hostname)
      oprot.writeFieldEnd()
    if self.heartbeatCount is not None:
      oprot.writeFieldBegin('heartbeatCount', TType.I32, 12)
      oprot.writeI32(self.heartbeatCount)
      oprot.writeFieldEnd()
    if self.agentInfo is not None:
      oprot.writeFieldBegin('agentInfo', TType.STRING, 13)
      oprot.writeString(self.agentInfo)
      oprot.writeFieldEnd()
    if self.blockedByExtId is not None:
      oprot.writeFieldBegin('blockedByExtId', TType.I64, 14)
      oprot.writeI64(self.blockedByExtId)
      oprot.writeFieldEnd()
    if self.blockedByIntId is not None:
      oprot.writeFieldBegin('blockedByIntId', TType.I64, 15)
      oprot.writeI64(self.blockedByIntId)
      oprot.writeFieldEnd()
    if self.lockIdInternal is not None:
      oprot.writeFieldBegin('lockIdInternal', TType.I64, 16)
      oprot.writeI64(self.lockIdInternal)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lockid is None:
      raise TProtocol.TProtocolException(message='Required field lockid is unset!')
    if self.dbname is None:
      raise TProtocol.TProtocolException(message='Required field dbname is unset!')
    if self.state is None:
      raise TProtocol.TProtocolException(message='Required field state is unset!')
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    if self.lastheartbeat is None:
      raise TProtocol.TProtocolException(message='Required field lastheartbeat is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    if self.hostname is None:
      raise TProtocol.TProtocolException(message='Required field hostname is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lockid)
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.partname)
    value = (value * 31) ^ hash(self.state)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.txnid)
    value = (value * 31) ^ hash(self.lastheartbeat)
    value = (value * 31) ^ hash(self.acquiredat)
    value = (value * 31) ^ hash(self.user)
    value = (value * 31) ^ hash(self.hostname)
    value = (value * 31) ^ hash(self.heartbeatCount)
    value = (value * 31) ^ hash(self.agentInfo)
    value = (value * 31) ^ hash(self.blockedByExtId)
    value = (value * 31) ^ hash(self.blockedByIntId)
    value = (value * 31) ^ hash(self.lockIdInternal)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShowLocksResponse:
  """
  Attributes:
   - locks
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'locks', (TType.STRUCT,(ShowLocksResponseElement, ShowLocksResponseElement.thrift_spec)), None, ), # 1
  )

  def __init__(self, locks=None,):
    self.locks = locks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.locks = []
          (_etype500, _size497) = iprot.readListBegin()
          for _i501 in xrange(_size497):
            _elem502 = ShowLocksResponseElement()
            _elem502.read(iprot)
            self.locks.append(_elem502)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShowLocksResponse')
    if self.locks is not None:
      oprot.writeFieldBegin('locks', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.locks))
      for iter503 in self.locks:
        iter503.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.locks)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HeartbeatRequest:
  """
  Attributes:
   - lockid
   - txnid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lockid', None, None, ), # 1
    (2, TType.I64, 'txnid', None, None, ), # 2
  )

  def __init__(self, lockid=None, txnid=None,):
    self.lockid = lockid
    self.txnid = txnid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lockid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HeartbeatRequest')
    if self.lockid is not None:
      oprot.writeFieldBegin('lockid', TType.I64, 1)
      oprot.writeI64(self.lockid)
      oprot.writeFieldEnd()
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 2)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lockid)
    value = (value * 31) ^ hash(self.txnid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HeartbeatTxnRangeRequest:
  """
  Attributes:
   - min
   - max
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'min', None, None, ), # 1
    (2, TType.I64, 'max', None, None, ), # 2
  )

  def __init__(self, min=None, max=None,):
    self.min = min
    self.max = max

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.min = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.max = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HeartbeatTxnRangeRequest')
    if self.min is not None:
      oprot.writeFieldBegin('min', TType.I64, 1)
      oprot.writeI64(self.min)
      oprot.writeFieldEnd()
    if self.max is not None:
      oprot.writeFieldBegin('max', TType.I64, 2)
      oprot.writeI64(self.max)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.min is None:
      raise TProtocol.TProtocolException(message='Required field min is unset!')
    if self.max is None:
      raise TProtocol.TProtocolException(message='Required field max is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.min)
    value = (value * 31) ^ hash(self.max)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HeartbeatTxnRangeResponse:
  """
  Attributes:
   - aborted
   - nosuch
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'aborted', (TType.I64,None), None, ), # 1
    (2, TType.SET, 'nosuch', (TType.I64,None), None, ), # 2
  )

  def __init__(self, aborted=None, nosuch=None,):
    self.aborted = aborted
    self.nosuch = nosuch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.aborted = set()
          (_etype507, _size504) = iprot.readSetBegin()
          for _i508 in xrange(_size504):
            _elem509 = iprot.readI64()
            self.aborted.add(_elem509)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.nosuch = set()
          (_etype513, _size510) = iprot.readSetBegin()
          for _i514 in xrange(_size510):
            _elem515 = iprot.readI64()
            self.nosuch.add(_elem515)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HeartbeatTxnRangeResponse')
    if self.aborted is not None:
      oprot.writeFieldBegin('aborted', TType.SET, 1)
      oprot.writeSetBegin(TType.I64, len(self.aborted))
      for iter516 in self.aborted:
        oprot.writeI64(iter516)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.nosuch is not None:
      oprot.writeFieldBegin('nosuch', TType.SET, 2)
      oprot.writeSetBegin(TType.I64, len(self.nosuch))
      for iter517 in self.nosuch:
        oprot.writeI64(iter517)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.aborted is None:
      raise TProtocol.TProtocolException(message='Required field aborted is unset!')
    if self.nosuch is None:
      raise TProtocol.TProtocolException(message='Required field nosuch is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.aborted)
    value = (value * 31) ^ hash(self.nosuch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CompactionRequest:
  """
  Attributes:
   - dbname
   - tablename
   - partitionname
   - type
   - runas
   - properties
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tablename', None, None, ), # 2
    (3, TType.STRING, 'partitionname', None, None, ), # 3
    (4, TType.I32, 'type', None, None, ), # 4
    (5, TType.STRING, 'runas', None, None, ), # 5
    (6, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 6
  )

  def __init__(self, dbname=None, tablename=None, partitionname=None, type=None, runas=None, properties=None,):
    self.dbname = dbname
    self.tablename = tablename
    self.partitionname = partitionname
    self.type = type
    self.runas = runas
    self.properties = properties

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.partitionname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.runas = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.properties = {}
          (_ktype519, _vtype520, _size518 ) = iprot.readMapBegin()
          for _i522 in xrange(_size518):
            _key523 = iprot.readString()
            _val524 = iprot.readString()
            self.properties[_key523] = _val524
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CompactionRequest')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 2)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.partitionname is not None:
      oprot.writeFieldBegin('partitionname', TType.STRING, 3)
      oprot.writeString(self.partitionname)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 4)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.runas is not None:
      oprot.writeFieldBegin('runas', TType.STRING, 5)
      oprot.writeString(self.runas)
      oprot.writeFieldEnd()
    if self.properties is not None:
      oprot.writeFieldBegin('properties', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
      for kiter525,viter526 in self.properties.items():
        oprot.writeString(kiter525)
        oprot.writeString(viter526)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbname is None:
      raise TProtocol.TProtocolException(message='Required field dbname is unset!')
    if self.tablename is None:
      raise TProtocol.TProtocolException(message='Required field tablename is unset!')
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.partitionname)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.runas)
    value = (value * 31) ^ hash(self.properties)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CompactionResponse:
  """
  Attributes:
   - id
   - state
   - accepted
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.STRING, 'state', None, None, ), # 2
    (3, TType.BOOL, 'accepted', None, None, ), # 3
  )

  def __init__(self, id=None, state=None, accepted=None,):
    self.id = id
    self.state = state
    self.accepted = accepted

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.state = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.accepted = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CompactionResponse')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.STRING, 2)
      oprot.writeString(self.state)
      oprot.writeFieldEnd()
    if self.accepted is not None:
      oprot.writeFieldBegin('accepted', TType.BOOL, 3)
      oprot.writeBool(self.accepted)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    if self.state is None:
      raise TProtocol.TProtocolException(message='Required field state is unset!')
    if self.accepted is None:
      raise TProtocol.TProtocolException(message='Required field accepted is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.state)
    value = (value * 31) ^ hash(self.accepted)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShowCompactRequest:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShowCompactRequest')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShowCompactResponseElement:
  """
  Attributes:
   - dbname
   - tablename
   - partitionname
   - type
   - state
   - workerid
   - start
   - runAs
   - hightestTxnId
   - metaInfo
   - endTime
   - hadoopJobId
   - id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tablename', None, None, ), # 2
    (3, TType.STRING, 'partitionname', None, None, ), # 3
    (4, TType.I32, 'type', None, None, ), # 4
    (5, TType.STRING, 'state', None, None, ), # 5
    (6, TType.STRING, 'workerid', None, None, ), # 6
    (7, TType.I64, 'start', None, None, ), # 7
    (8, TType.STRING, 'runAs', None, None, ), # 8
    (9, TType.I64, 'hightestTxnId', None, None, ), # 9
    (10, TType.STRING, 'metaInfo', None, None, ), # 10
    (11, TType.I64, 'endTime', None, None, ), # 11
    (12, TType.STRING, 'hadoopJobId', None, "None", ), # 12
    (13, TType.I64, 'id', None, None, ), # 13
  )

  def __init__(self, dbname=None, tablename=None, partitionname=None, type=None, state=None, workerid=None, start=None, runAs=None, hightestTxnId=None, metaInfo=None, endTime=None, hadoopJobId=thrift_spec[12][4], id=None,):
    self.dbname = dbname
    self.tablename = tablename
    self.partitionname = partitionname
    self.type = type
    self.state = state
    self.workerid = workerid
    self.start = start
    self.runAs = runAs
    self.hightestTxnId = hightestTxnId
    self.metaInfo = metaInfo
    self.endTime = endTime
    self.hadoopJobId = hadoopJobId
    self.id = id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.partitionname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.state = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.workerid = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.runAs = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.hightestTxnId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.metaInfo = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I64:
          self.endTime = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.hadoopJobId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShowCompactResponseElement')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 2)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.partitionname is not None:
      oprot.writeFieldBegin('partitionname', TType.STRING, 3)
      oprot.writeString(self.partitionname)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 4)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.STRING, 5)
      oprot.writeString(self.state)
      oprot.writeFieldEnd()
    if self.workerid is not None:
      oprot.writeFieldBegin('workerid', TType.STRING, 6)
      oprot.writeString(self.workerid)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 7)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.runAs is not None:
      oprot.writeFieldBegin('runAs', TType.STRING, 8)
      oprot.writeString(self.runAs)
      oprot.writeFieldEnd()
    if self.hightestTxnId is not None:
      oprot.writeFieldBegin('hightestTxnId', TType.I64, 9)
      oprot.writeI64(self.hightestTxnId)
      oprot.writeFieldEnd()
    if self.metaInfo is not None:
      oprot.writeFieldBegin('metaInfo', TType.STRING, 10)
      oprot.writeString(self.metaInfo)
      oprot.writeFieldEnd()
    if self.endTime is not None:
      oprot.writeFieldBegin('endTime', TType.I64, 11)
      oprot.writeI64(self.endTime)
      oprot.writeFieldEnd()
    if self.hadoopJobId is not None:
      oprot.writeFieldBegin('hadoopJobId', TType.STRING, 12)
      oprot.writeString(self.hadoopJobId)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 13)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbname is None:
      raise TProtocol.TProtocolException(message='Required field dbname is unset!')
    if self.tablename is None:
      raise TProtocol.TProtocolException(message='Required field tablename is unset!')
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    if self.state is None:
      raise TProtocol.TProtocolException(message='Required field state is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.partitionname)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.state)
    value = (value * 31) ^ hash(self.workerid)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.runAs)
    value = (value * 31) ^ hash(self.hightestTxnId)
    value = (value * 31) ^ hash(self.metaInfo)
    value = (value * 31) ^ hash(self.endTime)
    value = (value * 31) ^ hash(self.hadoopJobId)
    value = (value * 31) ^ hash(self.id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShowCompactResponse:
  """
  Attributes:
   - compacts
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'compacts', (TType.STRUCT,(ShowCompactResponseElement, ShowCompactResponseElement.thrift_spec)), None, ), # 1
  )

  def __init__(self, compacts=None,):
    self.compacts = compacts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.compacts = []
          (_etype530, _size527) = iprot.readListBegin()
          for _i531 in xrange(_size527):
            _elem532 = ShowCompactResponseElement()
            _elem532.read(iprot)
            self.compacts.append(_elem532)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShowCompactResponse')
    if self.compacts is not None:
      oprot.writeFieldBegin('compacts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.compacts))
      for iter533 in self.compacts:
        iter533.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.compacts is None:
      raise TProtocol.TProtocolException(message='Required field compacts is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.compacts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddDynamicPartitions:
  """
  Attributes:
   - txnid
   - dbname
   - tablename
   - partitionnames
   - operationType
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'txnid', None, None, ), # 1
    (2, TType.STRING, 'dbname', None, None, ), # 2
    (3, TType.STRING, 'tablename', None, None, ), # 3
    (4, TType.LIST, 'partitionnames', (TType.STRING,None), None, ), # 4
    (5, TType.I32, 'operationType', None,     5, ), # 5
  )

  def __init__(self, txnid=None, dbname=None, tablename=None, partitionnames=None, operationType=thrift_spec[5][4],):
    self.txnid = txnid
    self.dbname = dbname
    self.tablename = tablename
    self.partitionnames = partitionnames
    self.operationType = operationType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.partitionnames = []
          (_etype537, _size534) = iprot.readListBegin()
          for _i538 in xrange(_size534):
            _elem539 = iprot.readString()
            self.partitionnames.append(_elem539)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.operationType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddDynamicPartitions')
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 1)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 2)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 3)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.partitionnames is not None:
      oprot.writeFieldBegin('partitionnames', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.partitionnames))
      for iter540 in self.partitionnames:
        oprot.writeString(iter540)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.operationType is not None:
      oprot.writeFieldBegin('operationType', TType.I32, 5)
      oprot.writeI32(self.operationType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.txnid is None:
      raise TProtocol.TProtocolException(message='Required field txnid is unset!')
    if self.dbname is None:
      raise TProtocol.TProtocolException(message='Required field dbname is unset!')
    if self.tablename is None:
      raise TProtocol.TProtocolException(message='Required field tablename is unset!')
    if self.partitionnames is None:
      raise TProtocol.TProtocolException(message='Required field partitionnames is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.txnid)
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.partitionnames)
    value = (value * 31) ^ hash(self.operationType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BasicTxnInfo:
  """
  Attributes:
   - isnull
   - time
   - txnid
   - dbname
   - tablename
   - partitionname
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'isnull', None, None, ), # 1
    (2, TType.I64, 'time', None, None, ), # 2
    (3, TType.I64, 'txnid', None, None, ), # 3
    (4, TType.STRING, 'dbname', None, None, ), # 4
    (5, TType.STRING, 'tablename', None, None, ), # 5
    (6, TType.STRING, 'partitionname', None, None, ), # 6
  )

  def __init__(self, isnull=None, time=None, txnid=None, dbname=None, tablename=None, partitionname=None,):
    self.isnull = isnull
    self.time = time
    self.txnid = txnid
    self.dbname = dbname
    self.tablename = tablename
    self.partitionname = partitionname

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.isnull = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.txnid = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.dbname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.tablename = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.partitionname = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BasicTxnInfo')
    if self.isnull is not None:
      oprot.writeFieldBegin('isnull', TType.BOOL, 1)
      oprot.writeBool(self.isnull)
      oprot.writeFieldEnd()
    if self.time is not None:
      oprot.writeFieldBegin('time', TType.I64, 2)
      oprot.writeI64(self.time)
      oprot.writeFieldEnd()
    if self.txnid is not None:
      oprot.writeFieldBegin('txnid', TType.I64, 3)
      oprot.writeI64(self.txnid)
      oprot.writeFieldEnd()
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 4)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tablename is not None:
      oprot.writeFieldBegin('tablename', TType.STRING, 5)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.partitionname is not None:
      oprot.writeFieldBegin('partitionname', TType.STRING, 6)
      oprot.writeString(self.partitionname)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.isnull is None:
      raise TProtocol.TProtocolException(message='Required field isnull is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.isnull)
    value = (value * 31) ^ hash(self.time)
    value = (value * 31) ^ hash(self.txnid)
    value = (value * 31) ^ hash(self.dbname)
    value = (value * 31) ^ hash(self.tablename)
    value = (value * 31) ^ hash(self.partitionname)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreationMetadata:
  """
  Attributes:
   - dbName
   - tblName
   - tablesUsed
   - validTxnList
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.SET, 'tablesUsed', (TType.STRING,None), None, ), # 3
    (4, TType.STRING, 'validTxnList', None, None, ), # 4
  )

  def __init__(self, dbName=None, tblName=None, tablesUsed=None, validTxnList=None,):
    self.dbName = dbName
    self.tblName = tblName
    self.tablesUsed = tablesUsed
    self.validTxnList = validTxnList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.tablesUsed = set()
          (_etype544, _size541) = iprot.readSetBegin()
          for _i545 in xrange(_size541):
            _elem546 = iprot.readString()
            self.tablesUsed.add(_elem546)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.validTxnList = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreationMetadata')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.tablesUsed is not None:
      oprot.writeFieldBegin('tablesUsed', TType.SET, 3)
      oprot.writeSetBegin(TType.STRING, len(self.tablesUsed))
      for iter547 in self.tablesUsed:
        oprot.writeString(iter547)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.validTxnList is not None:
      oprot.writeFieldBegin('validTxnList', TType.STRING, 4)
      oprot.writeString(self.validTxnList)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    if self.tablesUsed is None:
      raise TProtocol.TProtocolException(message='Required field tablesUsed is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.tablesUsed)
    value = (value * 31) ^ hash(self.validTxnList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotificationEventRequest:
  """
  Attributes:
   - lastEvent
   - maxEvents
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'lastEvent', None, None, ), # 1
    (2, TType.I32, 'maxEvents', None, None, ), # 2
  )

  def __init__(self, lastEvent=None, maxEvents=None,):
    self.lastEvent = lastEvent
    self.maxEvents = maxEvents

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.lastEvent = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.maxEvents = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotificationEventRequest')
    if self.lastEvent is not None:
      oprot.writeFieldBegin('lastEvent', TType.I64, 1)
      oprot.writeI64(self.lastEvent)
      oprot.writeFieldEnd()
    if self.maxEvents is not None:
      oprot.writeFieldBegin('maxEvents', TType.I32, 2)
      oprot.writeI32(self.maxEvents)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lastEvent is None:
      raise TProtocol.TProtocolException(message='Required field lastEvent is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lastEvent)
    value = (value * 31) ^ hash(self.maxEvents)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotificationEvent:
  """
  Attributes:
   - eventId
   - eventTime
   - eventType
   - dbName
   - tableName
   - message
   - messageFormat
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'eventId', None, None, ), # 1
    (2, TType.I32, 'eventTime', None, None, ), # 2
    (3, TType.STRING, 'eventType', None, None, ), # 3
    (4, TType.STRING, 'dbName', None, None, ), # 4
    (5, TType.STRING, 'tableName', None, None, ), # 5
    (6, TType.STRING, 'message', None, None, ), # 6
    (7, TType.STRING, 'messageFormat', None, None, ), # 7
  )

  def __init__(self, eventId=None, eventTime=None, eventType=None, dbName=None, tableName=None, message=None, messageFormat=None,):
    self.eventId = eventId
    self.eventTime = eventTime
    self.eventType = eventType
    self.dbName = dbName
    self.tableName = tableName
    self.message = message
    self.messageFormat = messageFormat

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.eventId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.eventTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.eventType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.messageFormat = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotificationEvent')
    if self.eventId is not None:
      oprot.writeFieldBegin('eventId', TType.I64, 1)
      oprot.writeI64(self.eventId)
      oprot.writeFieldEnd()
    if self.eventTime is not None:
      oprot.writeFieldBegin('eventTime', TType.I32, 2)
      oprot.writeI32(self.eventTime)
      oprot.writeFieldEnd()
    if self.eventType is not None:
      oprot.writeFieldBegin('eventType', TType.STRING, 3)
      oprot.writeString(self.eventType)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 4)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 5)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 6)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    if self.messageFormat is not None:
      oprot.writeFieldBegin('messageFormat', TType.STRING, 7)
      oprot.writeString(self.messageFormat)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.eventId is None:
      raise TProtocol.TProtocolException(message='Required field eventId is unset!')
    if self.eventTime is None:
      raise TProtocol.TProtocolException(message='Required field eventTime is unset!')
    if self.eventType is None:
      raise TProtocol.TProtocolException(message='Required field eventType is unset!')
    if self.message is None:
      raise TProtocol.TProtocolException(message='Required field message is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.eventId)
    value = (value * 31) ^ hash(self.eventTime)
    value = (value * 31) ^ hash(self.eventType)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.message)
    value = (value * 31) ^ hash(self.messageFormat)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotificationEventResponse:
  """
  Attributes:
   - events
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'events', (TType.STRUCT,(NotificationEvent, NotificationEvent.thrift_spec)), None, ), # 1
  )

  def __init__(self, events=None,):
    self.events = events

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.events = []
          (_etype551, _size548) = iprot.readListBegin()
          for _i552 in xrange(_size548):
            _elem553 = NotificationEvent()
            _elem553.read(iprot)
            self.events.append(_elem553)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotificationEventResponse')
    if self.events is not None:
      oprot.writeFieldBegin('events', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.events))
      for iter554 in self.events:
        iter554.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.events is None:
      raise TProtocol.TProtocolException(message='Required field events is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.events)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CurrentNotificationEventId:
  """
  Attributes:
   - eventId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'eventId', None, None, ), # 1
  )

  def __init__(self, eventId=None,):
    self.eventId = eventId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.eventId = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CurrentNotificationEventId')
    if self.eventId is not None:
      oprot.writeFieldBegin('eventId', TType.I64, 1)
      oprot.writeI64(self.eventId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.eventId is None:
      raise TProtocol.TProtocolException(message='Required field eventId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.eventId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotificationEventsCountRequest:
  """
  Attributes:
   - fromEventId
   - dbName
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'fromEventId', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
  )

  def __init__(self, fromEventId=None, dbName=None,):
    self.fromEventId = fromEventId
    self.dbName = dbName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.fromEventId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotificationEventsCountRequest')
    if self.fromEventId is not None:
      oprot.writeFieldBegin('fromEventId', TType.I64, 1)
      oprot.writeI64(self.fromEventId)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fromEventId is None:
      raise TProtocol.TProtocolException(message='Required field fromEventId is unset!')
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fromEventId)
    value = (value * 31) ^ hash(self.dbName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotificationEventsCountResponse:
  """
  Attributes:
   - eventsCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'eventsCount', None, None, ), # 1
  )

  def __init__(self, eventsCount=None,):
    self.eventsCount = eventsCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.eventsCount = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotificationEventsCountResponse')
    if self.eventsCount is not None:
      oprot.writeFieldBegin('eventsCount', TType.I64, 1)
      oprot.writeI64(self.eventsCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.eventsCount is None:
      raise TProtocol.TProtocolException(message='Required field eventsCount is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.eventsCount)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InsertEventRequestData:
  """
  Attributes:
   - replace
   - filesAdded
   - filesAddedChecksum
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'replace', None, None, ), # 1
    (2, TType.LIST, 'filesAdded', (TType.STRING,None), None, ), # 2
    (3, TType.LIST, 'filesAddedChecksum', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, replace=None, filesAdded=None, filesAddedChecksum=None,):
    self.replace = replace
    self.filesAdded = filesAdded
    self.filesAddedChecksum = filesAddedChecksum

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.replace = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.filesAdded = []
          (_etype558, _size555) = iprot.readListBegin()
          for _i559 in xrange(_size555):
            _elem560 = iprot.readString()
            self.filesAdded.append(_elem560)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.filesAddedChecksum = []
          (_etype564, _size561) = iprot.readListBegin()
          for _i565 in xrange(_size561):
            _elem566 = iprot.readString()
            self.filesAddedChecksum.append(_elem566)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InsertEventRequestData')
    if self.replace is not None:
      oprot.writeFieldBegin('replace', TType.BOOL, 1)
      oprot.writeBool(self.replace)
      oprot.writeFieldEnd()
    if self.filesAdded is not None:
      oprot.writeFieldBegin('filesAdded', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.filesAdded))
      for iter567 in self.filesAdded:
        oprot.writeString(iter567)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.filesAddedChecksum is not None:
      oprot.writeFieldBegin('filesAddedChecksum', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.filesAddedChecksum))
      for iter568 in self.filesAddedChecksum:
        oprot.writeString(iter568)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.filesAdded is None:
      raise TProtocol.TProtocolException(message='Required field filesAdded is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.replace)
    value = (value * 31) ^ hash(self.filesAdded)
    value = (value * 31) ^ hash(self.filesAddedChecksum)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FireEventRequestData:
  """
  Attributes:
   - insertData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'insertData', (InsertEventRequestData, InsertEventRequestData.thrift_spec), None, ), # 1
  )

  def __init__(self, insertData=None,):
    self.insertData = insertData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.insertData = InsertEventRequestData()
          self.insertData.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FireEventRequestData')
    if self.insertData is not None:
      oprot.writeFieldBegin('insertData', TType.STRUCT, 1)
      self.insertData.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.insertData)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FireEventRequest:
  """
  Attributes:
   - successful
   - data
   - dbName
   - tableName
   - partitionVals
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'successful', None, None, ), # 1
    (2, TType.STRUCT, 'data', (FireEventRequestData, FireEventRequestData.thrift_spec), None, ), # 2
    (3, TType.STRING, 'dbName', None, None, ), # 3
    (4, TType.STRING, 'tableName', None, None, ), # 4
    (5, TType.LIST, 'partitionVals', (TType.STRING,None), None, ), # 5
  )

  def __init__(self, successful=None, data=None, dbName=None, tableName=None, partitionVals=None,):
    self.successful = successful
    self.data = data
    self.dbName = dbName
    self.tableName = tableName
    self.partitionVals = partitionVals

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.successful = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.data = FireEventRequestData()
          self.data.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.partitionVals = []
          (_etype572, _size569) = iprot.readListBegin()
          for _i573 in xrange(_size569):
            _elem574 = iprot.readString()
            self.partitionVals.append(_elem574)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FireEventRequest')
    if self.successful is not None:
      oprot.writeFieldBegin('successful', TType.BOOL, 1)
      oprot.writeBool(self.successful)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRUCT, 2)
      self.data.write(oprot)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 3)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 4)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.partitionVals is not None:
      oprot.writeFieldBegin('partitionVals', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.partitionVals))
      for iter575 in self.partitionVals:
        oprot.writeString(iter575)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.successful is None:
      raise TProtocol.TProtocolException(message='Required field successful is unset!')
    if self.data is None:
      raise TProtocol.TProtocolException(message='Required field data is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.successful)
    value = (value * 31) ^ hash(self.data)
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.partitionVals)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FireEventResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FireEventResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MetadataPpdResult:
  """
  Attributes:
   - metadata
   - includeBitset
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'metadata', None, None, ), # 1
    (2, TType.STRING, 'includeBitset', None, None, ), # 2
  )

  def __init__(self, metadata=None, includeBitset=None,):
    self.metadata = metadata
    self.includeBitset = includeBitset

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.metadata = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.includeBitset = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MetadataPpdResult')
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.STRING, 1)
      oprot.writeString(self.metadata)
      oprot.writeFieldEnd()
    if self.includeBitset is not None:
      oprot.writeFieldBegin('includeBitset', TType.STRING, 2)
      oprot.writeString(self.includeBitset)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.metadata)
    value = (value * 31) ^ hash(self.includeBitset)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetFileMetadataByExprResult:
  """
  Attributes:
   - metadata
   - isSupported
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'metadata', (TType.I64,None,TType.STRUCT,(MetadataPpdResult, MetadataPpdResult.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'isSupported', None, None, ), # 2
  )

  def __init__(self, metadata=None, isSupported=None,):
    self.metadata = metadata
    self.isSupported = isSupported

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.metadata = {}
          (_ktype577, _vtype578, _size576 ) = iprot.readMapBegin()
          for _i580 in xrange(_size576):
            _key581 = iprot.readI64()
            _val582 = MetadataPpdResult()
            _val582.read(iprot)
            self.metadata[_key581] = _val582
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.isSupported = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetFileMetadataByExprResult')
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.MAP, 1)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.metadata))
      for kiter583,viter584 in self.metadata.items():
        oprot.writeI64(kiter583)
        viter584.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.isSupported is not None:
      oprot.writeFieldBegin('isSupported', TType.BOOL, 2)
      oprot.writeBool(self.isSupported)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.metadata is None:
      raise TProtocol.TProtocolException(message='Required field metadata is unset!')
    if self.isSupported is None:
      raise TProtocol.TProtocolException(message='Required field isSupported is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.metadata)
    value = (value * 31) ^ hash(self.isSupported)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetFileMetadataByExprRequest:
  """
  Attributes:
   - fileIds
   - expr
   - doGetFooters
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fileIds', (TType.I64,None), None, ), # 1
    (2, TType.STRING, 'expr', None, None, ), # 2
    (3, TType.BOOL, 'doGetFooters', None, None, ), # 3
    (4, TType.I32, 'type', None, None, ), # 4
  )

  def __init__(self, fileIds=None, expr=None, doGetFooters=None, type=None,):
    self.fileIds = fileIds
    self.expr = expr
    self.doGetFooters = doGetFooters
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fileIds = []
          (_etype588, _size585) = iprot.readListBegin()
          for _i589 in xrange(_size585):
            _elem590 = iprot.readI64()
            self.fileIds.append(_elem590)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.expr = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.doGetFooters = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetFileMetadataByExprRequest')
    if self.fileIds is not None:
      oprot.writeFieldBegin('fileIds', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.fileIds))
      for iter591 in self.fileIds:
        oprot.writeI64(iter591)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expr is not None:
      oprot.writeFieldBegin('expr', TType.STRING, 2)
      oprot.writeString(self.expr)
      oprot.writeFieldEnd()
    if self.doGetFooters is not None:
      oprot.writeFieldBegin('doGetFooters', TType.BOOL, 3)
      oprot.writeBool(self.doGetFooters)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 4)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fileIds is None:
      raise TProtocol.TProtocolException(message='Required field fileIds is unset!')
    if self.expr is None:
      raise TProtocol.TProtocolException(message='Required field expr is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fileIds)
    value = (value * 31) ^ hash(self.expr)
    value = (value * 31) ^ hash(self.doGetFooters)
    value = (value * 31) ^ hash(self.type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetFileMetadataResult:
  """
  Attributes:
   - metadata
   - isSupported
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'metadata', (TType.I64,None,TType.STRING,None), None, ), # 1
    (2, TType.BOOL, 'isSupported', None, None, ), # 2
  )

  def __init__(self, metadata=None, isSupported=None,):
    self.metadata = metadata
    self.isSupported = isSupported

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.metadata = {}
          (_ktype593, _vtype594, _size592 ) = iprot.readMapBegin()
          for _i596 in xrange(_size592):
            _key597 = iprot.readI64()
            _val598 = iprot.readString()
            self.metadata[_key597] = _val598
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.isSupported = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetFileMetadataResult')
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.MAP, 1)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.metadata))
      for kiter599,viter600 in self.metadata.items():
        oprot.writeI64(kiter599)
        oprot.writeString(viter600)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.isSupported is not None:
      oprot.writeFieldBegin('isSupported', TType.BOOL, 2)
      oprot.writeBool(self.isSupported)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.metadata is None:
      raise TProtocol.TProtocolException(message='Required field metadata is unset!')
    if self.isSupported is None:
      raise TProtocol.TProtocolException(message='Required field isSupported is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.metadata)
    value = (value * 31) ^ hash(self.isSupported)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetFileMetadataRequest:
  """
  Attributes:
   - fileIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fileIds', (TType.I64,None), None, ), # 1
  )

  def __init__(self, fileIds=None,):
    self.fileIds = fileIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fileIds = []
          (_etype604, _size601) = iprot.readListBegin()
          for _i605 in xrange(_size601):
            _elem606 = iprot.readI64()
            self.fileIds.append(_elem606)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetFileMetadataRequest')
    if self.fileIds is not None:
      oprot.writeFieldBegin('fileIds', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.fileIds))
      for iter607 in self.fileIds:
        oprot.writeI64(iter607)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fileIds is None:
      raise TProtocol.TProtocolException(message='Required field fileIds is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fileIds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PutFileMetadataResult:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PutFileMetadataResult')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PutFileMetadataRequest:
  """
  Attributes:
   - fileIds
   - metadata
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fileIds', (TType.I64,None), None, ), # 1
    (2, TType.LIST, 'metadata', (TType.STRING,None), None, ), # 2
    (3, TType.I32, 'type', None, None, ), # 3
  )

  def __init__(self, fileIds=None, metadata=None, type=None,):
    self.fileIds = fileIds
    self.metadata = metadata
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fileIds = []
          (_etype611, _size608) = iprot.readListBegin()
          for _i612 in xrange(_size608):
            _elem613 = iprot.readI64()
            self.fileIds.append(_elem613)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.metadata = []
          (_etype617, _size614) = iprot.readListBegin()
          for _i618 in xrange(_size614):
            _elem619 = iprot.readString()
            self.metadata.append(_elem619)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PutFileMetadataRequest')
    if self.fileIds is not None:
      oprot.writeFieldBegin('fileIds', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.fileIds))
      for iter620 in self.fileIds:
        oprot.writeI64(iter620)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.metadata))
      for iter621 in self.metadata:
        oprot.writeString(iter621)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 3)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fileIds is None:
      raise TProtocol.TProtocolException(message='Required field fileIds is unset!')
    if self.metadata is None:
      raise TProtocol.TProtocolException(message='Required field metadata is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fileIds)
    value = (value * 31) ^ hash(self.metadata)
    value = (value * 31) ^ hash(self.type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ClearFileMetadataResult:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ClearFileMetadataResult')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ClearFileMetadataRequest:
  """
  Attributes:
   - fileIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fileIds', (TType.I64,None), None, ), # 1
  )

  def __init__(self, fileIds=None,):
    self.fileIds = fileIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fileIds = []
          (_etype625, _size622) = iprot.readListBegin()
          for _i626 in xrange(_size622):
            _elem627 = iprot.readI64()
            self.fileIds.append(_elem627)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ClearFileMetadataRequest')
    if self.fileIds is not None:
      oprot.writeFieldBegin('fileIds', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.fileIds))
      for iter628 in self.fileIds:
        oprot.writeI64(iter628)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fileIds is None:
      raise TProtocol.TProtocolException(message='Required field fileIds is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fileIds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CacheFileMetadataResult:
  """
  Attributes:
   - isSupported
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'isSupported', None, None, ), # 1
  )

  def __init__(self, isSupported=None,):
    self.isSupported = isSupported

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.isSupported = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CacheFileMetadataResult')
    if self.isSupported is not None:
      oprot.writeFieldBegin('isSupported', TType.BOOL, 1)
      oprot.writeBool(self.isSupported)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.isSupported is None:
      raise TProtocol.TProtocolException(message='Required field isSupported is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.isSupported)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CacheFileMetadataRequest:
  """
  Attributes:
   - dbName
   - tblName
   - partName
   - isAllParts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.STRING, 'partName', None, None, ), # 3
    (4, TType.BOOL, 'isAllParts', None, None, ), # 4
  )

  def __init__(self, dbName=None, tblName=None, partName=None, isAllParts=None,):
    self.dbName = dbName
    self.tblName = tblName
    self.partName = partName
    self.isAllParts = isAllParts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.partName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.isAllParts = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CacheFileMetadataRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.partName is not None:
      oprot.writeFieldBegin('partName', TType.STRING, 3)
      oprot.writeString(self.partName)
      oprot.writeFieldEnd()
    if self.isAllParts is not None:
      oprot.writeFieldBegin('isAllParts', TType.BOOL, 4)
      oprot.writeBool(self.isAllParts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.partName)
    value = (value * 31) ^ hash(self.isAllParts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAllFunctionsResponse:
  """
  Attributes:
   - functions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'functions', (TType.STRUCT,(Function, Function.thrift_spec)), None, ), # 1
  )

  def __init__(self, functions=None,):
    self.functions = functions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.functions = []
          (_etype632, _size629) = iprot.readListBegin()
          for _i633 in xrange(_size629):
            _elem634 = Function()
            _elem634.read(iprot)
            self.functions.append(_elem634)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAllFunctionsResponse')
    if self.functions is not None:
      oprot.writeFieldBegin('functions', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.functions))
      for iter635 in self.functions:
        iter635.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.functions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ClientCapabilities:
  """
  Attributes:
   - values
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'values', (TType.I32,None), None, ), # 1
  )

  def __init__(self, values=None,):
    self.values = values

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.values = []
          (_etype639, _size636) = iprot.readListBegin()
          for _i640 in xrange(_size636):
            _elem641 = iprot.readI32()
            self.values.append(_elem641)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ClientCapabilities')
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.values))
      for iter642 in self.values:
        oprot.writeI32(iter642)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.values is None:
      raise TProtocol.TProtocolException(message='Required field values is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.values)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTableRequest:
  """
  Attributes:
   - dbName
   - tblName
   - capabilities
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tblName', None, None, ), # 2
    (3, TType.STRUCT, 'capabilities', (ClientCapabilities, ClientCapabilities.thrift_spec), None, ), # 3
  )

  def __init__(self, dbName=None, tblName=None, capabilities=None,):
    self.dbName = dbName
    self.tblName = tblName
    self.capabilities = capabilities

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tblName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.capabilities = ClientCapabilities()
          self.capabilities.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTableRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblName is not None:
      oprot.writeFieldBegin('tblName', TType.STRING, 2)
      oprot.writeString(self.tblName)
      oprot.writeFieldEnd()
    if self.capabilities is not None:
      oprot.writeFieldBegin('capabilities', TType.STRUCT, 3)
      self.capabilities.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tblName is None:
      raise TProtocol.TProtocolException(message='Required field tblName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblName)
    value = (value * 31) ^ hash(self.capabilities)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTableResult:
  """
  Attributes:
   - table
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table', (Table, Table.thrift_spec), None, ), # 1
  )

  def __init__(self, table=None,):
    self.table = table

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table = Table()
          self.table.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTableResult')
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRUCT, 1)
      self.table.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table is None:
      raise TProtocol.TProtocolException(message='Required field table is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.table)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTablesRequest:
  """
  Attributes:
   - dbName
   - tblNames
   - capabilities
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.LIST, 'tblNames', (TType.STRING,None), None, ), # 2
    (3, TType.STRUCT, 'capabilities', (ClientCapabilities, ClientCapabilities.thrift_spec), None, ), # 3
  )

  def __init__(self, dbName=None, tblNames=None, capabilities=None,):
    self.dbName = dbName
    self.tblNames = tblNames
    self.capabilities = capabilities

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tblNames = []
          (_etype646, _size643) = iprot.readListBegin()
          for _i647 in xrange(_size643):
            _elem648 = iprot.readString()
            self.tblNames.append(_elem648)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.capabilities = ClientCapabilities()
          self.capabilities.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTablesRequest')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tblNames is not None:
      oprot.writeFieldBegin('tblNames', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.tblNames))
      for iter649 in self.tblNames:
        oprot.writeString(iter649)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.capabilities is not None:
      oprot.writeFieldBegin('capabilities', TType.STRUCT, 3)
      self.capabilities.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tblNames)
    value = (value * 31) ^ hash(self.capabilities)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTablesResult:
  """
  Attributes:
   - tables
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tables', (TType.STRUCT,(Table, Table.thrift_spec)), None, ), # 1
  )

  def __init__(self, tables=None,):
    self.tables = tables

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tables = []
          (_etype653, _size650) = iprot.readListBegin()
          for _i654 in xrange(_size650):
            _elem655 = Table()
            _elem655.read(iprot)
            self.tables.append(_elem655)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTablesResult')
    if self.tables is not None:
      oprot.writeFieldBegin('tables', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.tables))
      for iter656 in self.tables:
        iter656.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tables is None:
      raise TProtocol.TProtocolException(message='Required field tables is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tables)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CmRecycleRequest:
  """
  Attributes:
   - dataPath
   - purge
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dataPath', None, None, ), # 1
    (2, TType.BOOL, 'purge', None, None, ), # 2
  )

  def __init__(self, dataPath=None, purge=None,):
    self.dataPath = dataPath
    self.purge = purge

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dataPath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.purge = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CmRecycleRequest')
    if self.dataPath is not None:
      oprot.writeFieldBegin('dataPath', TType.STRING, 1)
      oprot.writeString(self.dataPath)
      oprot.writeFieldEnd()
    if self.purge is not None:
      oprot.writeFieldBegin('purge', TType.BOOL, 2)
      oprot.writeBool(self.purge)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dataPath is None:
      raise TProtocol.TProtocolException(message='Required field dataPath is unset!')
    if self.purge is None:
      raise TProtocol.TProtocolException(message='Required field purge is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dataPath)
    value = (value * 31) ^ hash(self.purge)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CmRecycleResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CmRecycleResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableMeta:
  """
  Attributes:
   - dbName
   - tableName
   - tableType
   - comments
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'tableType', None, None, ), # 3
    (4, TType.STRING, 'comments', None, None, ), # 4
  )

  def __init__(self, dbName=None, tableName=None, tableType=None, comments=None,):
    self.dbName = dbName
    self.tableName = tableName
    self.tableType = tableType
    self.comments = comments

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tableType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.comments = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableMeta')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.tableType is not None:
      oprot.writeFieldBegin('tableType', TType.STRING, 3)
      oprot.writeString(self.tableType)
      oprot.writeFieldEnd()
    if self.comments is not None:
      oprot.writeFieldBegin('comments', TType.STRING, 4)
      oprot.writeString(self.comments)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dbName is None:
      raise TProtocol.TProtocolException(message='Required field dbName is unset!')
    if self.tableName is None:
      raise TProtocol.TProtocolException(message='Required field tableName is unset!')
    if self.tableType is None:
      raise TProtocol.TProtocolException(message='Required field tableType is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dbName)
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.tableType)
    value = (value * 31) ^ hash(self.comments)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Materialization:
  """
  Attributes:
   - tablesUsed
   - validTxnList
   - invalidationTime
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'tablesUsed', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'validTxnList', None, None, ), # 2
    (3, TType.I64, 'invalidationTime', None, None, ), # 3
  )

  def __init__(self, tablesUsed=None, validTxnList=None, invalidationTime=None,):
    self.tablesUsed = tablesUsed
    self.validTxnList = validTxnList
    self.invalidationTime = invalidationTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.tablesUsed = set()
          (_etype660, _size657) = iprot.readSetBegin()
          for _i661 in xrange(_size657):
            _elem662 = iprot.readString()
            self.tablesUsed.add(_elem662)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.validTxnList = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.invalidationTime = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Materialization')
    if self.tablesUsed is not None:
      oprot.writeFieldBegin('tablesUsed', TType.SET, 1)
      oprot.writeSetBegin(TType.STRING, len(self.tablesUsed))
      for iter663 in self.tablesUsed:
        oprot.writeString(iter663)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.validTxnList is not None:
      oprot.writeFieldBegin('validTxnList', TType.STRING, 2)
      oprot.writeString(self.validTxnList)
      oprot.writeFieldEnd()
    if self.invalidationTime is not None:
      oprot.writeFieldBegin('invalidationTime', TType.I64, 3)
      oprot.writeI64(self.invalidationTime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tablesUsed is None:
      raise TProtocol.TProtocolException(message='Required field tablesUsed is unset!')
    if self.invalidationTime is None:
      raise TProtocol.TProtocolException(message='Required field invalidationTime is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tablesUsed)
    value = (value * 31) ^ hash(self.validTxnList)
    value = (value * 31) ^ hash(self.invalidationTime)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMResourcePlan:
  """
  Attributes:
   - name
   - status
   - queryParallelism
   - defaultPoolPath
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.I32, 'status', None, None, ), # 2
    (3, TType.I32, 'queryParallelism', None, None, ), # 3
    (4, TType.STRING, 'defaultPoolPath', None, None, ), # 4
  )

  def __init__(self, name=None, status=None, queryParallelism=None, defaultPoolPath=None,):
    self.name = name
    self.status = status
    self.queryParallelism = queryParallelism
    self.defaultPoolPath = defaultPoolPath

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.queryParallelism = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.defaultPoolPath = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMResourcePlan')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 2)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.queryParallelism is not None:
      oprot.writeFieldBegin('queryParallelism', TType.I32, 3)
      oprot.writeI32(self.queryParallelism)
      oprot.writeFieldEnd()
    if self.defaultPoolPath is not None:
      oprot.writeFieldBegin('defaultPoolPath', TType.STRING, 4)
      oprot.writeString(self.defaultPoolPath)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.queryParallelism)
    value = (value * 31) ^ hash(self.defaultPoolPath)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMNullableResourcePlan:
  """
  Attributes:
   - name
   - status
   - queryParallelism
   - isSetQueryParallelism
   - defaultPoolPath
   - isSetDefaultPoolPath
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.I32, 'status', None, None, ), # 2
    None, # 3
    (4, TType.I32, 'queryParallelism', None, None, ), # 4
    (5, TType.BOOL, 'isSetQueryParallelism', None, None, ), # 5
    (6, TType.STRING, 'defaultPoolPath', None, None, ), # 6
    (7, TType.BOOL, 'isSetDefaultPoolPath', None, None, ), # 7
  )

  def __init__(self, name=None, status=None, queryParallelism=None, isSetQueryParallelism=None, defaultPoolPath=None, isSetDefaultPoolPath=None,):
    self.name = name
    self.status = status
    self.queryParallelism = queryParallelism
    self.isSetQueryParallelism = isSetQueryParallelism
    self.defaultPoolPath = defaultPoolPath
    self.isSetDefaultPoolPath = isSetDefaultPoolPath

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.queryParallelism = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.isSetQueryParallelism = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.defaultPoolPath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.isSetDefaultPoolPath = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMNullableResourcePlan')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 2)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.queryParallelism is not None:
      oprot.writeFieldBegin('queryParallelism', TType.I32, 4)
      oprot.writeI32(self.queryParallelism)
      oprot.writeFieldEnd()
    if self.isSetQueryParallelism is not None:
      oprot.writeFieldBegin('isSetQueryParallelism', TType.BOOL, 5)
      oprot.writeBool(self.isSetQueryParallelism)
      oprot.writeFieldEnd()
    if self.defaultPoolPath is not None:
      oprot.writeFieldBegin('defaultPoolPath', TType.STRING, 6)
      oprot.writeString(self.defaultPoolPath)
      oprot.writeFieldEnd()
    if self.isSetDefaultPoolPath is not None:
      oprot.writeFieldBegin('isSetDefaultPoolPath', TType.BOOL, 7)
      oprot.writeBool(self.isSetDefaultPoolPath)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.queryParallelism)
    value = (value * 31) ^ hash(self.isSetQueryParallelism)
    value = (value * 31) ^ hash(self.defaultPoolPath)
    value = (value * 31) ^ hash(self.isSetDefaultPoolPath)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMPool:
  """
  Attributes:
   - resourcePlanName
   - poolPath
   - allocFraction
   - queryParallelism
   - schedulingPolicy
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
    (2, TType.STRING, 'poolPath', None, None, ), # 2
    (3, TType.DOUBLE, 'allocFraction', None, None, ), # 3
    (4, TType.I32, 'queryParallelism', None, None, ), # 4
    (5, TType.STRING, 'schedulingPolicy', None, None, ), # 5
  )

  def __init__(self, resourcePlanName=None, poolPath=None, allocFraction=None, queryParallelism=None, schedulingPolicy=None,):
    self.resourcePlanName = resourcePlanName
    self.poolPath = poolPath
    self.allocFraction = allocFraction
    self.queryParallelism = queryParallelism
    self.schedulingPolicy = schedulingPolicy

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.poolPath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.allocFraction = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.queryParallelism = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.schedulingPolicy = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMPool')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    if self.poolPath is not None:
      oprot.writeFieldBegin('poolPath', TType.STRING, 2)
      oprot.writeString(self.poolPath)
      oprot.writeFieldEnd()
    if self.allocFraction is not None:
      oprot.writeFieldBegin('allocFraction', TType.DOUBLE, 3)
      oprot.writeDouble(self.allocFraction)
      oprot.writeFieldEnd()
    if self.queryParallelism is not None:
      oprot.writeFieldBegin('queryParallelism', TType.I32, 4)
      oprot.writeI32(self.queryParallelism)
      oprot.writeFieldEnd()
    if self.schedulingPolicy is not None:
      oprot.writeFieldBegin('schedulingPolicy', TType.STRING, 5)
      oprot.writeString(self.schedulingPolicy)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.resourcePlanName is None:
      raise TProtocol.TProtocolException(message='Required field resourcePlanName is unset!')
    if self.poolPath is None:
      raise TProtocol.TProtocolException(message='Required field poolPath is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    value = (value * 31) ^ hash(self.poolPath)
    value = (value * 31) ^ hash(self.allocFraction)
    value = (value * 31) ^ hash(self.queryParallelism)
    value = (value * 31) ^ hash(self.schedulingPolicy)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMNullablePool:
  """
  Attributes:
   - resourcePlanName
   - poolPath
   - allocFraction
   - queryParallelism
   - schedulingPolicy
   - isSetSchedulingPolicy
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
    (2, TType.STRING, 'poolPath', None, None, ), # 2
    (3, TType.DOUBLE, 'allocFraction', None, None, ), # 3
    (4, TType.I32, 'queryParallelism', None, None, ), # 4
    (5, TType.STRING, 'schedulingPolicy', None, None, ), # 5
    (6, TType.BOOL, 'isSetSchedulingPolicy', None, None, ), # 6
  )

  def __init__(self, resourcePlanName=None, poolPath=None, allocFraction=None, queryParallelism=None, schedulingPolicy=None, isSetSchedulingPolicy=None,):
    self.resourcePlanName = resourcePlanName
    self.poolPath = poolPath
    self.allocFraction = allocFraction
    self.queryParallelism = queryParallelism
    self.schedulingPolicy = schedulingPolicy
    self.isSetSchedulingPolicy = isSetSchedulingPolicy

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.poolPath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.allocFraction = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.queryParallelism = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.schedulingPolicy = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.isSetSchedulingPolicy = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMNullablePool')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    if self.poolPath is not None:
      oprot.writeFieldBegin('poolPath', TType.STRING, 2)
      oprot.writeString(self.poolPath)
      oprot.writeFieldEnd()
    if self.allocFraction is not None:
      oprot.writeFieldBegin('allocFraction', TType.DOUBLE, 3)
      oprot.writeDouble(self.allocFraction)
      oprot.writeFieldEnd()
    if self.queryParallelism is not None:
      oprot.writeFieldBegin('queryParallelism', TType.I32, 4)
      oprot.writeI32(self.queryParallelism)
      oprot.writeFieldEnd()
    if self.schedulingPolicy is not None:
      oprot.writeFieldBegin('schedulingPolicy', TType.STRING, 5)
      oprot.writeString(self.schedulingPolicy)
      oprot.writeFieldEnd()
    if self.isSetSchedulingPolicy is not None:
      oprot.writeFieldBegin('isSetSchedulingPolicy', TType.BOOL, 6)
      oprot.writeBool(self.isSetSchedulingPolicy)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.resourcePlanName is None:
      raise TProtocol.TProtocolException(message='Required field resourcePlanName is unset!')
    if self.poolPath is None:
      raise TProtocol.TProtocolException(message='Required field poolPath is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    value = (value * 31) ^ hash(self.poolPath)
    value = (value * 31) ^ hash(self.allocFraction)
    value = (value * 31) ^ hash(self.queryParallelism)
    value = (value * 31) ^ hash(self.schedulingPolicy)
    value = (value * 31) ^ hash(self.isSetSchedulingPolicy)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMTrigger:
  """
  Attributes:
   - resourcePlanName
   - triggerName
   - triggerExpression
   - actionExpression
   - isInUnmanaged
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
    (2, TType.STRING, 'triggerName', None, None, ), # 2
    (3, TType.STRING, 'triggerExpression', None, None, ), # 3
    (4, TType.STRING, 'actionExpression', None, None, ), # 4
    (5, TType.BOOL, 'isInUnmanaged', None, None, ), # 5
  )

  def __init__(self, resourcePlanName=None, triggerName=None, triggerExpression=None, actionExpression=None, isInUnmanaged=None,):
    self.resourcePlanName = resourcePlanName
    self.triggerName = triggerName
    self.triggerExpression = triggerExpression
    self.actionExpression = actionExpression
    self.isInUnmanaged = isInUnmanaged

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.triggerName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.triggerExpression = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.actionExpression = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.isInUnmanaged = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMTrigger')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    if self.triggerName is not None:
      oprot.writeFieldBegin('triggerName', TType.STRING, 2)
      oprot.writeString(self.triggerName)
      oprot.writeFieldEnd()
    if self.triggerExpression is not None:
      oprot.writeFieldBegin('triggerExpression', TType.STRING, 3)
      oprot.writeString(self.triggerExpression)
      oprot.writeFieldEnd()
    if self.actionExpression is not None:
      oprot.writeFieldBegin('actionExpression', TType.STRING, 4)
      oprot.writeString(self.actionExpression)
      oprot.writeFieldEnd()
    if self.isInUnmanaged is not None:
      oprot.writeFieldBegin('isInUnmanaged', TType.BOOL, 5)
      oprot.writeBool(self.isInUnmanaged)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.resourcePlanName is None:
      raise TProtocol.TProtocolException(message='Required field resourcePlanName is unset!')
    if self.triggerName is None:
      raise TProtocol.TProtocolException(message='Required field triggerName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    value = (value * 31) ^ hash(self.triggerName)
    value = (value * 31) ^ hash(self.triggerExpression)
    value = (value * 31) ^ hash(self.actionExpression)
    value = (value * 31) ^ hash(self.isInUnmanaged)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMMapping:
  """
  Attributes:
   - resourcePlanName
   - entityType
   - entityName
   - poolPath
   - ordering
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
    (2, TType.STRING, 'entityType', None, None, ), # 2
    (3, TType.STRING, 'entityName', None, None, ), # 3
    (4, TType.STRING, 'poolPath', None, None, ), # 4
    (5, TType.I32, 'ordering', None, None, ), # 5
  )

  def __init__(self, resourcePlanName=None, entityType=None, entityName=None, poolPath=None, ordering=None,):
    self.resourcePlanName = resourcePlanName
    self.entityType = entityType
    self.entityName = entityName
    self.poolPath = poolPath
    self.ordering = ordering

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.entityType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.entityName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.poolPath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.ordering = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMMapping')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    if self.entityType is not None:
      oprot.writeFieldBegin('entityType', TType.STRING, 2)
      oprot.writeString(self.entityType)
      oprot.writeFieldEnd()
    if self.entityName is not None:
      oprot.writeFieldBegin('entityName', TType.STRING, 3)
      oprot.writeString(self.entityName)
      oprot.writeFieldEnd()
    if self.poolPath is not None:
      oprot.writeFieldBegin('poolPath', TType.STRING, 4)
      oprot.writeString(self.poolPath)
      oprot.writeFieldEnd()
    if self.ordering is not None:
      oprot.writeFieldBegin('ordering', TType.I32, 5)
      oprot.writeI32(self.ordering)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.resourcePlanName is None:
      raise TProtocol.TProtocolException(message='Required field resourcePlanName is unset!')
    if self.entityType is None:
      raise TProtocol.TProtocolException(message='Required field entityType is unset!')
    if self.entityName is None:
      raise TProtocol.TProtocolException(message='Required field entityName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    value = (value * 31) ^ hash(self.entityType)
    value = (value * 31) ^ hash(self.entityName)
    value = (value * 31) ^ hash(self.poolPath)
    value = (value * 31) ^ hash(self.ordering)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMPoolTrigger:
  """
  Attributes:
   - pool
   - trigger
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pool', None, None, ), # 1
    (2, TType.STRING, 'trigger', None, None, ), # 2
  )

  def __init__(self, pool=None, trigger=None,):
    self.pool = pool
    self.trigger = trigger

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pool = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.trigger = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMPoolTrigger')
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.STRING, 1)
      oprot.writeString(self.pool)
      oprot.writeFieldEnd()
    if self.trigger is not None:
      oprot.writeFieldBegin('trigger', TType.STRING, 2)
      oprot.writeString(self.trigger)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.pool is None:
      raise TProtocol.TProtocolException(message='Required field pool is unset!')
    if self.trigger is None:
      raise TProtocol.TProtocolException(message='Required field trigger is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pool)
    value = (value * 31) ^ hash(self.trigger)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMFullResourcePlan:
  """
  Attributes:
   - plan
   - pools
   - mappings
   - triggers
   - poolTriggers
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'plan', (WMResourcePlan, WMResourcePlan.thrift_spec), None, ), # 1
    (2, TType.LIST, 'pools', (TType.STRUCT,(WMPool, WMPool.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'mappings', (TType.STRUCT,(WMMapping, WMMapping.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'triggers', (TType.STRUCT,(WMTrigger, WMTrigger.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'poolTriggers', (TType.STRUCT,(WMPoolTrigger, WMPoolTrigger.thrift_spec)), None, ), # 5
  )

  def __init__(self, plan=None, pools=None, mappings=None, triggers=None, poolTriggers=None,):
    self.plan = plan
    self.pools = pools
    self.mappings = mappings
    self.triggers = triggers
    self.poolTriggers = poolTriggers

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.plan = WMResourcePlan()
          self.plan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.pools = []
          (_etype667, _size664) = iprot.readListBegin()
          for _i668 in xrange(_size664):
            _elem669 = WMPool()
            _elem669.read(iprot)
            self.pools.append(_elem669)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.mappings = []
          (_etype673, _size670) = iprot.readListBegin()
          for _i674 in xrange(_size670):
            _elem675 = WMMapping()
            _elem675.read(iprot)
            self.mappings.append(_elem675)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.triggers = []
          (_etype679, _size676) = iprot.readListBegin()
          for _i680 in xrange(_size676):
            _elem681 = WMTrigger()
            _elem681.read(iprot)
            self.triggers.append(_elem681)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.poolTriggers = []
          (_etype685, _size682) = iprot.readListBegin()
          for _i686 in xrange(_size682):
            _elem687 = WMPoolTrigger()
            _elem687.read(iprot)
            self.poolTriggers.append(_elem687)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMFullResourcePlan')
    if self.plan is not None:
      oprot.writeFieldBegin('plan', TType.STRUCT, 1)
      self.plan.write(oprot)
      oprot.writeFieldEnd()
    if self.pools is not None:
      oprot.writeFieldBegin('pools', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.pools))
      for iter688 in self.pools:
        iter688.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.mappings is not None:
      oprot.writeFieldBegin('mappings', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.mappings))
      for iter689 in self.mappings:
        iter689.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.triggers is not None:
      oprot.writeFieldBegin('triggers', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.triggers))
      for iter690 in self.triggers:
        iter690.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.poolTriggers is not None:
      oprot.writeFieldBegin('poolTriggers', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.poolTriggers))
      for iter691 in self.poolTriggers:
        iter691.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.plan is None:
      raise TProtocol.TProtocolException(message='Required field plan is unset!')
    if self.pools is None:
      raise TProtocol.TProtocolException(message='Required field pools is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.plan)
    value = (value * 31) ^ hash(self.pools)
    value = (value * 31) ^ hash(self.mappings)
    value = (value * 31) ^ hash(self.triggers)
    value = (value * 31) ^ hash(self.poolTriggers)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMCreateResourcePlanRequest:
  """
  Attributes:
   - resourcePlan
   - copyFrom
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'resourcePlan', (WMResourcePlan, WMResourcePlan.thrift_spec), None, ), # 1
    (2, TType.STRING, 'copyFrom', None, None, ), # 2
  )

  def __init__(self, resourcePlan=None, copyFrom=None,):
    self.resourcePlan = resourcePlan
    self.copyFrom = copyFrom

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.resourcePlan = WMResourcePlan()
          self.resourcePlan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.copyFrom = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMCreateResourcePlanRequest')
    if self.resourcePlan is not None:
      oprot.writeFieldBegin('resourcePlan', TType.STRUCT, 1)
      self.resourcePlan.write(oprot)
      oprot.writeFieldEnd()
    if self.copyFrom is not None:
      oprot.writeFieldBegin('copyFrom', TType.STRING, 2)
      oprot.writeString(self.copyFrom)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlan)
    value = (value * 31) ^ hash(self.copyFrom)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMCreateResourcePlanResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMCreateResourcePlanResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMGetActiveResourcePlanRequest:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMGetActiveResourcePlanRequest')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMGetActiveResourcePlanResponse:
  """
  Attributes:
   - resourcePlan
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'resourcePlan', (WMFullResourcePlan, WMFullResourcePlan.thrift_spec), None, ), # 1
  )

  def __init__(self, resourcePlan=None,):
    self.resourcePlan = resourcePlan

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.resourcePlan = WMFullResourcePlan()
          self.resourcePlan.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMGetActiveResourcePlanResponse')
    if self.resourcePlan is not None:
      oprot.writeFieldBegin('resourcePlan', TType.STRUCT, 1)
      self.resourcePlan.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlan)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMGetResourcePlanRequest:
  """
  Attributes:
   - resourcePlanName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
  )

  def __init__(self, resourcePlanName=None,):
    self.resourcePlanName = resourcePlanName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMGetResourcePlanRequest')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMGetResourcePlanResponse:
  """
  Attributes:
   - resourcePlan
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'resourcePlan', (WMFullResourcePlan, WMFullResourcePlan.thrift_spec), None, ), # 1
  )

  def __init__(self, resourcePlan=None,):
    self.resourcePlan = resourcePlan

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.resourcePlan = WMFullResourcePlan()
          self.resourcePlan.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMGetResourcePlanResponse')
    if self.resourcePlan is not None:
      oprot.writeFieldBegin('resourcePlan', TType.STRUCT, 1)
      self.resourcePlan.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlan)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMGetAllResourcePlanRequest:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMGetAllResourcePlanRequest')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMGetAllResourcePlanResponse:
  """
  Attributes:
   - resourcePlans
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'resourcePlans', (TType.STRUCT,(WMResourcePlan, WMResourcePlan.thrift_spec)), None, ), # 1
  )

  def __init__(self, resourcePlans=None,):
    self.resourcePlans = resourcePlans

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.resourcePlans = []
          (_etype695, _size692) = iprot.readListBegin()
          for _i696 in xrange(_size692):
            _elem697 = WMResourcePlan()
            _elem697.read(iprot)
            self.resourcePlans.append(_elem697)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMGetAllResourcePlanResponse')
    if self.resourcePlans is not None:
      oprot.writeFieldBegin('resourcePlans', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.resourcePlans))
      for iter698 in self.resourcePlans:
        iter698.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlans)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMAlterResourcePlanRequest:
  """
  Attributes:
   - resourcePlanName
   - resourcePlan
   - isEnableAndActivate
   - isForceDeactivate
   - isReplace
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
    (2, TType.STRUCT, 'resourcePlan', (WMNullableResourcePlan, WMNullableResourcePlan.thrift_spec), None, ), # 2
    (3, TType.BOOL, 'isEnableAndActivate', None, None, ), # 3
    (4, TType.BOOL, 'isForceDeactivate', None, None, ), # 4
    (5, TType.BOOL, 'isReplace', None, None, ), # 5
  )

  def __init__(self, resourcePlanName=None, resourcePlan=None, isEnableAndActivate=None, isForceDeactivate=None, isReplace=None,):
    self.resourcePlanName = resourcePlanName
    self.resourcePlan = resourcePlan
    self.isEnableAndActivate = isEnableAndActivate
    self.isForceDeactivate = isForceDeactivate
    self.isReplace = isReplace

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.resourcePlan = WMNullableResourcePlan()
          self.resourcePlan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.isEnableAndActivate = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.isForceDeactivate = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.isReplace = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMAlterResourcePlanRequest')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    if self.resourcePlan is not None:
      oprot.writeFieldBegin('resourcePlan', TType.STRUCT, 2)
      self.resourcePlan.write(oprot)
      oprot.writeFieldEnd()
    if self.isEnableAndActivate is not None:
      oprot.writeFieldBegin('isEnableAndActivate', TType.BOOL, 3)
      oprot.writeBool(self.isEnableAndActivate)
      oprot.writeFieldEnd()
    if self.isForceDeactivate is not None:
      oprot.writeFieldBegin('isForceDeactivate', TType.BOOL, 4)
      oprot.writeBool(self.isForceDeactivate)
      oprot.writeFieldEnd()
    if self.isReplace is not None:
      oprot.writeFieldBegin('isReplace', TType.BOOL, 5)
      oprot.writeBool(self.isReplace)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    value = (value * 31) ^ hash(self.resourcePlan)
    value = (value * 31) ^ hash(self.isEnableAndActivate)
    value = (value * 31) ^ hash(self.isForceDeactivate)
    value = (value * 31) ^ hash(self.isReplace)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMAlterResourcePlanResponse:
  """
  Attributes:
   - fullResourcePlan
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'fullResourcePlan', (WMFullResourcePlan, WMFullResourcePlan.thrift_spec), None, ), # 1
  )

  def __init__(self, fullResourcePlan=None,):
    self.fullResourcePlan = fullResourcePlan

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.fullResourcePlan = WMFullResourcePlan()
          self.fullResourcePlan.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMAlterResourcePlanResponse')
    if self.fullResourcePlan is not None:
      oprot.writeFieldBegin('fullResourcePlan', TType.STRUCT, 1)
      self.fullResourcePlan.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fullResourcePlan)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMValidateResourcePlanRequest:
  """
  Attributes:
   - resourcePlanName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
  )

  def __init__(self, resourcePlanName=None,):
    self.resourcePlanName = resourcePlanName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMValidateResourcePlanRequest')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMValidateResourcePlanResponse:
  """
  Attributes:
   - errors
   - warnings
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'errors', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'warnings', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, errors=None, warnings=None,):
    self.errors = errors
    self.warnings = warnings

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.errors = []
          (_etype702, _size699) = iprot.readListBegin()
          for _i703 in xrange(_size699):
            _elem704 = iprot.readString()
            self.errors.append(_elem704)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.warnings = []
          (_etype708, _size705) = iprot.readListBegin()
          for _i709 in xrange(_size705):
            _elem710 = iprot.readString()
            self.warnings.append(_elem710)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMValidateResourcePlanResponse')
    if self.errors is not None:
      oprot.writeFieldBegin('errors', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.errors))
      for iter711 in self.errors:
        oprot.writeString(iter711)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.warnings is not None:
      oprot.writeFieldBegin('warnings', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.warnings))
      for iter712 in self.warnings:
        oprot.writeString(iter712)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.errors)
    value = (value * 31) ^ hash(self.warnings)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMDropResourcePlanRequest:
  """
  Attributes:
   - resourcePlanName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
  )

  def __init__(self, resourcePlanName=None,):
    self.resourcePlanName = resourcePlanName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMDropResourcePlanRequest')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMDropResourcePlanResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMDropResourcePlanResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMCreateTriggerRequest:
  """
  Attributes:
   - trigger
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'trigger', (WMTrigger, WMTrigger.thrift_spec), None, ), # 1
  )

  def __init__(self, trigger=None,):
    self.trigger = trigger

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.trigger = WMTrigger()
          self.trigger.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMCreateTriggerRequest')
    if self.trigger is not None:
      oprot.writeFieldBegin('trigger', TType.STRUCT, 1)
      self.trigger.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.trigger)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMCreateTriggerResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMCreateTriggerResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMAlterTriggerRequest:
  """
  Attributes:
   - trigger
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'trigger', (WMTrigger, WMTrigger.thrift_spec), None, ), # 1
  )

  def __init__(self, trigger=None,):
    self.trigger = trigger

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.trigger = WMTrigger()
          self.trigger.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMAlterTriggerRequest')
    if self.trigger is not None:
      oprot.writeFieldBegin('trigger', TType.STRUCT, 1)
      self.trigger.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.trigger)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMAlterTriggerResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMAlterTriggerResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMDropTriggerRequest:
  """
  Attributes:
   - resourcePlanName
   - triggerName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
    (2, TType.STRING, 'triggerName', None, None, ), # 2
  )

  def __init__(self, resourcePlanName=None, triggerName=None,):
    self.resourcePlanName = resourcePlanName
    self.triggerName = triggerName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.triggerName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMDropTriggerRequest')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    if self.triggerName is not None:
      oprot.writeFieldBegin('triggerName', TType.STRING, 2)
      oprot.writeString(self.triggerName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    value = (value * 31) ^ hash(self.triggerName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMDropTriggerResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMDropTriggerResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMGetTriggersForResourePlanRequest:
  """
  Attributes:
   - resourcePlanName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
  )

  def __init__(self, resourcePlanName=None,):
    self.resourcePlanName = resourcePlanName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMGetTriggersForResourePlanRequest')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMGetTriggersForResourePlanResponse:
  """
  Attributes:
   - triggers
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'triggers', (TType.STRUCT,(WMTrigger, WMTrigger.thrift_spec)), None, ), # 1
  )

  def __init__(self, triggers=None,):
    self.triggers = triggers

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.triggers = []
          (_etype716, _size713) = iprot.readListBegin()
          for _i717 in xrange(_size713):
            _elem718 = WMTrigger()
            _elem718.read(iprot)
            self.triggers.append(_elem718)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMGetTriggersForResourePlanResponse')
    if self.triggers is not None:
      oprot.writeFieldBegin('triggers', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.triggers))
      for iter719 in self.triggers:
        iter719.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.triggers)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMCreatePoolRequest:
  """
  Attributes:
   - pool
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'pool', (WMPool, WMPool.thrift_spec), None, ), # 1
  )

  def __init__(self, pool=None,):
    self.pool = pool

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.pool = WMPool()
          self.pool.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMCreatePoolRequest')
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.STRUCT, 1)
      self.pool.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pool)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMCreatePoolResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMCreatePoolResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMAlterPoolRequest:
  """
  Attributes:
   - pool
   - poolPath
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'pool', (WMNullablePool, WMNullablePool.thrift_spec), None, ), # 1
    (2, TType.STRING, 'poolPath', None, None, ), # 2
  )

  def __init__(self, pool=None, poolPath=None,):
    self.pool = pool
    self.poolPath = poolPath

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.pool = WMNullablePool()
          self.pool.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.poolPath = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMAlterPoolRequest')
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.STRUCT, 1)
      self.pool.write(oprot)
      oprot.writeFieldEnd()
    if self.poolPath is not None:
      oprot.writeFieldBegin('poolPath', TType.STRING, 2)
      oprot.writeString(self.poolPath)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pool)
    value = (value * 31) ^ hash(self.poolPath)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMAlterPoolResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMAlterPoolResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMDropPoolRequest:
  """
  Attributes:
   - resourcePlanName
   - poolPath
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
    (2, TType.STRING, 'poolPath', None, None, ), # 2
  )

  def __init__(self, resourcePlanName=None, poolPath=None,):
    self.resourcePlanName = resourcePlanName
    self.poolPath = poolPath

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.poolPath = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMDropPoolRequest')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    if self.poolPath is not None:
      oprot.writeFieldBegin('poolPath', TType.STRING, 2)
      oprot.writeString(self.poolPath)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    value = (value * 31) ^ hash(self.poolPath)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMDropPoolResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMDropPoolResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMCreateOrUpdateMappingRequest:
  """
  Attributes:
   - mapping
   - update
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'mapping', (WMMapping, WMMapping.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'update', None, None, ), # 2
  )

  def __init__(self, mapping=None, update=None,):
    self.mapping = mapping
    self.update = update

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.mapping = WMMapping()
          self.mapping.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.update = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMCreateOrUpdateMappingRequest')
    if self.mapping is not None:
      oprot.writeFieldBegin('mapping', TType.STRUCT, 1)
      self.mapping.write(oprot)
      oprot.writeFieldEnd()
    if self.update is not None:
      oprot.writeFieldBegin('update', TType.BOOL, 2)
      oprot.writeBool(self.update)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.mapping)
    value = (value * 31) ^ hash(self.update)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMCreateOrUpdateMappingResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMCreateOrUpdateMappingResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMDropMappingRequest:
  """
  Attributes:
   - mapping
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'mapping', (WMMapping, WMMapping.thrift_spec), None, ), # 1
  )

  def __init__(self, mapping=None,):
    self.mapping = mapping

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.mapping = WMMapping()
          self.mapping.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMDropMappingRequest')
    if self.mapping is not None:
      oprot.writeFieldBegin('mapping', TType.STRUCT, 1)
      self.mapping.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.mapping)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMDropMappingResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMDropMappingResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMCreateOrDropTriggerToPoolMappingRequest:
  """
  Attributes:
   - resourcePlanName
   - triggerName
   - poolPath
   - drop
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourcePlanName', None, None, ), # 1
    (2, TType.STRING, 'triggerName', None, None, ), # 2
    (3, TType.STRING, 'poolPath', None, None, ), # 3
    (4, TType.BOOL, 'drop', None, None, ), # 4
  )

  def __init__(self, resourcePlanName=None, triggerName=None, poolPath=None, drop=None,):
    self.resourcePlanName = resourcePlanName
    self.triggerName = triggerName
    self.poolPath = poolPath
    self.drop = drop

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourcePlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.triggerName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.poolPath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.drop = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMCreateOrDropTriggerToPoolMappingRequest')
    if self.resourcePlanName is not None:
      oprot.writeFieldBegin('resourcePlanName', TType.STRING, 1)
      oprot.writeString(self.resourcePlanName)
      oprot.writeFieldEnd()
    if self.triggerName is not None:
      oprot.writeFieldBegin('triggerName', TType.STRING, 2)
      oprot.writeString(self.triggerName)
      oprot.writeFieldEnd()
    if self.poolPath is not None:
      oprot.writeFieldBegin('poolPath', TType.STRING, 3)
      oprot.writeString(self.poolPath)
      oprot.writeFieldEnd()
    if self.drop is not None:
      oprot.writeFieldBegin('drop', TType.BOOL, 4)
      oprot.writeBool(self.drop)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourcePlanName)
    value = (value * 31) ^ hash(self.triggerName)
    value = (value * 31) ^ hash(self.poolPath)
    value = (value * 31) ^ hash(self.drop)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WMCreateOrDropTriggerToPoolMappingResponse:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WMCreateOrDropTriggerToPoolMappingResponse')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MetaException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MetaException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnknownTableException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnknownTableException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnknownDBException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnknownDBException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AlreadyExistsException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AlreadyExistsException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidPartitionException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidPartitionException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnknownPartitionException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnknownPartitionException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidObjectException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidObjectException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoSuchObjectException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoSuchObjectException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IndexAlreadyExistsException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IndexAlreadyExistsException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidOperationException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidOperationException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ConfigValSecurityException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConfigValSecurityException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidInputException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidInputException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoSuchTxnException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoSuchTxnException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TxnAbortedException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TxnAbortedException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TxnOpenException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TxnOpenException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoSuchLockException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoSuchLockException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
